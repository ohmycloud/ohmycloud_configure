<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Data Dump]]></title>
      <url>http://ohmycloud.github.io/2016/09/10/Data-Dump/</url>
      <content type="html"><![CDATA[<h2 id="for-Perl-6"><a href="#for-Perl-6" class="headerlink" title="for Perl 6"></a>for Perl 6</h2><hr>
<p>你们选对了, 这就是满足你们快速打印数据需要的. 如果你已经安装了 <code>Term::ANSIColor</code>的话,输出就会亮瞎你的狗眼!</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><hr>
<h3 id="indent"><a href="#indent" class="headerlink" title="indent"></a>indent</h3><hr>
<p>默认缩进为 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;...&gt;</div><div class="line">say Dump(&#123; some =&gt; object &#125;, :indent(4));</div><div class="line">&lt;...&gt;</div></pre></td></tr></table></figure>
<h3 id="max-recursion"><a href="#max-recursion" class="headerlink" title="max-recursion"></a>max-recursion</h3><hr>
<p>默认为 50</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;...&gt;</div><div class="line">say Dump(&#123; some =&gt; object &#125;, :max-recursion(3));</div><div class="line">&lt;...&gt;</div></pre></td></tr></table></figure>
<h3 id="color"><a href="#color" class="headerlink" title=":color( )"></a>:color( )</h3><hr>
<p>默认为 <code>:color(true)</code>, 安装了 <code>Term::ANSIColor</code>的情况下输出会带颜色. 当为 <code>:color(False)</code> 时关闭彩色.</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use Data::Dump;</div><div class="line"></div><div class="line">say Dump(%(</div><div class="line">  key1 =&gt; &apos;value1&apos;,</div><div class="line">  key256 =&gt; 1,</div><div class="line">));</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  key1   =&gt; &quot;value1&quot;.Str,</div><div class="line">  key256 =&gt; 1.Int,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意: 如果你已经安装了 <code>Term::ANSIColor</code>, 那么接下来就会让你吃惊了. 所以, 做好思想准备.</p>
<h2 id="噢-你想-Dump-你的自定义类"><a href="#噢-你想-Dump-你的自定义类" class="headerlink" title="噢, 你想 Dump 你的自定义类?"></a>噢, 你想 <code>Dump</code> 你的自定义类?</h2><hr>
<p>就是这样, 你们城里人真会玩.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">use Data::Dump;</div><div class="line"></div><div class="line">class E &#123;</div><div class="line">  has $.public;</div><div class="line">  has Int $!private = 5;</div><div class="line">  method r(Str $a) &#123; &#125;;</div><div class="line">  method s($b, :$named? = 5) &#123; &#125;;</div><div class="line">  method e returns Int &#123; say $!private; &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">say Dump(E.new);</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">E :: (</div><div class="line">  $!private =&gt; 5.Int,</div><div class="line">  $!public  =&gt; (Any),</div><div class="line"></div><div class="line">  method e () returns Int &#123;...&#125;,</div><div class="line">  method public () returns Mu &#123;...&#125;,</div><div class="line">  method r (Str $a) returns Mu &#123;...&#125;,</div><div class="line">  method s (Any $b, Any :named($named) = 5) returns Mu &#123;...&#125;,</div><div class="line">)</div></pre></td></tr></table></figure>
<p>github: <a href="https://github.com/tony-o/perl6-data-dump" target="_blank" rel="external">Data::Dump</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-Shortcuts(第一部分)]]></title>
      <url>http://ohmycloud.github.io/2016/08/31/Perl-6-Shortcuts-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p><a href="http://blogs.perl.org/users/zoffix_znet/2016/02/perl-6-shortcuts-part-1.html" target="_blank" rel="external">查看原文</a></p>
<p>快捷(Shortcuts)是一个具有争议性的话题。有些人认为它让代码更快更易读。有些人认为它让代码变得更难度如果人们不熟悉那些快捷的话。这篇文章仅仅告诉你 Shortcuts 的东西, 用不用取决于你。让我们开始把。</p>
<h2 id="类属性的公开-Getter-Setter"><a href="#类属性的公开-Getter-Setter" class="headerlink" title="类属性的公开 Getter/Setter"></a>类属性的公开 Getter/Setter</h2><hr>
<p>“getter” 和 “setter” 的概念在很多语言中是共通的: 在你的类中有一个 “东西”, 并且你写了一个方法来设置或获取那个东西的值。以啰嗦的 Perl 6 方式来写, 这样的一个设置看起来像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">    has $!attr = 42;</div><div class="line">    method attr is rw &#123; $!attr &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my  $obj = Foo.new;</div><div class="line">say $obj.attr;</div><div class="line">    $obj.attr = 72;</div><div class="line">say $obj.attr;</div><div class="line"></div><div class="line"># 输出&gt;&gt;</div><div class="line"># 42</div><div class="line"># 72</div></pre></td></tr></table></figure>
<p>这就像它本来的那样简洁, 但公共属性通常足以使编写这点儿代码变得恼人。这就是为什么 <code>$.</code> twigil 存在的原因。单独使用它会创建一个 “getter”; 如果你还想要一个 “setter”, 需要使用 <code>is rw</code> 特性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Foo &#123; has $.attr is rw = 42; &#125;</div><div class="line">my  $obj = Foo.new;</div><div class="line">say $obj.attr;</div><div class="line">    $obj.attr = 72;</div><div class="line">say $obj.attr;</div><div class="line"></div><div class="line"># 输出&gt;&gt;:</div><div class="line"># 42</div><div class="line"># 72</div></pre></td></tr></table></figure>
<p>我们把属性上的 <code>$!</code> twigil 更改为 <code>$.</code> twigil, 并且它为我们创建了一个公共的方法。继续!</p>
<h2 id="在方法调用中省略圆括号"><a href="#在方法调用中省略圆括号" class="headerlink" title="在方法调用中省略圆括号"></a>在方法调用中省略圆括号</h2><hr>
<p>下面这样的代码你不会经常看见, 代码末尾有一整吨的圆括号。确保它们都能匹配!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$foo.log( $obj.nukanate( $foo.grep(*.bar).map(*.ber) ) );</div></pre></td></tr></table></figure>
<p>对于那些想起  <a href="https://xkcd.com/297/" target="_blank" rel="external">popular webcomic</a> 的人来说, Perl 6 还有一个备选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$foo.log: $obj.nukanate: $foo.grep(*.bar).map: *.ber;</div></pre></td></tr></table></figure>
<p>如果方法在方法调用链的最后, 你可以省略它的圆括号并使用一个冒号 : 代替。除了 <code>.grep</code>, 我们上面所有的调用在链中都是最后的(last in chain), 所以我们避免了很多圆括号。有时我也喜欢在冒号后面换行开始写东西。</p>
<p>还要注意: 你总是可以省略方法调用中的圆括号, 如果你没有提供任何参数的话; 也不需要分号。</p>
<h2 id="没有逗号的具名参数"><a href="#没有逗号的具名参数" class="headerlink" title="没有逗号的具名参数"></a>没有逗号的具名参数</h2><hr>
<p>如果你正调用一个提供只有具名参数的方法或子例程的话, 你可以省略参数之间的逗号。有时候, 我也喜欢把每个参数作为新行叠放在一块儿:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">    method baz (:$foo, :$bar, :$ber) &#123; say &quot;[$foo, $bar, $ber]&quot; &#125;</div><div class="line">&#125;</div><div class="line">    sub    baz (:$foo, :$bar, :$ber) &#123; say &quot;[$foo, $bar, $ber]&quot; &#125;</div><div class="line"></div><div class="line">Foo.baz:</div><div class="line">    :foo(42)</div><div class="line">    :bar(72)</div><div class="line">    :ber(100);</div><div class="line"></div><div class="line">baz :foo(42) :bar(72) :ber(100);</div><div class="line"></div><div class="line"># OUTPUT&gt;&gt;:</div><div class="line"># [42, 72, 100]</div><div class="line"># [42, 72, 100]</div></pre></td></tr></table></figure>
<p>再次, 这在当你提供只有具名参数的时候才有效。有很多很多其它使用同样形式提供参数或 Pairs 但是你又不能省略逗号的地方。</p>
<h2 id="具名参数-Pairs-中的整数"><a href="#具名参数-Pairs-中的整数" class="headerlink" title="具名参数/Pairs 中的整数"></a>具名参数/Pairs 中的整数</h2><hr>
<p>‘如果参数或 Pair 接收一个正整数作为值, 就把数字写在冒号和键的名字之间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say DateTime.new: :2016year :2month :1day :16hour :32minute;</div><div class="line"></div><div class="line"># 输出&gt;&gt;:</div><div class="line"># 2016-02-01T16:32:00Z</div></pre></td></tr></table></figure>
<p>这是其中之一当你第一次学习它的时候看起来不和谐的东西, 但是你会很快习惯它。它读起来很像英语:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %ingredients = :4eggs, :2sticks-of-butter, :4cups-of-suger;</div><div class="line">say %ingredients;</div><div class="line"></div><div class="line"># OUTPUT&gt;&gt;:</div><div class="line"># cups-of-sugar =&gt; 4, eggs =&gt; 4, sticks-of-butter =&gt; 2</div></pre></td></tr></table></figure>
<h2 id="具名参数-Pairs-中的布尔值"><a href="#具名参数-Pairs-中的布尔值" class="headerlink" title="具名参数/Pairs 中的布尔值"></a>具名参数/Pairs 中的布尔值</h2><hr>
<p>使用键自身的名字来标示 <strong>True</strong>, 在键名和冒号之间插入一个感叹号来标示 <strong>False</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub foo (:$bar, :$ber) &#123; say &quot;$bar, $ber&quot; &#125;</div><div class="line">foo :!bar :ber;</div><div class="line"></div><div class="line">my %hash = :!bar, :ber;</div><div class="line">say %hash;</div><div class="line"></div><div class="line"># OUTPUT&gt;&gt;:</div><div class="line"># False, True</div><div class="line"># bar =&gt; False, ber =&gt; True</div></pre></td></tr></table></figure>
<p>注意: 这也能应用在副词上!</p>
<h2 id="具名参数-Pairs-中的-Lists"><a href="#具名参数-Pairs-中的-Lists" class="headerlink" title="具名参数/Pairs 中的 Lists"></a>具名参数/Pairs 中的 Lists</h2><hr>
<p>如果你正提供一个 quote-word 结构给一个期望某种 listy 的具名参数/pair, 那么你可以省略圆括号; 在键和  quote-words 之间不留任何空格就是了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub foo (:@args) &#123; say @args &#125;</div><div class="line">foo :args&lt;foo bar ber&gt;;</div><div class="line"></div><div class="line">my %hash = :ingredients&lt;milk eggs butter&gt;;</div><div class="line">say %hash;</div><div class="line"></div><div class="line"># OUTPUT&gt;&gt;:</div><div class="line"># (foo bar ber)</div><div class="line"># ingredients =&gt; (milk eggs butter)</div></pre></td></tr></table></figure>
<h2 id="传递变量给具名参数-Pairs"><a href="#传递变量给具名参数-Pairs" class="headerlink" title="传递变量给具名参数/Pairs"></a>传递变量给具名参数/Pairs</h2><hr>
<p>你认为具名参数就这样了吗？还有一个更酷的 shortcut: 假设你有一个变量并且它和具名参数拥有相同的名字… 就通过使用变量自身把它传递进来好了, 代替键, 在冒号之后:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">hashify</span> (:$<span class="title">bar</span>, :@<span class="title">ber</span>) </span>&#123;</div><div class="line">    <span class="keyword">my</span> %hash = :$bar, :@ber;</div><div class="line">    <span class="keyword">say</span> %hash;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> ( $bar, @ber )  = <span class="number">42</span>, (<span class="number">1</span>..<span class="number">3</span>);</div><div class="line">hashify :$bar :@ber;</div><div class="line"></div><div class="line"><span class="comment"># OUTPUT&gt;&gt;:</span></div><div class="line"><span class="comment"># bar =&gt; 42, ber =&gt; [1..3]</span></div></pre></td></tr></table></figure>
<p>注意我们既没有在 sub 调用中也没有在我们创建的 hash 中重复键的名字。它们是从变量的名字中派生出来的。</p>
<h2 id="Subs-作为方法调用"><a href="#Subs-作为方法调用" class="headerlink" title="Subs 作为方法调用"></a>Subs 作为方法调用</h2><hr>
<p>如果你有一个 sub 想在某些东西上作为方法调用, 就在 sub 那儿前置一个 <code>&amp;</code>符号就好。 调用者会是第一个位置参数, 所有其它参数像往常那样传递。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">be</span>-<span class="title">wise</span> ($<span class="title">self</span>, $<span class="title">who</span> = '<span class="title">Anonymous</span>') </span>&#123; <span class="string">"Konw your $self, $who!"</span> &#125;</div><div class="line"></div><div class="line"><span class="string">'ABC'</span>.&amp;be-wise.say;</div><div class="line"><span class="string">'ABC'</span>.&amp;be-wise(<span class="string">'Zoffix'</span>).say;</div><div class="line"></div><div class="line"><span class="comment"># OUTPUT&gt;&gt;:</span></div><div class="line"><span class="comment"># Know your ABC, Anonymous!</span></div><div class="line"><span class="comment"># Know your ABC, Zoffix!</span></div></pre></td></tr></table></figure>
<p>这实质上是一种不那么难看的在某个实例上调用 <code>.map</code>的方式, 但是多数时候它的可读性更好。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">be</span>-<span class="title">wise</span> ($<span class="title">self</span>, $<span class="title">who</span> = '<span class="title">Anonymous</span>') </span>&#123; <span class="string">"Know your $self, $who!"</span> &#125;</div><div class="line"></div><div class="line"><span class="string">'ABC'</span>.map(&#123;be-wise $_, <span class="string">'Zoffix'</span>&#125;)».say;</div><div class="line"><span class="keyword">say</span> be-wise <span class="string">'ABC'</span>, <span class="string">'Zoffix'</span>;</div><div class="line"></div><div class="line"><span class="comment"># OUTPUT&gt;&gt;:</span></div><div class="line"><span class="comment"># Know your ABC, Zoffix!</span></div><div class="line"><span class="comment"># Know your ABC, Zoffix!</span></div></pre></td></tr></table></figure>
<p>为了完整性, 但不是过度使用, 你可以内联调用甚至使用一个 pointy block 来设置签名!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&apos;ABC&apos;.&amp;(&apos;Know your &apos; ~ *).say;</div><div class="line">&apos;ABC&apos;.&amp;( -&gt; $self, $who = &apos;Anonymous&apos; &#123;&quot;Know your $self, $who!&quot;&#125; )(&apos;Zoffix&apos;)</div><div class="line">    .say;</div><div class="line"></div><div class="line"># OUTPUT&gt;&gt;:</div><div class="line"># Know your ABC</div><div class="line"># Know your ABC, Zoffix!</div></pre></td></tr></table></figure>
<h2 id="Hyper-方法调用"><a href="#Hyper-方法调用" class="headerlink" title="Hyper 方法调用"></a>Hyper 方法调用</h2><hr>
<p>因为我们谈到了 .map 的快捷方式, 记住 » hyper 操作符。在方法调用的点号之前使用它以标示你想在调用者的每个元素身上调用点号后面跟着的方法, 而不是调用者本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(1, 2, 3)».is-prime.say;</div><div class="line">(1, 2, 3)&gt;&gt;.is-prime.say;</div><div class="line"></div><div class="line"># OUTPUT&gt;&gt;:</div><div class="line"># (False True True)</div><div class="line"># (False True True)</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<ul>
<li>使用 <code>$.</code> twigil 来声明公共属性</li>
<li>使用 <code>:</code>代替圆括号</li>
<li>只含具名参数的 Methods/sub 调用不需要逗号</li>
<li>通过把整数值写在键和冒号之间传递 Int 值</li>
<li>使用键自身来指定一个 True 布尔值</li>
<li>使用键自身, 并在键名和冒号之间插入一个 ! 号来指定一个 <strong>False</strong> 值</li>
<li>当值是 quote-word 结构时, 把它写在键后面, 不含任何圆括号</li>
<li>当变量和键的名字相同时, 把它直接用作键(包括符号), 不用指定任何值</li>
<li>在 sub 那儿前置一个 <code>&amp;</code>, 当把它作为方法调用时</li>
<li>使用 » 操作符来对列表中的每个元素调用一个方法</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6圣诞月历-(2014)]]></title>
      <url>http://ohmycloud.github.io/2016/08/19/Perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2014/</url>
      <content type="html"><![CDATA[<h1 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h1><hr>
<h2 id="Data-munging-in-Perl-6-vs-Perl-5"><a href="#Data-munging-in-Perl-6-vs-Perl-5" class="headerlink" title="Data munging in Perl 6 vs Perl 5"></a>Data munging in Perl 6 vs Perl 5</h2><hr>
<p>案例学习: 生成成绩报告单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">example.txt</div><div class="line">STDOUT</div><div class="line">Peter	B</div><div class="line">Celine	A-</div><div class="line">Zsófia	B+</div><div class="line">João	F</div><div class="line">Maryam	B+</div><div class="line">秀英	B-</div><div class="line">Finn	D+</div><div class="line">Aarav	A</div><div class="line">Emma	F</div><div class="line">Omar	B</div></pre></td></tr></table></figure>
<p>输出报告单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Zsófia&apos;s grade: B+</div><div class="line">List of students with a failing grade:</div><div class="line">  João, Emma</div><div class="line">Distribution of grades by letter:</div><div class="line">  A: 2 students</div><div class="line">  B: 5 students</div><div class="line">  D: 1 student</div><div class="line">  F: 2 students</div></pre></td></tr></table></figure>
<p>example.txt 是一个文本文件， 每行一个学生姓名和分数，中间用空格分割。<br>我们希望我们的脚本能解析这样的文件并打印含有如下信息的报告：</p>
<p>学生名为 “Zsófia”的成绩<br>所有不及格学生的名字 (i.e. worse than D-),<br>根据字母( 不带 +/- ) 把成绩分组。得到学生成绩的分布。<br>让我们一步步来：</p>
<p>Part 1: 样板</p>
<p>Perl 5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perluse warnings;</div><div class="line">use strict;use feature &apos;say&apos;;</div><div class="line">use utf8;</div><div class="line">binmode STDOUT, &apos;:utf8&apos;;</div></pre></td></tr></table></figure>
<p>Perl 6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div></pre></td></tr></table></figure>
<p>在 Perl 6 中所有这些都为我们做好了。</p>
<p>Part 2: 读取并解析输入</p>
<p>Perl 5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">open my $fh, &apos;&lt;:utf8&apos;, &quot;grades.txt&quot;</div><div class="line">    or die &quot;Failed to open file: $!&quot;;</div><div class="line">my %grade;</div><div class="line">while (&lt;$fh&gt;) &#123;</div><div class="line">    m/^(\w+) \s+ ([A-F][+-]?)$/x</div><div class="line">        or die &quot;Can&apos;t parse line &apos;$_&apos;&quot;;</div><div class="line">   $grade&#123;$1&#125; = $2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Perl 6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %grade = &quot;grades.txt&quot;.IO.lines.map: &#123;</div><div class="line">   m:s/^(\w+) (&lt;[A..F]&gt;&lt;[+-]&gt;?)$/</div><div class="line">        or die &quot;Can&apos;t parse line &apos;$_&apos;&quot;;</div><div class="line">    ~$0 =&gt; ~$1</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在 Perl 6 中， 对文件名字符串调用 .IO 方法会返回一个代表文件系统路径的对象， 我们可以继续在这个对象上调用  .lines 方法，得到文件的所有行的一个惰性列表。 “Lazy” 意味着它只会从磁盘中按需读取新行，当我们使用 .map 方法遍历列表元素的时候， 这样能使用单个赋值操作就能优雅地初始化一个散列。<br>我们不需要让文件句柄识别 Unicode ，也不用管文件句柄是否正确关闭， 这在 Perl 6 中都是默认发生的。<br> .method: … 语法也可以写为  .method(…),  前者使 map 看起来更像一个 block 语句，并减少了括号凌乱。<br> :s (“sigspace”) 正则修饰符使解析 tokens 间的空白更优雅。 但 Perl 6 中的字符类比 Perl 5 复杂了一丢丢。<br>正则捕获结果变量($0, $1, …) 返回一个完整的  Match 对象 - 它为复杂使用场景增加了很多灵活性， 但是这里我们只想保留字符串， 所以使用 ~ 前置操作符字符串化了匹配对象。</p>
<p>Part 3: 查看数据的特定项</p>
<p>Perl 5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;Zsófia&apos;s grade: $grade&#123;Zsófia&#125;&quot;;</div></pre></td></tr></table></figure>
<p>Perl 6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;Zsófia&apos;s grade: %grade&lt;Zsófia&gt;&quot;;</div></pre></td></tr></table></figure>
<p>Perl 6 总是把散列中的 <code>{ }</code>  中的东西解析为表达式， 使用 <code>&lt; &gt;</code> 表示字面值。</p>
<p>Part 4: 过滤数据</p>
<p>Perl 5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say &quot;List of students with a failing grade:&quot;;</div><div class="line">say &quot;  &quot; . join &quot;, &quot;,  grep &#123; $grade&#123;$_&#125; ge &quot;E&quot; &#125; keys %grade;</div></pre></td></tr></table></figure>
<p>Perl 6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say &quot;List of students with a failing grade:&quot;;</div><div class="line">say &quot;  &quot; ~ %grade.grep(*.value ge &quot;E&quot;)».key.join(&quot;, &quot;);</div></pre></td></tr></table></figure>
<p>Perl 6 中允许我们按执行顺序把一些列方法写为链式操作。有一个重要区别：Perl 6 能让我们直接遍历散列的项， 散列中每一项都是一个 Pair 对象（Pair 对象能使用 .key 和.value 方法)。</p>
<p>The <code>*</code>   Whatever star 用于定义一个简单的回调，而不用写一个花括号块。<br>The <code>».</code> hyper operator 用于对 .grep 返回的 Pairs  的每个 Pair 上调用 一次 .key  方法，得出姓名列表</p>
<p>Part 5: 从数据中创建频率分布</p>
<p>Perl 5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say &quot;Distribution of grades by letter:&quot;;</div><div class="line">my %freq;</div><div class="line">$freq&#123;substr $grade&#123;$_&#125;, 0, 1&#125;++ for keys %grade;</div><div class="line">say &quot;  $_: $freq&#123;$_&#125; student&quot;.($freq&#123;$_&#125; != 1 ? &quot;s&quot; : &quot;&quot;)    for sort keys %freq;</div></pre></td></tr></table></figure>
<p>Perl 6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say &quot;Distribution of grades by letter:&quot;;</div><div class="line">say &quot;  &#123;.key&#125;: &#123;+.value&#125; student&#123;&quot;s&quot; if .value != 1&#125;&quot;</div><div class="line">    for %grade.classify(*.value.comb[0]).sort(*.key);</div></pre></td></tr></table></figure>
<p>计数和分组实在太常见了， Perl 6 提供了 <code>.classify</code>  方法。<br>classify 方法里需要指定要分组的项（这里是 代表 <code>%grade</code> 条目的 Pair 对象 ）， 这些项应该根据什么规则进行分组（这里是根据第一个字母的值， 它代表分数（没有 +/-））。<br>这生成一个匿名的散列，散列的值是匿名数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%(&quot;B&quot; =&gt; [&quot;Peter&quot; =&gt; &quot;B&quot;, &quot;Zsófia&quot; =&gt; &quot;B+&quot;, &quot;Maryam&quot; =&gt; &quot;B+&quot;,</div><div class="line"> &quot;秀英&quot; =&gt; &quot;B-&quot;, &quot;Omar&quot; =&gt; &quot;B&quot;],  &quot;A&quot; =&gt; [&quot;Celine&quot; =&gt; &quot;A-&quot;, &quot;Aarav&quot; =&gt; &quot;A&quot;],  &quot;F&quot; =&gt; [&quot;João&quot; =&gt; &quot;F&quot;, &quot;Emma&quot; =&gt; &quot;F&quot;],  &quot;D&quot; =&gt; [&quot;Finn&quot; =&gt; &quot;D+&quot;])</div></pre></td></tr></table></figure>
<p>因为我们只对每组元素的个数感兴趣， 我们使用 + 前置操作符数字化每个值然后打印它， 在数组前面添加 + 符号会得到数组元素的个数。<br>在 term 位置上一个 单独的 .method  方法等价于 <code>$_.method</code>,  意思是对当前循环变量调用该方法。<br>任意代码的返回值能使用花括号 {} 插值到字符串中。<br>if 语句能被用作表达式 - 当条件为 false 时，返回空列表，然后被字符串化为空字符串。<br>对字符串调用不带参数的 <code>.comb</code>  会生成该字符串的一个字符列表。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[哇, Perl 6!]]></title>
      <url>http://ohmycloud.github.io/2016/08/14/%E5%93%87-Perl6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p><a href="http://tpm2016.zoffix.com/#/1" target="_blank" rel="external">Slides 地址</a><br><a href="https://www.youtube.com/watch?v=paa3niF72Nw" target="_blank" rel="external">视频地址</a></p>
<p><a href="http://blogs.perl.org/users/zoffix_znet/2016/03/wow-perl-6-talk-slides-recording-and-answers-to-questions.html" target="_blank" rel="external">答案地址</a></p>
<h2 id="注意-Unicode"><a href="#注意-Unicode" class="headerlink" title="注意 Unicode"></a><strong>注意</strong> Unicode</h2><p>Perl 6 允许你使用 Unicode 的项和操作符。<br>这些 Unicode 都有对应的只使用 ASCII 字符的 Texas 变体, 如果你更喜欢使用它们, 到 <a href="http://docs.perl6.org/language/unicode_texas" target="_blank" rel="external">http://docs.perl6.org/language/unicode_texas</a> 找到它们。</p>
<h2 id="惰性列表和它们的使用"><a href="#惰性列表和它们的使用" class="headerlink" title="惰性列表和它们的使用"></a><strong>惰性列表和它们的使用</strong></h2><p><img src="http://upload-images.jianshu.io/upload_images/326727-b8abf1b05dbb2b7e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h2 id="惰性列表"><a href="#惰性列表" class="headerlink" title="惰性列表"></a><strong>惰性列表</strong></h2><p>我们来做点儿疯狂的事情吧…例如创建一个无限列表(INIFINITE LIST)!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @to-infinity-and-beyond = 0, 2 ... ∞;</div><div class="line">say @to-infinity-and-beyond[1008]; # 2016</div></pre></td></tr></table></figure>
<p>来点更有用的东西: 处理大文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">for &apos;/tmp/4GB-file.txt&apos;.IO.words &#123;</div><div class="line">    .say;</div><div class="line">    last if ++$ == 3;</div><div class="line">&#125;</div><div class="line">say &quot;Code took &#123;now - INIT now&#125; seconds to run&quot;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># foo</div><div class="line"># bar</div><div class="line"># ber</div><div class="line"># Code took 0.01111143 seconds to run</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.say for &apos;/tmp/4GB-file.txt&apos;.IO.words[0..2];</div><div class="line">say &quot;Code took &#123;now - INIT now&#125; seconds to run&quot;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># foo</div><div class="line"># bar</div><div class="line"># ber</div><div class="line"># Code took 0.01111143 seconds to run</div></pre></td></tr></table></figure>
<h2 id="塑造你自己的-Subsets-自定义操作符-Muti-dispatch"><a href="#塑造你自己的-Subsets-自定义操作符-Muti-dispatch" class="headerlink" title="塑造你自己的 Subsets, 自定义操作符, Muti-dispatch"></a><strong>塑造你自己的</strong> Subsets, <strong>自定义操作符</strong>, Muti-dispatch</h2><p><img src="http://upload-images.jianshu.io/upload_images/326727-be2bf4d1cd691330.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h3 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h3><p>类型的 subset 使你可以约束它能接收的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">subset BigPrime of Int where &#123; $_ &gt; 10_000 and .is-prime &#125;</div><div class="line"></div><div class="line">sub MAIN ( BigPrime $num ) &#123;</div><div class="line">    say &quot;That&apos;s a nice-looking prime number you got there!&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ perl6 test.p6 3</div><div class="line">Usage:</div><div class="line">  test.p6 &lt;num&gt;</div><div class="line">$ perl6 test.p6 31337</div><div class="line">That&apos;s a nice-looking prime number you got there!</div><div class="line">$ perl6 test.p6 100000</div><div class="line">Usage:</div><div class="line">  test.p6 &lt;num&gt;</div></pre></td></tr></table></figure>
<h3 id="Multi-Dispatch"><a href="#Multi-Dispatch" class="headerlink" title="Multi-Dispatch"></a>Multi-Dispatch</h3><p>多个同名的 subs 或 方法, 但是拥有不同的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">subset Prime      of Int   where *.is-prime;</div><div class="line">subset BigPrime   of Prime where * &gt;  10_000;</div><div class="line">subset SmallPrime of Prime where * &lt;= 10_000;</div><div class="line"></div><div class="line">multi MAIN ( BigPrime   $num ) &#123; say &quot;Prime number! Nice and big&quot;; &#125;</div><div class="line">multi MAIN ( SmallPrime $num ) &#123; say &quot;Puny prime number&quot;;          &#125;</div><div class="line">multi MANI (            $num ) &#123; say &quot;Gimme primes&quot;;               &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ perl6 test.p6 42</div><div class="line">Gimme primes!</div><div class="line">$ perl6 test.p6 7</div><div class="line">Puny prime number</div><div class="line">$ perl6 test.p6 31337</div><div class="line">Prime number! Nice and big</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Numbers &#123;</div><div class="line">    multi method id ( Numeric $num ) &#123; say &quot;$num is a number&quot;       &#125;</div><div class="line">    multi method id (         $num ) &#123; say &quot;$num is something else&quot; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Numeric.new.id:  π;</div><div class="line">Numbers.new.id: &apos;blah&apos;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 3.14159265358979 is a number</div><div class="line"># blah is something else</div></pre></td></tr></table></figure>
<p>扩展方法的功能性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Numbers &#123;</div><div class="line">    multi method id ( Numeric $num ) &#123; say &quot;$num is a number&quot;       &#125;</div><div class="line">    multi method id (        $num  ) &#123; say &quot;$num is something else&quot; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SmarterNumbers is Numbers &#123;</div><div class="line">    multi method id (Numeric $num where * ==  π ) &#123; say &quot;Mmmm yummy pie!&quot; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SmarterNumbers.new.id: 42;</div><div class="line">SmarterNumbers.new.id: π;</div><div class="line">SmarterNumbers.new.id: &apos;blah&apos;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 42 is a number</div><div class="line"># Mmmm yummy pie!</div><div class="line"># blah is something else</div></pre></td></tr></table></figure>
<h3 id="Custom-Terms-and-Operators"><a href="#Custom-Terms-and-Operators" class="headerlink" title="Custom Terms and Operators"></a>Custom Terms and Operators</h3><p><img src="http://upload-images.jianshu.io/upload_images/326727-b310dac691db4f59.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;¯\(°_o)/¯&gt; &#123;</div><div class="line">     ($^a, $^b).pick</div><div class="line"> &#125;</div><div class="line"></div><div class="line">say &apos;Coke&apos; ¯\(°_o)/¯ &apos;Pepsi&apos;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Pepsi</div></pre></td></tr></table></figure>
<p>操作符分类: <code>infix</code>, <code>prefix</code>, <code>postfix</code>,<code>circumfix</code>, <code>postcircumfix</code>  并且你还能把  <code>term</code> 用于项中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub prefix:&lt;∑&gt; (*@els) &#123; @els.sum &#125;</div><div class="line">say ∑ 1, 2, 3, 4;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 1234</div></pre></td></tr></table></figure>
<p>看起来并没有很好地起作用…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub prefix:&lt;∑&gt; (*@els) is looser(&amp;infix:&lt;,&gt;) &#123; @els.sum &#125;</div><div class="line">say ∑ 1, 2, 3, 4;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 10</div></pre></td></tr></table></figure>
<p>使用 <code>is looser</code> 或 <code>is tighter</code> 来更改优先级。默认的优先级和那个位置上的 <code>+</code>/<code>++</code> 操作符的优先级相同。(查看 <a href="https://doc.perl6.org/language/functions#Associativity" target="_blank" rel="external">docs</a> 以使用 <code>is assoc</code> trait 更改结合性。)</p>
<p>One More Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> sub term:&lt;ξ&gt; &#123; (^10 + 1).pick; &#125;</div><div class="line"> sub postcircumfix:&lt;❨  ❩&gt; ($before, $inside) is rw &#123;</div><div class="line">     $before&#123;$inside&#125;;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> my %hash = :foo&lt;bar&gt;, :meow&lt;moo&gt;;</div><div class="line"> %hash❨&apos;foo&apos;❩  = ξ;</div><div class="line"> %hash❨&apos;meow&apos;❩ = ξ;</div><div class="line"></div><div class="line">say %hash;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># foo =&gt; 6, meow =&gt; 8</div></pre></td></tr></table></figure>
<p>重写已经存在的操作符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;+&gt; (Int $a, Int $b) &#123; $a - $b &#125;;</div><div class="line">say 2 + 2;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 0</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-71e3d5f44f434c2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>不要担心… 这个效果是本地作用域的(lexically scoped!)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-815a894031734d6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Thingamagig &#123; has $.value &#125;;</div><div class="line"></div><div class="line">multi infix:&lt;~&gt; (Thingamagig $a, Str $b) &#123;</div><div class="line">    $a.value ~ $b</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $thing = Thingamagig.new: value =&gt; &apos;thingamagig&apos;;</div><div class="line">say &apos;foo&apos; ~ &apos;bar&apos;;</div><div class="line">say $thing ~ &apos;bar&apos;;</div><div class="line">say &apos;bar&apos; ~ $thing;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># foobar</div><div class="line"># thingamagigbar</div><div class="line"># barThingamagig&lt;139870715547680&gt;</div></pre></td></tr></table></figure>
<p>查看 <a href="https://github.com/zoffixznet/perl6-Color/blob/master/lib/Color/Operators.pm6" target="_blank" rel="external">Color::Operators</a> 模块获取更多例子。</p>
<h2 id="Hyperspace"><a href="#Hyperspace" class="headerlink" title="Hyperspace"></a>Hyperspace</h2><h3 id="Multi-core-processing-at-a-touch-of-a-button"><a href="#Multi-core-processing-at-a-touch-of-a-button" class="headerlink" title="Multi-core processing at a touch of a button"></a>Multi-core processing at a touch of a button</h3><p><img src="http://upload-images.jianshu.io/upload_images/326727-be2f92ec80152cf1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h3 id="超运算符"><a href="#超运算符" class="headerlink" title="超运算符"></a>超运算符</h3><p>它们看起来像 <code>«</code> 和 <code>»</code> 你能在这儿看到它们的 <a href="http://perl6maven.com/tutorial/perl6-hyper-operators" target="_blank" rel="external">解释</a> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      (1, 2) «+« (3)</div><div class="line">      (1, 2) »+» 1</div><div class="line">(1, 2, 3, 4) «+» (1, 2)</div></pre></td></tr></table></figure>
<p>那些操作符暂时还不是多线程的, if at all。相反, 我要谈论的变体是这个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@foo».bar</div></pre></td></tr></table></figure>
<p>假设你想把数组中的每个字符串都转为大写然后把那个数组分割为子列表, 每个子列表含有 3 个元素:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my @a = &lt;one two three four five six seven eight nine&gt;;</div><div class="line">say @a.map(&#123; .uc&#125;).rotor: 3;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># ((ONE TWO THREE) (FOUR FIVE SIX) (SEVEN EIGHT NINE))</div></pre></td></tr></table></figure>
<p>很好很简短, 但是假设你想在上千个元素身上调用耗时更多的方法呢?</p>
<p>那么就在方法调用前使用一个 hyper 操作符好了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my @a =  &lt;one two three four five six  seven eight nine&gt;;</div><div class="line">say @a».uc.rotor: 3;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># ((ONE TWO THREE) (FOUR FIVE SIX) (SEVEN EIGHT NINE))</div></pre></td></tr></table></figure>
<p>在点号方法调用前面放上一个 » 那么你所调用的方法会在每个元素身上单独调用。链式调用中更远的那个方法会在数组(列表等)身上调用, 除非它们也是 hypered。</p>
<h3 id="Hyper-Seqs"><a href="#Hyper-Seqs" class="headerlink" title="Hyper Seqs"></a>Hyper Seqs</h3><p>假如你想在多核上对一堆东西上”做事情”呢?  遍历一个 <code>HyperSeq</code>。你可以调用下面的两者之一得到一个 HyperSeq:</p>
<ul>
<li><code>.hyper</code>— 保留元素顺序</li>
<li><code>.race</code>—   不保留元素顺序</li>
</ul>
<p>遍历一个 4-元素的序列, 每个元素睡眠 1 秒钟:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">for (1..4).race( batch =&gt; 1 ) &#123;</div><div class="line">    say &quot;Doing $_&quot;;</div><div class="line">    sleep 1;</div><div class="line">&#125;</div><div class="line">say &quot;Code took &#123;now - INIT now&#125; seconds to run&quot;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Doing 1</div><div class="line"># Doing 3</div><div class="line"># Doing 2</div><div class="line"># Doing 4</div><div class="line"># Code took 1.0090415 seconds to run</div></pre></td></tr></table></figure>
<p>代码只是运行了 1秒多!</p>
<p><code>.hyper</code>  同样, 但是它保留了结果序列中元素的顺序。</p>
<h3 id="Autothreaded-junctions"><a href="#Autothreaded-junctions" class="headerlink" title="Autothreaded junctions"></a>Autothreaded junctions</h3><ul>
<li>Logical superposition of values</li>
</ul>
<p>某些逻辑检查的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my @valid = &lt;foo bar baz&gt;;</div><div class="line">my $what = &apos;ber&apos;;</div><div class="line">say &quot;$what is not valid&quot; if not @valid.grep: &#123; $what eq $_ &#125;;</div><div class="line">say &quot;A ber or a bar&quot;     if $what eq &apos;ber&apos; or $what eq &apos;bar&apos;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># ber is not valid</div><div class="line"># A ber or a bar</div></pre></td></tr></table></figure>
<ul>
<li>Autothreaded junctions</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my @valid = &lt;foo bar baz&gt;;</div><div class="line">my $what = &apos;ber&apos;;</div><div class="line">say &quot;$what is not valid&quot; if $what eq none @valid;</div><div class="line">say &quot;A ber or a bar&quot;     if $what eq &apos;ber&apos; | &apos;bar&apos;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># ber is not valid</div><div class="line"># A ber or a bar</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">type</th>
<th style="text-align:center">constructor</th>
<th style="text-align:center">operator</th>
<th style="text-align:center">True if …</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">all</td>
<td style="text-align:center">all</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">没有值为 False</td>
</tr>
<tr>
<td style="text-align:center">any</td>
<td style="text-align:center">any</td>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>至少一个值为 True</td>
</tr>
<tr>
<td style="text-align:center">one</td>
<td style="text-align:center">one</td>
<td style="text-align:center">^</td>
<td style="text-align:center">完全只有一个值为 True</td>
</tr>
<tr>
<td style="text-align:center">none</td>
<td style="text-align:center">none</td>
<td style="text-align:center"></td>
<td style="text-align:center">没有值为 True</td>
</tr>
</tbody>
</table>
<p>最好的部分?  Junctions 是自动线程化的(autothreaded), 这意味着编译器能在多个线程上对它们进行求值!</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-0494c5bd718ac532.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>我不经常写并行化的代码, 但是当我写的时候, 它是这样的简单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> start &#123; sleep 3; say &quot;two&quot; &#125;;</div><div class="line"> say &quot;one&quot;;</div><div class="line"> sleep 5;</div><div class="line"> say &quot;three&quot;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># one</div><div class="line"># two</div><div class="line"># three</div></pre></td></tr></table></figure>
<p>并发 / 异步 代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">my @promises = ^3 .map: &#123;</div><div class="line">    start &#123;</div><div class="line">        .say; sleep 1;</div><div class="line">        $_ * 4;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">say &quot;Started! &#123;now - INIT now&#125;&quot;;</div><div class="line">say await @promises;</div><div class="line">say &quot;All done! &#123;now - INIT now&#125;&quot;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 0</div><div class="line"># 1</div><div class="line"># 2</div><div class="line"># Started! 0.0196113</div><div class="line"># (0 4 8)</div><div class="line"># All done! 1.0188611</div></pre></td></tr></table></figure>
<p>Start later:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.in(5).then: -&gt; $v &#123; say &quot;It&apos;s been &#123;now - INIT now&#125; seconds!&quot; &#125;;</div><div class="line">sleep 7;</div><div class="line">say &quot;Ran for &#123;now - INIT now&#125; seconds&quot;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># It&apos;s been 5.031918 seconds!</div><div class="line"># Ran for 7.0160562 seconds</div></pre></td></tr></table></figure>
<h2 id="Supplies"><a href="#Supplies" class="headerlink" title="Supplies"></a>Supplies</h2><p>异步数据流:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">my $supplier = Supplier.new;</div><div class="line"></div><div class="line">$supplier.Supply              .tap: -&gt; $v &#123; say &quot;Original: $v&quot; &#125;;</div><div class="line">$supplier.Supply.map(  * × 2 ).tap: -&gt; $v &#123; say &quot;  Double: $v&quot; &#125;;</div><div class="line">$supplier.Supply.grep( * % 2 ).tap: -&gt; $v &#123; say &quot;  Odd: $v&quot;    &#125;;</div><div class="line"></div><div class="line">$supplier.emit: $_ for ^3;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Original: 0</div><div class="line">#   Double: 0</div><div class="line"># Original: 1</div><div class="line">#   Double: 2</div><div class="line">#   Odd: 1</div><div class="line"># Original: 2</div><div class="line">#   Double: 4</div></pre></td></tr></table></figure>
<p>Events at interval inside an event loop (<code>react</code>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">react &#123;</div><div class="line">    whenever Supply.interval: 2 -&gt; $v &#123;</div><div class="line">        say &quot;$v: &#123;now - INIT now&#125;&quot;;</div><div class="line">        done if $v == 2;</div><div class="line">    &#125;</div><div class="line">    whenever Supply.interval: 1 -&gt; $v &#123; say &quot;  1 sec: &#123;now - INIT now&#125;&quot;; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> # OUTPUT:</div><div class="line"> # 0: 0.026734</div><div class="line"> #   1 sec: 0.0333274</div><div class="line"> #   1 sec: 1.02325708</div><div class="line"> # 1: 2.027192</div><div class="line"> #   1 sec: 2.0276854</div><div class="line"> #   1 sec: 3.0234109</div><div class="line"> # 2: 4.0324349</div></pre></td></tr></table></figure>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>一个线程安全的队列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">my $c = Channel.new;</div><div class="line">start &#123;</div><div class="line">    loop &#123; say &quot;$c.receive() at &#123;now - INIT now&#125;&quot; &#125;</div><div class="line">&#125;</div><div class="line">await ^10 .map: -&gt; $r &#123;</div><div class="line">    start &#123;</div><div class="line">         sleep $r;</div><div class="line">         $c.send: $r;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$c.close;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 0 at 0.01036314</div><div class="line"># 1 at 1.0152853</div><div class="line"># 2 at 2.0174991</div><div class="line"># 3 at 3.020067105</div></pre></td></tr></table></figure>
<h2 id="Grammars"><a href="#Grammars" class="headerlink" title="Grammars"></a>Grammars</h2><p>更容易的解析东西的方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-efdc5ad20795b4dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">grammar MyGrammar &#123;</div><div class="line">    token TOP     &#123; &lt;sign&gt; &lt;digits&gt; &lt;decimal&gt;? &#125;</div><div class="line">    token sign    &#123; &lt;[+-]&gt;?                    &#125;</div><div class="line">    token digits  &#123; \d+                        &#125;</div><div class="line">    token decimal &#123; \. &lt;digits&gt;                &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">say MyGrammar.parse: &apos;250.42&apos;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># ｢250.42｣</div><div class="line">#  sign =&gt; ｢｣</div><div class="line">#  digits =&gt; ｢250｣</div><div class="line">#  decimal =&gt; ｢.42｣</div><div class="line">#   digits =&gt; ｢42｣</div></pre></td></tr></table></figure>
<p>actions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">grammar MyGrammar &#123;</div><div class="line">    token TOP     &#123; &lt;sign&gt; &lt;digits&gt; &lt;decimal&gt;? &#125;</div><div class="line">    token sign    &#123; &lt;[+-]&gt;?                    &#125;</div><div class="line">    token digits  &#123; \d+                        &#125;</div><div class="line">    token decimal &#123; \. &lt;digits&gt;                &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyActions &#123;</div><div class="line">    method sign ($/) &#123; $/.make: $/.chars ?? ~$/ !! &apos;+&apos;                        &#125;</div><div class="line">    method TOP  ($/) &#123; $/.make: $&lt;sign&gt;.made ~ ($&lt;digits&gt; + 42 ) ~ $&lt;decimal&gt; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say MyGrammar.parse(&apos;250.42&apos;, actions =&gt; MyActions).made;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># +292.42</div></pre></td></tr></table></figure>
<h3 id="有用的模块"><a href="#有用的模块" class="headerlink" title="有用的模块:"></a>有用的模块:</h3><ul>
<li><code>Grammar::Debugger</code> 和 <code>Grammar::Tracer</code>—  使用两者之一来调试你的  grammars 的输出。</li>
<li><code>Grammar::BNF</code>— 自定地把 BNF 转换为 Perl 6 grammars !!</li>
</ul>
<h2 id="Whatever-man"><a href="#Whatever-man" class="headerlink" title="Whatever, man!"></a><em>Whatever, man!</em></h2><h3 id="Whatever-Code-Meta-operators-Model6-Object-Model-Sets-bags-and-mixes"><a href="#Whatever-Code-Meta-operators-Model6-Object-Model-Sets-bags-and-mixes" class="headerlink" title="Whatever Code, Meta operators, Model6 Object Model, Sets, bags, and mixes"></a>Whatever Code, Meta operators, Model6 Object Model, Sets, bags, and mixes</h3><p><img src="http://upload-images.jianshu.io/upload_images/326727-4b889b4217fec764.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h2 id="Whatever-Code"><a href="#Whatever-Code" class="headerlink" title="Whatever Code"></a>Whatever Code</h2><p>使用 WhateverStar 作为一种快速获取一个带有参数的闭包的方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> say (* + 2)(2);</div><div class="line"> say &lt;1 25 3 100&gt;.grep: * &gt; 5;</div><div class="line"> subset Primes of Int where *.is-prime;</div><div class="line"> </div><div class="line"> # same as</div><div class="line"> </div><div class="line"> say sub &#123; $^a + 2 &#125;(2);</div><div class="line"> say &lt;1 25 3 100&gt;.grep: &#123; $_ &gt; 5 &#125;;</div><div class="line"> subset Primes of Int where &#123; $_.is-prime &#125;;</div></pre></td></tr></table></figure>
<p>每个 WhateverStar 代表着下一个位置参数。你不能使用 WhateverStar 引用同一个参数多于 1 次:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say ( * + * + * )(2, 3, 4);</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 9</div></pre></td></tr></table></figure>
<p>n-at-a-time(一次 n 个) <code>.map</code> 从未像这样简单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say ^12 .map: * + * + *;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># (3 12 21 30)</div></pre></td></tr></table></figure>
<p>看, 整个 Fibonacci 序列存在于一个惰性列表中!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my  @fibonacci = 0, 1, * + * … *;</div><div class="line">say @fibonacci[42];</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 267914296</div></pre></td></tr></table></figure>
<h2 id="喂-还有-HyperWhatever"><a href="#喂-还有-HyperWhatever" class="headerlink" title="喂, 还有 HyperWhatever!"></a><strong>喂</strong>, <strong>还有</strong> HyperWhatever!</h2><p>Just sayin’…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">say ( ** + 2 )(^10);</div><div class="line">say (  * + 2 )(^10);</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># (2 3 4 5 6 7 8 9 10 11)</div><div class="line"># 2..^12</div></pre></td></tr></table></figure>
<h2 id="Meta-Operators"><a href="#Meta-Operators" class="headerlink" title="Meta Operators"></a>Meta Operators</h2><p>和你把方括号里面的操作符放在列表中的元素之间的效果一样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">say [+] 1, 2, 3;   # 6</div><div class="line">say [*] 1..5;      # 120</div><div class="line"></div><div class="line">my @numbers = (2, 4, 3);</div><div class="line">say [&lt;] @numbers;  # False</div></pre></td></tr></table></figure>
<p><em>Triangle Reduce</em>: 在两个相继的元素之间使用操作符, 在它的结果和下一个元素之间再次使用操作符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">say [\+] 1, 2, 3;</div><div class="line">say [\*] 1..5;</div><div class="line"></div><div class="line"> # OUTPUT:</div><div class="line"> # (1 3 6)  ## Breaking it down: 1 (1), 1 + 2 (3), 3 + 3 (6)</div><div class="line"> # (1 2 6 24 120)</div></pre></td></tr></table></figure>
<h2 id="Perl-6-Object-Model"><a href="#Perl-6-Object-Model" class="headerlink" title="Perl 6 Object Model"></a>Perl 6 Object Model</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">    has $.attr;</div><div class="line">    has $.attr-rw is rw;</div><div class="line">    has $.attr-required is required;</div><div class="line">    has $!attr-private = 42;</div><div class="line"></div><div class="line">    method public   &#123; say $!attr + $!attr-private; &#125;</div><div class="line">    method !private &#123; say &apos;secret&apos; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $foo = Foo.new: :attr&lt;public&gt;,</div><div class="line">                   :attr-required&lt;yup-here-it-is&gt;;</div><div class="line"></div><div class="line">say $foo.attr;</div><div class="line">say $foo.public;</div><div class="line">$foo.attr-rw = 42;</div></pre></td></tr></table></figure>
<p>你也可以指定类型约束和 subset 约束:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">    subset Primes of IntStr where *.is-prime;</div><div class="line"></div><div class="line">    has Int    $.attr;</div><div class="line">    has Str    $.attr-rw is rw where *.chars &lt; 5;</div><div class="line">    has Primes $.attr-required is required;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Roles— 安全地为你的类添加行为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">role Drawable &#123;</div><div class="line">    method draw &#123; say &quot;Line from $.x to $.y&quot; &#125;;</div><div class="line">&#125;</div><div class="line">class Line does Drawable &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">&#125;</div><div class="line">my $line = Line.new: :42x, :75y;</div><div class="line">$line.draw;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Line from 42 to 75</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">role Drawable &#123;</div><div class="line">    method draw &#123; say &quot;Line from $.x to $.y&quot; &#125;;</div><div class="line">&#125;</div><div class="line">role OtherDrawable &#123;</div><div class="line">    method draw &#123; say &quot;It&apos;s a draw!&quot; &#125;;</div><div class="line">&#125;</div><div class="line">class Line does Drawable does OtherDrawable &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">&#125;</div><div class="line">my $line = Line.new: :42x, :75y;</div><div class="line">$line.draw;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># ===SORRY!=== Error while compiling /home/zoffix/CPAN/TPM-2016/test.p6</div><div class="line"># Method &apos;draw&apos; must be resolved by class Line because it exists in multiple</div><div class="line"># roles (OtherDrawable, Drawable) at /home/zoffix/CPAN/TPM-2016/test.p6:7</div></pre></td></tr></table></figure>
<h2 id="MOP-Meta-Object-Protocol"><a href="#MOP-Meta-Object-Protocol" class="headerlink" title="MOP: Meta Object Protocol"></a>MOP: Meta Object Protocol</h2><p>自省和 Perl 6 对象系统</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-9562eb8b97578bd9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#| Just &apos;cause</div><div class="line">class TestStuff &#123;&#125;;</div><div class="line">my $x = TestStuff.new;</div><div class="line">say $x.WHAT;     # (TestStuff)  # The type object of the type</div><div class="line">say $x.WHICH;    # TestStuff|179689128 # The object&apos;s identity value</div><div class="line">say $x.WHO;      # TestStuff # The package supporting the object</div><div class="line">say $x.WHERE;    # -1225903068 # The memory address of the object (not stable)</div><div class="line">say $x.HOW;      # Perl6::Metamodel::ClassHOW.new # The metaclass object</div><div class="line">say $x.WHY;      # Just &apos;cause # The attached Pod value.</div><div class="line">say $x.DEFINITE; # True # Returns True for instances and False for type objects</div></pre></td></tr></table></figure>
<p>为已存在的类添加方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Int.^add_method(&apos;x&apos;, -&gt; $class, $v &#123; say $v &#125;);</div><div class="line">constant A := Metamodel::ClassHOW.new_type( name =&gt; &apos;A&apos; );</div><div class="line">A.^add_method(&apos;x&apos;, -&gt; $class, $v &#123; say $v &#125;);</div><div class="line">#A.^compose;</div><div class="line"></div><div class="line">A.x: &apos;A class&apos;;</div><div class="line">Int.x: &apos;Int class&apos;;</div></pre></td></tr></table></figure>
<h2 id="Sets-Bags-and-Mixes"><a href="#Sets-Bags-and-Mixes" class="headerlink" title="Sets, Bags, and Mixes"></a>Sets, Bags, and Mixes</h2><p><strong>Immutable:</strong></p>
<ul>
<li><code>Set</code>—不同对象的集合</li>
<li><code>Bag</code>—带有整数系数(权重)的不同对象的集合</li>
<li><code>Mix</code>—带有实际系数(权重)的不同对象的集合</li>
</ul>
<p><strong>Mutable:</strong></p>
<ul>
<li><code>SetHash</code>—不同对象的集合</li>
<li><code>BagHash</code>—带有整数系数(权重)的不同对象的集合</li>
<li><code>MixHash</code>—带有实际系数(权重)的不同对象的集合</li>
</ul>
<p>对东西进行计数? 一个 <code>Bag</code>  就做到了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.say for &apos;This is just a sentence&apos;.comb.Bag;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># n =&gt; 2</div><div class="line"># a =&gt; 1</div><div class="line">#   =&gt; 4</div><div class="line"># c =&gt; 1</div><div class="line"># j =&gt; 1</div><div class="line"># s =&gt; 4</div><div class="line"># T =&gt; 1</div><div class="line"># e =&gt; 3</div><div class="line"># t =&gt; 2</div><div class="line"># i =&gt; 2</div><div class="line"># u =&gt; 1</div><div class="line"># h =&gt; 1</div></pre></td></tr></table></figure>
<p>使用集合操作符写简明代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $valid = set &lt;foo bar ber boor&gt;;</div><div class="line">my @given = &lt;foo meow bar ber&gt;;</div><div class="line"></div><div class="line">say ‘Something&apos;s wrong’ unless @given ⊆ $valid;</div></pre></td></tr></table></figure>
<p>并集和差集:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">say &lt;foo bar&gt; ∪ &lt;bar meow&gt;;  # Union operator</div><div class="line">say &lt;foo bar&gt; ⊖ &lt;bar meow&gt;;  # Symmetric set difference operator</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># set(foo, bar, meow)</div><div class="line"># set(foo, meow)</div></pre></td></tr></table></figure>
<p>查看 <a href="http://docs.perl6.org/language/setbagmix" target="_blank" rel="external">the docs</a> 获取完整的操作符列表。</p>
<h2 id="Polyglot"><a href="#Polyglot" class="headerlink" title="Polyglot"></a>Polyglot</h2><p>在 Perl 6 使用其它语言!</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-5c9d882e4102b06a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="NativeCall"><a href="#NativeCall" class="headerlink" title="NativeCall"></a>NativeCall</h2><p>不用写任何 C 代码就可以使用  C libraries!!</p>
<p>(或多或少)</p>
<p>标准 C library:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use NativeCall;</div><div class="line">sub fork is native &#123;&#125;;</div><div class="line">fork;</div><div class="line">say $*PID;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 11274</div><div class="line"># 11275</div></pre></td></tr></table></figure>
<h2 id="BTW-A-Safety-Tip"><a href="#BTW-A-Safety-Tip" class="headerlink" title="BTW: A Safety Tip"></a>BTW: A Safety Tip</h2><p>在标准 C 库中有一个 <code>system</code> </p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-3dece01d75627a4d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>使用 C library:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class STMT is repr(&apos;CPointer&apos;) &#123; &#125;;</div><div class="line">sub sqlite3_column_text(STMT, int32)</div><div class="line">    returns Str</div><div class="line">    is native(&apos;sqlite3&apos;, v0) &#123; &#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int8           (int8_t in C, also used for char)</div><div class="line">int16          (int16_t in C, also used for short)</div><div class="line">int32          (int32_t in C, also used for int)</div><div class="line">int64          (int64_t in C)</div><div class="line">uint8          (uint8_t in C, also used for unsigned char)</div><div class="line">uint16         (uint16_t in C, also used for unsigned short)</div><div class="line">uint32         (uint32_t in C, also used for unsigned int)</div><div class="line">uint64         (uint64_t in C)</div><div class="line">long           (long in C)</div><div class="line">longlong       (long long in C, at least 64-bit)</div><div class="line">num32          (float in C)</div><div class="line">num64          (double in C)</div><div class="line">Str            (C string)</div><div class="line">CArray[int32]  (int* in C, an array of ints)</div><div class="line">Pointer[void]  (void* in C, can point to all other types)</div><div class="line">bool           (bool from C99)</div><div class="line">size_t         (size_t in C)</div></pre></td></tr></table></figure>
<p>使用 <a href="http://modules.perl6.org/dist/App::GPTrixie" target="_blank" rel="external">App::GPTrixie</a> 把 C 头文件转换为 Perl 6 子例程定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ gptrixie --all /usr/local/include/gumbo.h</div><div class="line"></div><div class="line">## Enumerations</div><div class="line">enum GumboNamespaceEnum is export (</div><div class="line">   GUMBO_NAMESPACE_HTML =&gt; 0,</div><div class="line">   GUMBO_NAMESPACE_SVG =&gt; 1,</div><div class="line">   GUMBO_NAMESPACE_MATHML =&gt; 2</div><div class="line">);</div><div class="line">enum GumboParseFlags is export (</div><div class="line">   GUMBO_INSERTION_NORMAL =&gt; 0,</div><div class="line">   GUMBO_INSERTION_BY_PARSER =&gt; 1,</div><div class="line"></div><div class="line">   ...</div></pre></td></tr></table></figure>
<h2 id="Inline-Perl5"><a href="#Inline-Perl5" class="headerlink" title="Inline::Perl5"></a><a href="http://modules.perl6.org/dist/Inline::Perl5" target="_blank" rel="external">Inline::Perl5</a></h2><p>在 Perl 6中使用任意 Perl 5 模块!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">use Inline::Perl5;</div><div class="line">use Mojo::DOM:from&lt;Perl5&gt;;</div><div class="line"> </div><div class="line">my $dom = Mojo::DOM.new: &apos;&lt;p&gt;&lt;b&gt;This is awesome&lt;/b&gt;, trust me&lt;/p&gt;&apos;;</div><div class="line"> </div><div class="line">say $dom.at(&apos;b&apos;).all_text;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># This is awesome</div></pre></td></tr></table></figure>
<ul>
<li>支持 Perl 5 模块, 包括 XS 模块。</li>
<li>允许在 Perl 5 和 Perl 6 之间传递整数、字符串、数组、散列、代码引用、文件句柄和对象。</li>
<li>支持从 Perl 6 中在 Perl 5 对象上调用方法并且支持从 Perl 5 中在 Perl 6 对象上调用方法。</li>
<li>在 Perl 6中子类化 Perl 5 的类。</li>
</ul>
<h2 id="使用一堆其它语言…"><a href="#使用一堆其它语言…" class="headerlink" title="使用一堆其它语言…"></a><strong>使用一堆其它语言</strong>…</h2><p>你和我展示的可能有点不同:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-fc3ec03dfe5240f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h2 id="Simple-Things-Hacking-on-the-Perl-6-Compiler"><a href="#Simple-Things-Hacking-on-the-Perl-6-Compiler" class="headerlink" title="Simple Things:Hacking on the Perl 6 Compiler"></a>Simple Things:Hacking on the Perl 6 Compiler</h2><p><img src="http://upload-images.jianshu.io/upload_images/326727-0c0668c970b6cc1b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="听起来很疯狂…"><a href="#听起来很疯狂…" class="headerlink" title="听起来很疯狂…"></a><strong>听起来很疯狂</strong>…</h2><p>Perl 6 大部分是用 Perl 6 写的!</p>
<h2 id="这意味着…"><a href="#这意味着…" class="headerlink" title="这意味着…"></a><strong>这意味着</strong>…</h2><p>一般的 Perl 6 使用者可以使 Perl 6 变得更好!</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-1cb84f014ede918b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="Perl-6-is-Written-in-Perl-6"><a href="#Perl-6-is-Written-in-Perl-6" class="headerlink" title="Perl 6 is Written in Perl 6"></a>Perl 6 is Written in Perl 6</h2><h3 id="How"><a href="#How" class="headerlink" title="How??"></a>How??</h3><p>基础是用 NQP 写的 (Not Quite Perl):<a href="https://github.com/perl6/nqp" target="_blank" rel="external">https://github.com/perl6/nqp</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-28231953961eec03.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其它的是用 Perl 6 写的: <a href="https://github.com/rakudo/rakudo" target="_blank" rel="external">https://github.com/rakudo/rakudo</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-7f43059cb5b74117.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="那么解析呢…"><a href="#那么解析呢…" class="headerlink" title="那么解析呢…?"></a>那么解析呢…?</h3><p>是的, 仅仅是一个 Perl 6 Grammar:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-e54d22969bf5ef49.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="Bonus-Slides"><a href="#Bonus-Slides" class="headerlink" title="Bonus Slides"></a>Bonus Slides</h2><h2 id="并发代码中的错误"><a href="#并发代码中的错误" class="headerlink" title="并发代码中的错误"></a><strong>并发代码中的错误</strong></h2><p>错误在哪一行?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">my $promise = start &#123;</div><div class="line">    say 0/0;</div><div class="line">    # A whole</div><div class="line">    # bunch</div><div class="line">    # of other code</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">say await $promise;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Attempt to divide by zero using div</div><div class="line">#   in block &lt;unit&gt; at test.p6 line 8</div></pre></td></tr></table></figure>
<p>包含一个花括号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> 1: my $promise = start &#123;</div><div class="line"> 2:     say 0/0;</div><div class="line"> 3:     # A whole</div><div class="line"> 4:     # bunch</div><div class="line"> 5:     # of other code</div><div class="line"> 6:     CATCH &#123; warn .backtrace &#125;;</div><div class="line"> 7: &#125;;</div><div class="line"> 8:</div><div class="line"> 9: say await $promise;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line">#   in block  at test.p6 line 2</div><div class="line">#   in block  at test.p6 line 6</div><div class="line"># Attempt to divide by zero using div</div><div class="line">#   in block &lt;unit&gt; at test.p6 line 9</div></pre></td></tr></table></figure>
<h2 id="有理数"><a href="#有理数" class="headerlink" title="有理数!"></a><strong>有理数</strong>!</h2><p><code>Rat</code> 是一种 Perl 6 类型, 它由分子和分母表示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $x = 0/0;</div><div class="line">say &apos;Universe is still unimploded&apos;;</div><div class="line">say sin $x;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Universe is still unimploded</div><div class="line"># NaN</div></pre></td></tr></table></figure>
<p>实际的数字只在需要时计算:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">my $x = 0/0;</div><div class="line">say &apos;Universe is still unimploded&apos;;</div><div class="line">say $x;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Universe is still unimploded</div><div class="line"># Attempt to divide by zero using div</div><div class="line">#   in block &lt;unit&gt; at test.p6 line 3</div><div class="line">#</div><div class="line"># Actually thrown at:</div><div class="line">#   in block &lt;unit&gt; at test.p6 line 3</div></pre></td></tr></table></figure>
<h2 id="Proc-Async"><a href="#Proc-Async" class="headerlink" title="Proc::Async"></a><a href="http://docs.perl6.org/language/concurrency#Proc%3A%3AAsync" target="_blank" rel="external">Proc::Async</a></h2><p>Async 和其它程序通信:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">my $proc = Proc::Async.new: :w, &apos;grep&apos;, &apos;foo&apos;;</div><div class="line">$proc.stdout.tap: -&gt; $v &#123; print &quot;Output: $v&quot; &#125;;</div><div class="line"></div><div class="line">say &apos;Starting grep process...&apos;;</div><div class="line">my $promise = $proc.start;</div><div class="line">    $proc.say: &apos;this line has foo&apos;;</div><div class="line">    $proc.say: &quot;this one doesn&apos;t&quot;;</div><div class="line">    $proc.close-stdin;</div><div class="line">await $promise;</div><div class="line">say &apos;Done.&apos;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Starting grep process...</div><div class="line"># Output: this line has foo</div><div class="line"># Done.</div></pre></td></tr></table></figure>
<h2 id="不要-say-太多"><a href="#不要-say-太多" class="headerlink" title="不要 say 太多!"></a><strong>不要</strong> <code>say</code> <strong>太多</strong>!</h2><p><code>say</code> 函数/方法用于展示人类可读的简明信息并调用对象的 <code>gist</code> 方法。如果你想输出一大堆东西, 那么使用 <code>put</code> 函数/方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">^101 .say;</div><div class="line">(0..100).list.say;</div><div class="line">say &apos;----------&apos;;</div><div class="line">^101 .put;</div><div class="line">(0..100).put;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># ^101</div><div class="line"># (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 ...)</div><div class="line"># ----------</div><div class="line"># 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100</div><div class="line"># 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100</div></pre></td></tr></table></figure>
<h2 id="更有用的对象"><a href="#更有用的对象" class="headerlink" title="更有用的对象"></a><strong>更有用的对象</strong></h2><p> 当使用<code>say</code>-ed, <code>put</code>-ed, 或其它任何东西时, 让你的对象更加准确地工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Thingamagig &#123;</div><div class="line">    method gist    &#123; &apos;Brief info&apos;        &#125;</div><div class="line">    method Str     &#123; &apos;Not so brief info&apos; &#125;</div><div class="line">    method Numeric &#123; 42                  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $thing = Thingamagig.new;</div><div class="line">say $thing;</div><div class="line">put $thing;</div><div class="line">say $thing + 2;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Brief info</div><div class="line"># Not so brief info</div><div class="line"># 44</div></pre></td></tr></table></figure>
<h2 id="内置的性能分析器"><a href="#内置的性能分析器" class="headerlink" title="内置的性能分析器"></a><strong>内置的性能分析器</strong></h2><p>仅仅在命令行上指定 <code>--profile</code> 标记, 就会为你生成 HTML 格式的结果文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ perl6 --profile test.p6</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-8a66f7a51366f797.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="谢谢"><a href="#谢谢" class="headerlink" title="谢谢!"></a><strong>谢谢</strong>!</h2><p>Any Questions?</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大列表重构]]></title>
      <url>http://ohmycloud.github.io/2016/08/12/%E5%A4%A7%E5%88%97%E8%A1%A8%E9%87%8D%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>Perl 6 最近(2015.9)经历的最大的变化就是 Great List Refactor(GLR), 俗称大列表重构。</p>
<p>它还很难解释！但是幸好有某些历史背景能帮助我们。 在 2014 年澳大利亚 Perl Workshop 会议上讨论了很多 GLR 的东西,  Patrick Michaud 在它的博客上写了很多关于 GLR 的内容。</p>
<p>GLE 意图强调性能和列表和相关类型操作的一致性问题。改变这样的基本数据类型将会很痛苦。</p>
<p>通常 Perl 5 这样展开列表:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">% perl -dE <span class="number">1</span> -MData::Dumper</div><div class="line"></div><div class="line">[...snip...]</div><div class="line">DB&lt;<span class="number">1</span>&gt; @foos=((<span class="number">1</span>,<span class="number">2</span>),<span class="number">3</span>)</div><div class="line"></div><div class="line">DB&lt;<span class="number">2</span>&gt; <span class="keyword">say</span> Dumper \@foos</div><div class="line">$VAR1 = [</div><div class="line">    <span class="number">1</span>,</div><div class="line">    <span class="number">2</span>,</div><div class="line">    <span class="number">3</span></div><div class="line">];</div></pre></td></tr></table></figure>
<p>开始, 很多的 Perl 6 行为都模仿这种展平行为但是在去年年底的时候, 使用 non-flatterning(非展平)行为以保留原始数据结构的用法越来越多。</p>
<p>这样做和很多边界情况不一致并且 Rakudo 内部大量使用了一种叫做 <code>Parcel</code> 的数据类型, 之后 Parcel 被认为是一个 Bad Idea(糟糕的设计) —  主要是因为性能问题。</p>
<p>2015 年 7 月, Patrick 导入了一个涵盖 “Synopsis 7” 的孪生设计草案, 随后的月份中它变成官方的 S07。</p>
<p>8 月份对于 GLR 是很繁忙的一个月。乔纳森.华盛顿在 Rakudo 仓库下开启了一个单独的 GLR 分支。很多人在那个分支下协同工作。同时在 IRC 频道有俩个机器人, Camelia 和 GLRelia(后者跟踪 GLR 分支)。所以人们能很快尝试并比较在新旧系统中代码的行为。大量的变化和诸如 panda 的软件不得不进行修补以保持功能。</p>
<p><strong>Parcel</strong> 数据类型变成了 <strong>List</strong>（它是不可变的并使用圆括号）而数组是 List 的一个可变子类, 它使用方括号。数组不再拥有隐式的列表展平行为。简单的数组可以使用 <code>.flat</code>方法进行展平。</p>
<h3 id="Pre-GLR"><a href="#Pre-GLR" class="headerlink" title="Pre GLR"></a>Pre GLR</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @array = 1,(2,3),4;       # 1 2 3 4</div><div class="line">@array.elems.say;            # 4</div></pre></td></tr></table></figure>
<h3 id="Post-GLR"><a href="#Post-GLR" class="headerlink" title="Post GLR"></a>Post GLR</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my @array = 1,(2,3),4;        # [1 (2 3) 4]</div><div class="line">@array.elems.say;             # 3</div><div class="line"></div><div class="line">my @array = (1,(2,3),4).flat; # [1 2 3 4]</div></pre></td></tr></table></figure>
<p>把列表滑进(Slip)数组中也是可行的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @a = 1, (2, 3).Slip, 4;    # [1 2 3 4]</div></pre></td></tr></table></figure>
<p>还有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @a = 1, |(2,3), 4;         # [1 2 3 4]</div></pre></td></tr></table></figure>
<p>序列(只能够被耗费<strong>一次</strong>)被引入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $grep = (1..4).grep(*&gt;2);  # (3 4)</div><div class="line">$grep.^name.say;              # Seq</div></pre></td></tr></table></figure>
<p>而 <code>.cache</code>方法能用于阻止 Seq 的消费。</p>
<h3 id="The-Single-Argument-Rule"><a href="#The-Single-Argument-Rule" class="headerlink" title="The Single Argument Rule"></a>The Single Argument Rule</h3><hr>
<p>传递给诸如 <em>for</em>循环迭代器的参数遵守”the single arg rule”, 意思是即使第一眼看上去是以多个参数出现的, 也会被当作单个参数。通常这会让 <em>for</em> 表现得如程序员所期望的那样除了带有尾随逗号的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">my @a = 1,2,3;</div><div class="line">my ($i, $j);</div><div class="line">for (@a) &#123;</div><div class="line">    $i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (@a,) &#123; # 这实际上是单个元素列表(single element list)</div><div class="line">    $j++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say :$i.gist;  # =&gt; 3</div><div class="line">say :$j.gist;  # =&gt; 1</div></pre></td></tr></table></figure>
<p>S07 在 2015年9月份被乔纳森-华盛顿重写了。结果就是 S07经历了很多改变。<em>Parcel</em> 被移除了, 重新引入进来, 并且最终又被移除了!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Abundant-and-Deficient-Numbers]]></title>
      <url>http://ohmycloud.github.io/2016/08/11/Abundant-and-Deficient-Numbers/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><hr>
<p><em>abundant</em> 数是其所有因子的和大于该数，而deficient数是其因子的和小于该数。</p>
<p>例如, 考虑数字 21。它的因子是 1, 3, 7 和 21, 这些因子的和是32。 因为 32 小于 2 x 21, 所以 21 是 deficient。它的差额是 2 x 21 - 32 = 10。</p>
<p>12 是第一个 abundant 数。它的因子是 1, 2, 3, 4, 6 和 12, 并且它们的和是 28。 因为 28 大于 2 x 12, 所以 12 是 abundant。它们的差额是 28 - 2 x 12 = 4。</p>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><hr>
<p>你会给定一个整数, 每行一个。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">18</div><div class="line">21</div><div class="line">9</div></pre></td></tr></table></figure>
<h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><hr>
<p>你的程序应该打印信息, 如果数字是 deficient, abundant(和它的abundance), 或者都不。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">18 abundant by 3</div><div class="line">21 deficient</div><div class="line">9 ~~neither~~ deficient</div></pre></td></tr></table></figure>
<h4 id="输入挑战"><a href="#输入挑战" class="headerlink" title="输入挑战"></a>输入挑战</h4><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">111  </div><div class="line">112 </div><div class="line">220 </div><div class="line">69 </div><div class="line">134 </div><div class="line">85</div></pre></td></tr></table></figure>
<h4 id="挑战输出"><a href="#挑战输出" class="headerlink" title="挑战输出:"></a>挑战输出:</h4><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">111 ~~neither~~ deficient </div><div class="line">112 abundant by 24</div><div class="line">220 abundant by 64</div><div class="line">69 deficient</div><div class="line">134 deficient</div><div class="line">85 deficient</div></pre></td></tr></table></figure>
<p><a href="https://www.reddit.com/user/smls" target="_blank" rel="external">smls</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for lines() -&gt; $n &#123;</div><div class="line">    my $sum = (1..$n/2).grep($n %% *).sum;</div><div class="line">    say &quot;$n &quot; ~ ($sum &gt; $n ?? &quot;abundant by &#123;$sum - $n&#125;&quot; !!</div><div class="line">                 $sum &lt; $n ?? &quot;deficient&quot; !! &quot;neither&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for lines() -&gt; $n &#123;</div><div class="line">    given (1..$n/2).grep($n %% *).sum &#123;</div><div class="line">        when * &gt; $n &#123; say &quot;$n abundant by &#123;$_ - $n&#125;&quot; &#125;</div><div class="line">        when * &lt; $n &#123; say &quot;$n deficient&quot; &#125;</div><div class="line">        default     &#123; say &quot;$n neither&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Quoting-Constructs]]></title>
      <url>http://ohmycloud.github.io/2016/08/09/Quoting-Constructs/</url>
      <content type="html"><![CDATA[<h2 id="The-Q-Lang"><a href="#The-Q-Lang" class="headerlink" title="The Q Lang"></a>The Q Lang</h2><hr>
<p>在 Perl 6 中, 字符串通常使用一些引号结构来表示. 这些引号结构中,最简单的就是 <code>Q</code>, 通过便捷方式 <code>｢…｣</code> 或 <code>Q</code> 后跟着由任意一对儿分隔符包围着的文本. 大多数时候, 你需要的只是 <code>&#39;…&#39;</code> 或 <code>&quot;…&quot;</code>.</p>
<h3 id="Literal-strings-Q"><a href="#Literal-strings-Q" class="headerlink" title="Literal strings: Q"></a>Literal strings: Q</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Q[A literal string]</div><div class="line">｢More plainly.｣</div><div class="line">Q ^Almost any non-word character can be a delimiter!^</div></pre></td></tr></table></figure>
<p>分隔符能够嵌套, 但是在普通的 Q 形式中, 反斜线转义是不允许的. 换种说法就是, Q 字符串尽可能被作为字面量.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Q&lt;Make sure you &lt;match&gt; opening and closing delimiters&gt;</div><div class="line">Q&#123;This is still a closing brace → \&#125;</div></pre></td></tr></table></figure>
<p>这些例子产生:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A literal string</div><div class="line">More plainly.</div><div class="line">Almost any non-word character can be a delimiter!</div><div class="line">Make sure you &lt;match&gt; opening and closing delimiters</div><div class="line">This is still a closing brace → \</div></pre></td></tr></table></figure>
<h3 id="Escaping-q"><a href="#Escaping-q" class="headerlink" title="Escaping: q"></a>Escaping: q</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&apos;Very plain&apos;</div><div class="line">q[This back\slash stays]</div><div class="line">q[This back\\slash stays] # Identical output</div><div class="line">q&#123;This is not a closing brace → \&#125;, but this is → &#125;</div><div class="line">Q :q $There are no backslashes here, only lots of \$\$\$!$</div><div class="line">&apos;(Just kidding. There\&apos;s no money in that string)&apos;</div><div class="line">&apos;No $interpolation &#123;here&#125;!&apos;</div><div class="line">Q:q#Just a literal &quot;\n&quot; here#</div></pre></td></tr></table></figure>
<p><code>q</code> 形式的引号结构允许使用反斜线转义可能会结束字符串的字符. 反斜线自身也能被转义, 就像上面的第三个例子那样. 通常的形式是 <code>&#39;...&#39;</code> 或 <code>q</code> 后跟着分隔符, 但是它也能作为 Q 上的副词使用, 就像上面的第五个和最后一个例子那样.</p>
<p>这些例子产生:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Very plain</div><div class="line">This back\slash stays</div><div class="line">This back\slash stays</div><div class="line">This is not a closing brace → &#125; but this is →</div><div class="line">There are no backslashes here, only lots of $$$!</div><div class="line">(Just kidding. There&apos;s no money in that string)</div><div class="line">No $interpolation &#123;here&#125;!</div><div class="line">Just a literal &quot;\n&quot; here</div></pre></td></tr></table></figure>
<h3 id="Interpolation-qq"><a href="#Interpolation-qq" class="headerlink" title="Interpolation: qq"></a>Interpolation: qq</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $color = &apos;blue&apos;;</div><div class="line">say &quot;My favorite color is $color!&quot; # My favorite color is blue!</div></pre></td></tr></table></figure>
<p><code>qq</code> 形式 – 通常使用双引号写成 – 允许变量的插值, 例如字符串中能写入变量, 以使变量的内容能插入到字符串中. 在 <code>qq</code> 引起字符串中, 也能转义变量.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say &quot;The \$color variable contains the value &apos;$color&apos;&quot;;</div><div class="line"># The $color variable contatins the value &apos;blue&apos;</div></pre></td></tr></table></figure>
<p><code>qq</code> 的另外一种功能是使用花括号在字符串中插值 Perl 6 代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my ($x, $y, $z) = 4, 3.5, 3;</div><div class="line">say &quot;This room is $x m by $y m by $z m.&quot;</div><div class="line">say &quot;Therefore its volume should be &#123; $x * $y * $z &#125; m³!&quot;</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">This room is 4 m by 3.5 m by 3 m.</div><div class="line">Therefore its volume should be 42 m³!</div></pre></td></tr></table></figure>
<p>默认情况下, 只有带有 ‘$’ 符号的变量才能正常插值. 这时, <code>&quot;documentation@perl6.org&quot;</code> 不会插值  <code>@perl6</code> 变量. 如果呢确实想那么做, 在变量名后面添加一个 <code>[]</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @neighbors = &quot;Felix&quot;, &quot;Danielle&quot;, &quot;Lucinda&quot;;</div><div class="line">say &quot;@neighbors[] and I try our best to coexist peacefully.&quot;</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Felix Danielle Lucinda and I try our best to coexist peacefully.</div></pre></td></tr></table></figure>
<p>通常使用一个方法调用会更合适. 只有在 qq 引号中, 方法调用后面有圆括号, 就能进行插值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;@neighbors.join(&apos;, &apos;) and I try our best to coexist peacefully.&quot;</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Felix, Danielle, Lucinda and I try our best to coexist peacefully.</div></pre></td></tr></table></figure>
<p>而 <code>&quot;@example.com&quot;</code> 产生 <code>@example.com</code>.</p>
<h3 id="Word-quoting-qw"><a href="#Word-quoting-qw" class="headerlink" title="Word quoting: qw"></a>Word quoting: qw</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a b c&gt; eqv (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)</div><div class="line">qw|! @ # $ % ^ &amp; * \| &lt; &gt; | eqv &apos;! @ # $ % ^ &amp; | &lt; &gt;&apos;.words</div><div class="line">Q:w &#123; [ ] \&#123; \&#125; &#125; eqv (&apos;[&apos;, &apos;]&apos;, &apos;&#123;&apos;, &apos;&#125;&apos;)</div></pre></td></tr></table></figure>
<p><code>:w</code> 通常写作 <code>&lt;...&gt;</code> 或 <code>qw</code>, 把字符串分割为”words” (单词). 在这种情景下, 单词被定义为由空格分割的一串非空白字符. <code>q:w</code> 和 <code>qw</code> 继承了 <code>q</code> 的插值和转义语法, 还有单引号字符串分割符, 而 <code>Qw</code> 和 <code>Q:w</code> 继承了 <code>Q</code> 的非转义语法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @directions = &apos;left&apos;, &apos;right,&apos;, &apos;up&apos;, &apos;down&apos;;</div></pre></td></tr></table></figure>
<p>这样读和写都更容易:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @directions = &lt;left right up down&gt;;</div></pre></td></tr></table></figure>
<h3 id="Word-quoting-with-interpolation-qqw"><a href="#Word-quoting-with-interpolation-qqw" class="headerlink" title="Word quoting with interpolation: qqw"></a>Word quoting with interpolation: qqw</h3><hr>
<p><code>qw</code> 形式的 word quoting 不会进行变量插值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $a = 42; say qw&#123;$a b c&#125;;  # $a b c</div></pre></td></tr></table></figure>
<p>因此, 如果你想在引号字符串中进行变量插值, 你需要使用 <code>qqw</code> 变体:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $a = 42;</div><div class="line">my @list = qqw&#123;$a b c&#125;;</div><div class="line">say @list;                # 42 b c</div></pre></td></tr></table></figure>
<p>或者同样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $a = 42;</div><div class="line">my @list = «$a b c»;</div><div class="line">say @list;                # 42 b c</div></pre></td></tr></table></figure>
<h3 id="Shell-quoting-qx"><a href="#Shell-quoting-qx" class="headerlink" title="Shell quoting: qx"></a>Shell quoting: qx</h3><hr>
<p>把一个字符串作为一个外部程序运行,  在 Perl 6 中反引号不再用于 shell quoting, 并且 qx 不再插值 Perl 变量, 因此:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $world = &quot;there&quot;;</div><div class="line">say qx&#123;echo &quot;hello $world&quot;&#125;</div></pre></td></tr></table></figure>
<p>仅仅打印 hello. 然而, 如果你在调用 perl6 之前声明了一个环境变量, 这在 qx 里是可用的, 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WORLD=&quot;there&quot; perl6</div><div class="line">&gt; say qx&#123;echo &quot;hello $WORLD&quot;&#125;</div></pre></td></tr></table></figure>
<p>现在会打印 hello there.</p>
<p>调用 <code>qx</code> 会返回结果, 所以这个结果能被赋值给一个变量以便后来使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $output = qx&#123;echo &quot;hello!&quot;&#125;;</div><div class="line">say $output;    # hello!</div></pre></td></tr></table></figure>
<h3 id="Shell-quoting-with-interpolation-qqx"><a href="#Shell-quoting-with-interpolation-qqx" class="headerlink" title="Shell quoting with interpolation: qqx"></a>Shell quoting with interpolation: qqx</h3><hr>
<p>带插值的 Shell quoting:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $world = &quot;there&quot;;</div><div class="line">say qqx&#123;echo &quot;hello $world&quot;&#125;;  # hello there</div></pre></td></tr></table></figure>
<p>再一次, 外部命令的输出结果可以保存在一个变量中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my $word = &quot;cool&quot;;</div><div class="line">my $option = &quot;-i&quot;;</div><div class="line">my $file = &quot;/usr/share/dict/words&quot;;</div><div class="line">my $output = qqx&#123;grep $option $word $file&#125;;</div><div class="line"># runs the command: grep -i cool /usr/share/dict/words</div><div class="line">say $output;      # Cooley␤Cooley&apos;s␤Coolidge␤Coolidge&apos;s␤cool␤ ...</div></pre></td></tr></table></figure>
<h3 id="Heredocs-to"><a href="#Heredocs-to" class="headerlink" title="Heredocs: :to"></a>Heredocs: :to</h3><hr>
<p><code>heredocs</code> 是多行字符串字面量的便捷方式, 你能选择自己的分隔符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">say q:to/END/;</div><div class="line">Here is</div><div class="line">some multi-line</div><div class="line">string</div><div class="line">END</div></pre></td></tr></table></figure>
<p> heredoc 的内容从下一行开始.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $escaped = my-escaping-function(q:to/TERMINATOR/, language =&gt; &apos;html&apos;);</div><div class="line">Here are the contents of the heredoc.</div><div class="line">Potentially multiple lines.</div><div class="line">TERMINATOR</div></pre></td></tr></table></figure>
<p>如果终止分隔符缩进了, 同等数量的缩进会从字符串字面量上移除. 因此下面这个 heredoc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">say q:to/END/;</div><div class="line">    Here is</div><div class="line">    some multi line</div><div class="line">        string</div><div class="line">    END</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Here is</div><div class="line">some multi line</div><div class="line">    string</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[智能匹配]]></title>
      <url>http://ohmycloud.github.io/2016/08/03/%E6%99%BA%E8%83%BD%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<h3 id="智能匹配"><a href="#智能匹配" class="headerlink" title="智能匹配"></a>智能匹配</h3><hr>
<p>智能匹配通常作用在当前”主题”(topic)上, 即作用在 <code>$_</code> 变量上. 在下面的表格中, <code>$_</code> 代表 <code>~~</code> 操作符的左侧, 或者作为 <code>given</code> 的参数,  或者作为其它主题化的参数.  <code>X</code> 代表 <code>~~</code> 操作符右侧要匹配的模式, 或者在 <code>when</code> 后面的模式.(实际上, <code>~~</code> 操作符充当着一个小型的主题; 即, 为了右侧的计算, 它把 <code>$_</code> 绑定到左侧的值上. 使用底层的 <code>.ACCEPTS</code> 形式来避免这种主题化.)</p>
<p>第一节包含了含有享有特权的语法; 如果匹配能通过那些条目之一完成, 那它就会那样做. 这些特别的语法是通过它们的形式而非它们的类型进行分派的. 否则就使用表格中的剩余部分,并且匹配会根据普通的方法分派规则进行分派.  允许优化器(optimizer)假定编译时之后没有定义额外的匹配操作符, 所以, 如果在编译时模式类型就显而易见的, 那么跳转表(jump table)可以被优化. 然而, 这部分表格的语法仍然有点特权的, 跟 <code>~~</code> 操作符一样, 是 Perl 中少有的几个不使用多重分派的操作符之一. 相反, 基于类型的智能匹配会被单个地分派给属于 <code>X</code> 模式对象的底层方法.</p>
<p>换句话说, 智能匹配首先根据模式(pattern)的<code>形式</code>或<code>类型</code>(下面的<code>X</code>)进行<code>分派</code>(dispatch), 然后那个模式自身决定<code>是否</code>和<code>怎样</code>注意主题(<code>$_</code>)的类型. 所以, 下面表格中的第二列就是初始列. 第一列中的 <code>Any</code> 条目标示了模式要么不关心主题的类型,  要么把那个条目作为默认值, 因为上面列出的更具体的类型不匹配.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">$_          X         Type of Match Implied   Match <span class="keyword">if</span> (<span class="keyword">given</span> $_)</div><div class="line">======      =====     =====================   ===================</div><div class="line">Any         True      ~~ True                 (parsewarn on literal token)</div><div class="line">Any         False     ~~ False match          (parsewarn on literal token)</div><div class="line">Any         Match     ~~ Successful match     (parsewarn on literal token)</div><div class="line">Any         Nil       ~~ Benign failure       (parsewarn on literal token)</div><div class="line">Any         Failure   Failure type check      (okay, matches against type)</div><div class="line">Any         *         block signature match   block successfully binds to |$_</div><div class="line">Any         Callable:($)  item <span class="function"><span class="keyword">sub</span> <span class="title">truth</span>      <span class="title">X</span>($_)</span></div><div class="line">                                              <span class="title">S03</span>-<span class="title">smartmatch</span>/<span class="title">any</span>-<span class="title">callable</span>.<span class="title">t</span> <span class="title">lines</span> 5–14</div><div class="line"><span class="title">Any</span>         <span class="title">Callable</span>:()   <span class="title">simple</span> <span class="title">closure</span> <span class="title">truth</span>    <span class="title">X</span>() (<span class="title">ignoring</span> $_)</div><div class="line">                                              <span class="title">S03</span>-<span class="title">smartmatch</span>/<span class="title">any</span>-<span class="title">callable</span>.<span class="title">t</span> <span class="title">lines</span> 15–24</div><div class="line"></div><div class="line"><span class="title">Any</span>         <span class="title">Bool</span>      <span class="title">simple</span> <span class="title">truth</span>            <span class="title">X</span> (<span class="title">treats</span> <span class="title">Bool</span> <span class="title">value</span> <span class="title">as</span> <span class="title">success</span>/<span class="title">failure</span>)</div><div class="line">                                              <span class="title">S03</span>-<span class="title">smartmatch</span>/<span class="title">any</span>-<span class="title">bool</span>.<span class="title">t</span> <span class="title">lines</span> 5–23</div><div class="line"></div><div class="line"><span class="title">Any</span>         <span class="title">List</span>      <span class="title">list</span> <span class="title">truth</span>              <span class="title">X</span> (<span class="title">treats</span> <span class="title">list</span> <span class="title">size</span> <span class="title">as</span> <span class="title">success</span>/<span class="title">failure</span>)</div><div class="line"><span class="title">Any</span>         <span class="title">Match</span>     <span class="title">match</span> <span class="title">success</span>           <span class="title">X</span> (<span class="title">treats</span> <span class="title">Match</span> <span class="title">value</span> <span class="title">as</span> <span class="title">success</span>)</div><div class="line"><span class="title">Any</span>         <span class="title">Nil</span>       <span class="title">benign</span> <span class="title">failure</span>          <span class="title">X</span> (<span class="title">treats</span> <span class="title">Nil</span> <span class="title">value</span> <span class="title">as</span> <span class="title">failure</span>)</div><div class="line"><span class="title">Any</span>         <span class="title">Failure</span>   <span class="title">malign</span> <span class="title">failure</span>          <span class="title">X</span> (<span class="title">passes</span> <span class="title">Failure</span> <span class="title">object</span> <span class="title">through</span>)</div><div class="line"><span class="title">Any</span>         <span class="title">Numeric</span>   <span class="title">numeric</span> <span class="title">equality</span>        +$_ == <span class="title">X</span></div><div class="line"><span class="title">Any</span>         <span class="title">Stringy</span>   <span class="title">string</span> <span class="title">equality</span>         ~$_ <span class="title">eq</span> <span class="title">X</span></div><div class="line"><span class="title">Any</span>         <span class="title">Whatever</span>  <span class="title">always</span> <span class="title">matches</span>          <span class="title">True</span></div><div class="line"><span class="title">Associative</span> <span class="title">Pair</span>      <span class="title">test</span> <span class="title">hash</span> <span class="title">mapping</span>       $_&#123;X.key&#125; ~~ X.value</div><div class="line">Any         Pair      test object attribute   ?.<span class="string">"&#123;X.key&#125;"</span> === ?X.value (e.g. filetests)</div><div class="line">                                              S03-smartmatch/any-pair.t lines <span class="number">5</span>–<span class="number">35</span></div><div class="line"></div><div class="line">Set         Set       identical sets          $_ === X</div><div class="line">Any         Setty     force set comparison    $_.Set === X.Set</div><div class="line">Bag         Bag       identical bags          $_ === X</div><div class="line">Any         Baggy     force bag comparison    $_.Bag === X.Bag</div><div class="line">Mix         Mix       identical bags          $_ === X</div><div class="line">Any         Mixy      force mix comparison    $_.Mix === X.Mix</div><div class="line">Positional  Array     arrays are comparable   $_ «===» X (dwims * wildcards!)</div><div class="line">                                              S03-smartmatch/array-array.t lines <span class="number">5</span>–<span class="number">70</span></div><div class="line"></div><div class="line">Associative Array     <span class="keyword">keys</span>/list are comparable +X == +$_ <span class="keyword">and</span> $_&#123;X.all&#125;:<span class="keyword">exists</span></div><div class="line">Callable    Positional list vs predicate      so $_(X)</div><div class="line">Any         Positional lists are comparable   $_[] «===» X[]</div><div class="line">Hash        Hash      hash mapping equivalent $_ eqv X</div><div class="line">Associative Hash      force hash comparison   $_.Hash eqv X</div><div class="line">Callable    Hash      hash vs predicate       so $_(X)</div><div class="line">Positional  Hash      attempted any/all    FAIL, point user to [].any <span class="keyword">and</span> [].all <span class="keyword">for</span> LHS</div><div class="line">Pair        Hash      hash does mapping       X&#123;.key&#125; ~~ .value</div><div class="line">Any         Hash      hash contains object    X&#123;$_&#125;:<span class="keyword">exists</span></div><div class="line">Str         Regex     string pattern match    .match(X)</div><div class="line">Associative Regex     attempted <span class="keyword">reverse</span> dwim  FAIL, point user to any/all vs <span class="keyword">keys</span>/<span class="keyword">values</span>/pairs</div><div class="line">Positional  Regex     attempted any/all/cat   FAIL, point user to any/all/cat/<span class="keyword">join</span> <span class="keyword">for</span> LHS</div><div class="line">Any         Regex     pattern match           .match(X)</div><div class="line">Range       Range     subset range            !$_ <span class="keyword">or</span> .bounds.all ~~ X (mod ^<span class="string">'s)</span></div><div class="line">                                              S03-smartmatch/range-range.t lines 5–29</div><div class="line"></div><div class="line">Any         Range     in real range           X.min &lt;= $_ &lt;= X.max (mod ^'<span class="keyword">s</span>)</div><div class="line">                                              S03-smartmatch/disorganized.t lines <span class="number">30</span>–<span class="number">145</span></div><div class="line"></div><div class="line">Any         Range     in stringy range        X.min le $_ le X.max (mod ^<span class="string">'s)</span></div><div class="line">Any         Range     in generic range        [!after] X.min,$_,X.max (etc.)</div><div class="line">Any         Type      type membership         $_.does(X)</div><div class="line">                                              S03-smartmatch/any-type.t lines 5–40</div><div class="line"></div><div class="line">Signature   Signature sig compatibility       $_ is a subset of X      ???</div><div class="line">Callable    Signature sig compatibility       $_.sig is a subset of X  ???</div><div class="line">Capture     Signature parameters bindable     $_ could bind to X (doesn't!)</div><div class="line">Any         Signature parameters bindable     |$_ could <span class="keyword">bind</span> to X (doesn<span class="string">'t!)</span></div><div class="line">Signature   Capture   parameters bindable     X could bind to $_</div><div class="line">Any         Any       scalars are identical   $_ === X</div><div class="line">                                               S03-smartmatch/any-any.t lines 5–29</div></pre></td></tr></table></figure>
<p>如果没有其它模式要求 X, 最后那个 rule 才会被应用.</p>
<p>所有的智能匹配类型都是<code>itemized</code>; <code>~~</code> 和 <code>given/when</code> 都为它们的参数提供了 item (标量) 上下文, 并自动展开任何 junctive 匹配, 以使最终给 <code>.ACCEPTS</code> 的分派看不到任何复数. 所以,上面的 <code>$_</code> 和 <code>X</code> 是能被看作标量的潜在容器对象. (你可以显式地使 <code>~~</code> 亢奋, 在这种情况下, 所有的智能匹配是使用 <code>.ACCEPTS</code> 的基于类型的分派来完成的, 不是前面表格中的基于形式的分派)</p>
<p>基于类型的底层方法分派真正形式是 :</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X.ACCEPTS($_)</div></pre></td></tr></table></figure>
<p>作为单个分派调用, 这仅仅只关注初始化的 X 的类型. <code>ACCEPT</code> 方法接口是通过 <code>Pattern</code> role 来定义的. 任何组成 <code>Pattern</code> role 的类都可以选择提供单个 <code>ACCEPTS</code> 方法来处理一切, 这对用于那些上面说的 Any 中只有一个条目模式类型. </p>
<p>或者在类中,类也能选择提供多个 <code>ACCEPTS</code>  multi-methods, 这些然后会在类中根据 <code>$_</code> 的类型进行重新分派.</p>
<p>智能匹配表格主要用于反应编译时能识别的形式和类型. 为了避免条目的扩展, 表格假设下面的类型会表现的类似:</p>
<table>
<thead>
<tr>
<th style="text-align:left">实际类型</th>
<th style="text-align:left">把条目用作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Iterator Array</td>
<td style="text-align:left">List</td>
</tr>
<tr>
<td style="text-align:left">使用 Class,Enum,Role,或一般类型绑定的具名值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Cat</td>
<td style="text-align:left">Str</td>
</tr>
<tr>
<td style="text-align:left">Int UInt等</td>
<td style="text-align:left">Num</td>
</tr>
<tr>
<td style="text-align:left">BUf</td>
<td style="text-align:left">Str or Array of Int</td>
</tr>
</tbody>
</table>
<p>(注意, 然而, 这些映射可以通过显式的 ACCEPTS 方法的定义进行重写. 如果在编译时, 重定义比智能匹配的分析早, 那么信息对优化器也是可访问的).</p>
<p> 一个在 ASCII 范围之外, 包含任何字节或整数的 <code>Buf</code> 类型可能会静静地提升为 <code>Str</code> 类型用于匹配, 只有在它跟 Unicode 的关系被清楚地声明或类型化时. 这种类型信息可能来自输入文件句柄, 或者 <code>Buf</code> role 可能是一个参数类型, 它允许你使用各种编码来实例化 buffers. 在没有这样的类型信息的情况下, 你仍然可以跟 buffer 进行模式匹配, 但是任何把 buffer 当作不是整数序列的尝试都是错误的, 这通常会发生警告.</p>
<p>匹配 Grammar 会把 grammar 当作类型名, 而不是一个 grammar. 你需要使用 <code>.parse</code> 和 <code>.parsefile</code> 方法来调用一个 grammar.</p>
<p>匹配 <code>Signature</code> 不会真的绑定任何变量, 而是测试签名是否能绑定. 要真的绑定到一个签名上, 使用模式  <code>*</code> 来代理绑定到 <code>when</code>语句块上代替. 匹配 <code>*</code> 在 when 里面很特殊 .  随后的 block 是否绑定了主题变量, 所以你可以做有序的签名匹配:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">given</span> $capture &#123;</div><div class="line">        <span class="keyword">when</span> * -&gt; Int $a, Str $b &#123; ... &#125;</div><div class="line">        <span class="keyword">when</span> * -&gt; Str $a, Int $b &#123; ... &#125;</div><div class="line">        <span class="keyword">when</span> * -&gt; $a, $b         &#123; ... &#125;</div><div class="line">        <span class="keyword">when</span> *                   &#123; ... &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p> 当多重分派无序的语义不足以定义代码的”主从秩序”时, 这会很有用. 注意, 你可以绑定给一个裸的 block 或 一个箭头 block. 绑定给裸的 block很方便的把主题放在 `$_ 中,所以上面最后那个形式等价于一个 default.(占位符参数也能用于裸 block 形式, 尽管它们的类型不能被那样指定.)</p>
<p>没有给 <code>Any</code> 模式定义模式匹配,  所以,如果你想要一个反转的智能匹配测试, 右边是一个 <code>Any</code>,这时你总是通过显式的调用使用了 <code>$_</code> 作为模式的底层 <code>ACCEPTS</code> 方法来获取它. 例如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$_       X    Type of Match Wanted   What to <span class="keyword">use</span> on the right</div><div class="line">======  ===  ====================   ========================</div><div class="line">Callable Any  item <span class="function"><span class="keyword">sub</span> <span class="title">truth</span>         .<span class="title">ACCEPTS</span>(<span class="title">X</span>) <span class="title">or</span> .(<span class="title">X</span>)</span></div><div class="line"><span class="title">Range</span>    <span class="title">Any</span>  <span class="title">in</span> <span class="title">range</span>               .<span class="title">ACCEPTS</span>(<span class="title">X</span>)</div><div class="line"><span class="title">Type</span>     <span class="title">Any</span>  <span class="title">type</span> <span class="title">membership</span>        .<span class="title">ACCEPTS</span>(<span class="title">X</span>) <span class="title">or</span> .<span class="title">does</span>(<span class="title">X</span>)</div><div class="line"><span class="title">Regex</span>    <span class="title">Any</span>  <span class="title">pattern</span> <span class="title">match</span>          .<span class="title">ACCEPTS</span>(<span class="title">X</span>)</div><div class="line"><span class="title">etc</span>.</div></pre></td></tr></table></figure>
<p>同样的技巧会允许你倾向于给混合对象以默认匹配规则, 只要你在 <code>$_</code> 身上以点方法开头:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">given</span> $somethingordered &#123;</div><div class="line">        <span class="keyword">when</span> .values.<span class="string">'[&lt;=]'</span>     &#123; <span class="keyword">say</span> <span class="string">"increasing"</span> &#125;</div><div class="line">        <span class="keyword">when</span> .values.<span class="string">'[&gt;=]'</span>     &#123; <span class="keyword">say</span> <span class="string">"decreasing"</span> &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>必要时, 你可以定义一个宏来得到”反转的 when”:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> macro statement_control:&lt;ACCEPTS&gt; () &#123; <span class="string">"when .ACCEPTS: "</span> &#125;</div><div class="line">    <span class="keyword">given</span> $pattern &#123;</div><div class="line">        ACCEPTS $a      &#123; ... &#125;</div><div class="line">        ACCEPTS $b      &#123; ... &#125;</div><div class="line">        ACCEPTS $c      &#123; ... &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>各种建议但不推荐使用的智能匹配行为 可以很容易地(并且我们希望更易读)被模仿成下面这样:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">$_      X      Type of Match Wanted   What to <span class="keyword">use</span> on the right</div><div class="line">======  ===    ====================   ========================</div><div class="line">Array   Num    array element truth    .[X]</div><div class="line">Array   Num    array contains number  *,X,*</div><div class="line">Array   Str    array contains string  *,X,*</div><div class="line">Array   Parcel array begins /w Parcel X,*</div><div class="line">Array   Parcel array contains Parcel  *,X,*</div><div class="line">Array   Parcel array ends with Parcel *,X</div><div class="line">Hash    Str    hash element truth     .<span class="string">&#123;X&#125;</span></div><div class="line">Hash    Str    hash key existence     .<span class="string">&#123;X&#125;</span>:<span class="keyword">exists</span></div><div class="line">Hash    Num    hash element truth     .<span class="string">&#123;X&#125;</span></div><div class="line">Hash    Num    hash key existence     .<span class="string">&#123;X&#125;</span>:<span class="keyword">exists</span></div><div class="line">Buf     Int    buffer contains <span class="keyword">int</span>    .match(X)</div><div class="line">Str     Str    string contains string .match(X)</div><div class="line">Array   Scalar array contains item    .any === X</div><div class="line">Str     Array  array contains string  X.any</div><div class="line">Num     Array  array contains number  X.any</div><div class="line">Scalar  Array  array contains object  X.any</div><div class="line">Hash    Array  hash slice <span class="keyword">exists</span>      .&#123;X.all&#125;:<span class="keyword">exists</span> .&#123;X.any&#125;:<span class="keyword">exists</span></div><div class="line">Set     Set    subset relation        .&#123;X.all&#125;:<span class="keyword">exists</span></div><div class="line">Set     Hash   subset relation        .&#123;X.all&#125;:<span class="keyword">exists</span></div><div class="line">Any     Set    subset relation        .Set.&#123;X.all&#125;:<span class="keyword">exists</span></div><div class="line">Any     Hash   subset relation        .Set.&#123;X.all&#125;:<span class="keyword">exists</span></div><div class="line">Any     Set    superset relation      X.&#123;.all&#125;:<span class="keyword">exists</span></div><div class="line">Any     Hash   superset relation      X.&#123;.all&#125;:<span class="keyword">exists</span></div><div class="line">Any     Set    sets intersect         .&#123;X.any&#125;:<span class="keyword">exists</span></div><div class="line">Set     Array  subset relation        X,*          <span class="comment"># (conjectured)</span></div><div class="line">Array   Regex  match array as string  .Cat.match(X)  cat(@$<span class="number">_</span>).match(X)</div></pre></td></tr></table></figure>
<p>(注意, <code>.cat</code> 方法和 <code>Cat</code> 类型都强制必须接收单个对象, 不像 <code>cat</code> 函数, cat 函数作为一个列表操作符, 接收一个句法的列表(或multilist ) 并展开它. 然而,所有的这些都返回 <code>Cat</code> 对象.)</p>
<p>布尔表达式能返回布尔值, 例如比较操作符或一元 <code>?</code> 操作符.它们可能显式或隐式地引用 <code>$_</code>. 如果它们一点也没有引用 <code>$_</code>, 那也是 okay 的 — 那种情况下你就使用 switch 结构作为比一串  elsifs 可读性更好的备选分支. 然而, 注意,那意味着你不能这样写:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">given</span> $boolean &#123;</div><div class="line">       <span class="keyword">when</span> True  &#123;...&#125;</div><div class="line">       <span class="keyword">when</span> False &#123;...&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>因为它总是会选择 <code>True</code> 这种情况. 相反, 使用某些像条件上下文的东西在内部使用更好:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">given</span> $boolean &#123;</div><div class="line">       <span class="keyword">when</span> .Bool == <span class="number">1</span> &#123;...&#125;</div><div class="line">       <span class="keyword">when</span> .Bool == <span class="number">0</span> &#123;...&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>就像使用 <code>if</code> 语句一样. 在任何情况下, 如果你想使用 <code>~~</code> 或 <code>when</code> 进行智能匹配, 它会依照语法识别 True 或 False, 并提醒你那不会按你期望的那样做. 编译器也允许提醒任何其它不测试 <code>$_</code> 的布尔结构, 在他能检测的范围之内.</p>
<p>同样地, 任何接收一个 Matcher的函数(诸如 grep) 不会接收一个 Bool 类型的参数, 因为那总是标示着编程错误.(可以使用 <code>*</code> 来匹配任何东西, 如果那就是你想要的. 或者使用一个闭包来返回一个常量布尔值)</p>
<p>也要注意 regex 匹配不返回 Bool, 而是返回一个能用作布尔值的 Match 对象(或 Nil). 如果想要, 使用显式的 <code>?</code> 或 <code>so</code> 来强制转为 布尔值. Match 对象代表一个成功的匹配, 并被智能匹配当作与 True 的值相同, 类似地, Nil 代表着失败, 并且不能直接用于智能匹配的右侧. 测试 definedness 来代替或使用 <code>* === Nil</code>.</p>
<p>带有诸如 <code>:g</code>那样的修饰符的正则匹配想返回多个匹配, 使用 <code>List</code>来做 <code>so</code>.就像任何列表一样, 如果有一个或多项, 值就是被计算为真. 如果没有匹配, 返回空列表, 它在布尔上下文中计算为 false.</p>
<p>为了智能匹配, 所有的 <code>Set</code>, <code>Bag</code>, 和<code>Mix</code> 值和对应的散了类型 <code>SetHash</code>, <code>BagHash</code>, 和<code>MixHash</code> 是等价的.即, Hash 容器中键代表唯一对象, 键值代表那些唯一键的重复次数.(当然, Set 能有 0 或 1次重复, 因为保证唯一性). 所以,所有这些 Mixy 类型只比较键, 不比较键值. 使用 <code>eqv</code> 代替, 来测试键和键值的相等性. </p>
<p>Despite the need for an implementation to examine the bounds of a range in order to perform smartmatching, the result of smartmatching two Range objects is not actually defined in terms of bounds, but rather as a subset relationship between two (potentially infinite) sets of values encompassed by the intervals involved, for any orderable type such as real numbers, strings, or versions. The result is defined as true if and only if all potential elements that would be matched by the left range are also matched by the right range. Hence it does not matter to what extent the bounds of a empty range are “overspecified”. If the left range is empty, it always matches, because there exists no value to falsify it. If the right range is empty, it can match only if the left range is also empty.尽管为了执行智能匹配, 需要一个实现来检查范围的边界,  两个 Range 对象的智能匹配结果实际上没有按照边界定义,而是作为子集关系</p>
<p>The Cat type allows you to have an infinitely extensible string. You can match an array or iterator by feeding it to a Cat, which is essentially a Str interface over an iterator of some sort. Then a Regex can be used against it as if it were an ordinary string. The Regex engine can ask the string if it has more characters, and the string will extend itself if possible from its underlying iterator. (Note that such strings have an indefinite number of characters, so if you use .* in your pattern, or if you ask the string how many characters it has in it, or if you even print the whole string, it may feel compelled to slurp in the rest of the string, which may or may not be expeditious.)</p>
<p> cat 操作符接收一个(潜在惰性的)列表并返回一个 Cat 对象.在字符串上下文中, 这惰性地强制列表中的每一个元素为字符串, 字符串的长度不明. 你可以像这样搜索一个 gather:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $lazystr := cat gather for @foo &#123; take .bar &#125;</div><div class="line">$lazystr ~~ /pattern/;</div></pre></td></tr></table></figure>
<p>Cat 接口允许 regex 使用 <code>&lt;,&gt;</code> 断言来匹配元素的边界, Match 对象提供了一种方式, 能获取元素在列表中的索引和位置. 如果底层的数据结构是一个可变数组, 数组的改变由 Cat 追踪, 以至于元素数字仍然正确. 字符串, 数组,列表,序列,捕获还有树节点都可以是正则匹配的模式, 或由签名匹配饿模式</p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-callable.t#L5-L14" target="_blank" rel="external">S03/Smart matching/any-callable.t lines 5–14</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use Test;</div><div class="line">plan 4;</div><div class="line"></div><div class="line">#L&lt;S03/&quot;Smart matching&quot;/Any Callable:($) item sub truth&gt;</div><div class="line">&#123;</div><div class="line">    sub is_even($x) &#123; $x % 2 == 0 &#125;</div><div class="line">    sub is_odd ($x) &#123; $x % 2 == 1 &#125;</div><div class="line">    ok 4 ~~ &amp;is_even,    &apos;scalar sub truth (unary)&apos;;</div><div class="line">    ok 4 !~~ &amp;is_odd,    &apos;scalar sub truth (unary, negated smart-match)&apos;;</div><div class="line">    ok !(3 ~~ &amp;is_even), &apos;scalar sub truth (unary)&apos;;</div><div class="line">    ok !(3 !~~ &amp;is_odd), &apos;scalar sub truth (unary, negated smart-match)&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-callable.t#L15-L24" target="_blank" rel="external">S03/Smart matching/any-callable.t lines 15–24</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="keyword">use</span> Test;</div><div class="line">plan <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">#L&lt;S03/"Smart matching"/Any Callable:() simple closure truth&gt;</span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">uhuh</span> </span>&#123; <span class="number">1</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">nuhuh</span> </span>&#123; Mu &#125;</div><div class="line"></div><div class="line">    ok((Mu ~~ &amp;uhuh), <span class="string">"scalar sub truth"</span>);</div><div class="line">    ok(!(Mu ~~ &amp;nuhuh), <span class="string">"negated scalar sub false"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-bool.t#L5-L23" target="_blank" rel="external">S03/Smart matching/any-bool.t lines 5–23</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="keyword">use</span> Test;</div><div class="line">plan <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="comment">#L&lt;S03/Smart matching/Any Bool simple truth&gt;</span></div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">is</span>-<span class="title">true</span>() </span>&#123; True &#125;;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">is</span>-<span class="title">false</span>() </span>&#123; False &#125;;</div><div class="line">    ok   <span class="number">0</span>  ~~ is-true(),      <span class="string">'~~ non-syntactic True'</span>;</div><div class="line">    ok  <span class="string">'a'</span> ~~ is-true(),      <span class="string">'~~ non-syntactic True'</span>;</div><div class="line">    nok  <span class="number">0</span>  ~~ is-false(),     <span class="string">'~~ non-syntactic True'</span>;</div><div class="line">    nok <span class="string">'a'</span> ~~ is-false(),     <span class="string">'~~ non-syntactic True'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    nok  <span class="number">0</span>   ~~ .so,           <span class="string">'boolean truth'</span>;</div><div class="line">    ok   <span class="string">'a'</span> ~~ .so,           <span class="string">'boolean truth'</span>;</div><div class="line">    ok   <span class="number">0</span>   ~~ .not,          <span class="string">'boolean truth'</span>;</div><div class="line">    nok  <span class="string">'a'</span> ~~ .not,          <span class="string">'boolean truth'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-pair.t#L5-L35" target="_blank" rel="external">S03/Smart matching/any-pair.t lines 5–35</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="keyword">use</span> Test;</div><div class="line">plan <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="comment">#L&lt;S03/Smart matching/Any Pair test object attribute&gt;</span></div><div class="line">&#123;</div><div class="line">    <span class="comment"># ?."&#123;X.key&#125;" === ?X.value</span></div><div class="line">    <span class="comment"># 意思是:</span></div><div class="line">    <span class="comment"># 在对象上调用名为`X.key` 的方法, 用`?`强制为布尔值</span></div><div class="line">    <span class="comment"># 并检查是否和 `X.value`的布尔值相同</span></div><div class="line"></div><div class="line">    class SmartmatchTest::AttrPair &#123;</div><div class="line">        has $.a = <span class="number">4</span>;</div><div class="line">        has $.b = <span class="string">'foo'</span>;</div><div class="line">        has $.c = Mu;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">my</span> $o = SmartmatchTest::AttrPair.new();</div><div class="line">    ok  ($o ~~ :a(<span class="number">4</span>)),      <span class="string">'$obj ~~ Pair (Int, +)'</span>;</div><div class="line">    ok  ($o ~~ :a(<span class="number">2</span>)),      <span class="string">'$obj ~~ Pair (Int, +)'</span>;</div><div class="line">    ok !($o ~~ :b(<span class="number">0</span>)),      <span class="string">'$obj ~~ Pair (different types)'</span>;</div><div class="line">    ok  ($o ~~ :b&lt;foo&gt;),    <span class="string">'$obj ~~ Pair (Str, +)'</span>;</div><div class="line">    ok  ($o ~~ :b&lt;ugh&gt;),    <span class="string">'$obj ~~ Pair (Str, -)'</span>;</div><div class="line">    ok  ($o ~~ :c(Mu)),     <span class="string">'$obj ~~ Pair (Mu, +)'</span>;</div><div class="line">    ok  ($o ~~ :c(<span class="number">0</span>)),      <span class="string">'$obj ~~ Pair (0, +)'</span>;</div><div class="line">    ok !($o ~~ :b(Mu)),     <span class="string">'$obj ~~ Pair (Mu, -)'</span>;</div><div class="line">    <span class="comment"># not explicitly specced, but implied by the spec and decreed </span></div><div class="line">    <span class="comment"># by TimToady: non-existing method or attribute dies:</span></div><div class="line">    <span class="comment"># http://irclog.perlgeek.de/perl6/2009-07-06#i_1293199</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/array-array.t#L5-L70" target="_blank" rel="external">S03/Smart matching/array-array.t lines 5–70</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="keyword">use</span> Test;</div><div class="line">plan <span class="number">36</span>;</div><div class="line"></div><div class="line"><span class="comment">#L&lt;S03/Smart matching/arrays are comparable&gt;</span></div><div class="line">&#123;</div><div class="line">    ok(((<span class="string">"blah"</span>, <span class="string">"blah"</span>) ~~ (<span class="string">"blah"</span>, <span class="string">"blah"</span>)), <span class="string">"qw/blah blah/ .eq"</span>);</div><div class="line">    ok(!(      (<span class="number">1</span>, <span class="number">2</span>) ~~ (<span class="number">1</span>, <span class="number">1</span>)    ),    <span class="string">"1 2 !~~ 1 1"</span>);</div><div class="line">    ok(!(   (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) ~~ (<span class="number">1</span>, <span class="number">2</span>)    ),    <span class="string">"1 2 3 !~~ 1 2"</span>);</div><div class="line">    ok(!(      (<span class="number">1</span>, <span class="number">2</span>) ~~ (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) ),    <span class="string">"1 2 !~~ 1 2 3"</span>);</div><div class="line">    ok(!(          [] ~~ [<span class="number">1</span>]), <span class="string">"array smartmatch boundary conditions"</span>);</div><div class="line">    ok(!(         [<span class="number">1</span>] ~~ []),  <span class="string">"array smartmatch boundary conditions"</span>);</div><div class="line">    ok((           [] ~~ []),  <span class="string">"array smartmatch boundary conditions"</span>);</div><div class="line">    ok((          [<span class="number">1</span>] ~~ [<span class="number">1</span>]), <span class="string">"array smartmatch boundary conditions"</span>);</div><div class="line"></div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,*),   <span class="string">'array smartmatch dwims * at end'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,*,*), <span class="string">'array smartmatch dwims * at end (many *s)'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (*,<span class="number">4</span>), <span class="string">'array smartmatch dwims * at start'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (*,*,<span class="number">4</span>), <span class="string">'array smartmatch dwims * at start (many *s)'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,*,<span class="number">3</span>,<span class="number">4</span>), <span class="string">'array smartmatch dwims * 1 elem'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,*,*,<span class="number">3</span>,<span class="number">4</span>), <span class="string">'array smartmatch dwims * 1 elem (many *s)'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,*,<span class="number">4</span>), <span class="string">'array smartmatch dwims * many elems'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,*,*,<span class="number">4</span>), <span class="string">'array smartmatch dwims * many elems (many *s)'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (*,<span class="number">3</span>,*), <span class="string">'array smartmatch dwims * at start and end'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (*,*,<span class="number">3</span>,*,*), <span class="string">'array smartmatch dwims * at start and end (many *s)'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (*,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), <span class="string">'array smartmatch dwims * can match nothing at start'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (*,*,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), <span class="string">'array smartmatch dwims * can match nothing at start (many *s)'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,<span class="number">2</span>,*,<span class="number">3</span>,<span class="number">4</span>), <span class="string">'array smartmatch dwims * can match nothing in middle'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,<span class="number">2</span>,*,*,<span class="number">3</span>,<span class="number">4</span>), <span class="string">'array smartmatch dwims * can match nothing in middle (many *s)'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,*), <span class="string">'array smartmatch dwims * can match nothing at end'</span>);</div><div class="line">    ok((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,*,*), <span class="string">'array smartmatch dwims * can match nothing at end (many *s)'</span>);</div><div class="line">    ok(!((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,*,<span class="number">3</span>)), <span class="string">'* dwimming does not cause craziness'</span>);</div><div class="line">    ok(!((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (*,<span class="number">5</span>)), <span class="string">'* dwimming does not cause craziness'</span>);</div><div class="line">    ok(!((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) ~~ (<span class="number">1</span>,<span class="number">3</span>,*)), <span class="string">'* dwimming does not cause craziness'</span>);</div><div class="line"></div><div class="line">    <span class="comment"># now try it with arrays as well</span></div><div class="line">    <span class="keyword">my</span> @a = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</div><div class="line">    <span class="keyword">my</span> @b = <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>;</div><div class="line">    <span class="keyword">my</span> @m = (*, <span class="number">2</span>, *); <span class="comment"># m as "magic" ;-)</span></div><div class="line"></div><div class="line">    ok (@a ~~  @a), <span class="string">'Basic smartmatching on arrays (positive)'</span>;</div><div class="line">    ok (@a !~~ @b), <span class="string">'Basic smartmatching on arrays (negative)'</span>;</div><div class="line">    ok (@b !~~ @a), <span class="string">'Basic smartmatching on arrays (negative)'</span>;</div><div class="line"></div><div class="line">    ok (@a ~~  @m), <span class="string">'Whatever dwimminess in arrays'</span>;</div><div class="line">    ok (@a ~~ (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)), <span class="string">'smartmatch Array ~~ List'</span>;</div><div class="line">    ok ((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) ~~ @a), <span class="string">'smartmatch List ~~ Array'</span>;</div><div class="line"></div><div class="line">    ok ((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) ~~ @m), <span class="string">'smartmatch List ~~ Array with dwim'</span>;</div><div class="line"></div><div class="line">    ok (<span class="number">1</span> ~~ *,<span class="number">1</span>,*),     <span class="string">'smartmatch with Array RHS co-erces LHS to list'</span>;</div><div class="line">    ok (<span class="number">1</span>..<span class="number">10</span> ~~ *,<span class="number">5</span>,*), <span class="string">'smartmatch with Array RHS co-erces LHS to list'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/range-range.t#L5-L29" target="_blank" rel="external">S03/Smart matching/range-range.t lines 5–29</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; (2..3).bounds</div><div class="line">2 3</div><div class="line">&gt; (2..3).bounds.all</div><div class="line">all(2, 3)</div><div class="line">&gt; my @a = (1,3,5,8);</div><div class="line">1 3 5 8</div><div class="line">&gt; @a.bounds;</div><div class="line">Method &apos;bounds&apos; not found for invocant of class &apos;Array&apos;</div><div class="line">&gt; (2..3).bounds.all ~~ 1..4</div><div class="line">all(True, True)</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="keyword">use</span> Test;</div><div class="line">plan <span class="number">14</span>;</div><div class="line"></div><div class="line"><span class="comment">#L&lt;S03/Smart matching/Range Range subset range&gt;</span></div><div class="line">&#123;</div><div class="line">    <span class="comment"># .bounds.all ~~ X (mod ^'s)</span></div><div class="line">    <span class="comment"># 意思是:</span></div><div class="line">    <span class="comment"># 检查 .min 和 .max 是否都在 Range X 里面.</span></div><div class="line">    <span class="comment"># (though this is only true to a first approximation, as</span></div><div class="line">    <span class="comment"># those .min and .max values might be excluded)</span></div><div class="line"></div><div class="line">    ok  (<span class="number">2</span>..<span class="number">3</span> ~~ <span class="number">1</span>..<span class="number">4</span>),     <span class="string">'proper inclusion +'</span>;</div><div class="line">    ok !(<span class="number">1</span>..<span class="number">4</span> ~~ <span class="number">2</span>..<span class="number">3</span>),     <span class="string">'proper inclusion -'</span>;</div><div class="line">    ok  (<span class="number">2</span>..<span class="number">4</span> ~~ <span class="number">1</span>..<span class="number">4</span>),     <span class="string">'inclusive vs inclusive right end'</span>;</div><div class="line">    ok  (<span class="number">2</span>..^<span class="number">4</span> ~~ <span class="number">1</span>..<span class="number">4</span>),    <span class="string">'exclusive vs inclusive right end'</span>;</div><div class="line">    ok !(<span class="number">2</span>..<span class="number">4</span> ~~ <span class="number">1</span>..^<span class="number">4</span>),    <span class="string">'inclusive vs exclusive right end'</span>;</div><div class="line">    ok  (<span class="number">2</span>..^<span class="number">4</span> ~~ <span class="number">1</span>..^<span class="number">4</span>),   <span class="string">'exclusive vs exclusive right end'</span>;</div><div class="line">    ok  (<span class="number">2</span>..<span class="number">3</span> ~~ <span class="number">2</span>..<span class="number">4</span>),     <span class="string">'inclusive vs inclusive left end'</span>;</div><div class="line">    ok  (<span class="number">2</span>^..<span class="number">3</span> ~~ <span class="number">2</span>..<span class="number">4</span>),    <span class="string">'exclusive vs inclusive left end'</span>;</div><div class="line">    ok !(<span class="number">2</span>..<span class="number">3</span> ~~ <span class="number">2</span>^..<span class="number">4</span>),    <span class="string">'inclusive vs exclusive left end'</span>;</div><div class="line">    ok  (<span class="number">2</span>^..<span class="number">3</span> ~~ <span class="number">2</span>^..<span class="number">4</span>),   <span class="string">'exclusive vs exclusive left end'</span>;</div><div class="line">    ok  (<span class="number">2</span>..<span class="number">3</span> ~~ <span class="number">2</span>..<span class="number">3</span>),     <span class="string">'inclusive vs inclusive both ends'</span>;</div><div class="line">    ok  (<span class="number">2</span>^..^<span class="number">3</span> ~~ <span class="number">2</span>..<span class="number">3</span>),   <span class="string">'exclusive vs inclusive both ends'</span>;</div><div class="line">    ok !(<span class="number">2</span>..<span class="number">3</span> ~~ <span class="number">2</span>^..^<span class="number">3</span>),   <span class="string">'inclusive vs exclusive both ends'</span>;</div><div class="line">    ok  (<span class="number">2</span>^..^<span class="number">3</span> ~~ <span class="number">2</span>^..^<span class="number">3</span>), <span class="string">'exclusive vs exclusive both ends'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/disorganized.t#L30-L145" target="_blank" rel="external">S03-smartmatch/disorganized.t lines 30–145</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="keyword">use</span> Test;</div><div class="line">plan <span class="number">42</span>;</div><div class="line"></div><div class="line"><span class="comment">=begin pod</span></div><div class="line">This tests the smartmatch operator, defined in L&lt;S03/"Smart matching"&gt;</div><div class="line">=end pod</div><div class="line"></div><div class="line">sub eval_elsewhere($code)&#123; EVAL($code) &#125;</div><div class="line"></div><div class="line">#L&lt;S03/Smart matching/Any undef undefined not .defined&gt;</div><div class="line">&#123; </div><div class="line">    ok("foo" ~~ .defined, "foo is ~~ .defined");</div><div class="line">    nok "foo" !~~ .defined,   'not foo !~~ .defined';</div><div class="line">    nok((Mu ~~ .defined), "Mu is not .defined");</div><div class="line">&#125;</div><div class="line"></div><div class="line"># <span class="doctag">TODO:</span> </div><div class="line"># Set   Set</div><div class="line"># Hash  Set</div><div class="line"># Any   Set</div><div class="line"># Set   Array</div><div class="line"># Set   Hash</div><div class="line"># Any   Hash</div><div class="line"></div><div class="line"># Regex tests are in spec/S05-*</div><div class="line"></div><div class="line">#L&lt;S03/"Smart matching"/in range&gt;</div><div class="line">&#123; </div><div class="line">    # more range tests in t/spec/S03-operators/range.t</div><div class="line">    ok((5 ~~ 1 .. 10), "5 is in 1 .. 10");</div><div class="line">    ok(!(10 ~~ 1 .. 5), "10 is not in 1 .. 5");</div><div class="line">    ok(!(1 ~~ 5 .. 10), "1 is not i n 5 .. 10");</div><div class="line">    ok(!(5 ~~ 5 ^..^ 10), "5 is not in 5 .. 10, exclusive");</div><div class="line">&#125;;</div><div class="line"></div><div class="line"># <span class="doctag">TODO:</span></div><div class="line"># Signature Signature</div><div class="line"># Callable  Signature</div><div class="line"># Capture   Signature</div><div class="line"># Any       Signature</div><div class="line"></div><div class="line"># Signature Capture  </div><div class="line"></div><div class="line"># reviewed by moritz on 2009-07-07 up to here.</div><div class="line"></div><div class="line">=begin Explanation</div><div class="line">You may be wondering what the heck is with all these try blocks.</div><div class="line">Prior to r12503, this test caused a horrible death of Pugs which</div><div class="line">magically went away when used inside an EVAL.  So the try blocks</div><div class="line">caught that case.</div><div class="line">=end Explanation</div><div class="line"></div><div class="line">&#123;</div><div class="line">    my $result = 0;</div><div class="line">    my $parsed = 0;</div><div class="line">    my @x = 1..20;</div><div class="line">    try &#123;</div><div class="line">        $result = all(@x) ~~ &#123; $_ &lt; 21 &#125;;</div><div class="line">        $parsed = 1;</div><div class="line">    &#125;;</div><div class="line">    ok $parsed, 'C&lt;all(@x) ~~ &#123; ... &#125;&gt; parses';</div><div class="line">    ok ?$result, 'C&lt;all(@x) ~~ &#123; ... &#125; when true for all';</div><div class="line"></div><div class="line">    $result = 0;</div><div class="line">    try &#123;</div><div class="line">        $result = !(all(@x) ~~ &#123; $_ &lt; 20 &#125;);</div><div class="line">    &#125;;</div><div class="line">    ok $result,</div><div class="line">        'C&lt;all(@x) ~~ &#123;...&#125; when true for one';</div><div class="line"></div><div class="line">    $result = 0;</div><div class="line">    try &#123;</div><div class="line">        $result = !(all(@x) ~~ &#123; $_ &lt; 12 &#125;);</div><div class="line">    &#125;;</div><div class="line">    ok $result, 'C&lt;all(@x) ~~ &#123;...&#125; when true for most';</div><div class="line"></div><div class="line">    $result = 0;</div><div class="line">    try &#123;</div><div class="line">        $result = !(all(@x) ~~ &#123; $_ &lt; 1  &#125;);</div><div class="line">    &#125;;</div><div class="line">    ok $result, 'C&lt;all(@x) ~~ &#123;...&#125; when true for one';</div><div class="line">&#125;;</div><div class="line"></div><div class="line"># need to test in EVAL() since class definitions happen at compile time,</div><div class="line"># ie before the plan is set up.</div><div class="line">eval-lives-ok 'class A &#123; method foo &#123; return "" ~~ * &#125; &#125;; A.new.foo',</div><div class="line">              'smartmatch in a class lives (RT 62196)';</div><div class="line"></div><div class="line"># RT #69762</div><div class="line">&#123;</div><div class="line">    ok sub &#123;&#125; ~~ Callable, '~~ Callable (true)';</div><div class="line">    nok 68762 ~~ Callable, '~~ Callable (false)';</div><div class="line">    ok 69762 !~~ Callable, '!~~ Callable (true)';</div><div class="line">    nok sub &#123;&#125; !~~ Callable, '!~~ Callable (false)';</div><div class="line"></div><div class="line">    ok sub &#123;&#125; ~~ Routine, '~~ Routine (true)';</div><div class="line">    nok 68762 ~~ Routine, '~~ Routine (false)';</div><div class="line">    ok 69762 !~~ Routine, '!~~ Routine (true)';</div><div class="line">    nok sub &#123;&#125; !~~ Routine, '!~~ Routine (false)';</div><div class="line"></div><div class="line">    ok sub &#123;&#125; ~~ Sub, '~~ Sub (true)';</div><div class="line">    nok 68762 ~~ Sub, '~~ Sub (false)';</div><div class="line">    ok 69762 !~~ Sub, '!~~ Sub (true)';</div><div class="line">    nok sub &#123;&#125; !~~ Sub, '!~~ Sub (false)';</div><div class="line"></div><div class="line">    ok sub &#123;&#125; ~~ Block, '~~ Block (true)';</div><div class="line">    nok 68762 ~~ Block, '~~ Block (false)';</div><div class="line">    ok 69762 !~~ Block, '!~~ Block (true)';</div><div class="line">    nok sub &#123;&#125; !~~ Block, '!~~ Block (false)';</div><div class="line"></div><div class="line">    ok sub &#123;&#125; ~~ Code, '~~ Code (true)';</div><div class="line">    nok 68762 ~~ Code, '~~ Code (false)';</div><div class="line">    ok 69762 !~~ Code, '!~~ Code (true)';</div><div class="line">    nok sub &#123;&#125; !~~ Code, '!~~ Code (false)';</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line"></div><div class="line">    class RT68762 &#123; our method rt68762 &#123;&#125; &#125;;</div><div class="line"></div><div class="line">    ok &amp;RT68762::rt68762 ~~ Method, '~~ Method (true)';</div><div class="line">    nok 68762            ~~ Method, '~~ Method (false)';</div><div class="line">    ok 69762              !~~ Method, '!~~ Method (true)';</div><div class="line">    nok &amp;RT68762::rt68762 !~~ Method, '!~~ Method (false)';</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"># RT 72048</div><div class="line">&#123;</div><div class="line">    role RT72048_role &#123;&#125;</div><div class="line">    class RT72048_class does RT72048_role &#123;&#125;</div><div class="line"></div><div class="line">    ok RT72048_class.new ~~ RT72048_role, 'class instance matches role';</div><div class="line">    nok RT72048_class.new !~~ RT72048_role, 'class instance !!matches role';</div><div class="line">&#125;</div><div class="line"></div><div class="line">ok ("foo" ~~ *) ~~ WhateverCode, 'thing ~~ * autoprimes';</div><div class="line">ok ("foo" ~~ *.chars == 3) ~~ Bool, 'thing ~~ WhateverCode is a boolean';</div><div class="line">ok ?(* ~~ "foo")('foo'), '* ~~ "foo" is WhateverCode';</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-type.t#L5-L40" target="_blank" rel="external">S03-smartmatch/any-type.t lines 5–40</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#L&lt;S03/Smart matching/type membership&gt;</span></div><div class="line">&#123; </div><div class="line">    class Dog &#123;&#125;</div><div class="line">    class Cat &#123;&#125;</div><div class="line">    class Chihuahua is Dog &#123;&#125; <span class="comment"># i'm afraid class Pugs will get in the way ;-)</span></div><div class="line">    role SomeRole &#123; &#125;;</div><div class="line">    class Something does SomeRole &#123; &#125;;</div><div class="line"></div><div class="line">    ok (Chihuahua ~~ Dog),      <span class="string">"chihuahua isa dog"</span>;</div><div class="line">    ok (Something ~~ SomeRole), <span class="string">'something does dog'</span>;</div><div class="line">    ok !(Chihuahua ~~ Cat),     <span class="string">"chihuahua is not a cat"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># RT #71462</span></div><div class="line">&#123;</div><div class="line">    is <span class="string">'RT71462'</span> ~~ Str,      True,  <span class="string">'~~ Str returns a Bool (1)'</span>;</div><div class="line">    is <span class="number">5</span>         ~~ Str,      False, <span class="string">'~~ Str returns a Bool (2)'</span>;</div><div class="line">    is <span class="string">'RT71462'</span> ~~ Int,      False, <span class="string">'~~ Int returns a Bool (1)'</span>;</div><div class="line">    is <span class="number">5</span>         ~~ Int,      True,  <span class="string">'~~ Int returns a Bool (2)'</span>;</div><div class="line">    is <span class="string">'RT71462'</span> ~~ Set,      False, <span class="string">'~~ Set returns a Bool (1)'</span>;</div><div class="line">    is set(<span class="number">1</span>, <span class="number">3</span>) ~~ Set,      True,  <span class="string">'~~ Set returns a Bool (2)'</span>;</div><div class="line">    is <span class="string">'RT71462'</span> ~~ Numeric,  False, <span class="string">'~~ Numeric returns a Bool (1)'</span>;</div><div class="line">    is <span class="number">5</span>         ~~ Numeric,  True,  <span class="string">'~~ Numeric returns a Bool (2)'</span>;</div><div class="line">    is &amp;<span class="keyword">say</span>      ~~ Callable, True,  <span class="string">'~~ Callable returns a Bool (1)'</span>;</div><div class="line">    is <span class="number">5</span>         ~~ Callable, False, <span class="string">'~~ Callable returns a Bool (2)'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># RT 76610</span></div><div class="line">&#123;</div><div class="line">    module M &#123; &#125;;</div><div class="line"></div><div class="line">    lives-ok &#123; <span class="number">42</span> ~~ M &#125;, <span class="string">'~~ module lives'</span>;</div><div class="line">    ok <span class="keyword">not</span> $/, <span class="string">'42 is not a module'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-any.t#L5-L29" target="_blank" rel="external">S03-smartmatch/any-any.t#L5-L29</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="keyword">use</span> Test;</div><div class="line">plan <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="comment">#L&lt;S03/Smart matching/Any Any scalars are identical&gt;</span></div><div class="line">&#123;</div><div class="line">    class Smartmatch::ObjTest &#123;&#125;</div><div class="line">    <span class="keyword">my</span> $a = Smartmatch::ObjTest.new;</div><div class="line">    <span class="keyword">my</span> $b = Smartmatch::ObjTest.new;</div><div class="line">    ok  ($a ~~  $a),    <span class="string">'Any ~~  Any (+)'</span>;</div><div class="line">    ok !($a !~~ $a),    <span class="string">'Any !~~ Any (-)'</span>;</div><div class="line">    ok !($a ~~  $b),    <span class="string">'Any ~~  Any (-)'</span>;</div><div class="line">    ok  ($a !~~ $b),    <span class="string">'Any !~~ Any (+)'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#123;</div><div class="line">    $_ = <span class="number">42</span>;</div><div class="line">    <span class="keyword">my</span> $x;</div><div class="line">    <span class="string">'abc'</span> ~~ ($x = $_);</div><div class="line">    is $x, <span class="string">'abc'</span>, <span class="string">'~~ sets $_ to the LHS'</span>;</div><div class="line">    is $_, <span class="number">42</span>, <span class="string">'original $_ restored'</span>;</div><div class="line">    <span class="string">'defg'</span> !~~ ($x = $_);</div><div class="line">    is $x, <span class="string">'defg'</span>, <span class="string">'!~~ sets $_ to the LHS'</span>;</div><div class="line">    is $_, <span class="number">42</span>, <span class="string">'original $_ restored'</span>;</div><div class="line">    <span class="string">'defg'</span> !~~ ($x = $_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-Types--成人之美]]></title>
      <url>http://ohmycloud.github.io/2016/08/02/Perl-6-Types-%E6%88%90%E4%BA%BA%E4%B9%8B%E7%BE%8E/</url>
      <content type="html"><![CDATA[<p>Perl 6 Types: 成人之美</p>
<p>在我的第一次大学编程语言课中， 我被告知 Pascal 语言在其它类型之外还拥有 <strong>Integer</strong>、<strong>Boolen</strong> 和 <strong>Stirng</strong> 类型。我知道了类型本来就该存在因为计算机很笨。当我在 C语言中涉猎的时候，我学到了更多有关 <em>int</em>、 <em>char</em> 和其它像在暖和的地方里地寄生虫， 还有我课桌底下嗡嗡的金属盒的声音。</p>
<p>Perl 5 没有类型，它给我的感觉就像骑着自行车无拘无束的追风少年，沿着斜坡而下。不久之后我一门心思钻到计算机硬件的缝隙中。我拥有数据并且我能用它做任何我想做的事， 只要我得到的不是错误的数据。当我搞定的时候，我从自行车上掉了下来并刮破了我的膝盖。</p>
<p>有了 Perl 6，鱼和熊掌可以兼得。你可以使用类型来避免它们。你可以拥有一个广域的类型来接收很多种类的值或窄类型。并且你可以享受代表机器智力的类型的速度， 或者你可以享受你自定义的代表你自己意志的类型的精度，类型为人类而生。</p>
<h2 id="渐进类型"><a href="#渐进类型" class="headerlink" title="渐进类型"></a>渐进类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my       $a = &quot;whatever&quot;;</div><div class="line">my Str   $b = &quot;strings only&quot;;</div><div class="line">my Str:D $c = &quot;defined strings only&quot;;</div><div class="line">my int   $d = 14; # native int</div><div class="line"></div><div class="line">sub foo ($x) &#123; $x + 2 &#125;</div><div class="line">sub bar (Int:D $x) returns Int &#123; $x + 2 &#125;</div></pre></td></tr></table></figure>
<p>Perl 6 拥有渐进类型， 这意味着你要么可以使用它们，要么避免使用它们。所以究竟为什么要打扰它们呢？</p>
<p>首先，类型约束了你的变量中能包含的，你的方法或子例程接受的或返回的值的范围。这个函数即作为数据校验又作为安全网以过滤掉不正确代码所生成的垃圾数据。</p>
<p>还有，当使用原生的，机器意志的类型的时候，你可以获得更好地性能并减少内存使用，假如它们对于你得数据来说是合适的工具的话。</p>
<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>有一个名副其实的自助式的<a href="http://docs.perl6.org/type.html" target="_blank" rel="external">Perl 6 中得内置类型</a>。如果你的子例程只对整数有意义，那么为你的参数使用 <strong>Int</strong> 类型。如果负数没有意义，那么使用 <strong>UInt</strong> - 一个无符号的 <strong>Int</strong> 来进一步限制值的范围。另一方面，如果你想处理一个较广的范围，那么 <strong>Numeric</strong> 类型可能更合适。</p>
<p>如果你想一探究竟，Perl 6 也提供了一系列的映射到你常常见到的，例如 C 语言中的原生类型。使用这些原生类型可能会提供性能提升或内存使用的减少。可用的原生类型有：int，int8，int16，int32，int64，uint，uint8，uint16，uint32，uint64，num，num32，num64。类型名字中的数字表示可得的字节，不含数字的类型是平台无关的。</p>
<p>诸如 int1，int2 和 int4 的子字节类型也计划在未来实现。</p>
<h2 id="笑脸符号"><a href="#笑脸符号" class="headerlink" title="笑脸符号"></a>笑脸符号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">multi foo (Int:U $x) &#123; &apos;Y U NO define $x?&apos;         &#125;</div><div class="line">multi foo (Int:D $x) &#123; &quot;The Square of $x is &#123;$x²&#125;&quot; &#125;</div><div class="line"></div><div class="line">my Int $x;</div><div class="line">say foo $x;</div><div class="line">$x = 42;</div><div class="line">say foo $x;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Y U NO define $x?</div><div class="line"># The square of 42 is 1764</div></pre></td></tr></table></figure>
<p>笑脸符号是追加在类型名后面的 <em>:U</em>、<em>:D</em> 或 <code>:_</code> 。 在你没有指定笑脸符号的时候，<code>:_</code> 是你获得的默认笑脸符号。<em>:U</em> 只指定未定义(undefined)值，而 <code>:D</code> 只指定定义(defined)值。</p>
<p>通过在调用者身上使用两个带有 <em>:U</em> 和 <em>:D</em> 的 multis，我们能知道方法是在类上调用的还是在实例上调用的。如果你在核动力装置上工作，确保你的鲁棒插入子例程绝对不会插入任何未定义的量也是一件好事情，我想。</p>
<h2 id="Subsets：定制的类型"><a href="#Subsets：定制的类型" class="headerlink" title="Subsets：定制的类型"></a>Subsets：定制的类型</h2><p>内置的类型很酷，但是程序员工作的大部分数据没有精确地匹配。这就是 Perl 6 subsets 进场的时候了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">subset Prime of Int where *.is-prime;</div><div class="line">my Prime $x = 3;</div><div class="line">$x = 11; # works</div><div class="line">$x = 4;  # 失败，类型不匹配。</div></pre></td></tr></table></figure>
<p>使用 <em>subset</em> 关键字，我们就地创建了一个叫做 <strong>Prime</strong> 的类型。它是 <strong>Int</strong> 类型的一个子集(subset)，所以任何非 Int 数不匹配这个类型。我们还使用 <em>where</em> 关键字指定了一个额外的约束；那个约束是在给定值身上调用的 <em>.is-prime</em> 方法必须返回一个 true 值。</p>
<p>使用那个单行代码， 我们创建了一个特定的类型并可以像内置类型那样使用它！我们不仅可以用它来指定变量的类型、 子例程/方法的参数类型和返回值类型，我们还能使用智能匹配操作符来测试任意值，就像我们在内置类型中做得那样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">subset Prime of Int where *.is-prime;</div><div class="line">say &quot;It is an Int&quot; if &apos;foo&apos; ~~ Int;   # false, it&apos;s a Str</div><div class="line">say &quot;It&apos;s a prime&quot; if 31337 ~~ Prime; # true, it&apos;s a prime number</div></pre></td></tr></table></figure>
<p>如果你的类型是一次性的东西，你只想把它应用到单个变量上呢？ 你一点也不必单独声明一个 subset！就在变量后面使用 <em>where</em> 关键字好了，你很好的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">multi is-a-prime ( Int $ where *.is-prime --&gt; &apos;Yup&apos; ) &#123;&#125;</div><div class="line">multi is-a-prime ( Any                    --&gt; &apos;Nope&apos;) &#123;&#125;</div><div class="line">  </div><div class="line">say is-a-prime 3;     # Yup</div><div class="line">say is-a-prime 4;     # Nope</div><div class="line">say is-a-prime &apos;foo&apos;; # Nope</div></pre></td></tr></table></figure>
<p>上面的签名中的 <strong>–&gt;</strong> 是表示返回值类型的另外一种方式，或者在这种情况下，是一种具体的返回值。所以我们拥有了两个含有不同签名的 multies。第一个接收一个 <strong>Int</strong> 类型的质数，第二个接受剩下的任何东西。我们的 multies 函数体中没有任何代码，就写了一个子例程告诉你一个数字是否是质数！</p>
<h2 id="打包重用"><a href="#打包重用" class="headerlink" title="打包重用"></a>打包重用</h2><p>目前为止我们学到的很酷，但是酷不是 awesome！你可能会很频繁地使用某些你自定义的类型。在厂里面工作，产品号至多有20个字符，以某种格式？ 非常好！我们为它创建一个子类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subset ProductNumber of Str where &#123; .chars &lt;=20 and m/^ \d**3 &lt;[-#]&gt; / &#125;;</div><div class="line">my ProductNumber $num = &apos;333-FOOBAR&apos;;</div></pre></td></tr></table></figure>
<p>这好极了，但是我们不想在所有的地方都重复这个 subset。 我们来把它推到一个单独的模块中。我会创建 <code>/opt/local/Perl6/Company/Types.pm6</code> 因为 <code>/opt/local/Perl6</code> 是包含在我为这个虚构的厂所写的所有 apps 中的模块搜索路径中的路径。在这个文件中，我会有下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">unit module Company::Types;</div><div class="line">my package EXPORT::DEFAULT &#123;</div><div class="line">    subset ProductNumber of Str where &#123; .chars &lt;=20 and m/^ \d**3 &lt;[-#]&gt; / &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们给我们的模块起了一个名字并默认导出我们可爱的 subsets。我们的代码看起来怎么样了？ 它看起来酷毙了 - 不，等等， AWESOME – 这一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">use Company::Types;</div><div class="line">my ProductNumber $num1 = &apos;333-FOOBAR&apos;; # succeeds</div><div class="line">my ProductNumber $num2 = &apos;meow&apos;;       # fails</div></pre></td></tr></table></figure>
<p>这样， 我们使用单个 use 语句扩展了 Perl 6 以为我们提供定制的类型，它精确地匹配了我们想要的数据成为什么样子。</p>
<h2 id="Awesome-Error-Messages-for-Subsets"><a href="#Awesome-Error-Messages-for-Subsets" class="headerlink" title="Awesome Error Messages for Subsets"></a>Awesome Error Messages for Subsets</h2><p>如果你尝试过所有这些例子，你可能注意到一点小瑕疵。你得到的错误信息不够给力！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Type check failed in assignment to $num2;</div><div class="line">expected Company::Types::EXPORT::DEFAULT::ProductNumber but got Str (&quot;meow&quot;)</div><div class="line">in block &lt;unit&gt; at test.p6 line 3</div></pre></td></tr></table></figure>
<p>当给你是你的目标的时候，你肯定有提升那些信息的方法。再次打开我们的 <strong>Company::Types</strong> 文件，并扩展我们的 <strong>ProductNumber</strong> 的 <em>where</em> 从句以包括给力的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">subset ProductNumber of Str where &#123;</div><div class="line">    .chars &lt;= 20 and m/^ \d**3 &lt;[-#]&gt; /</div><div class="line">        or warn &apos;ProductNumber type expects a string at most 20 chars long&apos;</div><div class="line">            ~ &apos; with the first 4 characters in the format of \d\d\d[-|#]&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> 现在，在东西不匹配我们的类型的时候，信息会在 <strong>Type</strong> 检查信息和栈追踪之前被包括进来， 为我们提供所期望的东西的更多信息。 如果你想，这儿你也可以调用 <em>fail</em> 代替 <em>warn</em> ，这时 Type check… 信息不会被打印出来，给你更多控制。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p> 结论个大西瓜！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[unspaces]]></title>
      <url>http://ohmycloud.github.io/2016/08/01/unspaces/</url>
      <content type="html"><![CDATA[<p>有些语言例如 <code>C</code> 允许你转义一个换行符使行联合起来. 其它语言(例如正则表达式)因为各种各样的原因, 允许你使用反斜线转义一个空白符. Perl 6 把这种记法推广到任何种类的空白上. 通过在空白处前置一个 <code>\</code>, 任何相邻的空白(包括注释)都会在解析器面前隐身. 这就是鼎鼎大名的空白隐身( “unspace”).</p>
<p>在 Perl 中, 一个 <a href="https://design.perl6.org/S02.html" target="_blank" rel="external">unspace</a> 能够抑制任意的几种空白附属物. 例如, 因为 Perl 要求名词和后缀操作符之间不能出现空白, 所以使用 unspace 让你可以把后缀操作符贴线对齐:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%hash\  &#123;$key&#125;</div><div class="line">@array\ [$ix]</div><div class="line">$subref\($arg)</div></pre></td></tr></table></figure>
<p>上面的最后一种形式作为一种退化了的 unspace,  即反斜线后面直接跟着后缀. 注意, 反斜线前面不允许有空白, 所以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$subref \($arg)</div></pre></td></tr></table></figure>
<p>是语法错误(two terms in a row). 而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo \($arg)</div></pre></td></tr></table></figure>
<p>会被解析为带有 <code>Capture</code> 参数的列表操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo(\($arg))</div></pre></td></tr></table></figure>
<p>然而, 其它形式的 unspace 可能被有效地放在空白之前.</p>
<p>其它后缀操作符也可能使用 unspace:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$number\  ++;</div><div class="line">$number\  --;</div><div class="line">1+3\      i;</div><div class="line">$object\  .say();</div><div class="line">$object\#`&#123; your ad here &#125;.say</div></pre></td></tr></table></figure>
<p>另外一种 “你看不见这空白” 的正常用法是, 在下一行放上一个点语法形式的后缀:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$object\ # comment</div><div class="line">.say</div><div class="line"> $object\#`[ comment</div><div class="line">].say</div><div class="line"> $object\</div><div class="line">.say</div></pre></td></tr></table></figure>
<p>但是 unspace 主要是关于语言扩展的: 它让你在换行可能会使解析器困惑的地方, 让行在任何情况下都能继续, 不管你当前安装的是什么解析器.(除非, 当然, 你自己覆写了 unspace 规则…)</p>
<p>尽管我们说, unspace 让空白在解析器面前隐身了,  但是它并不能使空白在词法分析程序面前隐身. 结果就是, 在 token 中禁止了 unspace. 此外, 如果 unspace 包含一行或多行,  它们的行数仍然会被计算在内.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[学习Perl6的一些网站]]></title>
      <url>http://ohmycloud.github.io/2016/07/25/%E5%AD%A6%E4%B9%A0Perl6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<p><a href="http://perl6intro.com/" target="_blank" rel="external">perl6intro</a><br><a href="http://www.reddit.com/r/perl6" target="_blank" rel="external">Perl6 - Reddit</a><br><a href="http://www.perlfoundation.org/perl6/index.cgi?perl_6_intro_tablet" target="_blank" rel="external">Perl 6 Tablet</a><br><a href="http://rosettacode.org/wiki/Category:Perl_6" target="_blank" rel="external">Rosetta</a><br><a href="http://mfollett.com/blog/categories/perl-6/" target="_blank" rel="external">mfollett</a><br><a href="http://perlgeek.de/blog-en/perl-6/" target="_blank" rel="external">perlgeek</a><br><a href="https://perl6advent.wordpress.com/" target="_blank" rel="external">Perl 6 advent calendars</a><br><a href="http://perl6maven.com/" target="_blank" rel="external">Perl6Maven</a><br><a href="http://strangelyconsistent.org/blog/list-of-posts" target="_blank" rel="external">Strangely Consistent</a><br><a href="http://ugexe.com" target="_blank" rel="external">Death by Perl6</a><br><a href="http://jnthn.net" target="_blank" rel="external">jnthn</a></p>
<h1 id="官方网站"><a href="#官方网站" class="headerlink" title="官方网站"></a>官方网站</h1><p><a href="http://perl6.org/" target="_blank" rel="external">perl6.org</a><br><a href="http://doc.perl6.org/" target="_blank" rel="external">Perl6 Documentation</a><br><a href="http://design.perl6.org/" target="_blank" rel="external">Perl 6 Design Documents</a><br><a href="http://modules.perl6.org/" target="_blank" rel="external">modules.perl6.org</a><br><a href="http://pl6anet.org/" target="_blank" rel="external">pl6anet</a><br><a href="http://examples.perl6.org/" target="_blank" rel="external">examples.perl6.org</a><br><a href="http://perl6.org/compilers/features" target="_blank" rel="external">Perl 6 Features</a><br><a href="https://github.com/perl6/roast" target="_blank" rel="external">Perl 6 测试套件</a><br><a href="http://irclog.perlgeek.de/perl6/" target="_blank" rel="external">Perl 6 IRC</a></p>
<h1 id="国内"><a href="#国内" class="headerlink" title="国内"></a>国内</h1><p><a href="http://sunnavy.net/tag/Perl6" target="_blank" rel="external">sunnavy</a><br><a href="http://www.perl-6.com" target="_blank" rel="external">songzan</a><br><a href="http://www.php-oa.com/perl-6" target="_blank" rel="external">扶凯</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HOW方法]]></title>
      <url>http://ohmycloud.github.io/2016/07/22/HOW%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><a href="http://stackoverflow.com/questions/35819026/why-cant-i-call-the-methods-method-on-a-perl-6s-classhow-object" target="_blank" rel="external">Why can’t I call the methods method on a Perl 6’s ClassHOW object?</a></p>
<p>我可以在某个对象身上调用 <code>^methods</code> 方法, 以列出我能调用的方法的名字列表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $object = &apos;Camelia&apos;</div><div class="line">my @object_methods = $object.^methods;</div><div class="line">@object_methods.map( &#123;.gist&#125; ).sort.join(&quot;\n&quot;).say;</div></pre></td></tr></table></figure>
<p><code>^methods</code> 返回一个列表,  通过对列表中的每个元素调用 <code>.gist</code> 方法, 得到一个人类友好的形式。 </p>
<p>但是 <code>^methods</code> 中的 <code>^</code> 暗含了 <code>.HOW</code> 方法:</p>
<p>我想下面这段代码本该有效的, 但是没有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $object = &apos;Camelia&apos;;</div><div class="line">my @object_objects = $object.HOW.methods;</div></pre></td></tr></table></figure>
<p>但是我得到了一个错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Too few positionals passed; expected 2 arguments but got 1</div><div class="line">  in any methods at gen/moar/m-Metamodel.nqp line 490</div><div class="line">  in block &lt;unit&gt; at...</div></pre></td></tr></table></figure>
<p>通过 <code>.</code> 调用的常规方法把点号左边的调用者作为第一个参数隐式地传递给该方法。通过 <code>.^</code> 调用的元方法传递了两个参数:作为调用者的元对象(meta-object)和作为第一个位置参数的实例:</p>
<p>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$obj.^can(&apos;sqrt&apos;)</div></pre></td></tr></table></figure>
<p>就是下面这段代码的语法糖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$obj.HOW.can($obj, &apos;sqrt&apos;)</div></pre></td></tr></table></figure>
<p>在你的例子中, 你应该写作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @object_methods = $object.HOW.methods($object);</div></pre></td></tr></table></figure>
<h2 id="D-和-D-之间的区别"><a href="#D-和-D-之间的区别" class="headerlink" title=":D 和 :D: 之间的区别"></a>:D 和 :D: 之间的区别</h2><hr>
<p>在一段定义 <code>shift</code> 子例程的Perl 6 代码里:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">multi sub    shift(Array:D)</div><div class="line">multi method shift(Array:D:)</div></pre></td></tr></table></figure>
<p>我知道 <code>:D</code> 意味着 <code>Array</code>是 <code>defined</code> (有定义的)而非 <code>Any</code> 或 <code>nil</code>, 但是 <code>:D:</code> 是什么意思呢? 文档中真的很难找到。</p>
<p><code>D</code>后面的冒号表示方法的调用者作为第一个参数被隐式地传入进来。如果你想在签名中使用显式的参数(例如给它添加一个诸如 :D 的类型笑脸或者给它一个更具描述性的名字), 你需要使用 <code>:</code> 而非 <code>,</code> 以把它和剩余的参数列表分割开。这甚至在空列表时也是必要的, 所以这能消除含有常规位置参数的签名中的歧义。</p>
<p>更多信息, 请查看<a href="http://design.perl6.org/S06.html#Invocant_parameters" target="_blank" rel="external">Invocant_parameters</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[The-Awesome-Errors-of-Perl-6]]></title>
      <url>http://ohmycloud.github.io/2016/07/20/The-Awesome-Errors-of-Perl-6/</url>
      <content type="html"><![CDATA[<h2 id="The-Awesome-Errors-of-Perl-6"><a href="#The-Awesome-Errors-of-Perl-6" class="headerlink" title="The Awesome Errors of Perl 6"></a><a href="http://perl6.party/post/The-Awesome-Errors-of-Perl-6" target="_blank" rel="external">The Awesome Errors of Perl 6</a></h2><p>如果你一直在读技术相关的东西，你现在可能知道 Rust 里面的<a href="https://internals.rust-lang.org/t/new-error-format/3438" target="_blank" rel="external">令人惊喜的错误报告能力</a>。 既然 Perl 6 也因它的绝妙的错误处理而闻名, mst 查询了一些例子来炫耀 rust 的错误处理能力, 但是不幸的是我没有发现。</p>
<p>我尽力避免错误并且我很少完整地读完它。所以我会搜寻一些很酷的关于令人惊叹的错误方面的例子并写出来。虽然我能够用头撞击键盘并把输出粘贴出来, 但是那将会惨不忍读, 所以我会谈论一些对初学者来说没那么明显的棘手的错误, 还有怎样修复那些错误。</p>
<p>让我们开始用头部猛击吧!</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>下面是一段有错误的代码;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">say &quot;Hello world!;</div><div class="line">say &quot;Local time is &#123;DateTime.now&#125;&quot;;</div><div class="line"></div><div class="line"># ===SORRY!=== Error while compiling /home/zoffix/test.p6</div><div class="line"># Two terms in a row (runaway multi-line &quot;&quot; quote starting at line 1 maybe?)</div><div class="line"># at /home/zoffix/test.p6:2</div><div class="line"># ------&gt; say &quot;Local time is &#123;DateTime.now&#125;&quot;;</div><div class="line">#     expecting any of:</div><div class="line">#         infix</div><div class="line">#         infix stopper</div><div class="line">#         postfix</div><div class="line">#         statement end</div><div class="line">#         statement modifier</div><div class="line">#         statement modifier loop</div></pre></td></tr></table></figure>
<p>第一行丢失了字符串上的闭合引号, 所以直到第二行的开括号之间的所有东西都会被认为是字符串的一部分。一旦推测的闭合引号被找到, Perl 6 就看到单词 “Local”, 这个单词被定义为一个项(item)。因为在 Perl 6 中一行中同时存在两个项(item)是不允许的, 所以编译器抛出了错误, 并对它所期望的提供了一些建议, 并且它探测到了我们正处在一个字符串中, 并且建议我们检测, 我们忘记在行 1 中闭合引号了。</p>
<p>===SORRY!=== 部分并不是意味着你运行的是加拿大版本的编译器, 而是意味着该错误是一个编译时错误(和运行时相比)。</p>
<h2 id="Nom-nom-nom-nom"><a href="#Nom-nom-nom-nom" class="headerlink" title="Nom-nom-nom-nom"></a>Nom-nom-nom-nom</h2><p>下面有一个有趣的错误。我们有一个返回东西的子例程, 所以我们调用了它并使用了 for 循环来迭代值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sub things &#123;1 ... ∞&#125;</div><div class="line"></div><div class="line">for things &#123;</div><div class="line">    say &quot;Current stuff is $_&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># ===SORRY!===</div><div class="line"># Function &apos;things&apos; needs parens to avoid gobbling block</div><div class="line"># at /home/zoffix/test.p6:5</div><div class="line"># ------&gt; &#125;&lt;EOL&gt;</div><div class="line"># Missing block (apparently claimed by &apos;things&apos;)</div><div class="line"># at /home/zoffix/test.p6:5</div><div class="line"># ------&gt; &#125;&lt;EOL&gt;</div></pre></td></tr></table></figure>
<p>Perl 6 允许你在调用子例程的时候省略圆括号。上面的错误提到了全局块儿(globbing blocks)。实际发生的是我们希望传给 for 循环的块儿被作为参数传递给了子例程。输出中的第二个错误证实 for 循环丢失了它的块儿(并且给出了一个建议, 它被我们的 things 子例程接收了)。</p>
<p>第一个错误告诉我们怎样修复那个问题: Function ‘things’ needs parens, 所以我们的循环需要是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for things() &#123;</div><div class="line">    say &quot;Current stuff is $_&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而, 如果我们的子例程真的期望传递一个块儿, 那么圆括号就不是必须的。两个代码块肩并肩地在一块儿会导致  “two terms in a row” 错误, 所以 Perl 6 知道把第一个 block 传递给子例程并使用第二个 block 作为 for 循环的主体:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub things (&amp;code) &#123; code &#125;</div><div class="line"></div><div class="line">for things &#123; 1 ... ∞ &#125; &#123;</div><div class="line">    say &quot;Current stuff is $_&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Did-You-Mean-Levestein"><a href="#Did-You-Mean-Levestein" class="headerlink" title="Did You Mean Levestein?"></a>Did You Mean Levestein?</h2><p>下面有一个很酷的特性, 它不仅告诉你出错了, 还能指出你可能想要的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub levenshtein &#123;&#125;</div><div class="line">levestein;</div><div class="line"></div><div class="line"># ===SORRY!=== Error while compiling /home/zoffix/test.p6</div><div class="line"># Undeclared routine:</div><div class="line">#     levestein used at line 2. Did you mean &apos;levenshtein&apos;?</div></pre></td></tr></table></figure>
<p>当 Perl 6 遇到它不认识的名字时它会为它知道的东西计算<a href="https://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank" rel="external">Levenshtein distance</a>以尝试提供一个有用的建议。在上面的距离中它遇到了一个它不知道的子例程调用。它注意到我们确实有一个相似的子例程, 所以它把它作为备选提供了出来。不要再盯着屏幕了, 尝试找到你在哪里敲击的键盘！</p>
<p>然而, 这个特性不可能在触发时面面俱到。假设我们把子例程的名字变为大写的 Levenshtein, 我们就不会得到那个建议, 因为对于以大写字母开头的东西, 编译器认为它看起来像一个类型名而非子例程名, 所以它检测这些东西来代替:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Levenshtein &#123;&#125;</div><div class="line">Lvnshtein.new;</div><div class="line"></div><div class="line"># ===SORRY!=== Error while compiling /home/zoffix/test.p6</div><div class="line"># Undeclared name:</div><div class="line">#    Lvnshtein used at line 2. Did you mean &apos;Levenshtein&apos;?</div></pre></td></tr></table></figure>
<h2 id="一旦你成了-Seq-你再也变不回来"><a href="#一旦你成了-Seq-你再也变不回来" class="headerlink" title="一旦你成了 Seq, 你再也变不回来"></a>一旦你成了 Seq, 你再也变不回来</h2><p>我们假设你生成了一个短的斐波纳契数字序列。你打印了它然后你想再打印它一次, 但是这一次打印每个成员的平方。发生了什么?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my $seq = (1, 1, * + * ... * &gt; 100);</div><div class="line">$seq.join(&apos;, &apos;).say;</div><div class="line">$seq.map(&#123; $_² &#125;).join(&apos;, &apos;).say;</div><div class="line"></div><div class="line"># 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144</div><div class="line"># This Seq has already been iterated, and its values consumed</div><div class="line"># (you might solve this by adding .cache on usages of the Seq, or</div><div class="line"># by assigning the Seq into an array)</div><div class="line">#   in block &lt;unit&gt; at test.p6 line 3</div></pre></td></tr></table></figure>
<p>嗷, 运行时错误。我们从<a href="https://docs.perl6.org/language/operators#index-entry-..._operators" target="_blank" rel="external">序列操作符</a>得到的 Seq 类型不能保留东西。当你迭代序列的时候, 每次它给你一个值之后就丢弃这个值, 所以一旦你迭代完整个 Seq 序列, 就结束了。</p>
<p>上面的例子中, 我们尝试再次迭代那个序列, 所以 Rakudo 运行时奔溃并抱怨了, 因为它做不了。错误消息的确提供了两种可能的解决方案。我们要么使用 .cache 方法来获得一个我们将要迭代的 List:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my $seq = (1, 1, * + * ... * &gt; 100).cache;</div><div class="line">$seq             .join(&apos;, &apos;).say;</div><div class="line">$seq.map(&#123; $_² &#125;).join(&apos;, &apos;).say;</div><div class="line"></div><div class="line"># 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144</div><div class="line"># 1, 1, 4, 9, 25, 64, 169, 441, 1156, 3025, 7921, 20736</div></pre></td></tr></table></figure>
<p>或者我们可以从一开始就使用数组 Array:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my @seq = 1, 1, * + * … * &gt; 100;</div><div class="line">@seq             .join(&apos;, &apos;).say;</div><div class="line">@seq.map(&#123; $_² &#125;).join(&apos;, &apos;).say;</div><div class="line"></div><div class="line"># 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144</div><div class="line"># 1, 1, 4, 9, 25, 64, 169, 441, 1156, 3025, 7921, 20736</div></pre></td></tr></table></figure>
<p>并且即使我们把序列 Seq 存储进了 Array 中, 它不会被具体化直到真正被需要时:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my @a = 1 … ∞;</div><div class="line">say @a[^10];</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># (1 2 3 4 5 6 7 8 9 10)</div></pre></td></tr></table></figure>
<h2 id="These-Aren’t-The-Attributes-You’re-Looking-For"><a href="#These-Aren’t-The-Attributes-You’re-Looking-For" class="headerlink" title="These Aren’t The Attributes You’re Looking For"></a>These Aren’t The Attributes You’re Looking For</h2><p>假设你有一个类。在类里面, 你有一些私有属性并且你有一个使用属性的值作为它的一部分的正则匹配方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class &#123;</div><div class="line">    has $!prefix = &apos;foo&apos;;</div><div class="line">	method has-prefix ($text) &#123;</div><div class="line">	    so $text ~~ /^ $!prefix/;</div><div class="line">	&#125;</div><div class="line">&#125;.new.has-prefix(&apos;foobar&apos;).say;</div><div class="line"></div><div class="line"># ===SORRY!=== Error while compiling /home/zoffix/test.p6</div><div class="line"># Attribute $!prefix not available inside of a regex, since regexes are methods on Cursor.</div><div class="line"># Consider storing the attribute in a lexical, and using that in the regex.</div><div class="line"># at /home/zoffix/test.p6:4</div><div class="line"># ------&gt;         so $text ~~ /^ $!prefix⏏/;</div><div class="line">#     expecting any of:</div><div class="line">#         infix stopper</div></pre></td></tr></table></figure>
<p>糟糕! 发生什么了?</p>
<p>就像编译器所指出的那样, Perl 6 实际上是由几种语言编织而成: Perl 6, Quote, 和 Regex 语言是这个编织物的一部分。这就是为什么像下面这样的东西就能起效:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say &quot;foo &#123; &quot;bar&quot; ~ &quot;meow&quot; &#125; ber &quot;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># foo barmeow ber</div></pre></td></tr></table></figure>
<p>尽管内插的代码块中使用了同样的引号”, 但是没有发生冲突。然而, 同样的机制在正则表达式中有限制, 因为在正则表达式中, 所查询的属性属于 Cursor 对象, 它负责这个正则表达式。</p>
<p>为了避免这个错误, 就像错误信息暗示的那样, 仅仅使用一个临时的变量来存储 $!prefix 好了, 或者使用 given 块儿:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class &#123;</div><div class="line">    has $!prefix = &apos;foo&apos;;</div><div class="line">	method has-prefix ($text) &#123;</div><div class="line">	    given $!prefix &#123; so $text ~~ /^ $_/ &#125;</div><div class="line">	&#125;</div><div class="line">&#125;.new.has-prefix(&apos;foobar&apos;).say;</div></pre></td></tr></table></figure>
<h2 id="De-Ranged"><a href="#De-Ranged" class="headerlink" title="De-Ranged"></a>De-Ranged</h2><p>尝试过访问列表中超出范围的元素吗?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my @a = &lt;foo bar ber&gt;;</div><div class="line">say @a[*-42];</div><div class="line"></div><div class="line"># Effective index out of range. Is: -39, should be in 0..Inf</div><div class="line">#  in block &lt;unit&gt; at test.p6 line 2</div></pre></td></tr></table></figure>
<p>在 Perl 6 中, 如果从列表末端索引一个条目, 要使用时髦的语法: <code>[*-42]</code>。它实际上是一个接收一个参数(它是列表中元素的个数)的闭包, 然后减去 42, 然后返回的值作为实际的索引。如果你特别无聊, 你可以使用 <code>@a[sub ($total) { $total - 42 }]</code> 代替。</p>
<p>在上面的错误中, 那个索引以 <code>3 - 42</code> 结束, 或者说是 <code>-39</code>, 这是我们在错误信息中看到的那个值。因为索引不能是负的, 所以我们收到了错误, 这也告诉我们索引必须从 0 到 正无穷大(任何超过列表所包含的索引会在被查询时返回 Any)。</p>
<h2 id="A-Rose-By-Any-Other-Name-Would-Code-As-Sweet"><a href="#A-Rose-By-Any-Other-Name-Would-Code-As-Sweet" class="headerlink" title="A Rose By Any Other Name, Would Code As Sweet"></a>A Rose By Any Other Name, Would Code As Sweet</h2><p>如果你是 Perl 6 的姐妹语言, Perl  5 的活跃使用者, 你可能会发现有时候你在 Perl 6 代码中写出 Perl 5 风格的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">say &quot;foo&quot; . &quot;bar&quot;;</div><div class="line"></div><div class="line"># ===SORRY!=== Error while compiling /home/zoffix/test.p6</div><div class="line"># Unsupported use of . to concatenate strings; in Perl 6 please use ~</div><div class="line"># at /home/zoffix/test.p6:1</div><div class="line"># ------&gt; say &quot;foo&quot; .⏏ &quot;bar&quot;;</div></pre></td></tr></table></figure>
<p>在上面, 我们尝试使用 Perl 5 的字符串连接操作符来连接两个字符串。这个错误机制足够聪明地检测到这样的用法并推荐了正确的 <code>~</code> 操作符来代替。</p>
<p>这不是这种探测的唯一使用场景。有很多场景。这儿有另外一个例子, 用于探测 Perl 5 的钻石操作符的意外使用, 伴随着几个程序员可能想要的建议:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">while &lt;&gt; &#123;&#125;</div><div class="line"></div><div class="line"># ===SORRY!=== Error while compiling /home/zoffix/test.p6</div><div class="line"># Unsupported use of &lt;&gt;; in Perl 6 please use lines() to read input, (&apos;&apos;) to</div><div class="line"># represent a null string or () to represent an empty list</div><div class="line"># at /home/zoffix/test.p6:1</div><div class="line"># ------&gt; while &lt;⏏&gt; &#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="Heredoc-Theredoc-Everywheredoc"><a href="#Heredoc-Theredoc-Everywheredoc" class="headerlink" title="Heredoc, Theredoc, Everywheredoc"></a>Heredoc, Theredoc, Everywheredoc</h2><p>为了抛出问题, 请先阅读底部的错误, 假装就是你自己写的程序代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">my $stuff = qq:to/END/;</div><div class="line">Blah blah blah</div><div class="line">END;</div><div class="line"></div><div class="line">for ^10 &#123;</div><div class="line">    say &apos;things&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for ^20 &#123;</div><div class="line">    say &apos;moar things&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub foo ($wtf) &#123;</div><div class="line">    say &apos;oh my!&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># ===SORRY!=== Error while compiling /home/zoffix/test.p6</div><div class="line"># Variable &apos;$wtf&apos; is not declared</div><div class="line"># at /home/zoffix/test.p6:13</div><div class="line"># ------&gt; sub foo (⏏$wtf) &#123;</div></pre></td></tr></table></figure>
<p>哈? 编译器哭着说有一个未声明的变量, 但是它指向的却是子例程中的签名。当然它不会被声明。</p>
<p>那些没有发现问题的人: 问题就出在 heredoc 中的闭合 END 后面的分号上。 heredoc 在闭合分隔符单独出现在一行的地方结束。在编译器看来, 我们还没有在 <code>END;</code> 这儿看到分隔符, 所以它继续解析就像它仍旧在解析 heredoc 一样。<code>qq</code> heredoc 能让你插入变量, 所以当解析器解析到签名中的 <code>$wtf</code> 变量时, 解析器并不知道它是一段实际代码中的签名还是某些随机的文本, 所以编译器哭着说变量未找到。</p>
<h2 id="Won’t-Someone-Think-of-The-Reader"><a href="#Won’t-Someone-Think-of-The-Reader" class="headerlink" title="Won’t Someone Think of The Reader?"></a>Won’t Someone Think of The Reader?</h2><p>下面有一个极好的错误能阻止你写出恐怖的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">my $a;</div><div class="line">sub &#123;</div><div class="line">    $a.say;</div><div class="line">	$^a.say;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># ===SORRY!=== Error while compiling /home/zoffix/test.p6</div><div class="line"># $a has already been used as a non-placeholder in the surrounding sub block,</div><div class="line">#   so you will confuse the reader if you suddenly declare $^a here</div><div class="line"># at /home/zoffix/test.p6:4</div><div class="line"># ------&gt;         $^a.say;</div></pre></td></tr></table></figure>
<p>这里有一点背景: 你可以在变量身上使用 <code>$^ twigil</code> 来创建一个隐式的签名。为了能在嵌套的块中使用这样的变量, 这个语法实际上创建了不带 twigil 的相同变量, 所以 <code>$^a</code> 和 <code>$a</code> 是同一个东西, 并且上面的子例程的签名是 <code>($a)</code>。</p>
<p>在我们的代码中, 我们还在外部作用域中有个 <code>$a</code> 并且推测我们首先打印出它, 在使用 <code>$^</code> twigil 在同样一个作用域中创建另外一个 <code>$a</code> 之前, 但是这个子例程包含了参数… 真绕脑! 为了避免这样, 就把你的变量重命名为某个不会冲突的东西好了。改成泰文怎么样?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my $ความสงบ = &apos;peace&apos;;</div><div class="line">sub &#123;</div><div class="line">    $ความสงบ.say;</div><div class="line">    $^กับตัวแปรของคุณ.say;</div><div class="line">&#125;(&apos;to your variables&apos;);</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># peace</div><div class="line"># to your variables</div></pre></td></tr></table></figure>
<h2 id="Well-Colour-Me-Errpressed"><a href="#Well-Colour-Me-Errpressed" class="headerlink" title="Well, Colour Me Errpressed!"></a>Well, Colour Me Errpressed!</h2><p>如果你的终端支持它, 那么编译器就会发出 ANSI 代码来给输出着点色:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ^5 &#123;</div><div class="line">    say meow&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-dc7e73c2e865eb03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>那很好也很显眼夺目, 但是假设你想把从编译器中捕获的输出显示到任何地方, 你会原样地得到 ANSI 代码, 就像 <code>31m===[0mSORRY![31m===[0m</code>。</p>
<p>这很可怕, 但是幸运的是, 禁用颜色很简单: 仅仅把 <code>RAKUDO_ERROR_COLOR</code> 这个环境变量的值设置为 0 就好了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-3581c5469cbca92e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>你也可以在程序中设置它。你不得不足够早地设置它, 所以在任何地方把它放置在程序的开头并使用 <a href="https://docs.perl6.org/language/phasers#BEGIN" target="_blank" rel="external">BEGIN phaser</a> 来设置它只要赋值被编译完成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BEGIN %*ENV&lt;RAKUDO_ERROR_COLOR&gt; = 0;</div><div class="line"></div><div class="line">for ^5 &#123;</div><div class="line">    say meow&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="An-Exceptional-Failure"><a href="#An-Exceptional-Failure" class="headerlink" title="An Exceptional Failure"></a>An Exceptional Failure</h2><p>Perl 6 有一个特殊的异常 – <a href="https://docs.perl6.org/type/Failure" target="_blank" rel="external">Failure</a> – 直到你把它用作变量它才会被激发, 并且你甚至可以通过在布尔上下文中使用它来彻底地消除它。你可以通过调用 <a href="https://docs.perl6.org/routine/fail" target="_blank" rel="external">fail</a> 子例程产生你自己的 Failures 并且 Perl 6 在核心中在尽可能合适的时候使用它。</p>
<p>这儿有一段代码, 其中我们定义了一个前缀操作符用来计算对象的圆周长, 给定一个半径。如果半径是负值, 它就调用 fail, 并返回一个 Failure 对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">sub prefix:&lt;⟳&gt; (\𝐫) &#123;</div><div class="line">    𝐫 &lt; 0 and fail &apos;Your object warps the Universe a new one&apos;;</div><div class="line">    τ × 𝐫;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say &apos;Calculating the circumference of the mystery object&apos;;</div><div class="line">my $cₘ = ⟳ −𝑒;</div><div class="line"></div><div class="line">say &apos;Calculating the circumference of the Earth&apos;;</div><div class="line">my $cₑ = ⟳ 6.3781 × 10⁶;</div><div class="line"></div><div class="line">say &apos;Calculating the circumference of the Sun&apos;;</div><div class="line">my $cₛ = ⟳ 6.957 × 10⁸;</div><div class="line"></div><div class="line">say &quot;The circumference of the largest object is &#123;max $cₘ, $cₑ, $cₛ&#125; metres&quot;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Calculating the circumference of the mystery object</div><div class="line"># Calculating the circumference of the Earth</div><div class="line"># Calculating the circumference of the Sun</div><div class="line"># Your object warps the Universe a new one</div><div class="line">#   in sub prefix:&lt;⟳&gt; at test.p6 line 2</div><div class="line">#   in block &lt;unit&gt; at test.p6 line 7</div><div class="line">#</div><div class="line"># Actually thrown at:</div><div class="line">#   in block &lt;unit&gt; at test.p6 line 15</div></pre></td></tr></table></figure>
<p>在第七行中我们正计算一个半径为负值的圆的周长, 所以如果它仅仅是一个常规的异常, 那么我们的代码会当场挂掉。相反, 通过输出, 我们能够看到我们继续计算了 Earth 和 Sun 的周长, 直到我们到达最后一行。</p>
<p>在那儿我们尝试在 <code>$cₘ</code> 变量中使用 Failure 作为 max 程序的一个参数。因为我们在查询真实的值, Failure 被激发并给了我们一个很好的反向追踪。上面的错误信息包含了我们的 Failure 爆发(第十五行)点, 还有我们的接收点(第七行)还有错误来自哪儿(第二行)。真甜!</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Perl 6 拥有令人惊叹的 Errors!</p>
<p>大西瓜啊。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[roundrobin]]></title>
      <url>http://ohmycloud.github.io/2016/07/18/roundrobin/</url>
      <content type="html"><![CDATA[<p>定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi roundrobin(List:D: --&gt; Seq)</div></pre></td></tr></table></figure>
<p>用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">roundrobin LISTS</div></pre></td></tr></table></figure>
<h2 id="Round-Robin-Merge-Two-Lists-of-Different-Length"><a href="#Round-Robin-Merge-Two-Lists-of-Different-Length" class="headerlink" title="Round-Robin Merge Two Lists of Different Length"></a>Round-Robin Merge Two Lists of Different Length</h2><hr>
<p><strong>roundrobin</strong>很像 <strong>zip</strong>。不同之处是, <code>roundrobin</code>不会在用光元素的列表上停止而是仅仅跳过任何未定义的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my @a = 1;</div><div class="line">my @b = 1..2;</div><div class="line">my @c = 1..3;</div><div class="line"></div><div class="line">for flat roundrobin(@a, @b, @c) -&gt; $x &#123; $x.say &#125; # 1,1,1,2,2,3</div></pre></td></tr></table></figure>
<p>它只是跳过了未定的值, 直到最长的那个列表的元素用完。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @list1 = &apos;a&apos; .. &apos;h&apos;;</div><div class="line">my @list2 = &lt;x y&gt;;</div><div class="line">say flat roundrobin @list1, @list2; # a x b y c d e f g h</div></pre></td></tr></table></figure>
<p><strong>roundrobin</strong> 返回的是一列 <code>Seq</code>, 所以使用 flat 进行展开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my @list1 = &apos;a&apos; .. &apos;h&apos;;</div><div class="line">my @list2 = &lt;x y&gt;;</div><div class="line">my $n = 3;</div><div class="line">say flat roundrobin @list1.rotor($n - 1, :partial), @list2;</div><div class="line"></div><div class="line"># &gt;&gt;&gt;</div><div class="line"># OUTPUT«a b x c d y e f g h»</div></pre></td></tr></table></figure>
<p><code>.rotor</code>方法把一个列表分解为子列表。</p>
<h2 id="交叉两个字符串中的字符"><a href="#交叉两个字符串中的字符" class="headerlink" title="交叉两个字符串中的字符"></a>交叉两个字符串中的字符</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#Given:</div><div class="line">u = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;</div><div class="line">l = &apos;abcdefghijklmnopqrstuvwxyz&apos;</div><div class="line"></div><div class="line">#Wanted:</div><div class="line">&apos;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz&apos;</div></pre></td></tr></table></figure>
<p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say join &apos;&apos;, (u.comb Z l.comb);</div></pre></td></tr></table></figure>
<p>方法二:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say [~] (u.comb Z l.comb);</div></pre></td></tr></table></figure>
<p>方法三</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say [~] flat (u.comb Z l.comb);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[副词的-Pair-形式]]></title>
      <url>http://ohmycloud.github.io/2016/07/16/%E5%89%AF%E8%AF%8D%E7%9A%84-Pair-%E5%BD%A2%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="副词的-Pair-形式"><a href="#副词的-Pair-形式" class="headerlink" title="副词的 Pair 形式"></a>副词的 Pair 形式</h2><p><a href="https://github.com/perl6/roast/blob/master/S02-literals/adverbs.t#L6-L69" target="_blank" rel="external">S02-literals/adverbs.t lines 6–69</a></p>
<p>现在有一个普通的副词形式的 Pair 记号，也是人们所熟知的 “colon pair”（冒号对）形式。下面的表格展示了和胖箭头记号相一致的记号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Fat arrow           Adverbial pair  Paren form</div><div class="line">=========           ==============  ==========</div><div class="line">a =&gt; True           :a</div><div class="line">a =&gt; False          :!a</div><div class="line">a =&gt; 0              :a(0)</div><div class="line">a =&gt; $x             :a($x)</div><div class="line">a =&gt; &apos;foo&apos;          :a&lt;foo&gt;         :a(&lt;foo&gt;)</div><div class="line">a =&gt; &lt;foo bar&gt;      :a&lt;foo bar&gt;     :a(&lt;foo bar&gt;)</div><div class="line">a =&gt; «$foo @bar»    :a«$foo @bar»   :a(«$foo @bar»)</div><div class="line">a =&gt; &#123;...&#125;          :a&#123;...&#125;         :a(&#123;...&#125;)</div><div class="line">a =&gt; [...]          :a[...]         :a([...])</div><div class="line">a =&gt; $a             :$a</div><div class="line">a =&gt; @a             :@a</div><div class="line">a =&gt; %a             :%a</div><div class="line">a =&gt; &amp;a             :&amp;a</div><div class="line">a =&gt; %foo&lt;a&gt;        %foo&lt;a&gt;:p</div></pre></td></tr></table></figure>
<p>胖箭头结构应只用于项(term)所在位置因为它被认为是一个独立的表达式，因为胖箭头自身被解析为一个普通的中缀操作符（即使自动引起它左侧的标识符时）。因为左侧是一个普通的表达式，胖箭头形式会使用任何值作为键来创建 Pair。另一方面，当用上面的形式来生成 Pair 对象时，副词形式被约束为使用标识符作为键。在键不是标识符的地方，你必须使用胖箭头形式来生成 Pair。</p>
<p>尽管有那个约束，但是冒号和括号之间有其它东西也是可能的；然而，所有可能的非标识符形式的副词形式的键都被保留用作特殊的语义形式。Perl 6 当前识别十进制数的键和空(null)键。在下面的表格中，第一列和第二列不是同一个东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Simple pair         DIFFERS from    which means</div><div class="line">===========         ============    ===========</div><div class="line">2 =&gt; &lt;101010&gt;       :2&lt;101010&gt;      二进制字面值 0b101010</div><div class="line">8 =&gt; &lt;123&gt;          :8&lt;123&gt;         八进制字面值 0o123</div><div class="line">16 =&gt; &lt;deadbeef&gt;    :16&lt;deadbeef&gt;   十六进制字面值 0xdeadbeef</div><div class="line">16 =&gt; $somevalue    :16($somevalue) 十六进制转换函数，把十六进制的字符串转换为数字</div><div class="line">&apos;&apos; =&gt; $x            :($x)           签名字面值</div><div class="line">&apos;&apos; =&gt; ($x,$y)       :($x,$y)        签名字面值</div><div class="line">&apos;&apos; =&gt; &lt;x&gt;           :&lt;x&gt;            name extension</div><div class="line">&apos;&apos; =&gt; «x»           :«x»            name extension</div><div class="line">&apos;&apos; =&gt; [$x,$y]       :[$x,$y]        name extension</div><div class="line">&apos;&apos; =&gt; &#123; .say &#125;      :&#123; .say &#125;       adverbial block (not allowed on names)</div></pre></td></tr></table></figure>
<p>所有的副词形式（包括普通的带有标识符键的副词）被认为是特殊的令牌(tokens)并且除了能在项的位置上被识别，也能在各种不同的位置上被识别。特别地，当把它用在中缀的位置上时，它们修改了之前的顶端的优先级比”loose unary”紧凑的操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 == 100 :fuzz(3)   # 调用: infix:&lt;==&gt;(1, 100, fuzz =&gt; 3)</div></pre></td></tr></table></figure>
<p>在声明内部副词形式用于重命名参数声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub foo ( :externalname($myname) ) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>副词修改了各种引号形式的意义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">q:x &apos;cat /etc/passwd&apos;</div></pre></td></tr></table></figure>
<p>当副词被追加到标识符（即，在后缀位置上）后面时，副词形式的语法用于生成那个标识符的唯一变体；该语法用于命名诸如 <code>infix:&lt;+&gt;</code> 这样的操作符和诸如 <code>statement_control:if</code> 这样的多重分发文法规则。当这样用时，副词被认为是名字的一部分，所以 <code>infix:&lt;+&gt;</code> 和 <code>infix:&lt;-&gt;</code> 是两个不同的操作符。同样地, <code>prefix:&lt;+&gt;</code> 不同于 <code>infix&lt;+&gt;</code>。（这种记法的好处有把不同的标识符分组到容易访问的集合中，例如，这就是 Perl 6 标准文法时如何知道当前中缀操作符集合的）。</p>
<p>只有能产生一列一个或更多值（偏好字符串）的标识符被允许作为名字扩展；特殊地，闭包不能作为值，所以 <code>:{...}</code> 形式的副词不能被允许作为名字扩展。特别地，这把方法名后面的 block 空了出来，所以它允许我们把 block 解析为方法的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@stuff.sort:&#123; +$_ &#125;</div></pre></td></tr></table></figure>
<p>这些看起来它们使用的是 pairs，实际上它们等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@stuff.sort: &#123; +$_ &#125;</div></pre></td></tr></table></figure>
<p>所以这儿的冒号真得不是在引入 pairs，而是引入了该方法的参数列表。在其他任何位置，<code>:{...}</code> 会使用两种用法的一种，根据花括号定义的是闭包还是散列。如果被当做闭包， <code>:{...}</code> 会创建把空键(null)映射到闭包的 pair。如果被当做散列构造器，那么空键会被忽略，并且 <code>:{...}</code> 会创建一个以对象为键的散列而非像没有冒号的 <code>{...}</code>那样创建一个以字符串为键的散列。</p>
<p>胖箭头和副词对儿记法都能用于把具名参数作为项传递给函数或方法。在括号里面带有参数的调用后面，只有副词形式的语法能用于传递额外的参数。这通常用于传递额外的 block:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find($directory) :&#123; when not /^\./ &#125;</div></pre></td></tr></table></figure>
<p>这正好和前面的规则离经叛道，因为副词形式的 block 处于操作符的位置，所以它修改了 “find operator”。(括号不被认为是操作符)</p>
<p>注意（和往常一样）<code>{...}</code> 形式（要么基于操作符要么是特殊的）可以根据内容要么标示一个闭包，要么标示一个散列。它没有标示下标，因为 <code>:key{}</code> 实际上等价于 <code>key =&gt; {}</code>, 并且花括号一点儿也没有表现得像后缀一样。（然而，它所传递给的函数也能把那个值用于下标）</p>
<p>还要注意 <code>&lt;a b&gt;</code> 形式不是下标，因此并不等价于 <code>.{&#39;a&#39;, &#39;b&#39;}</code> 而是等价于 <code>(&#39;a&#39;, &#39;b&#39;)</code>。 裸的 <code>&lt;a&gt;</code> 转换为 <code>(&#39;a&#39;)</code> 而不是 <code>(&#39;a&#39;,)</code>。（然而，对于其它形式的括号，根据上下文，值可能也能用作下标）</p>
<p>两个更多地副词总是可以捆绑在一块儿。当在参数列表中用作具名参数时，你可能在参数之间放上逗号，因为它们对于函数来说就是普通的具名参数，并且胖箭头形式的参数效果相同。然而，当第一个 pair 出现在项(term)的位置上时，这个逗号才只允许出现。当期望一个中缀操作符时，那个副词总是被看做修改最近的之前的操作符，它没有被隐藏在圆括号中，并且如果你把多个这样的 pairs 作为一个字符串放在一块儿，那么你就不能在它们中间放上逗号，因为那会让之后的 pairs 看起来像项(terms)。（在操作符的位置上一点也不允许胖箭头形式）查看 S06 获取把副词用作具名参数的用法。</p>
<p>否定形式(:!a) 和符号形式(:$a, :@a, :%a) 绝对不会接收参数也不关心下一个字符是什么。它们被认为是完备的。这些形式需要一个标识符作为键。包含 twigil 的符号形式不会在键中包含那个 twigil。</p>
<p>对于接收一个非否定整数参数的标识符，它被允许缩写，例如，把 <code>:sweet(16)</code> 缩写为 <code>:16sweet</code>。（这个和 <code>:16&lt;deadbeef&gt;</code> 形式不一样，后者从来没有字母字符跟在数字后面。）只有字面的非负数字可以这样交换使用。请注意这个缩写允许：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s:2nd/foo/bar/  # or 3rd, 4th, 5th etc.</div></pre></td></tr></table></figure>
<p>其它形式的副词（包括裸的 <code>:a</code> 形式）总是查找紧紧跟随的用括号括起的参数，并且把它吞噬掉。如果那没有达到预期，那么你必须在副词和开括号之间使用空白。在 Perl 6中单独的副词语法在各处都是相同的。基于参数是需要还是不需要，没有例外。（对于引号副词和 regex 副词有一个小例外，它们只接受圆括号作为它们的括号操作符，并且忽略其它括号，如果需要它们必须被放到括号里。查看上表中得” Paren form”）</p>
<p>除了上面要注意的之外，解析器常常会寻找括号。尽管没有标示一个真的下标，括号被类似地解析为后缀操作符。因为把括号后缀化可以和它们起初的使用 unspace 或点(或两者都) <code>:foo</code> 的区分开。</p>
<p>不管语法，用作具名参数的副词一般作为我们正谈论的函数的可选具名参数呈现 – 即使那个函数是操作符或宏。那个正被谈论的函数既不知道也不关心原语法是多么的怪异。</p>
<blockquote>
<p>翻译的真心大西瓜</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[given-when]]></title>
      <url>http://ohmycloud.github.io/2016/07/09/given-when/</url>
      <content type="html"><![CDATA[<p>given-when 有两个小的改变, 并且这俩改变都是开启新行为的, 而不是限制已存在的行为。</p>
<p>第一个小的改变: when 的开关行为不仅仅是用于 given 块儿中的, 而是可以用在任何”主题化”的块儿中的, 例如 for 循环中或接收 <code>$_</code>作为参数的子例程中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">given $answer &#123;</div><div class="line">    when &quot;Atlantis&quot; &#123; say &quot;那是对的&quot; &#125;</div><div class="line">    default &#123; say &quot;BZZZZZZZZZZZZZ!&quot; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for 1..100 &#123;</div><div class="line">    when * %% 15 &#123; say &quot;Fizzbuzz&quot; &#125;</div><div class="line">    when * %% 3  &#123; say &quot;Fizz&quot;     &#125;</div><div class="line">    when * %% 5  &#123; say &quot;Buzz&quot;     &#125;</div><div class="line">    default      &#123; say $_         &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub expand($_) &#123;</div><div class="line">    when &quot;R&quot; &#123; say &quot;红警&quot; &#125;</div><div class="line">    when &quot;G&quot; &#123; say &quot;绿警&quot; &#125;</div><div class="line">    when &quot;B&quot; &#123; say &quot;蓝警&quot; &#125;</div><div class="line">    default  &#123; say $_     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是甚至不接受 <code>$_</code>作为参数的子例程也得到了它们自己的词法变量 <code>$_</code>供修改。所以规则就是”现在, 在 $<em> 中有某些我能启动的好东西吗”。如果我们想要, 我们甚至能自己设置 `$</em>`。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub seek-the-answer() &#123;</div><div class="line">    $_ = (^100).pick;</div><div class="line">    when 42 &#123; say &quot;The answer&quot; &#125;</div><div class="line">    default &#123; say &quot;A number&quot;   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>换句话说, 我们已经知道了 <strong>when</strong> 和 <strong>given</strong> 是单独的。Switch 语句逻辑都在 when 语句中。</p>
<p>第二个小改变: 你可以嵌套 <em>when</em> 语句!</p>
<p>我很确信你没有在野外见过这种用法。但它有时候特别有用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">when * &gt; 2 &#123;</div><div class="line">    when 4  &#123; say &apos;Four!&apos; &#125;</div><div class="line">    default &#123; say &apos;huge&apos;  &#125;</div><div class="line">&#125;</div><div class="line">default &#123;</div><div class="line">    say &apos;little&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能记得, 在 when 块儿中有一个隐式的 <em>succeed</em> 语句在末尾, 这让周围的主题化块退出。(意思是你不必记着手动退出 switch 语句)。 如果你想重写 succeed 语句并继续通过 when block, 那么你在 <em>when</em> block 的末尾写上一个显式的 <em>proceed</em> 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">given $verse-number &#123;</div><div class="line">    when * &gt;= 12 &#123; say &quot;Twelve drummers drumming&quot;; proceed &#125;</div><div class="line">    when * &gt;= 11 &#123; say &quot;Eleven pipers piping&quot;; proceed &#125;</div><div class="line">    # ...</div><div class="line">    when * &gt;= 5 &#123; say &quot;FIIIIIIVE GOLDEN RINGS!&quot;; proceed &#125;</div><div class="line">    when * &gt;= 4 &#123; say &quot;Four calling birds&quot;; proceed &#125;</div><div class="line">    when * &gt;= 3 &#123; say &quot;Three French hens&quot;; proceed &#125;</div><div class="line">    when * &gt;= 2 &#123;</div><div class="line">        say &quot;Two turtle doves&quot;;</div><div class="line">        say &quot;and a partridge in a pear tree&quot;;</div><div class="line">    &#125;</div><div class="line">    say &quot;a partridge in a pear tree&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl--6-中的梳子!]]></title>
      <url>http://ohmycloud.github.io/2016/07/07/Perl6%E4%B8%AD%E7%9A%84%E6%A2%B3%E5%AD%90/</url>
      <content type="html"><![CDATA[<h1 id="Perl-6-中的梳子"><a href="#Perl-6-中的梳子" class="headerlink" title="Perl  6 中的梳子!"></a>Perl  6 中的梳子!</h1><p>在 Perl 5 中, 我很感激有这样两个便利的结构:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @things = $text =~ <span class="regexp">/thing/g</span>;</div><div class="line"><span class="keyword">my</span> %things = $text =~ <span class="regexp">/(key)...(value)/g</span>;</div></pre></td></tr></table></figure>
<p>你拿出一小段可以预见的文本，并给它一个正则表达式，吼吼, 你得到了一个列表和散列，像变魔术一般！我们也可以在 Perl  6 中使用正则表达式，但是 <strong><a href="http://docs.perl6.org/routine/comb" target="_blank" rel="external">comb</a></strong> 更适合做这个工作。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-29a3966bbb8e437f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h2 id="Plain-‘Ol-Characters"><a href="#Plain-‘Ol-Characters" class="headerlink" title="Plain ‘Ol Characters"></a>Plain ‘Ol Characters</h2><p>你可以把 <em>comb</em> 用作子例程或方法。在它的最基本的形式中， <em>comb</em> 会把字符串分解为字符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&apos;foobar moobar 駱駝道bar&apos;.comb.join(&apos;|&apos;).say;</div><div class="line">&apos;foobar moobar 駱駝道bar&apos;.comb(6).join(&apos;|&apos;).say;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># f|o|o|b|a|r| |m|o|o|b|a|r| |駱|駝|道|b|a|r</div><div class="line"># foobar| mooba|r 駱駝道b|ar</div></pre></td></tr></table></figure>
<p>不适用任何参数的 <em>comb</em> 你会得到各个单独的字符。给 <em>comb</em> 提供一个整数 <code>$n</code>, 那么你会得到长度至多为 <code>$n</code> 个字符的一个列表，并且如果没有剩下的字符不够的话，这个列表会接收较短的这个字符串。这个方法比使用正则表快了 30 倍。</p>
<h2 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h2><p>你也可以为 <em>comb</em> 提供第二个整数参数，即 <em>limit</em>，来标示每个列表中最多含有 limit 个元素:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&apos;foobar moobar 駱駝道bar&apos;.comb(1, 5).join(&apos;|&apos;).say;</div><div class="line">&apos;foobar moobar 駱駝道bar&apos;.comb(6, 2).join(&apos;|&apos;).say;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># f|o|o|b|a</div><div class="line"># foobar| mooba</div></pre></td></tr></table></figure>
<p>这适用于使用 <em>comb</em> 方法/函数的所有形式，而不仅仅是上面展示的那样。</p>
<h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p><em>comb</em> 也接收普通的 <a href="http://docs.perl6.org/type/Str" target="_blank" rel="external">Str</a> 作为参数，返回一个包含那个字符串的匹配的列表。所以这在计算子字符串在字符串中出现的次数时很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&apos;The 🐈 ran after a 🐁, but the 🐁 ran away&apos;.comb(&apos;🐈&apos;).Int.say;</div><div class="line">&apos;The 🐈 ran after a 🐁, but the 🐁 ran away&apos;.comb(&apos;ran&apos;).Int.say;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 1</div><div class="line"># 2</div></pre></td></tr></table></figure>
<h2 id="简单的匹配"><a href="#简单的匹配" class="headerlink" title="简单的匹配"></a>简单的匹配</h2><p><em>comb</em> 的参数也可以是一个正则表达式，整个匹配会作为一个标量被返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foobar moobar 駱駝道bar&apos;.comb(/&lt;[a..z]&gt;+ &apos;bar&apos;/).join(&apos;|&apos;).say;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># foobar|moobar</div></pre></td></tr></table></figure>
<h2 id="限制所匹配的东西"><a href="#限制所匹配的东西" class="headerlink" title="限制所匹配的东西"></a>限制所匹配的东西</h2><p>你可以使用<a href="http://docs.perl6.org/language/regexes#Look-around_assertions" target="_blank" rel="external">环视断言</a>或者更简单的 <code>&lt;(</code> 和 <code>)&gt;</code> 正则表达式捕获记号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&apos;moo=meow ping=pong&apos;.comb(/\w+    &apos;=&apos; &lt;( \w**4/).join(&apos;|&apos;).say; # values</div><div class="line">&apos;moo=meow ping=pong&apos;.comb(/\w+ )&gt; &apos;=&apos;    \w**4/).join(&apos;|&apos;).say; # keys</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># meow|pong</div><div class="line"># moo|ping</div></pre></td></tr></table></figure>
<p>你可以使用  <code>&lt;(</code> 和 <code>)&gt;</code> 两者之一或两者都使用。 <code>&lt;(</code> 从匹配中排除任何它之前的东西而 <code>)&gt;</code> 会排序之后的任何东西。即 <code>/&#39;foo&#39; &lt;(&#39;bar&#39;)&gt; &#39;ber&#39;/</code>  会匹配包含 <em>foobarber</em> 的东西，但是从 <em>comb</em> 中返回的东西只会有 <em>bar</em>。</p>
<h2 id="多个捕获"><a href="#多个捕获" class="headerlink" title="多个捕获"></a>多个捕获</h2><p>怎么样得出 Perl 5 那样的 键/值对儿呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %things = &apos;moo=meow ping=pong&apos;.comb(/(\w+) &apos;=&apos; (\w+)/, :match)».Slip».Str;</div><div class="line">say %things;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># moo =&gt; meow, ping =&gt; pong</div></pre></td></tr></table></figure>
<p>圆括号用于捕获。<code>:match</code> 参数使 <em>comb</em> 返回一个 <strong>Match</strong> 对象的列表，而非返回一个字符串列表。下一步，我们使用两个 hyper 运算符把 <strong>Matches</strong> 转换为 <a href="http://docs.perl6.org/type/Slip" target="_blank" rel="external">Slips</a>，这会给我们一个捕获的列表，但是它们仍旧是 <strong>Match</strong> 对象，这就是为什么我们还要把它们转换为 <strong>Str</strong> 的原因。</p>
<p>我们还可以使用具名捕获使代码更清晰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my %things = &apos;moo=meow ping=pong&apos;</div><div class="line">    .comb(/$&lt;key&gt;=\w+ &apos;=&apos; $&lt;value&gt;=\w+/, :match)</div><div class="line">    .map(&#123; .&lt;key&gt; =&gt; .&lt;value&gt;.Str &#125;);</div><div class="line">say %things;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># moo =&gt; meow, ping =&gt; pong</div></pre></td></tr></table></figure>
<p>你还可以把上面的代码写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %things = (&apos;moo=meow ping=pong&apos; ~~ m:g/(\w+) &apos;=&apos; (\w+)/)».Slip».Str;</div><div class="line">say %things;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># moo =&gt; meow, ping =&gt; pong</div></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>把 <em>comb</em> 和 <em><a href="http://blogs.perl.org/users/zoffix_znet/2016/01/perl-6-rotor-the-king-of-list-manipulation.html" target="_blank" rel="external">rotor</a></em> 结合起来用会很强大。</p>
<h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>代替使用带有 <code>:match</code> 参数的 <code>.comb</code> , 你最好就使用 <code>.match</code> 方法好了: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;moo=meow ping=pong&apos;.match(/(\w+) &apos;=&apos; (\w+)/, :g)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[It's-blocks-all-the-way-down]]></title>
      <url>http://ohmycloud.github.io/2016/07/07/It-s-blocks-all-the-way-down/</url>
      <content type="html"><![CDATA[<p><a href="https://gfldex.wordpress.com/2016/07/19/its-blocks-all-the-way-down/" target="_blank" rel="external">It’s blocks all the way down</a></p>
<p>当我在 <a href="https://glot.io/new/perl6" target="_blank" rel="external">glot.io</a> 上玩 Perl 6 的时候我知道它们真的很像带有简单程序的 docker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dir(&apos;/&apos;)&gt;&gt;.Str.say;</div></pre></td></tr></table></figure>
<p>我想知道递归到目录里面是否还有更好的方法。 IO::Path.dir 会返回一个 IO::Path 对象的 Seq 序列。那就是为什么 <code>&gt;&gt;.</code> 超运算符会有效。它当然不会递归因为没有用来进行递归的子例程, 经过一段时间的冥思苦想我找到了我找了很久的东西。</p>
<p>在 Perl 6 中带有一个位置参数的 block 块是可调用的(Callable)。那个参数被绑定给主题变量 <code>$_</code>。 那是我们为什么能做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for 1,2,3 &#123;.say&#125;</div></pre></td></tr></table></figure>
<p>递归到目录中会很容易如果我们把 <code>Str &#39;/&#39;</code> 变成 IO::Path 对象并且检测我们是否得到了一个目录并且使用那个元素调用那个 block 块。那个 block 块需要一个名字, 这个我们可以通过使用 <code>my &amp;block = {Nil}</code> 做到, 或者我们使用编译时变量 <code>&amp;?BLOCK</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for &apos;.&apos; &#123;</div><div class="line">    .Str.say when !.IO.d;</div><div class="line">    .IO.dir()&gt;&gt;.&amp;?BLOCK.IO.d</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>.&amp;?BLOCK</code> 形式会把调用看作像方法调用一样, 这意味着 <code>.</code> 号左侧的对象会成为调用的第一个参数, 在调用者所属的地方。</p>
<p>我相信这是一个相当好的关于怎样使用 <code>&amp;?BLOCK</code> 来避免嵌套循环和短变量的例子。这会在稍后被添加到文档中。</p>
<p>在 <a href="http://perl6.party/" target="_blank" rel="external">Zoffix</a> 的友好帮助下, 那个例子被进一步优化了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; .d &amp;&amp; .dir».&amp;?BLOCK || .put &#125;(&quot;.&quot;.IO)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的正则表达式(二)]]></title>
      <url>http://ohmycloud.github.io/2016/06/29/Perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h1 id="允许的修饰符"><a href="#允许的修饰符" class="headerlink" title="允许的修饰符"></a>允许的修饰符</h1><p>有些修饰符能在所有允许的地方出现, 但并非所有的都这样.</p>
<p>通常,  影响 regex 编译的修饰符( 像 <code>:i</code> ) 一定要在编译时被知道. 只影响行为而非 regex本身的修饰符(eg. <code>:pos</code>, <code>:overlap</code>, <code>:x(4)</code>) 可能只出现在引用某个调用的结构上(例如 <code>m//</code> 和<code>s///</code>),  并且不会出现在 <code>rx//</code> 上.  最后, 重叠在替换结构中是不被允许的, 而影响修改的副词只允许出现在替中.</p>
<p>这些准则导致了下面的 rules:</p>
<ul>
<li><code>:ignorecase</code>, <code>:ignoremark</code>, <code>:sigspace</code>, <code>:ratchet</code>  和 <code>:Perl5</code>  修饰符和它们的便捷形式允许出现在 regex 中的任何地方, 还有 <code>m//</code>, <code>rx//</code> 和<code>s///</code>  结构中. 一个 regex实现可能要求它们的值在编译时是被知晓的, 而如果不是这种情况则给出编译时错误信息.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rx:i/ hello /           # OK</div><div class="line">rx:i(1) /hello/         # OK</div><div class="line">my $i = 1;</div><div class="line">rx:i($i) /hello/        # may error out at compile time</div></pre></td></tr></table></figure>
<ul>
<li><code>:samecase</code>, <code>:samespace</code> 和 <code>:same mark</code>  修饰符(还有它们的便捷形式) 只允许出现在替换结构上 (<code>s///</code> 和 <code>s[] = ...</code>).</li>
<li><code>:overlap</code> 和 <code>:exhaustive</code>修饰符(还有它们的便捷形式) 只允许出现匹配结构上(i.e. <code>m//</code>), 不会出现在替换或 regex qoutes 结构上.</li>
<li><code>:pos</code>, <code>:continue</code>, <code>:x</code> 和 <code>:nth</code>  修饰符和它们的别名只允许作用在引用即时调用的结构上. (eg. <code>m//</code> 和<code>s///</code> (but not on <code>rx//</code>).</li>
<li><code>:dba</code> 副词只在  regex 内部被允许.</li>
</ul>
<h1 id="改变了的元字符"><a href="#改变了的元字符" class="headerlink" title="改变了的元字符"></a>改变了的元字符</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/changed.t#L6-L38" target="_blank" rel="external"><code>S05-metasyntax/changed.t lines 6–38</code></a></p>
<ul>
<li><code>.</code> 现在匹配任意字符,包括换行符. (<code>/s</code> 修饰符被废弃了).</li>
<li><code>^</code> 和 <code>$</code> 现在总是匹配字符串的开始/末尾, 就像旧的  <code>\A</code> 和  <code>\z</code>. (<code>/m</code> 修饰符被废弃了.)  On the right side of an embedded在内含的  <code>~~</code>或 <code>!~~</code>  操作符的右侧, <code>^</code> 和 <code>$</code>  总是匹配指定 submatch  的开头/结尾, 因为那个 submatch  在逻辑上被看作为单独的字符串.</li>
<li><code>$</code>不再匹配一个可选的前置 <code>\n</code>, 所以你还是想要的话, 使用 <code>\n?$</code> 代替.</li>
<li><code>\n</code> 现在匹配一个逻辑(跟平台有关)换行符, 不仅仅是 <code>\x0a</code>.</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metachars/newline.t#L13-L37" target="_blank" rel="external"><code>S05-metachars/newline.t lines 13–37</code></a></p>
<ul>
<li><code>\A</code>, <code>\Z</code>, 和 <code>\z</code> 元字符被废弃了.</li>
</ul>
<h1 id="新的元字符"><a href="#新的元字符" class="headerlink" title="新的元字符"></a>新的元字符</h1><ul>
<li><p>因为 <code>/x</code> 是默认的:</p>
<ul>
<li>不加引号的 <code>#</code> 现在总是引入一个注释.  如果它后面跟着一个反引号和一个开放的括号字符, 它会引入一个以闭括号终止的嵌入式注释. 否则, 注释会以换行终止.</li>
<li>空白现在总是元语法，即只用于布局，不会再被照字面意义被匹配。（参看上面的描述的<code>:sigspace</code>修饰符）</li>
</ul>
</li>
<li><p><code>^^</code> 和 <code>$$</code> 匹配行的开头和结尾. (<code>/m</code> 修饰符不存在了.) 它俩都是零宽断言.  <code>$$</code> 匹配任何 <code>\n</code> (逻辑换行) 之前的位置, 如果最后一个字符不是 <code>\n</code> , 那它也匹配字符串的末尾.  <code>^^</code> 总是匹配字符串的开头,  还匹配字符串中任何不是最后一个字符的 <code>\n</code> 的后面</p>
</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metachars/line-anchors.t#L15-L43" target="_blank" rel="external"><code>S05-metachars/line-anchors.t lines 15–43</code></a></p>
<ul>
<li><p><code>.</code> 匹配任何东西, 而 <code>\N</code> 任何除 <code>\n</code> 之外的东西 (<code>/s</code> 修饰符不存在了.) 特别地, <code>\N</code>  既不匹配回车, 也不匹配换行.</p>
<ul>
<li>新的  <code>&amp;</code> 元字符分割连结项.   模式两边必须以同一个开始点和结束点匹配. 注意, 如果你不想两个项以同一个点结尾, 那么你真正需要的是使用向前查看代替.</li>
</ul>
</li>
</ul>
<p>就像<code>或</code>有 <code>|</code> 和 <code>||</code> 一样, <code>与</code>也有 <code>&amp;</code> 和 <code>&amp;&amp;</code> 两种形式.  <code>&amp;</code> 形式的与被认为是描述性的而不是程序性的; 它允许编译器 和/或 运行时系统决定首先计算哪一部分, 一贯的任何顺序都可能发生的假设是错误的. <code>&amp;&amp;</code> 保证了从左到右的顺序, 并且回溯使右侧的参数比左侧的参数变化得更快. 换句话说,  <code>&amp;&amp;</code> 和 <code>||</code> 建立了一连串的点. 左侧可以在回溯允许的时候作为整体回溯到结构中.</p>
<p>  <a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/sequential-alternation.t#L5-L21" target="_blank" rel="external"><code>S05-metasyntax/sequential-alternation.t lines 5–21</code></a></p>
<p>​<code>&amp;&amp;</code>and <code>||</code>. <code>&amp;</code> 像 <code>|</code> 那样是列表结合性的, 但是有高一点的优先级. 同样地, <code>&amp;&amp;</code> 的优先级比 <code>||</code> 的优先级高一点. 就像普通的连接和短路操作符一样, <code>&amp;</code> 和 <code>|</code> 的结合性比 <code>&amp;&amp;</code> 和 <code>||</code> 更紧.</p>
<ul>
<li><code>~~</code> 和 <code>!~~</code> 操作符让在左侧的变量或原子所匹配到的东西身上执行 submatch。所以, 例如, 你可以匹配任何不包含单词”moose”的标识符:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ident&gt; !~~ &apos;moose&apos;</div></pre></td></tr></table></figure>
<p>In contrast</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ident&gt; !~~ ^ &apos;moose&apos; $</div></pre></td></tr></table></figure>
<p>会包含任意标识符 (包括任何含有 “moose” 作为子字符串的标识符)只要该标识符作为一个整体不等于 “moose”。 (注意锚点, 它把子匹配锚定到标识符的开头和结尾, 就像它们是整个匹配一样。) 当用作更长匹配的一部分时, 为了清晰, 使用额外的方括号可能更好:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ &lt;ident&gt; !~~ ^ &apos;moose&apos; $ ]</div></pre></td></tr></table></figure>
<p><em>~~</em> 和 <code>!~~</code> 的优先级位于逻辑操作符的 <code>|</code> 和 <code>||</code> 之间, 就像在普通的 Perl 表达式中那样。 (查看 S03). 因此:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ident&gt; !~~ &apos;moose&apos; | &apos;squirrel&apos;</div></pre></td></tr></table></figure>
<p>解析为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ident&gt; !~~ [ &apos;moose&apos; | &apos;squirrel&apos; ]</div></pre></td></tr></table></figure>
<p>而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ident&gt; !~~ &apos;moose&apos; || &apos;squirrel&apos;</div></pre></td></tr></table></figure>
<p>解析为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ &lt;ident&gt; !~~ &apos;moose&apos; ] || &apos;squirrel&apos;</div></pre></td></tr></table></figure>
<ul>
<li><code>~</code> 操作符是一个用于匹配嵌套的带有特定终止符作为目标的 subrules 的助手。 它被设计为放置在开括号和闭括号之间, 就像这样:<br><a href="https://github.com/perl6/roast/blob/master/S05-metachars/tilde.t#L6-L81" target="_blank" rel="external"><code>S05-metachars/tilde.t lines 6–81</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;(&apos; ~ &apos;)&apos; &lt;expression&gt;</div></pre></td></tr></table></figure>
<p>然而, 它通常忽略左边的参数, 并在接下来的那两个原子身上进行操作(原子也可以被量词化)。它对后续的那两个原子的操作就是旋动它们以使它们以反转的顺序匹配。因此上面的表达式, 乍一看, 只是下面这种形式的简写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;(&apos; &lt;expression&gt; &apos;)&apos;</div></pre></td></tr></table></figure>
<p>  But beyond that, when it rewrites the atoms it also inserts the apparatus that will set up the inner expression to recognize the terminator, and to produce an appropriate error message if the inner expression does not terminate on the required closing atom. So it really does pay attention to the left bracket as well, and it actually rewrites our example to something more like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&lt;OPEN&gt; = &apos;(&apos; &lt;SETGOAL: &apos;)&apos;&gt; &lt;expression&gt; [ $GOAL || &lt;FAILGOAL&gt; ]</div></pre></td></tr></table></figure>
<p>注意,  即使在没有开括号时, 你也可以使用这种结构来设置期望一个闭合结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;?&gt; ~ &apos;)&apos; \d+</div></pre></td></tr></table></figure>
<p>这儿的  <code>&lt;?&gt;</code> 在第一个 null 字符串上返回 true。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $a = &apos;12)34)&apos;;</div><div class="line">$a~~ m:g/ &lt;?&gt; ~ &apos;)&apos; \d+ /;</div><div class="line">say $/.Str;  # 12) 34)</div></pre></td></tr></table></figure>
<p>  ​</p>
<p>By default the error message uses the name of the current rule as an indicator of the abstract goal of the parser at that point. However, often this is not terribly informative, especially when rules are named according to an internal scheme that will not make sense to the user. The <code>:dba(&quot;doing business as&quot;)</code> adverb may be used to set up a more informative name for what the following code is trying to parse:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">token postfix:sym&lt;[ ]&gt; &#123;</div><div class="line">    :dba(&apos;array subscript&apos;)</div><div class="line">    &apos;[&apos; ~ &apos;]&apos; &lt;expression&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么得到的不是诸如这样的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unable to parse expression in postfix:sym&lt;[ ]&gt;; couldn&apos;t find final &apos;]&apos;</div></pre></td></tr></table></figure>
<p>你会得到像下面这样的消息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unable to parse expression in array subscript; couldn&apos;t find final &apos;]&apos;</div></pre></td></tr></table></figure>
<p>(<code>:dba</code> 副词也能用于轮试和候选分支起名字, 这帮助词法分析器给出更好的错误消息。)<br>  ​</p>
<h1 id="括号合理化"><a href="#括号合理化" class="headerlink" title="括号合理化"></a>括号合理化</h1><ul>
<li><p><code>(...)</code> 仍然界定一个捕获组. 然而, 这些捕获组的顺序是分等级的, 而不是线性的. 查看 “Nested subpattern captures”.</p>
</li>
<li><p><code>[...]</code> 不再表示字符类. 它现在界定一个<code>非捕获组</code>.</p>
</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-match/non-capturing.t#L11-L39" target="_blank" rel="external"><code>S05-match/non-capturing.t lines 11–39</code></a></p>
<p>字符类现在使用 <code>&lt;[...]&gt;</code> 指定. 查看 “Extensible metasyntax (&lt;…&gt;)”.</p>
<ul>
<li><code>{...}</code> 不再是重复量词. 它现在界定一个嵌入的<code>闭包</code>. 它总是被认为是过程式的而非声明性的;  它在之前和之后之间建立了一系列的点. (为了避免这个, 使用 <code>&lt;?{…}&gt;</code> 断言语法代替. ). regex 中的闭包建立了它自己的词法作用域<br><a href="https://github.com/perl6/roast/blob/master/S05-metachars/closure.t#L15-L53" target="_blank" rel="external"><code>S05-metachars/closure.t lines 15–53</code></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">my $x = 3;</div><div class="line">my $y = 2;</div><div class="line">&apos;a&apos; ~~ /. &#123; $y = $x; 0 &#125;/;  # can match and execute a closure&apos;</div><div class="line">say $y;                     # 3, &apos;could access and update outer lexicals&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>测试中的 <code>#?rakudo skip &#39;assignment to match variables (dubious) RT #124946&#39;</code> 表示跳过该测试, 功能尚未实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $caught = &quot;oops!&quot;;</div><div class="line">&quot;abc&quot; ~~ m/a(bc)&#123;$caught = $0&#125;/;  # Outer match</div><div class="line">say $caught;                      # bc, Outer caught</div></pre></td></tr></table></figure>
<ul>
<li><p>你可以使用闭包调用 Perl 代码作为正则表达式匹配的一部分. 嵌入的代码不经常影响匹配 – 它只用作副作用(比如保存捕获的值):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/ (\S+) &#123; print &quot;string not blank\n&quot;; $text = $0; &#125;</div><div class="line">  \s+   &#123; print &quot;but does contain whitespace\n&quot;   &#125;</div><div class="line">/</div></pre></td></tr></table></figure>
<p>​<br>在匹配过程中使用 <code>{...}</code> 闭包的一个例子就是 <code>make</code> 函数。<br>一个使用 make 函数的显式换算生成了这个匹配(match)的抽象语法树(简写成抽象对象或 ast):</p>
</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-grammar/action-stubs.t#L37-L182" target="_blank" rel="external"><code>S05-grammar/action-stubs.t lines 37–182</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-match/make.t#L7-L8" target="_blank" rel="external"><code>S05-match/make.t lines 7–8</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ (\d) &#123; make $0.sqrt &#125; Remainder /;</div></pre></td></tr></table></figure>
<p>  ​<br>这捕获了数字化字符串的平方根, 而不是字符串的平方根。   如果前面的 <code>\d</code> 匹配成功, 那么 <code>Remainder</code>(剩余的) 部分继续被匹配并作为 <code>Match</code> 对象的一部分返回, 但是没有作为<code>抽象对象</code>的一部分返回。因为抽象对象通常代表抽象语法树的顶层节点, 所以抽象对象可以通过使用 <code>.made</code> 方法从 <code>Match</code> 对象中提取出来。</p>
<p>  This has the effect of capturing the square root of the numified string, instead of the string. The <code>Remainder</code>part is matched and returned as part of the <code>Match</code> object but is not returned as part of the abstract object. Since the abstract object usually represents the top node of an abstract syntax tree, the abstract object may be extracted from the <code>Match</code> object by use of the <code>.made</code> method.<br>  ​<br><code>make</code> 的二次调用会重写之前的 <code>make</code> 调用。 每个匹配对象上都可以有 <code>make</code>方法。</p>
<p>  A second call to <code>make</code> overrides any previous call to <code>make</code>. <code>make</code> is also available as a method on each match object.<br>  ​<br>在闭包里面, 搜索的实时位置是由  <code>$¢.pos</code> 方法指示的。就像所有的字符串位置一样, 你不能把它当作一个数字除非你很清楚你正处理的单元是哪一个。<br>  Within a closure, the instantaneous position within the search is denoted by the <code>$¢.pos</code> method. As with all string positions, you must not treat it as a number unless you are very careful about which units you are dealing with.</p>
<p><code>Cursor</code>  对象也能返回我们匹配的原始项; 这能从 <code>.orig</code> 方法中得到。<br>  ​<br>  The <code>Cursor</code> object can also return the original item that we are matching against; this is available from the <code>.orig</code> method.</p>
<p>  到目前为止闭包也保证了开启一个 <code>$/</code> Match 对象代表了匹配到的东西。 然而, 如果闭包自身内部做了匹配, 那么它的 <code>$/</code> 变量会被绑定到那个匹配的结果上直到嵌入闭包的结束。在闭包的后面, 匹配实际会使用 <code>$¢</code> 的当前值继续。 在你的闭包中 <code>$/</code> 和 <code>$¢</code> 是一样的。</p>
<ul>
<li>闭包能影响匹配如果它调用了 <code>fail</code>:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ (\d+) &#123; $0 &lt; 256 or fail &#125; /</div></pre></td></tr></table></figure>
<p>因为闭包建立了一个序列点,  它们保证会在规定的时间被调用即使优化器能证明它们后面的某些东西不能匹配。(任何之前的都是公平游戏。 特别地, 闭包常常用作最长 token 模式的终结者。)​</p>
<ul>
<li>普通的重复分类符现在是 <code>**</code>, 用于贪婪匹配,  使用对应的 <code>**?</code> 用于非贪婪匹配.(所有这样的量词修饰符现在直接跟在 <code>**</code> 后面).整个量词的两边都允许有空格, 但是只有 <code>**</code> 前面的空格在 <code>:sigspace</code> 下和重复之间的匹配被认为是有意义的.</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/repeat.t#L19-L88" target="_blank" rel="external"><code>S05-metasyntax/repeat.t lines 19–88</code></a></p>
<p>下一个 token 限制了左边的 pattern 必须被匹配多少次。 如果下一个东西是整数, 那么它会被解析为一个精确的计数或一个范围:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">. ** 42                  # match exactly 42 times</div><div class="line">&lt;item&gt; ** 3..*           # match 3 or more times</div></pre></td></tr></table></figure>
<p>这种形式被认为是陈述性的。</p>
<p>如果你提供一个闭包, 它应该返回一个 Int 或 Range 对象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;x&apos; ** &#123;$m&#125;              # 从闭包中返回精确计数</div><div class="line">&lt;foo&gt; ** &#123;$m..$n&#125;        # 从闭包中返回范围</div><div class="line"> / value was (\d **? &#123;1..6&#125;) with ([ &lt;alpha&gt;\w* ]**&#123;$m..$n&#125;) /</div></pre></td></tr></table></figure>
<p>从闭包返回一个列表是非法的, 所以这种简单的错误会导致失败:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ [foo] ** &#123;1,3&#125; /</div></pre></td></tr></table></figure>
<p>这种形式的闭包总被看作是​过程式的, 所以它所修饰的项绝不会被当作是最长 token 的一部分。<br>  ​<br>为了和之前的 Perl 6 版本保持向后兼容, 如果一个 token 后面跟着的既不是闭包也不是整数字面值, 那么它会被解释为 <code>+%</code>, 并带有一个警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/ x ** y /                # same as / x+ % y /</div><div class="line">/ x ** $y /               # same as / x [$y x]* /</div></pre></td></tr></table></figure>
<p>这并不会检查 $y 是否包含一个整数或范围值。这个兼容功能也不能保证会永远存在。<br>  ​</p>
<ul>
<li>负数范围值也是允许的, 但是只有当模式是可逆的时候(例如 after 能匹配的). 例如, 搜索元素周围 200 个定义为点的字符, 可以写为:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ . ** -100..100 &lt;element&gt; /</div></pre></td></tr></table></figure>
<p>类似地, 你可以后退 50 个字符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ . ** -50 &lt;element&gt; /</div></pre></td></tr></table></figure>
<ul>
<li>任何量词化的原子都能通过添加一个额外的约束, 来指定重复左侧的两个原子之间的分隔符.  在量词和分割符之间添加一个 <code>%</code>号. 只要两个 item 之间有分隔符就重复初始的 item:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;alt&gt;+    % &apos;|&apos;            # repetition controlled by presence of character</div><div class="line">&lt;addend&gt;+ % &lt;addop&gt;        # repetition controlled by presence of subrule</div><div class="line">&lt;item&gt;+   % [ \!?&apos;==&apos; ]    # repetition controlled by presence of operator</div><div class="line">&lt;file&gt;+   % \h+            # repetition controlled by presence of whitespace</div></pre></td></tr></table></figure>
<p>任何量词都可以这样修改:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;a&gt;* % &apos;,&apos;              # 0 or more comma-separated elements</div><div class="line">&lt;a&gt;+ % &apos;,&apos;              # 1 or more</div><div class="line">&lt;a&gt;? % &apos;,&apos;              # 0 or 1 (but &apos;,&apos; never used!?!)</div><div class="line">&lt;a&gt; ** 2..* % &apos;,&apos;       # 2 or more</div></pre></td></tr></table></figure>
<p><code>%</code> 修饰符只能用在量词上;  把 <code>%</code> 用在裸 item 上的任何尝试都会导致解析失败.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;ident&gt;+ % &apos;,&apos; /</div></pre></td></tr></table></figure>
<p>能匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo</div><div class="line">foo,bar</div><div class="line">foo,bar,baz</div></pre></td></tr></table></figure>
<p>但是不会匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo,</div><div class="line">foo,bar,</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;&apos; ~~ / &lt;ident&gt;* % &apos;,&apos; /  # matches because of the *</div></pre></td></tr></table></figure>
<p>使用 <code>%%</code> 能匹配末尾的分隔符. 因此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;ident&gt;+ %% &apos;,&apos; /</div></pre></td></tr></table></figure>
<p>能匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">foo</div><div class="line">foo,</div><div class="line">foo,bar</div><div class="line">foo,bar,</div><div class="line">foo,bar,baz</div><div class="line">foo,bar,baz,</div></pre></td></tr></table></figure>
<p>If you wish to quantify each match on the left individually, you must place it in brackets:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&lt;a&gt;*]+ % &apos;,&apos;</div></pre></td></tr></table></figure>
<p>零宽的分隔符也是合法的, 只要左侧的模式每次能够重复:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.+ % &lt;?same&gt;   # 匹配同一字符的序列</div></pre></td></tr></table></figure>
<p>The separator never matches independently of the next item; if the separator matches but the next item fails, it backtracks all the way back through the separator. Likewise, this matching of the separator does not count as “progress” under <code>:ratchet</code> semantics unless the next item succeeds.</p>
<p>When significant space is used under <code>:sigspace</code>, each matching element enables the immediately following whitespace to be considered significant. Space after the <code>%</code> does nothing. 当在 <code>:sigspace</code> 下使用了有意义的空格, 每个匹配元素使后面跟着的空格变得有意义. % 后面的空格什么也不做. 如果你这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ms/ &lt;element&gt; +  %  &apos;,&apos; /</div><div class="line">  #1        #2 #3 #4  #5</div></pre></td></tr></table></figure>
<p>它会忽略 <code>#1</code> 和 <code>#4</code> 位置的空白, 并把剩下的重写为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/ [ &lt;element&gt; &lt;.ws&gt; ]+ % [ &apos;,&apos; &lt;.ws&gt; ] &lt;.ws&gt; /</div><div class="line">                #2               #5      #3</div></pre></td></tr></table></figure>
<p>因为 <code>#3</code> 对于 <code>#2</code> 来说是多余的(因为 <code>+</code> 要求一个元素), <code>#2</code> 或 <code>#3</code> 都可以满足:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ms/ &lt;element&gt;+ % &apos;,&apos; /    # ws after comma and at end</div><div class="line">ms/ &lt;element&gt; +% &apos;,&apos; /    # ws after comma and any element</div></pre></td></tr></table></figure>
<p>所以第一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ms/ &lt;element&gt;+ % &apos;,&apos; /    # ws after comma and at end</div></pre></td></tr></table></figure>
<p>就像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;element&gt;[&apos;,&apos;&lt;.ws&gt;&lt;element&gt;]*&lt;.ws&gt; /</div></pre></td></tr></table></figure>
<p>而第二个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ms/ &lt;element&gt; +% &apos;,&apos; /    # ws after comma and any element</div></pre></td></tr></table></figure>
<p>就像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;element&gt;&lt;.ws&gt;[&apos;,&apos;&lt;.ws&gt;&lt;element&gt;&lt;.ws&gt;]* /</div></pre></td></tr></table></figure>
<p>并且</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ms/ &lt;element&gt;+% &apos;,&apos;/</div></pre></td></tr></table></figure>
<p>排除了所有有意义的空格,就像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;element&gt;[&apos;,&apos;&lt;element&gt;]* /</div></pre></td></tr></table></figure>
<p>  ​<br>注意, 使用 <code>*</code> 而非 <code>+</code>, 空格 <code>#3</code> 对于 <code>#2</code> 来说并不是多余的, 因为如果匹配了 0 个元素, 那么跟它有关的(#2) 空格就不会匹配。 那种情况下, 在 <code>*</code> 两边都放上空格是有意义的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ms/ &lt;element&gt; * % &apos;,&apos; /</div></pre></td></tr></table></figure>
<ul>
<li><code>&lt;...&gt;</code> 现在是可扩展的元语法分隔符或<em>断言</em>(例如, 它们代替 Perl‘5 的<code>(?...)</code> 语法)。</li>
</ul>
<h1 id="变量-non-插值"><a href="#变量-non-插值" class="headerlink" title="变量(non-)插值"></a>变量(non-)插值</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-interpolation/regex-in-variable.t#L13-L81" target="_blank" rel="external"><code>S05-interpolation/regex-in-variable.t lines 13–81</code></a></p>
<ul>
<li><p>在 Perl 6 的 regexes 中, 变量不会进行插值. </p>
</li>
<li><p>相反, 它们被原原本本地传递给正则引擎, 然后正则引擎决定怎样处理它们.</p>
</li>
<li><p>在正则引擎中处理字符串标量的默认方式是把它作为 <code>&quot;...&quot;</code> 字面量匹配 (i.e. 它不会把插值字符串作为 subpattern). 换句话说, 一个 Perl 6 的:<br><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/litvar.t#L17-L39" target="_blank" rel="external"><code>S05-metasyntax/litvar.t lines 17–39</code></a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ $var /</div></pre></td></tr></table></figure>
<p>就像 Perl 5 的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ \Q$var\E /</div></pre></td></tr></table></figure>
<p>为了插值一个 Regex 对象, 使用  <code>&lt;$var&gt;</code> 代替. 如果 <code>$var</code> 未定义, 会出现一个警告并匹配失败.` </p>
<p><a href="https://github.com/perl6/roast/blob/master/S05-interpolation/regex-in-variable.t#L85-L119" target="_blank" rel="external"><code>S05-interpolation/regex-in-variable.t lines 85–119</code></a></p>
<p>当匹配一个不是 Str 类型的字符串化的类型时, 那个变量必须被作为那个字符串化类型的值被插值(或者是能强制转换成那个类型的相关类型) 例如: 当 regex 匹配一个 Buf 类型时, 变量将会在 Buf 类型的语义下被匹配, 而非 Str 语义.</p>
<p>[猜想: 当我们允许匹配非字符串类型时, 在当前节点上做类型匹配会要求一个内含的签名的语法,  不仅仅是一个裸的变量, 所以没有必要对包含一个类型对象的变量作出解释, 它明显是未定义的, 因此对上面的 rule 会匹配失败]</p>
<p>然而,  一个在等号左边用作别名的变量或 submatch 操作符是不用于匹配的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$x = &lt;.ident&gt;</div><div class="line">$0 ~~ &lt;.ident&gt;</div></pre></td></tr></table></figure>
<p>如果你想再次匹配 <code>$0</code> 然后把它用作 submatch, 你可以强制这个匹配使用双引号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;$0&quot; ~~ &lt;.ident&gt;</div></pre></td></tr></table></figure>
<p>另一方面,  如果别名不是一个变量的话就没有意义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;$0&quot; = &lt;.ident&gt;     # ERROR</div><div class="line">$0 = &lt;.ident&gt;       # okay</div><div class="line">$x = &lt;.ident&gt;       # okay, 临时捕获</div><div class="line">$&lt;x&gt; = &lt;.ident&gt;     # okay, 持久捕获</div><div class="line">&lt;x=.ident&gt;          # 同上</div></pre></td></tr></table></figure>
<p>在捕获别名中声明的变量的作用域是词法作用域,一直到 regex 的剩余部分. 你不能把这种 = 号的用法和普通赋值或普通绑定操作混淆。 你更应该把这种 = 号读作声明符的伪赋值, 而非普通赋值。 它更像普通的 <code>:=</code> 操作符, 因为在 regexes 的工作级别, 字符串是不可变的, 所以捕获正是预先计算好的 substr 值.  尽管如此, 当你最终独立地使用这些值时, 那个 substr 就会被复制, 然后它就更像原来的赋值操作.</p>
<p><code>$&lt;ident&gt;</code> 形式的捕获变量能在词法作用域之外持久; 如果匹配成功的话, 它们会被记忆在 Match 对象的散列中, 散列的键对应于变量名的标识符. 同样地, 绑定的数字变量保存在 <code>$0</code> 那样的变量中, 等等.</p>
<p> 你可以把捕获保存到已经存在的词法变量中; 这样的变量可能已经能从外部的作用域中可见, 或者可能在 regex 中通过一个 <code>:my</code> 声明符来声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $x; / $x = [...] /            # capture to outer lexical $x</div><div class="line">/ :my $x; $x = [...] /           # capture to our own lexical $x</div></pre></td></tr></table></figure>
<ul>
<li>一个插值的数组:<br><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/litvar.t#L40-L102" target="_blank" rel="external"><code>S05-metasyntax/litvar.t lines 40–102</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/sequential-alternation.t#L22-L39" target="_blank" rel="external"><code>S05-metasyntax/sequential-alternation.t lines 22–39</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ @cmds /</div></pre></td></tr></table></figure>
<p>被匹配为好像它是它的字面元素的一个备选分支. 通常地, 它使用 junctive 语义来匹配:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ [ $(@cmds[0]) | $(@cmds[1]) | $(@cmds[2]) | ... ] /</div></pre></td></tr></table></figure>
<p>然而, 如果它是 <code>||</code> 列表中的一个直接成员, 它会使用相继的匹配语义, 即使它是列表中的唯一成员. 方便地, 你可以把 <code>||</code> 放在备选分支的第一个成员之前, 因此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ || @cmds /</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ [ $(@cmds[0]) || $(@cmds[1]) || $(@cmds[2]) || ... ] /</div></pre></td></tr></table></figure>
<p>当然, 你也可以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ | @cmds /</div></pre></td></tr></table></figure>
<p>需要明确的是, 你想要 junctive 语义.</p>
<p>注意, <code>$(...)</code> 的用法是为了阻止下标被解析为 regex 语法而非真正的下标.</p>
<p>因为 <code>$x</code> 被插值为好像你说了 <code>&quot;$x&quot;</code> 一样, 如果 $x 包含了一个列表, 它会先被字符串化. 为了获取备选分支, 你必须使用 <code>@$x</code> 或  <code>@($x)</code> 形式来标示你想要把那个标量变量当作一个列表。</p>
<p>只有当它在regex被编译时为常量所熟知, 一个使用 junctive 语义的插值数组才是陈述性的(参与外部的最长token匹配)。</p>
<p>像标量变量那样, 每个元素被作为字面量匹配. 所有这样的值负责当前的 <code>:ignorecase</code> 和 <code>:ignoremark</code> 设置.</p>
<p>当你写烦了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">token sigil &#123; &apos;$&apos; | &apos;@&apos; | &apos;%&apos; | &apos;&amp;&apos; | &apos;::&apos; &#125;</div></pre></td></tr></table></figure>
<p>你可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">token sigil &#123; &lt; $ @ % &amp; :: &gt; &#125;</div></pre></td></tr></table></figure>
<p>只要你细心地在起始的尖括号后面放上一个空格, 以至于它不会被解释为 subrule. 有了空格, 它会像普通 Perl 6 中的尖括号引号那样被解析, 并被当作一个字面数组值。</p>
<ul>
<li>要不, 如果你预先声明一个 proto regex, 你可以给同一个类别写多个正则表达式, 区别仅仅在于它们所匹配的符号. 符号被指定为”长名字” 的一部分. 也可以在 rule 中使用 <code>&lt;sym&gt;</code> 进行匹配, 就像这样:<br><a href="https://github.com/perl6/roast/blob/master/S05-grammar/protos.t#L7-L31" target="_blank" rel="external"><code>S05-grammar/protos.t lines 7–31</code></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">proto token sigil &#123;*&#125;</div><div class="line">multi token sigil:sym&lt;$&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">multi token sigil:sym&lt;@&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">multi token sigil:sym&lt;%&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">multi token sigil:sym&lt;&amp;&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">multi token sigil:sym&lt;::&gt; &#123; &lt;sym&gt; &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>(multi 是可选的, 并且通常在 grammar 中被省略)</p>
<p>这可以被看作多重分发的一种形式, 除了它是基于最长 token 匹配而非签名匹配之外。 这种写法的好处就是在一个派生的 grammar 中, 给同一个类别添加额外的 rules 很容易.  当你尝试匹配 <code>/&lt;sigil&gt;/</code> 时, 它们中的所有 rules 都会被并行地匹配.<br>  ​<br>如果 multi regex 方法中有形参, 仍然首先通过最长 token 继续匹配。如果那导致了绑定, 使用剩下的变体的参数来产生一个普通的多重分发, 假设它们能通过类型进行区分的话。</p>
<p>当 <code>proto</code> 看见一个不为量词的 <code>*</code> 并且在包含 <em> 号的 block 中只有这个`</em><code>时,</code>proto<code>就会进入 subdispatcher 调用。因此, 通过把这个</code>*` 号放进花括号中, 你就能在这个 subdispatcher 的前面和后面放上 items 了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proto token foo &#123; &lt;prestuff&gt; &#123;*&#125; &lt;poststuff&gt; &#125;</div></pre></td></tr></table></figure>
<p>  ​<br>这只在 proto 中有效。查看 <a href="http://design.perl6.org/S06.html" target="_blank" rel="external">S06</a> 关于 <code>{*}</code> 语法的讨论。(不像 proto sub 那样, proto regex 会自动记忆从 <code>{*}</code> 中返回的值, 因为它们伴随着匹配光标)。</p>
<ul>
<li>模式中散列变量的用法被保留了.</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-interpolation/regex-in-variable.t#L82-L84" target="_blank" rel="external"><code>S05-interpolation/regex-in-variable.t lines 82–84</code></a></p>
<ul>
<li>只有当变量代表一个常量时, 变量的匹配才被认为是声明性的，否则它们是程序性的。注意，role 参数（如果ReadOnly）被认为是用于此目的的常量声明,尽管没有显式的 <code>constant</code> 声明符 , 因为 roles 本身是不变的，当组合的时候,可能会使用一个常量值来替换那个参数（如果传递的值是一个常量）。使用常量的宏也会使那些常量在声明时更适合。</li>
</ul>
<h1 id="可扩展的-lt-gt-元语法"><a href="#可扩展的-lt-gt-元语法" class="headerlink" title="可扩展的 &lt;...&gt; 元语法"></a>可扩展的 <code>&lt;...&gt;</code> 元语法</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/angle-brackets.t#L16-L139" target="_blank" rel="external"><code>S05-metasyntax/angle-brackets.t lines 16–139</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-mass/recursive.t#L14-L48" target="_blank" rel="external"><code>S05-mass/recursive.t lines 14–48</code></a></p>
<p><code>&lt;</code> 和 <code>&gt;</code> 都是元字符, 并且经常(但不总是) 用于 matched pairs. (有些元字符函数组合成独立的 tokens, 并且这些可能包含尖括号). 对于 matched pairs, <code>&lt;</code> 后面的<strong>第一个字符</strong>决定了断言的性质:</p>
<ul>
<li>如果 <code>&lt;</code> 后面的第一个字符是<code>空格</code>, 尖括号会被看作普通的引号单词数组字面量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt; adam &amp; eve &gt;   # 等价于 [ &apos;adam&apos; | &apos;&amp;&apos; | &apos;eve&apos; ]</div></pre></td></tr></table></figure>
<p>注意末尾的 <code>&gt;</code> 之前的空格是可选的, 因此, <code>&lt; adam &amp; eve&gt;</code> 也可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;even&quot; ~~ /&lt; odd &amp; eve &gt;/</div><div class="line">&quot;even&quot; ~~ /&lt; adam &amp; eve&gt; &#123;say ~$/&#125;/ # eve</div></pre></td></tr></table></figure>
<ul>
<li><code>&lt;</code> 后面的第一个字符如果是字母, 那么它就是一个符合语法规范的捕获断言(例如: subrule 或字符类 - 看下面):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;sign&gt;? &lt;mantissa&gt; &lt;exponent&gt;? /</div></pre></td></tr></table></figure>
<p>标识符(例如下面的 foo)后面的第一个字符决定了闭合尖括号之前剩余文本的处理。它的底层语义是<strong>函数</strong>或<strong>方法调用</strong>, 所以, 如果标识符后面的第一个字符是<em>左圆括号</em>, 那么它要么是方法调用, 要么是函数调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo(&apos;bar&apos;)&gt;</div></pre></td></tr></table></figure>
<p>如果标识符后面的第一个字符是 <code>=</code>, 那么该标识符就是等号后面跟着的另一个<strong>标识符的别名</strong>。 特别地,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo=bar&gt;</div></pre></td></tr></table></figure>
<p>是下面这种形式的简写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&lt;foo&gt; = &lt;bar&gt;</div></pre></td></tr></table></figure>
<p>注意这种别名不会修改原来的 <code>&lt;bar&gt;</code> 捕获. 要重命名一个继承而来的方法而不使用它原来的名字,  就在你想要抑制的捕获名前面加上一个点, 即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo=.bar&gt;</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&lt;foo&gt; = &lt;.bar&gt;</div></pre></td></tr></table></figure>
<p>同样地, 要显式的重命名一个本地作用域的 regex, 就在 <code>=</code> 号后面的标识符前面添加一个 <code>&amp;</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo=&amp;bar&gt;</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&lt;foo&gt; = &lt;&amp;bar&gt;</div></pre></td></tr></table></figure>
<p>多个别名也是允许的, 所以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo=pub=bar&gt;</div></pre></td></tr></table></figure>
<p>是下面这种形式的简写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&lt;foo&gt; = $&lt;pub&gt; = &lt;bar&gt;</div></pre></td></tr></table></figure>
<p>类似地, 你也能给其它断言起别名, 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;foo=[abc]&gt;    # 字符类, 等同于      $&lt;foo&gt;=&lt;[abc]&gt;</div><div class="line">&lt;foo=:Letter&gt;  # unicode 属性,等同于 $&lt;foo&gt;=&lt;:Letter&gt;</div><div class="line">&lt;foo=:!Letter&gt; # a negated unicode property lookup</div></pre></td></tr></table></figure>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$_ = &quot;aabdc&quot;;</div><div class="line">m/&lt;foo=[abc]&gt;/;</div><div class="line">say ~$&lt;foo&gt;;     # a</div><div class="line">say $&lt;foo&gt;.WHAT; # Match</div><div class="line"></div><div class="line">m/&lt;foo=[abc]&gt;+/;</div><div class="line">say $&lt;foo&gt;.WHAT    # Array</div><div class="line">say $&lt;foo&gt;[0].WHAT # Match</div><div class="line">say ~$&lt;foo&gt;;       # a a b</div></pre></td></tr></table></figure>
<p>如果标识符后面的第一个字符是<strong>空格</strong>, 则随后的文本(跟着任意空格)被解析为 <em>regex</em>, 所以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo bar&gt;</div></pre></td></tr></table></figure>
<p>或多或少,等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo(/bar/)&gt;  # 方法调用</div></pre></td></tr></table></figure>
<p>要传递一个带有前置空格的 regex, 你必须使用加上括弧的形式。</p>
<p>如果标识符后面的第一个字符是一个<code>冒号后再跟着空格</code>, 那么闭合尖括号之前的剩余文本会被当作方法的<strong>参数列表</strong>, 就像普通 Perl 语法中的那样。所以这些意味着相同的东西:  ​</p>
<p><a href="https://github.com/perl6/roast/blob/master/S05-grammar/signatures.t#L7-L24" target="_blank" rel="external">S05-grammar/signatures.t lines 7–24</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;foo(&apos;foo&apos;, $bar, 42)&gt;  # 函数调用, 果然, 标识符后面紧跟着圆括号一般就是函数调用</div><div class="line">&lt;foo: &apos;foo&apos;, $bar, 42&gt;  # 冒号形式的函数调用</div></pre></td></tr></table></figure>
<p>起始标识符的后面不再允许有其它字符。</p>
<p>例如, subrule 匹配在某种程度上是陈述性的, subrule 自身de 前面被认为是陈述性的。如果 subrule 包含了一个序列点, 那么 subrule 匹配也是。Longest-token 匹配不继续通过这样的 subrule。<br>​<br>这种形式总是给词法作用域的正则表达式声明以优先, 直接分派它, 就好像它是函数一样。如果作用域中没有这样的词法正则表达式(或词法方法),那么调用会分派给当前 grammar,假设有的话。<br>即, 如果在当前本地作用域有一个可见的 <code>my regex foo</code> 声明, 那么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo(1,2,3)&gt;</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo=&amp;foo(1,2,3)&gt;</div></pre></td></tr></table></figure>
<p>然而, 如果没有这样的词法作用域的 regex (并且注意在 gramamr 中, regexes 被作为方法安装, 默认没有词法别名), 那么该调用被在当前 <code>Cursor</code> 上作为普通方法被分派。(这会失败, 如果当前你不在 grammar 中的话)。 所以在那种情况下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo(1,2,3)&gt;</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;foo=.foo(1,2,3)&gt;</div></pre></td></tr></table></figure>
<p>​<br>如果既没有任何它能调用的那个名字的词法作用域的子例程, 又没有任何以通过方法分发获得的那个名字的方法, 那么调用 <code>&lt;foo&gt;</code> 会失败。(决定使用哪个分派器是在编译时做出的; 方法调用不是回调机制。)<br>​</p>
<ul>
<li>一个前置的 <code>.</code> 显式地把方法作为 subrule 调用; 实际上如果初始的字符不是字母数字的话会引起该具名断言不捕获它匹配到的东西。(查看 “Subrule captures”) 例如:</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/angle-brackets.t#L140-L242" target="_blank" rel="external"><code>S05-metasyntax/angle-brackets.t lines 140–242</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/ &lt;ident&gt;  &lt;ws&gt;  /      # $/&lt;ident&gt; 和 $/&lt;ws&gt; 都被捕获了</div><div class="line">/ &lt;.ident&gt; &lt;ws&gt;  /      # 只有 $/&lt;ws&gt; 被捕获了</div><div class="line">/ &lt;.ident&gt; &lt;.ws&gt; /      # 什么也没有捕获</div></pre></td></tr></table></figure>
<p>该断言然后被恒等地解析为以一个标识符开始的断言，假设点号之后的下一个东西是一个标识符的话。至于标识符的形式，任何跟匹配引擎有关的额外参数都被自动地通过隐式的 <code>Cursor</code> 调用者提供给参数列表。如果没有当前类/grammar， 或者当前类不是派生于 <code>Cursor</code>， 那么该调用很可能会失败。<br>  ​  ​<br>如果点号后面跟着的不是标识符，那么它被解析为某种类型的 “dotty” 后缀，例如一个间接的方法调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;.$indirect(@args)&gt;</div></pre></td></tr></table></figure>
<p>对于所有的正则匹配，当前的匹配状态（某些 <code>Cursor</code> 的衍生物）被作为第一个参数传递，它在这种情况下就是该方法的调用者。这个方法期望返回一个新匹配状态对象的惰性列表，或者返回 <code>Nil</code> 如果匹配彻底失败的话。像棘轮般转动的程序通常会返回一个只含有一个匹配的列表。<br>  ​</p>
<ul>
<li>鉴于一个前置的 <code>.</code> 明确无误地调用一个方法，一个前置的 <code>&amp;</code> 明确无误地调用了子例程代替。这样的一个正则表达式程序必须使用 <code>my</code> 或 <code>our</code> 作用域声明(或导入)以让它的名字在本地作用域中可见，因为默认地正则表达式的名字仅被安装到当前类的元对象实例中，就像普通方法那样。 那个程序充当着一种私有的 submethod，<br>并且调用时不用考虑任何继承。它仍旧必须接收一个 <strong>Cursor</strong> 作为它的第一个参数(它能把它当做一个调用者如果它喜欢的话)，并且必须返回那个新的匹配状态作为游标对象。因此,</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/interpolating-closure.t#L17-L39" target="_blank" rel="external"><code>S05-metasyntax/interpolating-closure.t lines 17–39</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;&amp;foo(1,2,3)&gt;</div></pre></td></tr></table></figure>
<p>对于某些像如下这样的东四是一种语法糖:  is sugar for something like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;.gather &#123; take foo($¢,1,2,3) &#125;&gt;</div></pre></td></tr></table></figure>
<p>其中 <code>$c</code> 代表当前传入的匹配状态，并且程序必须在失败时返回 <code>Nil</code>，如果匹配成功则返回一个含有一个或多个匹配状态(<code>Cursor</code> 驱动的对象)的惰性列表。<br>正如 <code>.</code> 形式一样， 一个显式的 <code>&amp;</code> 抑制了捕获。</p>
<p>注意所有正常的 <code>Regex</code> 对象实际上是伪装成这样的程序。当你说:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rx/stuff/</div></pre></td></tr></table></figure>
<p>你实际上正在声明一个匿名的方法，某些像这样的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $internal = anon regex :: ($¢: ) &#123; stuff &#125;</div></pre></td></tr></table></figure>
<ul>
<li>一个前置的 <code>$</code> 标示着一个间接的 subrule 调用。那个变量要么包含一个 <code>Regex</code> 对象(实际上是一个匿名的方法 – 看上面), 要买包含一个将被编译为正则表达式的字符串。那个字符串绝对不会按照字面值匹配。</li>
</ul>
<p>如果字符串形式的编译失败，那么错误信息会被转换为警告并且那个断言会失败。<br>那个间接的 subrule 断言没有被捕获。（默认地没有带有前置的标点符号的断言会被捕获）当然，你总是可以显式地捕获它:<br>  ​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;name=$rx&gt; /</div></pre></td></tr></table></figure></p>
<p>间接的 subrule 总是被看作是过程式的，并且可能不会参与最长 token 匹配。</p>
<ul>
<li>一个前置的 <code>::</code> 标示着一个符号的间接 subrule:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;::($somename)&gt; /</div></pre></td></tr></table></figure>
<p>  ​<br>那个变量必须包含 subrule 的名字。按照单个方法分发的规则，在当前 grammar 和它的祖先中这被首先搜索。如果这个搜索失败了，那么会尝试通过 MMD 进行分发，在这种情况下，它可以找到定义为 <em>multis</em> 的 subrules 而非 方法。默认地这种形式不会被捕获。它总是被当作是过程式的，不是声明式的。</p>
<ul>
<li>一个前置的 <code>@</code> 像一个裸的数组那样匹配除了每个元素被看做 subrule 之外（字符串或 <code>Regex</code> 对象）而非被当做字面值。即，字符串被强制编译为 subrule 而不是按照字面值匹配。(对于 <code>Regex</code> 对象没有区别。)</li>
</ul>
<p>这个断言不会被自动捕获。<br>​</p>
<ul>
<li>散列作为断言的用法被保留了。</li>
<li>一个前置的 <code>{</code> 标示在那个位置上产生要被插值到模式中作为 subrule 的 regex 的代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ (&lt;.ident&gt;)  &lt;&#123; %cache&#123;$0&#125; //= get_body_for($0) &#125;&gt; /</div></pre></td></tr></table></figure>
<p>​那个闭包确保会在标准时运行；它声明了一个序列点，并且别看作是过程式的。</p>
<ul>
<li><p>在任何正则表达式插值情况下，如果那个值碰巧已经是一个  <code>Regex</code> 对象，那么它不会被编译。如果它是一个字符串，那么带有字符串的编译形式被缓存，以至于下次你使用它的时候它不会重新编译除非字符串发生更改。（然而任何外部词法变量名必须被重新装订。）带有不平衡括号的 Subrules 可能不被插值。插值过的 subrule 把它自己内部的结果保存为单个标量，所以它的括号绝对不会计算到外部的正则表达式分组中。（换句话说，圆括号编号总是本地作用域的。）</p>
</li>
<li><p>在 <code>&lt;...&gt;</code> 中, 一个前置的 <code>?{</code> 或 <code>!{</code> 标示着代码断言:<br><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/assertions.t#L7-L25" target="_blank" rel="external"><code>S05-metasyntax/assertions.t lines 7–25</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/ (\d**1..3) &lt;?&#123; $0 &lt; 256 &#125;&gt; /</div><div class="line">/ (\d**1..3) &lt;!&#123; $0 &lt; 256 &#125;&gt; /</div></pre></td></tr></table></figure>
</li>
</ul>
<p>类似于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/ (\d**1..3) &#123; $0 &lt; 256 or fail &#125; /</div><div class="line">/ (\d**1..3) &#123; $0 &lt; 256 and fail &#125; /</div></pre></td></tr></table></figure></p>
<p>  ​<br>不像闭包那样, 代码断言被认为是陈述性质的;<br>  ​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $str = &quot;foo123bar&quot;;</div><div class="line">$str  ~~ token &#123; foo .* &lt;?&#123; do &#123; say &quot;Got here!&quot; &#125; or 1 &#125;&gt; .* bar &#125; # Got here!</div></pre></td></tr></table></figure></p>
<p><code>do</code> block 不太可能运行,除非字符串以 “bar” 结尾.</p>
<ul>
<li>一个前置的 <code>[</code> 标示着可枚举的字符类. 在枚举字符类中, 范围是由 <code>..</code> 而非 <code>-</code> 来标示的.<br><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/charset.t#L18-L22" target="_blank" rel="external"><code>S05-metasyntax/charset.t lines 18–22</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L248-L262" target="_blank" rel="external"><code>S05-mass/rx.t lines 248–262</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L283-L428" target="_blank" rel="external"><code>S05-mass/rx.t lines 283–428</code></a><br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;[a..z_]&gt;* /</div></pre></td></tr></table></figure>
</li>
</ul>
<p>方括号内的<code>空白</code>被忽略:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/ &lt;[ a .. z _ ]&gt;* /</div><div class="line">/ &lt;[ . _ ]&gt;* /</div></pre></td></tr></table></figure>
<p>反转的范围是非法的. 在直接编译的代码中会报错如果你写成这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;[ z .. a ]&gt; /  # 反转的范围是不允许的</div></pre></td></tr></table></figure>
<p>在间接编译的代码中, 出现类似的问题并使断言失败:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$rx = &apos;&lt;[ z .. a ]&gt;&apos;;</div><div class="line">/ &lt;$rx&gt; /;  # warns and never matches</div></pre></td></tr></table></figure>
<ul>
<li>前置的 <code>-</code> 标示互补字符类:<br><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/charset.t#L23-L27" target="_blank" rel="external"><code>S05-metasyntax/charset.t lines 23–27</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L263-L282" target="_blank" rel="external"><code>S05-mass/rx.t lines 263–282</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/ &lt;-[a..z_]&gt; &lt;-alpha&gt; /</div><div class="line">/ &lt;- [a..z_]&gt; &lt;- alpha&gt; /  #  - 后面允许有空格</div></pre></td></tr></table></figure>
<p>这在本质上与使用 <code>否定向前查看</code> 和 <code>点</code> 是相同的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;![a..z_]&gt; . &lt;!alpha&gt; . / # `!`标示前面不是什么</div></pre></td></tr></table></figure>
<p>初始的 <code>-</code> 之后的空白被忽略.</p>
<ul>
<li>一个前置的 <code>+</code> 也能标示后面的字符类会以肯定的意义匹配:<br><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L511-L2140" target="_blank" rel="external"><code>S05-mass/rx.t lines 511–2140</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/ &lt;+[a..z_]&gt;* /</div><div class="line">/ &lt;+[ a..z _ ]&gt;* /</div><div class="line">/ &lt;+ [ a .. z _ ] &gt;* /      # whitespace allowed after +</div></pre></td></tr></table></figure>
<ul>
<li>在单个尖括号集中, 字符类可以组合(相加或相减). 空白被忽略. 例如:<br><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/charset.t#L28-L96" target="_blank" rel="external"><code>S05-metasyntax/charset.t lines 28–96</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;[a..z] - [aeiou] + xdigit&gt; /      # 辅音或十六进制数</div></pre></td></tr></table></figure>
<p>一个具名的字符类可以使用它自己:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;alpha&gt;</div></pre></td></tr></table></figure>
<p>然而, 为了组合字符类, 必须在<code>具名</code>字符类前面前置一个 <code>+</code> 或 <code>-</code>。在任何 <code>-</code> 可能会被误解析为一个标识符扩展器的前面需要有空格。</p>
<ul>
<li>使用 pair 记法代替一个正常的 rule 的名字来标记 Unicode 属性:</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/unicode-property-pair.t#L6-L21" target="_blank" rel="external"><code>S05-metasyntax/unicode-property-pair.t lines 6–21</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;:Letter&gt;   # a letter</div><div class="line">&lt;:!Letter&gt;  # a non-letter</div></pre></td></tr></table></figure>
<p>带参数的属性作为参数传递给 pair:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;:East_Asian_Width&lt;Narrow&gt;&gt;</div><div class="line">&lt;:!Blk&lt;ASCII&gt;&gt;</div></pre></td></tr></table></figure>
<p>这个 pair 值与 Unicode 数据库中的值相智能匹配。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;:Nv(0 ^..^ 1)&gt;     # Nv 代表数值, 该正则匹配特有分数值的字符</div><div class="line"></div><div class="line">&apos;flubber¼½worms&apos; ~~ /&lt;:NumericValue(0 ^..^ 1)&gt;+/;  # ~$/ =&gt; ¼½</div></pre></td></tr></table></figure>
<p>作为智能匹配的一种特殊情况, TR18 的第 2.6 章节也允许使用模式作为参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;:name(/^LATIN LETTER.*P$/)&gt;</div><div class="line"></div><div class="line">&apos;FooBar&apos; ~~ /&lt;:name(/:s LATIN SMALL LETTER/)&gt;+/;     #  &apos;oo&apos;, &apos;match character names&apos;;</div><div class="line">&apos;FooBar&apos; ~~ /&lt;:Name(/:s LATIN CAPITAL LETTER/)&gt;+/;   #  &apos;F&apos;,  &apos;match character names&apos;;</div></pre></td></tr></table></figure>
<ul>
<li>多个这样的项(terms)可以使用加号和减号组合到一块儿:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;+ :HexDigit - :Upper &gt;</div></pre></td></tr></table></figure>
<p>项之间也能使用 <code>&amp;</code> 组合起来用于集合交集，或使用 <code>|</code> 用于集合并集，还有使用 <code>^</code> 用于对称的集合的差集。括号能用于分组。（方括号总是括起字面的字符(包括反斜线字面形式)，并且可能没有嵌套，不像 TR18 章节 1.3 中建议的记号那样。）操作符的优先级和<a href="http://design.perl6.org/S03.html#Operator_precedence" target="_blank" rel="external">“Operator precedence” in S03</a>中对应的具名操作符的优先级相同，即使它们的语义稍微有点不同。</p>
<ul>
<li>额外的长字符可以通过引用来键入并通过交叉来包含。合适的时候,任何引起的字符都会被当作”最长 tokens”。 这儿 ‘ll’ 会在 ‘l’ 之前被识别:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;[ a..z ] | &apos;ñ&apos; | &apos;ch&apos; | &apos;ll&apos; | &apos;rr&apos;&gt; /</div></pre></td></tr></table></figure>
<p>​注意包含”长字符”的否定字符类总是提前单个字符。</p>
<ul>
<li>当任何诸如 <code>\c</code>, <code>\x</code>, or <code>\o</code> 的字符构造结构包含多个由逗号分割的值时，这些值就被看做”长字符”。所以你可以把 <code>\c[13,10]</code> 添加到上面的列表中以把 CRLF 作为一个长字符匹配。<br>​<br>当那个长字符没有作为一个整体被匹配时，那么否定形式的就会提前一个单个字符(像 <code>.</code> 那样匹配)。因此，这个会匹配：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;\c[13,13,10,10]&quot; ~~ /\C[13,10]* \c[13,10] \C[13,10]/;</div></pre></td></tr></table></figure>
<p>如果你想要的是 \C13\C10，那么你就那样写好了。<br>​</p>
<ul>
<li>一个前置的 <code>!</code> 标示否定的意思(总是一个零宽断言):</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/angle-brackets.t#L243-L321" target="_blank" rel="external"><code>S05-metasyntax/angle-brackets.t lines 243–321</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L2141-L2377" target="_blank" rel="external"><code>S05-mass/rx.t lines 2141–2377</code></a><br>​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;!before _ &gt; /    # 我们不在 _ 前面</div></pre></td></tr></table></figure></p>
<p>注意 <code>&lt;!alpha&gt;</code> 和 <code>&lt;-alpha&gt;</code> 是不同的.  <code>/&lt;-alpha&gt;/</code> 是一个互补字符类 , 它等价于 <code>/&lt;!before &lt;alpha&gt;&gt; ./</code>,  而 <code>&lt;!alpha&gt;</code> 是一个零宽断言, 它等价于  <code>/&lt;!before &lt;alpha&gt;&gt;/</code> .</p>
<p>还要注意作为一个元字符, <code>!</code>不改变它后面所跟的任何东西的解析规则(这点与 + 或 - 不同)</p>
<ul>
<li>一个前置的 <code>?</code> 标示正向的零宽断言, 并且像 <code>!</code> 只是重新递归解析剩下的断言, 就像 <code>?</code> 不存在那一样. 此外, 要强制零宽断言, 它也能抑制任何具名捕获:<br><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L429-L451" target="_blank" rel="external"><code>S05-mass/rx.t lines 429–451</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;alpha&gt;     # 匹配一个字母,并捕获到 `$alpha` (最终是捕获到 $&lt;alpha&gt;)</div><div class="line">&lt;.alpha&gt;    # 匹配一个字母,不捕获</div><div class="line">&lt;?alpha&gt;    # match null before a letter, 不捕获</div></pre></td></tr></table></figure>
<p>特殊的具名断言包括:<br><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/lookaround.t#L13-L27" target="_blank" rel="external"><code>S05-metasyntax/lookaround.t lines 13–27</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L452-L510" target="_blank" rel="external"><code>S05-mass/rx.t lines 452–510</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-mass/charsets.t#L5-L59" target="_blank" rel="external"><code>S05-mass/charsets.t lines 5–59</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-mass/stdrules.t#L15-L309" target="_blank" rel="external"><code>S05-mass/stdrules.t lines 15–309</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/ &lt;?before pattern&gt; /    # lookahead  向前查看</div><div class="line">/ &lt;?after pattern&gt; /     # lookbehind 向后查看</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;?same&gt; /              # true between two identical characters</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/ &lt;.ws&gt; /                # match &quot;whitespace&quot;:</div><div class="line">                         # \s+ if it&apos;s between two \w characters,</div><div class="line">                         # \s* otherwise</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/ &lt;?at($pos)&gt; /          # 只在特定位置匹配</div><div class="line">                         # 是 &lt;?&#123; .pos === $pos &#125;&gt; 的简写形式</div><div class="line">                         # (considered declarative until $pos changes)</div></pre></td></tr></table></figure>
<p>​通过省略前面的标点符号把这些断言作为具名捕获使用是合法的。然而, 捕获需要一些内存和计算消耗, 所以你一般会抑制捕获不感兴趣的数据。<br><code>after</code> 断言通过反转语法树并以与左相反的顺序查找东西来实现向后查看。在不能反转的模式上做向后查看是违反规则的。  ​<br>注意：向前扫描向后查看的效果在顶层可以使用这个达成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ .*? prestuff &lt;( mainpat )&gt; /</div></pre></td></tr></table></figure>
<ul>
<li>一个前置的 <code>*</code> 标示后面的模式允许部分匹配. 匹配尽可能多的字符之后,它总是能成功. (它不是零宽的除非它匹配了0个字符). 例如, 要匹配一些缩写词, 你可以写下面任意一个:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">s/ ^ G&lt;*n|enesis&gt;     $ /gen/  or</div><div class="line">s/ ^ Ex&lt;*odus&gt;        $ /ex/   or</div><div class="line">s/ ^ L&lt;*v|eviticus&gt;   $ /lev/  or</div><div class="line">s/ ^ N&lt;*m|umbers&gt;     $ /num/  or</div><div class="line">s/ ^ D&lt;*t|euteronomy&gt; $ /deut/ or</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ (&lt;* &lt; foo bar baz &gt; &gt;) /</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;short=*@abbrev&gt; / and return %long&#123;$&lt;short&gt;&#125; || $&lt;short&gt;;</div></pre></td></tr></table></figure>
<p>这儿省略了一堆尚未实现的内容。​</p>
<ul>
<li>一个前置的 <code>|</code> 标示某种零宽边界. 使用这个语法你可以引用反引号序列; <code>&lt;|h&gt;</code> 会在 \h 和  \H 之间匹配, 例如. 一些例子:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;|w&gt; 单词边界</div><div class="line">&lt;|g&gt; 字素边界 (总是在字素模式下匹配)</div><div class="line">&lt;|c&gt; 代码点边界 (总是在 `字素/代码点` 模式下匹配)</div></pre></td></tr></table></figure>
<p>下面的 tokens 包含尖号但平衡不是必须的:</p>
<ul>
<li><code>&lt;(</code> token 标示匹配的全部捕获的开头, 而对应的 <code>)&gt;</code> token 标示它的终点。当匹配后, 这些表现像断言的总为真, 但是有设置匹配对象的 <code>.from</code> 和 <code>.to</code> 属性的副作用。即：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ foo &lt;( \d+ )&gt; bar /</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ &lt;?after foo&gt; \d+ &lt;?before bar&gt; /</div></pre></td></tr></table></figure>
<ul>
<li><code>«</code> 或 <code>&lt;&lt;</code> token 标示左单词边界。 <code>»</code> 或 <code>&gt;&gt;</code> token 标示右单词边界。(作为单独的 tokens, 这些 tokens 不需要保持平衡)。Perl 5’的 <code>\b</code> 被 <code>&lt;|w&gt;</code> “单词边界” 断言代替, 而 <code>\B</code> 变为 <code>丢失了</code>.</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6圣诞月历-(2011)]]></title>
      <url>http://ohmycloud.github.io/2016/06/28/Perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2011/</url>
      <content type="html"><![CDATA[<h1 id="2011"><a href="#2011" class="headerlink" title="2011"></a>2011</h1><hr>
<h2 id="The-Flip-Flop-operator"><a href="#The-Flip-Flop-operator" class="headerlink" title="The Flip-Flop operator"></a>The Flip-Flop operator</h2><hr>
<p>Perl5有一个二元操作符叫做flip-flop,它为假直到它的第一个参数被计算为真，然后它保持真(反转)，直到第二个参数计算为真，然后在那里它又变成假(flop)。 这真是太有用了，以至于Perl6也有flip-flop,只是它拼写为ff,并有一些变异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ff</div><div class="line">ff^</div><div class="line">^ff</div><div class="line">^ff^</div></pre></td></tr></table></figure>
<p>音调符号^意味着在那个结尾跳过结尾。<br>…或许一些例子更能说明问题…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for 1..20 &#123; .say if $_ == 9  ff  $_ == 13; &#125;     # 9 10 11 12 13</div><div class="line">for 1..20 &#123; .say if $_ == 9  ff^ $_ == 13; &#125;     # 9 10 11 12</div><div class="line">for 1..20 &#123; .say if $_ == 9 ^ff  $_ == 13; &#125;     # 10 11 12 13</div><div class="line">for 1..20 &#123; .say if $_ == 9 ^ff^ $_ == 13; &#125;     # 10 11 12</div></pre></td></tr></table></figure>
<p>每个例子中，我们遍历从1到20的数字范围，并且在flip-flop返回真时输出那些数字。每次循环中，flip-flop 操作符的左边(<code>$_ == 9</code>) 和 flip-flop操作符的右边 (<code>$_ == 13</code>)都会被计算。 (这里我已经在 flip-flop操作符的两侧使用了简单的数字比较，但是，一般任何布尔表达式都能使用。</p>
<p>每个 flip-flop 操作符的实例维护它们的内部状态以决定什么时候返回TRUE或False.所有的flip-flop操作符在它们的内部状态被设置为返回False时出现，直到它们被反转然后开始返回 TRUE.</p>
<p>在第一个和第二个例子中，当<code>$_ == 9</code> 时，flip-flop 操作符反转它们的内部状态为 TRUE ，然后立即返回 TRUE.在第三个和第四个例子中，当<code>$_== 9</code>时，flip-flop操作符将它们的内部状态设置为 TRUE,但是它们在那次遍历中返回 False ，因为前置的 ^符号。<br>类似地，在上面的第一个和第三个例子中，一旦RHS求值为真时， flip-flop操作符在下一次循环中将它们的内部状态反转回FALSE,然后返回True.在第三个和第四个例子中，flip-flop操作符在RHS返回真时立即反转为FALSE.<br>让flip-flop操作符反转但从不flop,在RHS上使用*：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for 1..20 &#123; .say if $_ == 15 ff *; &#125;     # 15 16 17 18 19 20</div></pre></td></tr></table></figure>
<p>Perl6有另外一套 flip-flop操作符，功能与上面提到的差不多，除了，在LHS变成真的时候，RHS不被求值。这很有用，当flip-flop操作符的RHS 和LHS 都同时求值为真的时候，These operators are spelled 这些操作符被拼写为  fff, fff^, ^fff, and ^fff^.</p>
<h2 id="Idiomatic-Perl-6"><a href="#Idiomatic-Perl-6" class="headerlink" title="Idiomatic Perl 6"></a>Idiomatic Perl 6</h2><hr>
<p>December 23, 2011</p>
<p>下面大多数的例子使用 4 种版本展示代码：</p>
<ul>
<li>Non-idiomatic Perl 5,</li>
<li>then made idiomatic.</li>
<li>Perl 5 idiom, naively translated into Perl 6,</li>
<li>then made idiomatic.</li>
</ul>
<p>从 1 到 4 越来越清晰和简洁</p>
<ul>
<li>随机选择数组元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$z = $array[ int(rand scalar(@array)) ];</div><div class="line">$z = $array[ rand @array ];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$z = @array[ rand*@array ];</div><div class="line">$z = @array.pick;</div></pre></td></tr></table></figure>
<ul>
<li>循环遍历数组的键（索引）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for ( my $i=0; $i&lt;@array; $i++ ) &#123;...&#125;</div><div class="line">for my $i ( 0 .. $#array )       &#123;...&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for 0 .. @array.end -&gt; $i &#123;...&#125;</div><div class="line">for @array.keys -&gt; $i     &#123;...&#125;</div></pre></td></tr></table></figure>
<ul>
<li>整除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">( ($x - ($x % 3) ) / 3 )</div><div class="line">int( $x / 3 )</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Int( $x / 3 )   # 首字母需大写</div><div class="line">$x div 3        # 整除运算符</div></pre></td></tr></table></figure>
<ul>
<li>打印数组元素的个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say scalar @array;</div><div class="line">say 0+@array;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say 0+@array;          # Identical in Perl 6</div><div class="line">say +@array;           # + 强制新的“数值”上下文</div><div class="line">say @array.elems;      # .elems 方法更清楚.</div></pre></td></tr></table></figure>
<ul>
<li>每隔5 次 做些事情</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if ( ($x/5) == int($x/5) ) &#123;...&#125;</div><div class="line">if ( !($x % 5) )           &#123;...&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if !($x % 5) &#123;...&#125;</div><div class="line">if $x %% 5   &#123;...&#125;     # %% means &quot;is evenly divisible by&quot;</div></pre></td></tr></table></figure>
<ul>
<li>Do something $n times, 直到 $n-1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for ( $_=0; $_ &lt; $n; $_++ ) &#123;...&#125;</div><div class="line">for ( 0 .. ($n-1) )         &#123;...&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for 0 ..^ $n &#123;...&#125;</div><div class="line">for ^$n      &#123;...&#125;     # ^9 means 0 ..^ 9, or 0..8</div></pre></td></tr></table></figure>
<p>eg：</p>
<pre><code>&gt; .say for ^5
</code></pre><p>0<br>1<br>2<br>3<br>4</p>
<p>Bare method calls are <em>always</em> methods on $<em>, eliminating Perl 5’s confusion on which functions default to $</em>.</p>
<ul>
<li>按空白分割</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@words = split /\s+/, $_;</div><div class="line">@words = split;           # Default is useful, but not intuitive</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@words = .split(/\s+/);  # split() 现在没有默认的模式</div><div class="line">@words = .words;         # split 的旧的行为现在成为了一个单独的方法.words</div></pre></td></tr></table></figure>
<ul>
<li>将字符串分割成单独的字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@chars = map &#123; substr $word, $_, 1 &#125; 0..length($word);</div><div class="line">@chars = split &apos;&apos;, $word;# Split on nothingness</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@chars = $word.split(&apos;&apos;);</div><div class="line">@chars = $word.comb;     # Default is to &quot;keep everything&quot;</div></pre></td></tr></table></figure>
<p> eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; my $word=&apos;Perl6&apos;</div><div class="line">Perl6</div><div class="line">&gt; my @chars=$word.split(&apos;&apos;)</div><div class="line">P e r l 6</div><div class="line">&gt; my @chars=$word.split(&apos;&apos;).join(&apos;-&gt;&apos;)</div><div class="line">P-&gt;e-&gt;r-&gt;l-&gt;6</div><div class="line">&gt; my @chars=$word.comb</div><div class="line">P e r l 6</div><div class="line">&gt; my @chars=$word.comb.join(&apos;:&apos;)</div><div class="line">P:e:r:l:6</div></pre></td></tr></table></figure>
<ul>
<li>无限循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for (;;)  &#123;...&#125;    # Spoken with a &apos;C&apos; accent</div><div class="line">while (1) &#123;...&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while 1   &#123;...&#125;</div><div class="line">loop      &#123;...&#125;   # 没有给出限定条件，所以默认无止尽</div></pre></td></tr></table></figure>
<ul>
<li>按原来的顺序返回列表中的唯一元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %s, @r; for @a  &#123; push @r, $_ if !$s&#123;$_&#125;; $s&#123;$_&#125;++; &#125; return @r;</div><div class="line">my %s; return grep &#123; !$s&#123;$_&#125;++ &#125; @a;    # or List::MoreUtils::uniq</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %s; return grep &#123; !%s&#123;$_&#125;++ &#125;, @a;</div><div class="line">return @a.uniq;</div></pre></td></tr></table></figure>
<ul>
<li>将列表中的所有元素求和</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $sum = 0; for my $num (@a) &#123; $sum += $num &#125;</div><div class="line">my $sum; $sum += $_ for @a;    # or List::Util::sum</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $sum = @a.reduce(*+*);</div><div class="line">my $sum = [+] @a;              # [op] 将op操作符应用到整个列表</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@alpha = &apos;A&apos; .. &apos;Z&apos;;</div><div class="line">@a = qw&#123; able baker charlie &#125;;</div><div class="line">%meta = ( foo =&gt; &apos;bar&apos;, baz =&gt; &apos;quz&apos; );</div><div class="line">@squares = map &#123; $_ * $_ &#125;, @a;</div><div class="line">@starts_with_number = grep &#123; /^\d/ &#125;, @a;</div></pre></td></tr></table></figure>
<p>钻石操作符还在：</p>
<ul>
<li>Process each line from STDIN or from command-line files.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for my $file (@ARGV) &#123; open FH, $file; while (&lt;FH&gt;) &#123;...&#125; &#125;</div><div class="line">while (&lt;&gt;) &#123;...&#125;               # Null filehandle is magical</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for $*ARGFILES.lines &#123;...&#125;</div><div class="line">for lines()          &#123;...&#125;     # lines() defaults to $fh = $*ARGFILES</div></pre></td></tr></table></figure>
<ul>
<li>将散列初始化为一个常量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %h;   for (@a) &#123; $h&#123;$_&#125; = 1 &#125;</div><div class="line">my %h = map &#123; $_ =&gt; 1 &#125; @a;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %h = map &#123; $_ =&gt; 1 &#125;, @a;</div><div class="line">my %h = @a X=&gt; 1;</div></pre></td></tr></table></figure>
<p>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; my @a=&lt;Perl Python Ruby Perl6&gt;</div><div class="line">Perl Python Ruby Perl6</div><div class="line">&gt; my %h= @a X=&gt; 1</div><div class="line">(&quot;Perl&quot; =&gt; 1, &quot;Python&quot; =&gt; 1, &quot;Ruby&quot; =&gt; 1, &quot;Perl6&quot; =&gt; 1).hash</div></pre></td></tr></table></figure>
<ul>
<li>Hash initialization for enumeration</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %h;   for (0..$#a) &#123; $h&#123; $a[$_] &#125; = $_ &#125;</div><div class="line">my $c;   my %h = map  &#123; $_ =&gt; ++$c &#125; @a;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $c;   my %h = map &#123; $_ =&gt; ++$c &#125;, @a;</div><div class="line">(&quot;Perl&quot; =&gt; 1, &quot;Python&quot; =&gt; 2, &quot;Ruby&quot; =&gt; 3, &quot;Perl6&quot; =&gt; 4).hash</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %h = @a Z=&gt; 1..*;       # (&quot;Perl&quot; =&gt; 1, &quot;Python&quot; =&gt; 2, &quot;Ruby&quot; =&gt; 3, &quot;Perl6&quot; =&gt; 4).hash</div><div class="line">my %h = @a.pairs».invert;  # if zero based , (&quot;Perl&quot; =&gt; 0, &quot;Python&quot; =&gt; 1, &quot;Ruby&quot; =&gt; 2, &quot;Perl6&quot; =&gt; 3).hash</div></pre></td></tr></table></figure>
<blockquote>
<p>@a.pairs<br>0 =&gt; “Perl” 1 =&gt; “Python” 2 =&gt; “Ruby” 3 =&gt; “Perl6”</p>
</blockquote>
<ul>
<li>Hash initialization from parallel arrays</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %h;   for (@a) &#123; $h&#123;$_&#125; = shift @b &#125;</div><div class="line">my %h;   @h&#123;@a&#125; = @b;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %h;   %h&#123;@a&#125; = @b;</div><div class="line">my %h = @a Z=&gt; @b;</div></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; my @b=&lt;Larry Gao Mztiz Larry_Wall&gt;</div><div class="line">Larry Gao Mztiz Larry_Wall</div><div class="line">&gt; my %h= @a Z=&gt; @b</div><div class="line">(&quot;Perl&quot; =&gt; &quot;Larry&quot;, &quot;Python&quot; =&gt; &quot;Gao&quot;, &quot;Ruby&quot; =&gt; &quot;Mztiz&quot;, &quot;Perl6&quot; =&gt; &quot;Larry_Wall&quot;).hash</div></pre></td></tr></table></figure>
<ul>
<li>交换两个变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $temp = $x; $x = $y; $y = $temp;</div><div class="line">( $x, $y ) = ( $y, $x );</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">( $x, $y )  = $y, $x;</div><div class="line">( $x, $y ) .= reverse;   # .= makes reverse into a &quot;mutating&quot; method</div><div class="line"># Tastes great on array swaps, too!   @a[ $j, $k ] .= reverse;</div></pre></td></tr></table></figure>
<ul>
<li>Rotate array left by 1 element</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $temp = shift @a; push @a, $temp;</div><div class="line">push @a, shift @a;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@a.push: @a.shift;</div><div class="line">@a .= rotate; # Python Ruby Perl6 Perl</div></pre></td></tr></table></figure>
<ul>
<li>创建一个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $pet = new Dog;</div><div class="line">my $pet = Dog-&gt;new;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $pet = Dog.new;</div><div class="line">my Dog $pet .= new;    # $pet *always* isa Dog; Compiler can optimize!</div></pre></td></tr></table></figure>
<p>Combining transformation with selection was an advanced idiom in Perl 5. The new return values for if provide a bite-sized idiom.</p>
<ul>
<li>Three copies of elements &gt; 5</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@z = map &#123; ($_) x 3 &#125; grep &#123; $_ &gt; 5 &#125; @y;    # map,grep</div><div class="line">@z = map &#123; $_ &gt; 5 ? ($_) x 3 : () &#125; @y;      # map as grep</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@z = map &#123; $_ &gt; 5 ?? ($_) xx 3 !! Nil &#125;, @y;</div><div class="line">@z = @y.map: &#123; $_ xx 3 if $_ &gt; 5 &#125;;          # !if == Empty list</div><div class="line">@z = ($_ xx 3 if $_ &gt; 5 for @y);             # List comprehension</div></pre></td></tr></table></figure>
<ul>
<li>3到7之间的随机整数，包含3和7</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">do &#123; $z = int rand 8 &#125; until $z &gt;= 3;</div><div class="line">$z = 3 + int rand 5;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$z = 3 + Int(5.rand);</div><div class="line">$z = (3..7).pick;</div></pre></td></tr></table></figure>
<ul>
<li>在无限循环中每次循环加 3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for ( my $i = 1; ; $i++ ) &#123; my $n = 3 * $i; ... &#125;</div><div class="line">for ( my $n = 3; ; $n += 3 ) &#123;...&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">loop ( my $n = 3; ; $n += 3 ) &#123;...&#125;</div><div class="line">for 3, * + 3 ... * -&gt; $n      &#123;...&#125;      # `...` is the &quot;sequence&quot; operator</div><div class="line">for 3, 6, 9 ... * -&gt; $n       &#123;...&#125;      # `...` can infer from example list</div></pre></td></tr></table></figure>
<ul>
<li>遍历区间, 不包含开始点和结束点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for my $i ( $start .. $limit ) &#123; next if $i == $start or $i == $limit; ... &#125;</div><div class="line">for my $i ( ($start+1) .. ($limit-1) ) &#123;...&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for ($start+1) .. ($limit-1) -&gt; $i &#123;...&#125;</div><div class="line">for $start    ^..^ $limit    -&gt; $i &#123;...&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[S06-Subroutines]]></title>
      <url>http://ohmycloud.github.io/2016/06/27/S06-Subroutines/</url>
      <content type="html"><![CDATA[<p>原文<a href="http://design.perl6.org/S06.html" target="_blank" rel="external">Subroutines</a></p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><hr>
<p>概要 6: 子例程</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><hr>
<p>创建于: 2003 年 5 月 21</p>
<p>上一次更新: 2015 年 10 月 16</p>
<p>版本: 169</p>
<p>该文档总结了概要 6, 其中涵盖了子例程和新的类型系统。</p>
<h2 id="子例程和其它-code-对象"><a href="#子例程和其它-code-对象" class="headerlink" title="子例程和其它 code 对象"></a>子例程和其它 code 对象</h2><hr>
<p><strong>Routine</strong> 是所有以关键字声明的 code blocks 的父类型。所有的 routines(程序)生来就带有未定义的 <code>$_</code>、<code>$!</code>和<code>$/</code> 值, 除非该 routine 显式地声明了它们。一个编译单元, 例如模块文件或 <strong>EVAL</strong> 字符串, 也被看作是 routine, 要不然你就不能引用它们里面的 <code>$!</code> 或 <code>$/</code>。</p>
<p>使用 <code>-&gt;</code> 声明或使用裸花括号的非-routine 的 code Blocks, 生来只有 <code>$_</code>, 它被别名到它的 <code>OUTER::&lt;$_&gt;</code> 上, 除非被绑定为参数。 block 通常使用由最里面的闭合 routine 所定义的 <code>$!</code> 和 <code>$/</code>, 除非在 block 中显式地声明了 <code>$!</code> 或 <code>$/</code>。</p>
<p>形实转换程序是一段不会立即执行的代码, 例如因为它是条件操作符的一部分, 或者它是某个属性的默认初始化函数。它没有自己的作用域, 所以在形实转换程序中定义的任何新的变量, 都会漏到它们所在的作用域中。然而, 要知道任意和所有的 lazy(惰性)结构, 不管是基于 block 的还是基于形实转换程序的, 例如 gather 或者 start 或者 <code>==&gt;</code> 应该声明它们自己的 <code>$/</code> 和 <code>$!</code> , 以至于那些变量的用户值不会发生异步碰撞(clobbered asynchronously)。</p>
<p><strong>Subroutines</strong> (关键字: sub) 是带有参数列表的非继承程序。</p>
<p><strong>Methods</strong> (关键字: method) 是有关联对象(即它们的调用者)的可继承程序并且属于特殊的类别或类。</p>
<p><strong>Submethods</strong> (关键字: submethod) 是非继承方法, 或者是伪装成方法的子例程。它们拥有一个调用者并属于特殊的类别或类。</p>
<p><strong>Regexes</strong> (关键字: regex)是执行模式匹配的方法(grammar 的)。它们关联的 block 拥有特殊的语法(查看 Synopsis 5)。(我们也使用术语 <code>regex</code> 用于传统形式的匿名模式。)</p>
<p><strong>Tokens</strong> (关键字: token) 是执行低级别(low-level) 非回溯(默认的)模式匹配的 regexes。</p>
<p><strong>Rules</strong> (关键字: rule) 是执行非回溯(默认的)模式匹配(而且 rules 中空白是开启的)的 regexes。</p>
<p><strong>Macros</strong> (关键字: macro 或 slang) 是被安装的程序或方法, 它们作为编译程序的一部分被调用, 因此能临时取得随后编译的控制权以像编译器作弊那样作弊。</p>
<h2 id="Routine-修饰符"><a href="#Routine-修饰符" class="headerlink" title="Routine 修饰符"></a>Routine 修饰符</h2><hr>
<blockquote>
<p><a href="https://github.com/perl6/roast/blob/master/S06-multi/value-based.t#L7-L104" target="_blank" rel="external"><code>S06-multi/value-based.t</code> lines <code>7–104</code></a><br><a href="https://github.com/perl6/roast/blob/master/S06-multi/type-based.t#L50-L57" target="_blank" rel="external"><code>S06-multi/type-based.t</code> lines <code>50–57</code></a><br><a href="https://github.com/perl6/roast/blob/master/S06-multi/type-based.t#L58-L283" target="_blank" rel="external"><code>S06-multi/type-based.t</code> lines <code>58–283</code></a><br><a href="https://github.com/perl6/roast/blob/master/S06-multi/syntax.t#L7-L183" target="_blank" rel="external"><code>S06-multi/syntax.t</code> lines <code>7–183</code></a></p>
</blockquote>
<p><strong>Multis</strong> (关键字: multi) 是可以拥有多个共享同一个名字的变体的 routines, 它们通过元数、类型或其它约束被选择。</p>
<p><strong>Prototypes</strong> (关键字: proto) 指定了在 <em>proto</em> 声明的作用域中, 那个名字的所有 muitis 所共享的共性(例如参数名, 不变性和结合性)。理论上讲, <em>proto</em> 是包裹在 <em>multis</em> 分发周围的通用包装器(wrapper)。对于每个需要一个不同候选者列表的作用域, 每个 <em>proto</em> 被具体化到一个实际的分发器(dispatcher)。</p>
<p><strong>Only</strong> (关键字: only) 不和其它 routines 共享它们的短名字的 routines。这对所有的 routines 是默认的修饰符, 除非作用域中已经有了一个同名的 <code>proto</code>。(对于 subs, 执政的那个 <em>proto</em> 必须已经在同一个文件中声明过, 所以 从设置中或其它模块中声明的 <code>proto</code> 没有这种效果, 除非被显式地导入。)</p>
<p>在具名 routine 中, 修饰符关键字可以出现在 routine 关键字前面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">only     sub foo  &#123;...&#125;</div><div class="line">proto    sub foo  &#123;...&#125;</div><div class="line">dispatch sub foo  &#123;...&#125; # 内部的</div><div class="line">multi    sub foo  &#123;...&#125;</div><div class="line"></div><div class="line">only     method bar  &#123;...&#125;</div><div class="line">proto    method bar  &#123;...&#125;</div><div class="line">dispatch method bar  &#123;...&#125; # 内部的</div><div class="line">multi    method bar  &#123;...&#125;</div></pre></td></tr></table></figure>
<p>如果 routine 关键字被省略了, 那么就默认为 <code>sub</code>。</p>
<p>修饰符关键字不能应用到匿名 routines 上。</p>
<p><code>proto</code> 是一个通用的分发器, 其中带有唯一候选者列表的任意给定作用域会被实例化到某个分发子例程中。因此 <code>proto</code>从来不会被直接调用, 这和 <em>role</em> 不能用作实例化对象很像。</p>
<p>当你调用任何可能拥有多个候选者的子例程(或者方法, 或者 rule)时, 基础分发器真正调用的是 <strong>only</strong> sub 或方法 — 但是如果有多个候选者, 将被找到的 “only” 就是一个分发器。这个实例化的分发器总是被首先调用(至少在理论上 — 这通常会被优化掉)。本质上, <em>dispatch</em> 总是像 <code>only</code> sub 那样, 但是 <em>dispatch</em> 自身可以代理给任何它所管理的候选者。</p>
<p>首先为所有的候选者审查参数是分发器(dispatch)的责任。任何不能成功约束为分发器签名的调用都会立即失败。(它的签名是属于该 proto 所实例化的候选者签名的拷贝。) 然而, 该分发器(dispatch)没有必要把原来的捕获(capture)发送给它的候选者。在分发器签名中约束为位置的具名参数对于所有随后的它所管理的 multis 的调用都会变成位置的。</p>
<p>然后, 该分发器(dispatch)从调用者或对象的角度考虑它所管理的候选者列表, 把它们按照某种顺序排序, 然后根据每个不同的调度器(dispatchers)定义的多重分派的规则来分派它们。在 multi subs 的情况下, 候选者列表在编译时是被知晓的。在 multi methods 的情况下, 在运行时生成(或重新生成)候选者列表可能是必要的, 根据关于继承树时所知道的。</p>
<p>这种默认的分发器行为在原来的 <em>proto</em> 中通过一个含有单个 <code>*</code> (即 “whatever”)的 block 使用符号给表现了。因此, 标准的 <code>proto</code> 会仅仅有一个 <code>{*}</code> 主体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proto method bar &#123;*&#125;</div></pre></td></tr></table></figure>
<p>(我们不使用 … 代替它是因为它会在运行时失败, 而该 proto 实例化的 dispatch blocks 不是 stubs, 但是想要被执行。)</p>
<p> 其它语句可以插入在 <code>{*}</code> 语句之前和之后以在 multi dispatch 之前或之后捕获控制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proto foo ($a, $b) &#123; say &quot;Called with $a, $b&quot;; &#123;*&#125;; say &quot;Returning&quot;; &#125;</div></pre></td></tr></table></figure>
<p>(那个 <code>proto</code> 只对带有副作用并不返回值的 multis 很有用, 因为它返回了 say 的结果, 这可能不是你想要的。查看下面的来修复它 。)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[给标题添加换行]]></title>
      <url>http://ohmycloud.github.io/2016/06/19/%E7%BB%99%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%8D%A2%E8%A1%8C/</url>
      <content type="html"><![CDATA[<p>简书太扯了, 不管是什么空格都替换掉了。<br>开门见山, 废话不多说。如果非标题行在标题行上面, 那么这俩行之间会有一段空白, 但是你肯定遇到过:</p>
<h2 id="这个标题会和下面的非标题行贴在一块"><a href="#这个标题会和下面的非标题行贴在一块" class="headerlink" title="这个标题会和下面的非标题行贴在一块"></a>这个标题会和下面的非标题行贴在一块</h2><p>即使我在这一行换行也于事无补,  它们被简书吃掉啦。这不能忍! 看起来很丑有没有？下面我们就来解决这个问题, 手动在这一行的上面加上一个全角的空格, 就 okay 了。</p>
<p>问题似乎已经解决了, 但是我不能够。必须写个程序来帮我们解决这烦人的问题。方法就是在<strong>标题行</strong>后面添加一个换行符和一个全角空格（测试后行不通, 还是被吃, 换成 <strong><code>&lt;br&gt;</code></strong> 吧）。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">for</span> dir(<span class="string">test =&gt;</span> /\. md|markdown $/) -&gt; $file &#123;</div><div class="line">    <span class="keyword">my</span> $out   = <span class="keyword">open</span> $file ~ <span class="string">'.txt'</span>, :w;</div><div class="line">    <span class="keyword">my</span> @lines = $file.lines;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> @lines -&gt; $line is rw &#123;</div><div class="line">        <span class="keyword">if</span> $line ~~ <span class="regexp">/^\s*$/</span> &#123;</div><div class="line">            $out.say($line);</div><div class="line">            <span class="keyword">next</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $line ~~ <span class="regexp">s/^ ('#' ** 1..7 .*?) $/$0\n  &lt;br&gt;/</span> <span class="keyword">unless</span></div><div class="line">            $line ~~ <span class="regexp">/^\s*'```'\s*(\w+)?$/</span> fff $line ~~ <span class="regexp">/^\s*'```'\s*$/</span>;</div><div class="line">        $out.say($line);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    $out.close;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中有段代码比较有意思, 就是:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$line ~~ <span class="regexp">/^\s*'```'\s*(\w+)?$/</span> fff $line ~~ <span class="regexp">/^\s*'```'\s*$/</span>;</div></pre></td></tr></table></figure>
<p>这是用来匹配代码片段的。 它匹配 ``` 标识之间的东西。这能够用于提取代码片段, 假如我有一个叫做 <strong>input.txt</strong> 的文本文件:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 提取代码片段</span></div><div class="line">　</div><div class="line"><span class="comment">## Flip 和 Flop</span></div><div class="line">　</div><div class="line">这俩单词是什么鬼? 反转操作符? 看起来很牛的样子, 我<span class="string">`方`</span>了, 我觉得它像开关。</div><div class="line"></div><div class="line"><span class="comment">## 片段1</span></div><div class="line">　</div><div class="line"><span class="string">''</span><span class="string">'perl6</span></div><div class="line">say 'hello<span class="string">';</span></div><div class="line">### 我是 Perl 6 代码</div><div class="line">'<span class="string">''</span></div><div class="line"></div><div class="line">ff 还有 ^ff、 ff^ 和 ^ff^ 三种变体。 </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">## 片段2</span></div><div class="line">　</div><div class="line"><span class="string">''</span><span class="string">' perl</span></div><div class="line"># 我是 Perl 5 代码</div><div class="line">say 'hello<span class="string">' ~ '</span>world<span class="string">';</span></div><div class="line">'<span class="string">''</span></div><div class="line"></div><div class="line"><span class="comment"># 片段3</span></div><div class="line">　</div><div class="line"><span class="string">''</span><span class="string">'</span></div><div class="line">fff 用于对付某些特殊情况。</div><div class="line">### 这是注释</div><div class="line">我只是在测试 ff 和 fff 的不同。显然, fff 更智能点。</div><div class="line">'<span class="string">''</span></div></pre></td></tr></table></figure>
<p>因为简书对嵌套的 <strong>```</strong> 这种结构处理不好, 所以我使用单引号 <strong>‘</strong> 来代替 <strong>`</strong>。我需要提取每对 <strong>```</strong> 之间的内容, 那么:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> @lines = <span class="string">"input.txt"</span>.IO.lines;</div><div class="line"><span class="keyword">for</span> @lines -&gt; $line &#123;</div><div class="line">    <span class="keyword">say</span> $line <span class="keyword">if</span> $line ~~ <span class="regexp">/^\s*'```'\s*(\w+)?$/</span> ff $line ~~ <span class="regexp">/^\s*'```'\s*$/</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是对于片段3, 因为开始标识符和结束标识符都是 <strong>```</strong>,  <code>ff</code> 提取不到, 这时需要用到 <code>fff</code> 了:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> $line <span class="keyword">if</span> $line ~~ <span class="regexp">/^\s*'```'\s*(\w+)?$/</span> fff $line ~~ <span class="regexp">/^\s*'```'\s*$/</span>;</div></pre></td></tr></table></figure>
<p>如果你连开始和结尾的 <strong>```</strong> 标识符也不想要, 那么使用 <code>^fff^</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl 6 FAQ]]></title>
      <url>http://ohmycloud.github.io/2016/06/06/Perl-6-FAQ/</url>
      <content type="html"><![CDATA[<p>源文件可以在 <a href="https://github.com/perl6/faq" target="_blank" rel="external">github</a> 或 <a href="https://doc.perl6.org/language/faq" target="_blank" rel="external">perl6.org</a>上找到.</p>
<h2 id="General"><a href="#General" class="headerlink" title="General"></a>General</h2><hr>
<h3 id="Rakudo-和-Perl-6-的区别是什么？"><a href="#Rakudo-和-Perl-6-的区别是什么？" class="headerlink" title="Rakudo 和 Perl 6 的区别是什么？"></a>Rakudo 和 Perl 6 的区别是什么？</h3><hr>
<p>Rakudo 是 Perl 6 的一个实现。目前它是完成度最好的但是过去也有其它的实现, 将来也可能会有其它实现。Perl 6 是语言的定义。很多场合</p>
<p>这两个名字可以宽松地使用并互相替换。</p>
<h3 id="作为一个-Perl-6-初学者我应该安装什么？"><a href="#作为一个-Perl-6-初学者我应该安装什么？" class="headerlink" title="作为一个 Perl 6 初学者我应该安装什么？"></a>作为一个 Perl 6 初学者我应该安装什么？</h3><hr>
<p>如果你是一个 Linux 或 Mac 用户, 你可能需要下载 <a href="http://rakudo.org/downloads/star/" target="_blank" rel="external">Rakudo Star</a> 并通过编译 MoarVM 版本安装（一个简单的处理）</p>
<p>如果你是一个 Windows 32 或 64 位用户, 那么 Rakudo Star 二进制版本在 rakudo 网站也能获得。你需要 Windows Git 来使用 panda。</p>
<p>Linux 和 Mac 二进制版本稍后也可能从供应商和第三方那儿获取到。尽管供应商版本可能过时了。</p>
<h3 id="作为一个中高级用户我想跟进-Rakudo-开发"><a href="#作为一个中高级用户我想跟进-Rakudo-开发" class="headerlink" title="作为一个中高级用户我想跟进 Rakudo 开发"></a>作为一个中高级用户我想跟进 Rakudo 开发</h3><hr>
<p>安装类似于 Perl 5 的 perlbrew – rakudobrew , 和 同等的 Python 还有 Ruby工具。</p>
<h3 id="从哪里能找到关于-Perl-6-的好文档？"><a href="#从哪里能找到关于-Perl-6-的好文档？" class="headerlink" title="从哪里能找到关于 Perl 6 的好文档？"></a>从哪里能找到关于 Perl 6 的好文档？</h3><hr>
<p>最令人信赖的信息能在 perl6.org 或那儿的直接链接。</p>
<p><a href="http://www.perl6.org/documentation/" target="_blank" rel="external">http://www.perl6.org/documentation/</a> 和 <a href="http://doc.perl6.org/" target="_blank" rel="external">http://doc.perl6.org/</a></p>
<h3 id="什么是-Perl-6-spec？"><a href="#什么是-Perl-6-spec？" class="headerlink" title="什么是 Perl 6 spec？"></a>什么是 Perl 6 spec？</h3><hr>
<p>“spec” 指的是 Perl 6的官方测试套件。它被称作 roast 并被托管在 <a href="https://github.com/perl6/roast" target="_blank" rel="external">github</a> 上.</p>
<p>它被用来测量一个 Perl 6 的实现有多彻底。</p>
<h3 id="有没有-Perl-6-的术语相关的项目？"><a href="#有没有-Perl-6-的术语相关的项目？" class="headerlink" title="有没有 Perl 6 的术语相关的项目？"></a>有没有 Perl 6 的术语相关的项目？</h3><hr>
<p>查看 <a href="http://design.perl6.org/S99.html" target="_blank" rel="external">S99</a></p>
<h3 id="我是一个-Perl-5程序员-Perl-5-和-Perl-6-的区别在哪儿？"><a href="#我是一个-Perl-5程序员-Perl-5-和-Perl-6-的区别在哪儿？" class="headerlink" title="我是一个 Perl 5程序员. Perl 5 和 Perl 6 的区别在哪儿？"></a>我是一个 Perl 5程序员. Perl 5 和 Perl 6 的区别在哪儿？</h3><hr>
<p>查看 <a href="http://doc.perl6.org/language.html" target="_blank" rel="external">http://doc.perl6.org/language.html</a></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><hr>
<h3 id="Perl-6-有-CPAN-吗-或者-Perl-6-会使用-Perl-5-的-CPAN-吗"><a href="#Perl-6-有-CPAN-吗-或者-Perl-6-会使用-Perl-5-的-CPAN-吗" class="headerlink" title="Perl 6 有 CPAN 吗? 或者 Perl 6 会使用 Perl 5 的 CPAN 吗?"></a>Perl 6 有 CPAN 吗? 或者 Perl 6 会使用 Perl 5 的 CPAN 吗?</h3><hr>
<p>Perl 6 还没有像 CPAN 那样成熟的模块仓库. 但是 <a href="http://modules.perl6.org/" target="_blank" rel="external">modules.perl6.org</a> 有很多已知的 Perl 6 模块, <a href="https://github.com/tadzik/panda/" target="_blank" rel="external">panda</a> 能在 Rakudo 上安装这些模块.</p>
<h3 id="我能在-Perl-6-中使用-Perl-5的模块吗？"><a href="#我能在-Perl-6-中使用-Perl-5的模块吗？" class="headerlink" title="我能在 Perl 6 中使用 Perl 5的模块吗？"></a>我能在 Perl 6 中使用 Perl 5的模块吗？</h3><hr>
<p>使用 Inline::Perl5 能很好地运行 Perl 5的 Catalyst 和 DBI。</p>
<h3 id="我能在-Perl-6-中使用-C-和-C-吗？"><a href="#我能在-Perl-6-中使用-C-和-C-吗？" class="headerlink" title="我能在 Perl 6 中使用 C 和 C++ 吗？"></a>我能在 Perl 6 中使用 C 和 C++ 吗？</h3><hr>
<p><a href="http://docs.perl6.org/language/nativecall" target="_blank" rel="external">Nativecall</a> 让这个特别容易。</p>
<h3 id="Nativecall-找不到-libfoo-so-并且我只有-libfoo-so-1-2"><a href="#Nativecall-找不到-libfoo-so-并且我只有-libfoo-so-1-2" class="headerlink" title="Nativecall 找不到 libfoo.so 并且我只有 libfoo.so.1.2!"></a>Nativecall 找不到 libfoo.so 并且我只有 libfoo.so.1.2!</h3><hr>
<p>这在 Debian 那样的系统中很常见。 你需要安装 “libfoo-dev” 来为丢失的文件设置符号链接。</p>
<h3 id="所有的传统-Unix-库函数去哪儿了？"><a href="#所有的传统-Unix-库函数去哪儿了？" class="headerlink" title="所有的传统 Unix 库函数去哪儿了？"></a>所有的传统 Unix 库函数去哪儿了？</h3><hr>
<p>使用 Nativecall 访问它们很容易。</p>
<h3 id="Rakudo-有核心标准库吗"><a href="#Rakudo-有核心标准库吗" class="headerlink" title="Rakudo 有核心标准库吗?"></a>Rakudo 有核心标准库吗?</h3><hr>
<p>Rakudo 是一个包含最小电量的编译器发布（Test 和 Nativecall等等），像 linux 内核一样。</p>
<p>Rakudo Star 是一个带有一些有用模块的 rakudo, 并且更多的模块可以从生态系统里安装。</p>
<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><hr>
<h3 id="我怎么-dump-Perl-6-的数据结构-就像-Perl-5-的-Data-Dumper-和类似的-？"><a href="#我怎么-dump-Perl-6-的数据结构-就像-Perl-5-的-Data-Dumper-和类似的-？" class="headerlink" title="我怎么 dump Perl 6 的数据结构(就像 Perl 5 的 Data::Dumper 和类似的)？"></a>我怎么 dump Perl 6 的数据结构(就像 Perl 5 的 Data::Dumper 和类似的)？</h3><hr>
<p>examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my $foo=&quot;bar&quot;</div><div class="line">dd $foo        # Str $foo = &quot;bar&quot;</div><div class="line">say :$foo.perl # :foo(&quot;bar&quot;)</div><div class="line">say :$foo.gist # foo =&gt; bar</div></pre></td></tr></table></figure>
<p>生态系统中还有模块来做这个事情, 例如 <a href="https://github.com/tony-o/perl6-data-dump/" target="_blank" rel="external">Data::Dump</a> 使用颜色来 Dump。</p>
<h3 id="我怎么在-Perl-6提示符（REPL）中找到历史命令行？"><a href="#我怎么在-Perl-6提示符（REPL）中找到历史命令行？" class="headerlink" title="我怎么在 Perl 6提示符（REPL）中找到历史命令行？"></a>我怎么在 Perl 6提示符（REPL）中找到历史命令行？</h3><hr>
<p>从生态系统中安装 <a href="https://github.com/hoelzro/p6-linenoise/" target="_blank" rel="external">Linenoise</a>.</p>
<p>作为一种选择, 在 UNIX 那样的系统中可以安装 rlwrap。这在类 Debian 系统中可以通过<code>apt-get install rlwrap</code> 安装。</p>
<h3 id="为什么-Rakudo-编译器有时候报错更友好？"><a href="#为什么-Rakudo-编译器有时候报错更友好？" class="headerlink" title="为什么 Rakudo 编译器有时候报错更友好？"></a>为什么 Rakudo 编译器有时候报错更友好？</h3><hr>
<p>如果 <code>SORRY!</code> 出现在输出中, 则错误是编译时错误, 否则是运行时错误。<br>Examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say 1/0     # Attempt to divide 1 by zero using div</div><div class="line"></div><div class="line">sub foo ( Int $a, Int $b ) &#123;...&#125;</div><div class="line">foo(1)      # ===SORRY!=== Error while compiling ...</div></pre></td></tr></table></figure>
<h3 id="什么是-Any"><a href="#什么是-Any" class="headerlink" title="什么是 (Any)?"></a>什么是 (Any)?</h3><hr>
<p><a href="http://doc.perl6.org/routine/type%2FAny" target="_blank" rel="external">Any</a> 是一个用于新类的默认超类(superclass)的顶层类。<br>它经常在这样的上下文出现：变量被定义但没有被赋值， 这里它类似于其它语言中的 undef 或 null 值。<br>examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $foo;</div><div class="line">say $foo;       # (Any) 注意圆括号表明的类型对象</div><div class="line">say $foo.^name  # Any</div></pre></td></tr></table></figure>
<p>(Any) 不应该被用于检查definedness。 在 Perl 6中, definedness 可能是一个对象。 通常实例是被定义的, 而类型对象是未定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say 1.defined       # True</div><div class="line">say (Any).defined   # False</div></pre></td></tr></table></figure>
<h3 id="so-是什么"><a href="#so-是什么" class="headerlink" title="so 是什么?"></a>so 是什么?</h3><hr>
<p><code>so</code> 是一个松散优先级的操作符, 它强制上下文为 <code>Bool</code>.  <code>not</code> 的</p>
<p><code>so</code> 拥有和 <code>?</code>前缀操作符同样的语义, 就像 <code>and</code> 是 <code>&amp;&amp;</code> 的低优先级版本一样.</p>
<p>用法示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say so 1|2 == 2;    # Bool::True</div></pre></td></tr></table></figure>
<p>在这个例子中, 比较的结果(结果是 Junction)在打印之前被转换为 Bool 值了.</p>
<h3 id="签名中的那些-D-和-U-是什么东东？"><a href="#签名中的那些-D-和-U-是什么东东？" class="headerlink" title="签名中的那些 :D 和 :U 是什么东东？"></a>签名中的那些 :D 和 :U 是什么东东？</h3><hr>
<p>在 Perl 6 中, 类和其它类型是对象, 并且传递自身类型的类型检测。<br>例如如果你声明一个变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my Int $x = 42;</div></pre></td></tr></table></figure>
<p>那么, 你不仅可以给它赋值整数（即， Int 类的实例）, 还能给它赋值 Int 类型对象自身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$x = Int</div></pre></td></tr></table></figure>
<p>如果你想排除类型对象, 你可以追加一个 :D 类型微笑符, 它代表”定义”（definite）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my Int:D $x = 42;</div><div class="line">$x = Int;  # dies with:</div><div class="line">           # Type check failed in assignment to $x;</div><div class="line">           # expected Int:D but got Int</div></pre></td></tr></table></figure>
<p> 同样地, <code>:U</code> 约束为未定义的值, 即类型对象。<br> 要显式地允许类型对象或实例, 你可以使用 <code>:_</code>。</p>
<h3 id="签名中的-–-gt-是什么东东？"><a href="#签名中的-–-gt-是什么东东？" class="headerlink" title="签名中的 –&gt; 是什么东东？"></a>签名中的 –&gt; 是什么东东？</h3><hr>
<p><code>--&gt;</code> 是一个返回值约束, 在编译时被检查。<br>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub foo ( Int $a, Int $b --&gt; Int ) &#123;</div><div class="line">        return $a + $b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(2,3.1)</div><div class="line"># ===SORRY!===  ... Calling foo(Int, Rat) will never work</div><div class="line">#    with declared signature (Int $a, Int $b --&gt; Int)</div></pre></td></tr></table></figure>
<h3 id="Any-和-Mu-的区别是什么"><a href="#Any-和-Mu-的区别是什么" class="headerlink" title="Any 和 Mu 的区别是什么?"></a>Any 和 Mu 的区别是什么?</h3><hr>
<p><code>Mu</code> 是所派生出的所有其它类型的基类型. <code>Any</code> 是从  <code>Mu</code>派生来的, 代表着任何类型的 Perl 6 值. 主要区别是, <code>Any</code> 不包含 <code>Junction</code>.</p>
<p>子例程参数的默认类型是 <code>Any</code>, 以至于当你声明 <code>sub foo ($a)</code> 时, 你真正表达的是 <code>sub foo (Any $a)</code> . 类似地, 类的声明被假定继承自 <code>Any</code>, 除非使用了像 <code>is Mu</code> 这样的 trait 特征.</p>
<h3 id="怎么从-Junction-中提取值"><a href="#怎么从-Junction-中提取值" class="headerlink" title="怎么从 Junction 中提取值?"></a>怎么从 Junction 中提取值?</h3><hr>
<p>如果你想从 junction 中提取值(特征态), 那你可能正误入歧途.  Junctions 作为匹配器, 而不是使用它们做代数.</p>
<p>如果你还是想那样做, 你可以滥用自动穿引(autothreading):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub eigenstates(Mu $j) &#123;</div><div class="line">    my @states;</div><div class="line">    -&gt; Any $s &#123; @states.push: $s &#125;.($j);</div><div class="line">    @states;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say eigenstates(1|2|3).join(&apos;, &apos;);</div><div class="line"># prints 1, 2, 3 or a permutation thereof</div></pre></td></tr></table></figure>
<h3 id="如果-Str-是不可变的-那么-s-是怎么工作的-如果-Int-是不可变的-i-是怎么工作的"><a href="#如果-Str-是不可变的-那么-s-是怎么工作的-如果-Int-是不可变的-i-是怎么工作的" class="headerlink" title="如果 Str 是不可变的, 那么 s/// 是怎么工作的? 如果 Int 是不可变的, $i++ 是怎么工作的?"></a>如果 Str 是不可变的, 那么 <code>s///</code> 是怎么工作的? 如果 Int 是不可变的, <code>$i++</code> 是怎么工作的?</h3><hr>
<p>在 Perl 6 中, 很多基本类型是不可变的, 但是保存它们的变量不是. <code>s///</code> 作用于变量上, 在这个变量中放入一个新创建的字符串对象. 同样地, <code>$i++</code> 作用于 <code>$i</code> 变量上, 而不是作用在它里面的值身上.</p>
<p>请查看:  <a href="http://doc.perl6.org/language/containers" target="_blank" rel="external">documention on containers</a></p>
<h3 id="什么是数组引用和自动解引用-我仍然需要-符号吗"><a href="#什么是数组引用和自动解引用-我仍然需要-符号吗" class="headerlink" title="什么是数组引用和自动解引用? 我仍然需要 @ 符号吗?"></a>什么是数组引用和自动解引用? 我仍然需要 @ 符号吗?</h3><hr>
<p>在 Perl 6 中, 几乎所有的东西都是引用. 所以谈论 taking references 没有多大意义. 不像 Perl 5 那样, Perl 6 的标量标量也能直接包含数组:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my @a = 1, 2, 3;</div><div class="line">say @a;                 # &quot;1 2 3\n&quot;</div><div class="line">say @a.WHAT;            # (Array)</div><div class="line"></div><div class="line">my $scalar = @a;</div><div class="line">say $scalar;            # &quot;1 2 3\n&quot;</div><div class="line">say $scalar.WHAT;       # (Array)</div></pre></td></tr></table></figure>
<p>最大的区别是, 标量变量中的数组在列表上下文中不会被展平(flattern):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my @a = 1, 2, 3;</div><div class="line">my $s = @a;</div><div class="line"></div><div class="line">for @a &#123; ... &#125;          # loop body executed 3 times</div><div class="line">for $s &#123; ... &#125;          # loop body executed only once</div><div class="line"></div><div class="line">my @flat = @a, @a;</div><div class="line">say @flat.elems;        # 6</div><div class="line"></div><div class="line">my @nested = $s, $s;</div><div class="line">say @nested.elems;      # 2</div></pre></td></tr></table></figure>
<p>你可以使用 <code>@( ... )</code> 或通过在表达式身上调用 <code>.list</code> 方法来强制展平, 使用 <code>$( ... )</code> 或通过在表达式身上调用 <code>.item</code> 方法强制为 item  上下文(不展平).</p>
<p><code>[...]</code> 数组字面值不会被展平到列表中.</p>
<p>更多查看: <a href="http://doc.perl6.org/language/containers" target="_blank" rel="external">the documentation on containers and flattening</a></p>
<h3 id="为什么还要符号-你不能失去它们吗"><a href="#为什么还要符号-你不能失去它们吗" class="headerlink" title="为什么还要符号? 你不能失去它们吗?"></a>为什么还要符号? 你不能失去它们吗?</h3><hr>
<p>有几个原因:</p>
<ul>
<li>它们使插值变量到字符串中变得更容易</li>
<li>它们为不同的变量组成微型命名空间, 因此避免了名字冲突.</li>
<li>它们允许简单的 单数/复数 区别</li>
</ul>
<h3 id="Perl-6-有协程吗-什么是-yield"><a href="#Perl-6-有协程吗-什么是-yield" class="headerlink" title="Perl 6 有协程吗? 什么是 yield ?"></a>Perl 6 有协程吗? 什么是 yield ?</h3><hr>
<p>​    Perl 6 没有 Python 那样的 <code>yield</code> 语句, 但是它通过惰性列表却能提供类似的功能. 有两种很潮的方式来写出能返回惰性列表的子例程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># first method, gather/take</div><div class="line">my @values := gather while have_data() &#123;</div><div class="line">    # do some computations</div><div class="line">    take some_data();</div><div class="line">    # do more computations</div><div class="line">&#125;</div><div class="line"></div><div class="line"># second method, use .map or similar method</div><div class="line"># on a lazy list</div><div class="line">my @squares := (1..*).map(-&gt; $x &#123; $x * $x &#125;);</div></pre></td></tr></table></figure>
<h3 id="为什么我需要反斜线-unspace-在多行上分割方法调用"><a href="#为什么我需要反斜线-unspace-在多行上分割方法调用" class="headerlink" title="为什么我需要反斜线(unspace)在多行上分割方法调用?"></a>为什么我需要反斜线(unspace)在多行上分割方法调用?</h3><hr>
<p>(请在这儿添加答案)</p>
<h3 id="为什么我不能从-new-方法初始化私有属性-我怎么修复它"><a href="#为什么我不能从-new-方法初始化私有属性-我怎么修复它" class="headerlink" title="为什么我不能从 new 方法初始化私有属性, 我怎么修复它?"></a>为什么我不能从 new 方法初始化私有属性, 我怎么修复它?</h3><hr>
<p>这样的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class A &#123;</div><div class="line">    has $!x;</div><div class="line">    method show-x &#123;</div><div class="line">        say $!x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">A.new(x =&gt; 5).show-x;</div></pre></td></tr></table></figure>
<p>不会打印出 5. Private 属性是私有的, 这意味着私有属性在外面是不可见的. 如果默认的构造器能够初始化私有属性, 那么这些私有属性就会泄露到公共 API 中.</p>
<p>如果你仍旧想让它工作, 你可以添加一个 <code>submethod BUILD</code> 来初始化它们:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class B &#123;</div><div class="line">    has $!x;</div><div class="line">    submethod BUILD(:$!x) &#123; &#125;</div><div class="line">    method show-x &#123;</div><div class="line">        say $!x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">A.new(x =&gt; 5).show-x;</div></pre></td></tr></table></figure>
<p><code>BUILD</code> 由默认的构造器使用用户传递给构造器的所有具名参数调用(直接地, 查看更多细节<a href="http://perlgeek.de/blog-en/perl-6/object-construction-and-initialization.html" target="_blank" rel="external">object-construction-and-initilization</a>). <code>:$!x</code> 是名为 <code>x</code> 的具名参数, 当使用名为 <code>x</code> 的具名参数来调用时, 它的值被绑定到属性 <code>$!x</code> 上.</p>
<p>但是如果你允许从外面设置私有属性, 相反它们应该被设置为公共属性.</p>
<h3 id="say-和-print-怎么不同-为什么不同"><a href="#say-和-print-怎么不同-为什么不同" class="headerlink" title="say 和 print 怎么不同, 为什么不同?"></a>say 和 print 怎么不同, 为什么不同?</h3><hr>
<p>最明显的区别是, <code>say</code> 在输出后面添加了一个换行符, 而 <code>print</code> 没有.</p>
<p>但是还有另外一个区别: <code>print</code> 通过对每一个传递来的 item 调用 <code>Str</code> 方法来把它的参数转换为字符串, 相反,  <code>say</code> 使用  <code>gist</code> 方法. 前者是为计算机设计的, 后者是为人类.</p>
<p>或者它俩被解析的方式不同, <code>$obj.Str</code> 给出一个字符串表示, <code>$obj.gist</code> 是对象的一个简短总结, 适合编程人员的快速识别, <code>$obj.perl</code> 打印一个 Perlish 的表示.</p>
<p>例如, 类型对象, 也是熟知的 “未定义值”, 字符串化为一个空的字符串和警告, 而 <code>gist</code> 方法返回由一对圆括号包裹的类型的名字.(用于表明除了类型之外什么也没有).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my Date $x;     # $x now contains the Date type object</div><div class="line">print $x;       # empty string plus warning</div><div class="line">say $x;         # (Date)\n</div></pre></td></tr></table></figure>
<p>所以, <code>say</code> 优化的用于调试和向人们展示, <code>print</code> 更适合于产生用于其它程序的输出.</p>
<h3 id="token-和-rule-之间的区别是什么"><a href="#token-和-rule-之间的区别是什么" class="headerlink" title="token 和 rule 之间的区别是什么?"></a>token 和 rule 之间的区别是什么?</h3><hr>
<p><code>regex</code> , <code>token</code> 和 <code>rule</code> 这三个都引入了正则表达式, 但是语义略微有一点不同.</p>
<p><code>token</code> 隐含了 <code>:ratchet</code> 或 <code>:r</code> 修饰符, 这阻止了规则的回溯.</p>
<p><code>rule</code> 隐含了 <code>:ratchet</code> 和  <code>:sigspace</code> (缩写为 <code>:s</code>)修饰符, 这因为着规则不会回溯, 并且它把 regex中的文本中空白当作 <code>&lt;.ws&gt;</code> 调用(例如匹配空白, 除了在两个单词字符之间之外, 它是可选的).  regex 开头的空白和备选分支中每个分支开头的空白会被忽略.</p>
<p><code>regex</code> 声明不带任何隐含修饰符的普通 regex.</p>
<h3 id="die-和-fail-之间的区别是什么"><a href="#die-和-fail-之间的区别是什么" class="headerlink" title="die 和 fail 之间的区别是什么?"></a>die 和 fail 之间的区别是什么?</h3><hr>
<p><code>die</code> 抛出一个异常.</p>
<p>如果 <code>use fatal;</code> (它是动态作用域的)在作用域中, <code>fail</code> 也会抛出一个异常. 否则它从调用它的子例程中返回一个 <code>Failure</code>.</p>
<p><code>Failure</code> 是一个 “未抛出的” 或 “软的” 异常.它是一个含有异常的对象, 当这个 Failure 被用作普通的对象时会抛出一个异常.</p>
<p>Failure 从 <code>defined</code> 检查中返回 False, 并且你可以使用 <code>exception</code> 方法提取出异常.</p>
<h3 id="为什么-wantarray-或-want-不见了-我能在不同的上下文中返回不同的东西吗"><a href="#为什么-wantarray-或-want-不见了-我能在不同的上下文中返回不同的东西吗" class="headerlink" title="为什么 wantarray 或 want 不见了? 我能在不同的上下文中返回不同的东西吗?"></a>为什么 wantarray 或 want 不见了? 我能在不同的上下文中返回不同的东西吗?</h3><hr>
<p>Perl 拥有 <code>wantarray</code> 函数来告诉你这是在空上下文, 标量上下文,还是在列表上下文中调用的. Perl 6 没有与之等价的结构, 因为上下文不是向内流动的,  例如, 子例程不知道调用所在的上下文.</p>
<p>一个愿意是因为 Perl 6 有多重分派, 在这样一个例子中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi w(Int $x) &#123; say &apos;Int&apos; &#125;</div><div class="line">multi w(Str $x) &#123; say &apos;Str&apos; &#125;</div><div class="line">w(f());</div></pre></td></tr></table></figure>
<p>没办法决定子例程 <code>f</code> 的调用者想要一个字符串还是想要一个整数, 因为它还不知道调用者是什么. 通常这要求解决 halting 问题, 在这个问题上, 即使写 Perl 6编译器的人也会遇到麻烦.</p>
<p>在 Perl 6 中达到上下文敏感的方式是返回一个知道怎样响应方法调用的对象.</p>
<p>例如, regex 匹配返回 Match <a href="http://doc.perl6.org/type/Match" target="_blank" rel="external">对象</a>, 该对象知道怎样响应列表索引, 散列索引, 并能变成匹配的字符串.</p>
<h3 id="为什么我不能把所有的数值都赋值给-Num-类型的变量"><a href="#为什么我不能把所有的数值都赋值给-Num-类型的变量" class="headerlink" title="为什么我不能把所有的数值都赋值给 Num 类型的变量?"></a>为什么我不能把所有的数值都赋值给 Num 类型的变量?</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my Num $x = 42;</div><div class="line"># dies with</div><div class="line"># Type check failed in assignment to &apos;$x&apos;; expected &apos;Num&apos; but got &apos;Int&apos;</div></pre></td></tr></table></figure>
<p><a href="http://doc.perl6.org/type/Num" target="_blank" rel="external">Num</a> 是浮点类型, 与 <a href="http://doc.perl6.org/type/Int" target="_blank" rel="external"> integers</a> 不兼容. 如果你想要一个允许任何数字值的类型约束, 使用 <a href="http://doc.perl6.org/type/Numeric" target="_blank" rel="external">Numeric</a> (它也允许<a href="http://doc.perl6.org/type/Complex" target="_blank" rel="external">复数</a>), 或 <a href="http://doc.perl6.org/type/Real" target="_blank" rel="external">Real</a>如果你想排除复数.</p>
<h2 id="Meta-Questions-and-Advocacy"><a href="#Meta-Questions-and-Advocacy" class="headerlink" title="Meta Questions and Advocacy"></a>Meta Questions and Advocacy</h2><hr>
<h3 id="Perl-6-什么时间会准备好-就是现在吗"><a href="#Perl-6-什么时间会准备好-就是现在吗" class="headerlink" title="Perl 6 什么时间会准备好? 就是现在吗?"></a>Perl 6 什么时间会准备好? 就是现在吗?</h3><hr>
<p>编程语言和它们的编译器的准备就绪不是一个二元决策. 因为它们(语言和实现)能进化, 它们平稳地发展变得更可用. 根据你对编程语言的要求, 它可能适合也可能不适合你.</p>
<p>请查看 <a href="http://perl6.org/compilers/features" target="_blank" rel="external">功能对比矩阵</a> 了解更详尽的实现了的功能.</p>
<p>请注意, Larry Wall 已经在 FOSDEM 2015 会议上宣布, 一个产品级的 Rakudo Perl 6 将会在 2015 圣诞节发布.</p>
<h3 id="为什么我要学习-Perl-6-它有什么了不起的吗"><a href="#为什么我要学习-Perl-6-它有什么了不起的吗" class="headerlink" title="为什么我要学习 Perl 6? 它有什么了不起的吗?"></a>为什么我要学习 Perl 6? 它有什么了不起的吗?</h3><hr>
<p>Perl 6 统一了很多其它编程语言中不经常有的伟大想法. 虽然其中的几种语言提供了其中的某些功能, 但是没有提供全部.</p>
<p>不像大部分语言那样, 它提供了：</p>
<ul>
<li>Perl 6 提供了过程式的, 面向对象的和函数式编程方法。</li>
<li>易于使用的一致性语法, 数据结构中的符号不变性。</li>
<li>完全基于字素的 Unicode 支持, 包括附件 #29</li>
<li>足够清晰的正则表达式, 更易读, 更多功能。</li>
<li>Junctions 允许多个可能性的简单检测, 例如 $a == 1|3|42（意思是 $a 等于 1 或 3 或 42）</li>
<li>相对于全局变量, 动态作用域变量提供了词法作用域备选</li>
<li>强调可组合性和本地作用域以阻止「超距作用」。例如, imports 总是本地作用域的。</li>
<li>易于理解的一致性作用域规则和闭包</li>
<li>强大的面向对象, 含有类和 roles(所有的东西都可以当做对象)。继承、子类型、代码复用。</li>
<li>内省到对象和元对象中</li>
<li>像 PEG 那样用于解析的 grammars</li>
<li>惰性列表</li>
<li>强大的元对象系统</li>
<li>值的 junction</li>
<li>像偏函数和柯里化那样的高阶函数功能更易获取</li>
<li>对于子类型(继承)和代码复用(role 应用)的单独机制</li>
<li>可选的类型标注(渐进类型)</li>
<li>对于子例程和方法, 基于数量, 类型和其它代码约束的强大的运行时多重分派</li>
<li>词法导入</li>
</ul>
<p>它还提供了：</p>
<ul>
<li>闭包</li>
<li>匿名类型</li>
<li>roles 和 traits</li>
<li>具名参数</li>
<li>嵌套签名</li>
<li>签名中对象的解包</li>
<li>惊艳,优雅的语法(不像 Lisp)</li>
<li>更易懂, 显式的作用域规则(不像 Python)</li>
<li>不依赖 eval 的强健的元对象系统(不像 Ruby)</li>
<li>富有表现力的子例程签名(不像Perl 5)</li>
<li>状态变量</li>
<li>不像很多动态语言那样, 调用一个缺失的子例程会在编译时被捕捉到, 并且在某些情况下, 不匹配的签名也能在编译时被捕捉到.</li>
</ul>
<p>请查看 <a href="http://perl6.org/compilers/features" target="_blank" rel="external">功能比较矩阵</a> 获取更多信息.</p>
<h3 id="为什么不把它叫做除了-Perl-以外的其它东西"><a href="#为什么不把它叫做除了-Perl-以外的其它东西" class="headerlink" title="为什么不把它叫做除了 Perl 以外的其它东西?"></a>为什么不把它叫做除了 Perl 以外的其它东西?</h3><hr>
<p>很多人建议, Perl 6 跟之前的 Perl 版本的区别太大了, 我们应该考虑给它改名, 或者考虑到 Perl 6 伤害了 Perl 5, 仅仅拥有同样的名字却有更高的版本号.</p>
<p>Perl 6 仍然叫做 “Perl” 的主要原因是:</p>
<ul>
<li>Perl 6 仍然是一个 perlish 风格的语言, 和之前的版本遵守相同的底层思想(用于微型命名空间的符号, 条条大路通罗马, 吸收了很多自然语言的思想..)</li>
<li>Perl 6 的代码很 perlish.</li>
<li>Perl 仍然是一个强健的品牌名, 我们不想马上抛弃它</li>
<li>找到一个替代的名字很困难. 而且, “camelia” 和 “rakudo” 不是合适的编程语言名</li>
<li>即使 Perl 6 更改了它的名字, Perl 5 也不大可能增加它的版本号为 6.因为 Perl 6 已经根植于人们的头脑中了</li>
</ul>
<h3 id="Perl-6-对我来说足够快了吗"><a href="#Perl-6-对我来说足够快了吗" class="headerlink" title="Perl 6 对我来说足够快了吗?"></a>Perl 6 对我来说足够快了吗?</h3><hr>
<p>那取决于你正在做什么。Perl 6 一直奉行“做对的事情然后做的更快”的哲学进行开发。对于某些东西来说它够快了, 但是需要做的更多。<br>Perl 6 大部分是由志愿者开发的, 但是 Perl 6 的性能在不久的将来有待提高, 因为 MoarVM 后端包含一个现代的即时（JIT）编译器。<br>Perl 5 程序员应该意识到 Perl 6 在面向对象方面有很多内建函数并且还有更多其它的。<br>简单的基准测试会误导除非你在你的 Perl 5脚本中包含了诸如 Moose, 类型检测模块等。</p>
<p>下面这个粗超的基准测试, 使用了所有诸如此类的一般说明, 能展示 Perl 6 在某些类似任务上能和 Perl 5的速度接近。<br>在你的系统上尝试下, 你可能会感到很惊讶!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># perl 6 version</div><div class="line">use v6;</div><div class="line"></div><div class="line">class Foo &#123; has $.i is rw&#125;;</div><div class="line"></div><div class="line">for (1..1_000_000) -&gt; $i &#123;</div><div class="line">    my $obj = Foo.new;</div><div class="line">    $obj.i = $i;</div><div class="line">    say $obj.i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># perl 5 version</div><div class="line">package Foo;</div><div class="line">use 5.10.0;</div><div class="line">use Moose;</div><div class="line"></div><div class="line">has i =&gt; ( is=&gt; &apos;rw&apos;);</div><div class="line"></div><div class="line">for my $i (1..1_000_000) &#123;</div><div class="line">    my $obj = Foo-&gt;new;</div><div class="line">    $obj-&gt;i($i);</div><div class="line">    say $obj-&gt;i;</div><div class="line">&#125;</div><div class="line"></div><div class="line">__PACKAGE__-&gt;meta-&gt;make_immutable;</div><div class="line"></div><div class="line">1;</div></pre></td></tr></table></figure>
<h3 id="更多问题"><a href="#更多问题" class="headerlink" title="更多问题"></a>更多问题</h3><hr>
<p>(目前还没有)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的-Subscripts]]></title>
      <url>http://ohmycloud.github.io/2016/06/01/Perl6%E4%B8%AD%E7%9A%84Subscripts/</url>
      <content type="html"><![CDATA[<h1 id="TITLE"><a href="#TITLE" class="headerlink" title="TITLE"></a>TITLE</h1><hr>
<p>下标</p>
<h1 id="SUBTITLE"><a href="#SUBTITLE" class="headerlink" title="SUBTITLE"></a>SUBTITLE</h1><hr>
<p>通过索引或键访问数据结构中的元素。</p>
<p>通常，人们需要引用集合或数据结构中的一个特定的元素（或特定的元素切片）。从数学标记法中偷学到的，向量 <code>v</code> 的组成部分用 <em>v₁, v₂, v₃</em> 来引用，在 Perl 6 中这个概念叫做 “下标” （或“索引”）。</p>
<h1 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h1><hr>
<p>Perl 6 提供了两个通用的下标接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	   elements are identified by     interface name    supported by</div><div class="line">[ ]	 zero-based indices	              Positional        Array, List, Buf, Match, ...</div><div class="line">&#123; &#125;	 string or object keys            Associative       Hash, Bag, Mix, Match, ...</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>Positional</strong> 下标 (通过 <a href="http://doc.perl6.org/language/operators#postcircumfix_[_]" target="_blank" rel="external">postcircumfix [ ]</a> 通过元素在有序集合中的位置来寻址元素。)索引 0 引用第一个元素， 索引 1 引用第二个元素， 以此类推：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my @chores = &quot;buy groceries&quot;, &quot;feed dog&quot;, &quot;wash car&quot;;</div><div class="line">say @chores[0];  #-&gt; buy groceries</div><div class="line">say @chores[1];  #-&gt; feed dog</div><div class="line">say @chores[2];  #-&gt; wash car</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Associative</strong> 下标 (通过 <a href="http://doc.perl6.org/language/operators#postcircumfix_{_}" target="_blank" rel="external">postcircumfix { }</a>), 不要求集合以任何特定的顺序保存元素 - 相反，它使用一个唯一的键来寻址每个值。键的种类取决于使用的集合： 举个例子， 一个标准的<a href="http://doc.perl6.org/type/Hash" target="_blank" rel="external">散列</a> 使用字符串作为键， 而一个 <a href="http://doc.perl6.org/type/Mix" target="_blank" rel="external">Mix</a> 能使用任意的对象作为键， 等等:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my %grade = Zoe =&gt; &quot;C&quot;, Ben =&gt; &quot;B+&quot;;</div><div class="line">say %grade&#123;&quot;Zoe&quot;&#125;;  #-&gt; C</div><div class="line">say %grade&#123;&quot;Ben&quot;&#125;;  #-&gt; B+</div><div class="line"></div><div class="line">my $stats = ( Date.today =&gt; 4.18, Date.new(2015,  4,  5) =&gt; 17.253 ).Mix;</div><div class="line">say $stats&#123; Date.new(2015, 4, 5) &#125;;  #-&gt; 17.253</div></pre></td></tr></table></figure>
<p>相对于传递单个-单词字符串键给 <code>{ }</code> , 你也可以使用<a href="http://doc.perl6.org/language/quoting#Word_quoting:_qw" target="_blank" rel="external">以尖括号引起单词的结构</a> ，就像它们是后缀操作符一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say %grade&lt;Zoe&gt;;    #-&gt; C</div><div class="line">say %grade&lt;Ben&gt;;    #-&gt; B+</div></pre></td></tr></table></figure>
<p>这实际上仅仅是在编译时被转换为对应 <code>{ }</code> 形式的语法糖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%hash&lt;foo bar&gt;;     # same as %hash&#123; &lt;foo bar&gt; &#125;</div><div class="line">%hash«foo $var»;    # same as %hash&#123; «foo $var» &#125;</div><div class="line">%hash&lt;&lt;foo $var&gt;&gt;;  # same as %hash&#123; &lt;&lt;foo $var&gt;&gt; &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>下标能应用到能返回可下标化对象的任何表达式上， 而不仅仅应用到变量上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say &quot;__Hello__&quot;.match(/__(.*)__/)[0];   #-&gt; ｢Hello｣</div><div class="line">say &quot;__Hello__&quot;.match(/__(.*)__/).[0];  # same, in method notation</div></pre></td></tr></table></figure>
<p>Positional 和 associative  下标并不互相排斥 - 举个例子， <code>Match</code> 对象两个都支持（每个访问不同的数据集）。还有， 为了让列表处理更方便， 类 <code>Any</code> 为<code>位置下标</code>提供了备用的实现，这会把调用者看作含有<code>一个</code>元素的列表。(但是对于关系下标，没有这样的备用实现， 所以会抛出一个异常，当下标被应用到没有实现支持的对象上时。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say 42[0];    #-&gt; 42</div><div class="line">say 42&lt;foo&gt;;  # ERROR: postcircumfix &#123; &#125; not defined for type Int</div></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><p>当通过下标寻址一个不存在的元素所发生的事情取决于正在使用的集合类型。标准的 Array 和 Hash 集合返回它们的<a href="http://doc.perl6.org/routine/of" target="_blank" rel="external">value type constraint</a>  的类型对象（这默认是 <code>Any</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my @array1;     say @array1[10];  #-&gt; (Any)</div><div class="line">my Int @array2; say @array2[10];  #-&gt; (Int)</div><div class="line"></div><div class="line">my %hash1;      say %hash1&lt;foo&gt;;  #-&gt; (Any)</div><div class="line">my Int %hash2;  say %hash2&lt;foo&gt;;  #-&gt; (Int)</div></pre></td></tr></table></figure>
<p>然而， 其它类型的集合可能在寻址不存在的元素的下标时反应也不用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say (0, 10, 20)[3];       #-&gt; Nil</div><div class="line">say bag(&lt;a a b b b&gt;)&lt;c&gt;;  #-&gt; 0</div></pre></td></tr></table></figure>
<p>为了在下标操作中默默地跳过不存在的元素， 查看 <a href="http://doc.perl6.org/language/subscripts#Truncating_slices" target="_blank" rel="external">#Truncating slices</a>  和 <a href="http://doc.perl6.org/language/subscripts#%3Av" target="_blank" rel="external"><code>#:v</code></a> 副词。</p>
<h1 id="From-the-end"><a href="#From-the-end" class="headerlink" title="From the end"></a>From the end</h1><hr>
<p>Positional  索引是从集合的开头计数的， 但是也有一种标记法用于，通过相对于末尾的位置来寻址元素：<code>*-1</code> 引用最后一个元素， <code>*-2</code> 引用倒数第二个元素， 以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my @alphabet = &apos;A&apos; .. &apos;Z&apos;;</div><div class="line">say @alphabet[*-1];  #-&gt; Z</div><div class="line">say @alphabet[*-2];  #-&gt; Y</div><div class="line">say @alphabet[*-3];  #-&gt; X</div></pre></td></tr></table></figure>
<p>注意：星号很重要。在 Perl 6中，如果像在很多其它编程语言中那样传递一个裸的负整数（例如 <code>@alphabet[-1]</code>）， 会抛出错误。</p>
<p>这里实际发生的是， <code>*-1</code> 那样的表达式通过 <a href="http://doc.perl6.org/type/Whatever" target="_blank" rel="external">Whatever</a> 柯里化声明了一个代码对象 - <code>[ ]</code>会把代码对象作为索引， 通过集合的长度作为参数来调用它并使用结果值作为实际的索引。 换句话说，<code>@alphabet[*-1]</code> 变成了 <code>@alphabet[@alphabet.elems - 1]</code>。</p>
<p>这意味着你可以使用任何依赖于集合尺寸的表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say @array[* div 2];  # 选择最中间的那个元素</div><div class="line">say @array[$i % *];   # wrap around a given index (&quot;模运算&quot;)</div><div class="line">say @array[ -&gt; $size &#123; $i % $size &#125; ];  # same as previous</div></pre></td></tr></table></figure>
<h1 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h1><hr>
<p>当需要访问集合中的多个元素时，有一个快捷方式用于处理多个单独的下标操作：仅仅在下标中指定一个<code>索引/键</code>的列表，来取回一个元素的列表 - 也被叫做”切片” - 以相同的顺序。</p>
<p>对于 positional  切片， 你可以混合普通切片和  <a href="http://doc.perl6.org/language/subscripts#From_the_end" target="_blank" rel="external">from-the-end</a> 切片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @alphabet = &apos;a&apos; .. &apos;z&apos;;</div><div class="line">dd @alphabet[15, 4, *-9, 11];  #-&gt; (&quot;p&quot;, &quot;e&quot;, &quot;r&quot;, &quot;l&quot;)</div></pre></td></tr></table></figure>
<p>对于 associative  切片，尖括号形式的切片通常会很方便：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my %color = kiwi =&gt; &quot;green&quot;, banana =&gt; &quot;yellow&quot;, cherry =&gt; &quot;red&quot;;</div><div class="line">dd %color&#123;&quot;cherry&quot;, &quot;kiwi&quot;&#125;;  #-&gt; (&quot;red&quot;, &quot;green&quot;)</div><div class="line">dd %color&lt;cherry kiwi&gt;;       #-&gt; (&quot;red&quot;, &quot;green&quot;)</div><div class="line">dd %color&#123;*&#125;;                 #-&gt; (&quot;green&quot;, &quot;red&quot;, &quot;yellow&quot;)</div></pre></td></tr></table></figure>
<p>要知道切片是由传入 (<a href="http://doc.perl6.org/language/subscripts#Multiple_dimensions" target="_blank" rel="external">one dimension of</a>)下标的类型控制的，而非它的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">subscript	                               result</div><div class="line">any Positional object not covered below	   normal slice</div><div class="line">a Range or infinite sequence	           truncating slice (only for positional subscripts)</div><div class="line">* (Whatever-star)	                       full slice (as if all keys/indices were specified)</div><div class="line">any other object	                       single-element access rather than a slice</div><div class="line">empty	                                   Zen slice</div></pre></td></tr></table></figure>
<p>所以，即使一个单个元素的列表也会返回一个切片， 而一个裸的标量值不会：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dd @alphabet[2,];  #-&gt; (&quot;c&quot;,)</div><div class="line">dd @alphabet[2];   #-&gt; &quot;c&quot;</div></pre></td></tr></table></figure>
<p>(尖括号形式的 associative 下标也没有问题，因为 <a href="http://doc.perl6.org/language/quoting#Word_quoting:_qw" target="_blank" rel="external">word quoting</a>  在单个单词的情况下很方便的返回一个 Str, 但是在多个单词的情况下返回一个 <a href="http://doc.perl6.org/type/Parcel" target="_blank" rel="external">Parcel</a>)。</p>
<p>对于普通的切片，下标的内容 (<a href="http://doc.perl6.org/language/subscripts#Multiple_dimensions" target="_blank" rel="external">the current dimension of</a>) 在它的元素被解释为 <code>索引/键</code> 之前会被展平(flattened)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd @alphabet[0, (1..2, (3,)))];  #-&gt; (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</div></pre></td></tr></table></figure>
<h2 id="Truncating-slices"><a href="#Truncating-slices" class="headerlink" title="Truncating slices"></a>Truncating slices</h2><hr>
<p>通常, 在切片下标中引用不存在的元素会让输出列表包含未定义的值。然而， 如果传递给位置下标的对象是一个 Range 或使用序列操作符构建的无限序列， 它会被自动截断到集合的实际尺寸：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @letters = &lt;a b c d e f&gt;;</div><div class="line">dd @letters[3, 4, 5, 6, 7];  #-&gt; (&quot;d&quot;, &quot;e&quot;, &quot;f&quot;, Any, Any)</div><div class="line">dd @letters[3 .. 7];         #-&gt; (&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)</div></pre></td></tr></table></figure>
<p><a href="http://doc.perl6.org/language/subscripts#From_the_end" target="_blank" rel="external">From-the-end</a>  索引被允许作为范围的端点，代表无限的范围和序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say @array[*-3 .. *];       # select the last three elements</div><div class="line">say @array[0, 2, 4 ... *];  # select all elements with even indices</div></pre></td></tr></table></figure>
<p>如果你不想把你的切片指定为 <code>range/sequence</code> 但仍旧想默默地跳过不存在的元素， 你可以使用 <a href="http://doc.perl6.org/language/subscripts#%3Av" target="_blank" rel="external">#:v</a> 副词。</p>
<h2 id="Zen-slices"><a href="#Zen-slices" class="headerlink" title="Zen slices"></a>Zen slices</h2><hr>
<p>如果你写的下标没有指定任何 <code>索引/键</code> ，那它就会返回被脚注的对象自身。因为它是空的但是返回了全部东西， 这就是所谓的 “Zen slice”。</p>
<p>这和传递一个  Whatever-star （这，像普通的切片， 总是返回一个元素的 Parcel，不管原对象的类型）还有传递一个空的列表都不同（它返回一个空的切片）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %bag := (&quot;orange&quot; =&gt; 1, &quot;apple&quot; =&gt; 3).Bag;</div><div class="line">dd %bag&lt;&gt;;    #-&gt; (&quot;orange&quot;=&gt;1,&quot;apple&quot;=&gt;3).Bag</div><div class="line">dd %bag&#123;&#125;;    #-&gt; (&quot;orange&quot;=&gt;1,&quot;apple&quot;=&gt;3).Bag</div><div class="line">dd %bag&#123;*&#125;;   #-&gt; (1, 3)</div><div class="line">dd %bag&#123;()&#125;;  #-&gt; ()</div></pre></td></tr></table></figure>
<p>这通常被用于把整个 <code>数组/散列</code> 插值到字符串中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @words = &quot;cruel&quot;, &quot;world&quot;;</div><div class="line">say &quot;Hello, @words[]!&quot;  #-&gt; Hello, cruel world!</div></pre></td></tr></table></figure>
<h1 id="Multiple-dimensions"><a href="#Multiple-dimensions" class="headerlink" title="Multiple dimensions"></a>Multiple dimensions</h1><hr>
<p>尚未实现！等到 9 月份？</p>
<h1 id="Modifying-elements"><a href="#Modifying-elements" class="headerlink" title="Modifying elements"></a>Modifying elements</h1><hr>
<h1 id="Autovivification"><a href="#Autovivification" class="headerlink" title="Autovivification"></a>Autovivification</h1><hr>
<p>下标参与 “autovivification”（自动复活），i.e. 这是一种数组和散列在需要时会自动存在的处理， 以至于你没有必要在每一层级预声明集合的类型来构建嵌套的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $beatles;</div><div class="line">$beatles&#123;&quot;White Album&quot;&#125;[0] = &quot;Back in the U.S.S.R.&quot;;  # autovivification!</div><div class="line">say $beatles.perl;  #-&gt; &#123;&quot;White Album&quot; =&gt; [&quot;Back in the U.S.S.R.&quot;]&#125;</div></pre></td></tr></table></figure>
<p><code>$beatles</code>  从未定义开始， 但是它变成了一个 Hash 对象， 因为它在赋值时用 <code>{ }</code> 标注了。 类似地，  <code>$beatles{&quot;White Album”}</code> 变成一个 Array 对象， 因为它在赋值时用 <code>[ ]</code> 标注了。</p>
<p>注意下标本身不会引起 autovivification（自动复活）：它只发生在下标链的结果被赋值时（或变化时）。</p>
<h1 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h1><hr>
<p>下标表达式也可以用在绑定语句的左侧。如果被标注的集合的类型支持， 这会使用指定的容器替换集合里的插槽的值：（给跪了！）</p>
<p>内置的 Array 和 Hash 类型支持这种绑定， 为了允许构建复杂的联动的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my @a = 10, 11, 12, 13;</div><div class="line">my $x = 1;</div><div class="line"></div><div class="line">@a[2] := $x;  # binding! (@a[2] and $x refer to the same container now.)</div><div class="line"></div><div class="line">$x++; @a[2]++;</div><div class="line"></div><div class="line">dd @a;  #-&gt; [10, 11, 3, 13]&lt;&gt;</div><div class="line">dd $x;  #-&gt; 3</div></pre></td></tr></table></figure>
<p>查看 <a href="http://doc.perl6.org/language/subscripts#method_BIND-POS" target="_blank" rel="external">#method BIND-POS</a> 和 <a href="http://doc.perl6.org/language/subscripts#method_BIND-KEY" target="_blank" rel="external">#method BIND-KEY</a> 了解底层机制.</p>
<h1 id="Adverbs"><a href="#Adverbs" class="headerlink" title="Adverbs"></a>Adverbs</h1><hr>
<p>下标操作的返回值和可能存在的副作用能够使用副词来控制。</p>
<p>要知道副词操作符的优先级相对宽松，这可能需要你在合成表达式中添加括号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if $foo || %hash&lt;key&gt;:exists &#123; ... &#125;    # WRONG, tries to adverb the || op</div><div class="line">if $foo || (%hash&lt;key&gt;:exists) &#123; ... &#125;  # correct</div></pre></td></tr></table></figure>
<p>支持的副词有:</p>
<h2 id="exists"><a href="#exists" class="headerlink" title=":exists"></a>:exists</h2><hr>
<p>返回请求的元素是否存在，而不是返回元素实际的值。这能够用于区别未定义值的元素和一点儿也不属于集合部分的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">my @foo = Any, 10;</div><div class="line">dd @foo[0].defined;    #-&gt; False</div><div class="line">dd @foo[0]:exists;     #-&gt; True</div><div class="line">dd @foo[2]:exists;     #-&gt; False</div><div class="line">dd @foo[0, 2]:exists;  #-&gt; (True, False)</div><div class="line"></div><div class="line">my %fruit = apple =&gt; Any, orange =&gt; 10;</div><div class="line">dd %fruit&lt;apple&gt;.defined;       #-&gt; False</div><div class="line">dd %fruit&lt;apple&gt;:exists;        #-&gt; True</div><div class="line">dd %fruit&lt;banana&gt;:exists;       #-&gt; False</div><div class="line">dd %fruit&lt;apple banana&gt;:exists; #-&gt; (True, False)</div></pre></td></tr></table></figure>
<p>也可以对副词取反来测试不存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd %fruit&lt;apple banana&gt;:!exists; #-&gt; (False, True)</div></pre></td></tr></table></figure>
<p>要检查切片的所有元素是否存在， 使用 <a href="http://doc.perl6.org/routine/all" target="_blank" rel="external">all</a> junction:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if all %fruit&lt;apple orange banana&gt;:exists &#123; ... &#125;</div></pre></td></tr></table></figure>
<p><code>:exists</code>  可以和  <a href="http://doc.perl6.org/language/subscripts#%3Adelete" target="_blank" rel="external">:delete</a> 还有 <code>:p/:kv</code> 副词组合 - 这时表达式的行为就由那些副词决定，除了使用表明元素存在的对应 Bool 值替换返回的元素值之外。</p>
<p>查看 <a href="http://doc.perl6.org/language/subscripts#method_EXISTS-POS" target="_blank" rel="external">method EXISTS-POS</a>  和 <a href="http://doc.perl6.org/language/subscripts#method_EXISTS-KEY" target="_blank" rel="external">method EXISTS-KEY</a> 了解底层机制.</p>
<h2 id="delete"><a href="#delete" class="headerlink" title=":delete"></a>:delete</h2><hr>
<p>从集合中删除元素， 除了返回它们的值以外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my @tens = 0, 10, 20, 30;</div><div class="line">dd @tens[3]:delete;     #-&gt; 30</div><div class="line">dd @tens;               #-&gt; [0, 10, 20]&lt;&gt;</div><div class="line"></div><div class="line">my %fruit = apple =&gt; 5, orange =&gt; 10, banana =&gt; 4, peach =&gt; 17;</div><div class="line">dd %fruit&lt;apple&gt;:delete;         #-&gt; 5</div><div class="line">dd %fruit&lt;peach orange&gt;:delete;  #-&gt; (17, 10)</div><div class="line">dd %fruit;                       #-&gt; &#123;banana =&gt; 4&#125;&lt;&gt;</div></pre></td></tr></table></figure>
<p>使用否定形式的副词，元素实际上不会被删除。这意味着你可以传递一个标记，让它变成有条件的删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dd %fruit&lt;apple&gt; :delete($flag);  # deletes the element only if $flag is</div><div class="line">                                  # true, but always returns the value.</div></pre></td></tr></table></figure>
<p>能和 <code>:exists</code> 还有 <code>:p/:kv/:k/:v</code> 副词组合 - 这时返回值由那些副词决定， 但是同时元素也会被删除。</p>
<p>查看 <a href="http://doc.perl6.org/language/subscripts#method_DELETE-POS" target="_blank" rel="external">method DELETE-POS</a> and <a href="http://doc.perl6.org/language/subscripts#method_DELETE-KEY" target="_blank" rel="external">method DELETE-KEY</a> 了解底层机制.</p>
<h2 id="p"><a href="#p" class="headerlink" title=":p"></a>:p</h2><hr>
<p>以 Pair 的形式，返回元素的<code>索引/键</code> 和元素值， 并默默跳过不存在的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my @tens = 0, 10, 20, 30;</div><div class="line">dd @tens[1]:p;        #-&gt; 1 =&gt; 10</div><div class="line">dd @tens[0, 4, 2]:p;  #-&gt; (0 =&gt; 0, 2 =&gt; 20)</div><div class="line"></div><div class="line">my %month = Jan =&gt; 1, Feb =&gt; 2, Mar =&gt; 3;</div><div class="line">dd %month&lt;Feb&gt;:p;          #-&gt; &quot;Feb&quot; =&gt; 2</div><div class="line">dd %month&lt;Jan Foo Mar&gt;:p;  #-&gt; (&quot;Jan&quot; =&gt; 1, &quot;Mar&quot; =&gt; 3)</div></pre></td></tr></table></figure>
<p>如果你不想跳过不存在的元素， 使用否定形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd %month&lt;Jan Foo Mar&gt;:!p;  #-&gt; (&quot;Jan&quot; =&gt; 1, &quot;Foo&quot; =&gt; Any, &quot;Mar&quot; =&gt; 3)</div></pre></td></tr></table></figure>
<p>能和 <code>:exists</code> 还有 <code>:delete</code> 组合。</p>
<p>也可以查看  <a href="http://doc.perl6.org/routine/pairs" target="_blank" rel="external">pairs</a> 子例程.</p>
<h2 id="kv"><a href="#kv" class="headerlink" title=":kv"></a>:kv</h2><hr>
<p>以列表的形式返回元素的<code>索引/键</code>和<code>值</code> , 并默默地跳过不存在的元素。 当作用在切片上时，返回值是一个展平的键和值交叉着的单个列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my @tens = 0, 10, 20, 30;</div><div class="line">dd @tens[1]:kv;        #-&gt; (1, 10)</div><div class="line">dd @tens[0, 4, 2]:kv;  #-&gt; (0, 0, 2, 20)</div><div class="line"></div><div class="line">my %month = Jan =&gt; 1, Feb =&gt; 2, Mar =&gt; 3;</div><div class="line">dd %month&lt;Feb&gt;:kv;          #-&gt; (&quot;Feb&quot;, 2)</div><div class="line">dd %month&lt;Jan Foo Mar&gt;:kv;  #-&gt; (&quot;Jan&quot;, 1, &quot;Mar&quot;, 3)</div></pre></td></tr></table></figure>
<p>如果你不想跳过不存在的元素， 使用否定形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd %month&lt;Jan Foo Mar&gt;:!kv;  #-&gt; (&quot;Jan&quot;, 1, &quot;Foo&quot;, Any, &quot;Mar&quot;, 3)</div></pre></td></tr></table></figure>
<p>这个副词一般用于遍历切片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for %month&lt;Feb Mar&gt;:kv -&gt; $month, $i &#123;</div><div class="line">    say &quot;$month had &#123;Date.new(2015, $i, 1).days-in-month&#125; days in 2015&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>能和 <code>:exists</code> 还有 <code>:delete</code> 组合。</p>
<p>也可以查看  <a href="http://doc.perl6.org/routine/kv" target="_blank" rel="external">kv</a> 子例程.</p>
<h2 id="k"><a href="#k" class="headerlink" title=":k"></a>:k</h2><hr>
<p>只返回元素的<code>索引/键</code> , 而不是它们的值, 并默默地跳过不存在的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my @tens = 0, 10, 20, 30;</div><div class="line">dd @tens[1]:k;        #-&gt; 1</div><div class="line">dd @tens[0, 4, 2]:k;  #-&gt; (0, 2)</div><div class="line"></div><div class="line">my %month = Jan =&gt; 1, Feb =&gt; 2, Mar =&gt; 3;</div><div class="line">dd %month&lt;Feb&gt;:k;          #-&gt; &quot;Feb&quot;</div><div class="line">dd %month&lt;Jan Foo Mar&gt;:k;  #-&gt; (&quot;Jan&quot;, &quot;Mar&quot;)</div></pre></td></tr></table></figure>
<p>如果你不想跳过不存在的元素， 使用否定形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd %month&lt;Jan Foo Mar&gt;:!k;  #-&gt; (&quot;Jan&quot;, &quot;Foo&quot;, &quot;Mar&quot;)</div></pre></td></tr></table></figure>
<p>还可以查看  <a href="http://doc.perl6.org/routine/keys" target="_blank" rel="external">keys</a> 子例程.</p>
<h2 id="v"><a href="#v" class="headerlink" title=":v"></a>:v</h2><hr>
<p>返回元素的裸值（不是有可能返回一个可变值容器），并默默跳过不存在的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my @tens = 0, 10, 20, 30;</div><div class="line">dd @tens[1]:v;        #-&gt; 10</div><div class="line">dd @tens[0, 4, 2]:v;  #-&gt; (0, 20)</div><div class="line">@tens[3] = 31;        # OK</div><div class="line">@tens[3]:v = 31;      # ERROR, cannot assign to immutable integer value</div><div class="line"></div><div class="line">my %month = Jan =&gt; 1, Feb =&gt; 2, Mar =&gt; 3;</div><div class="line">dd %month&lt;Feb&gt;:v;          #-&gt; 2</div><div class="line">dd %month&lt;Jan Foo Mar&gt;:v;  #-&gt; (1, 3)</div></pre></td></tr></table></figure>
<p>如果你不想跳过不存在的元素， 使用否定形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd %month&lt;Jan Foo Mar&gt;:!v;  #-&gt; (1, Any, 3)</div></pre></td></tr></table></figure>
<p>还可以查看  <a href="http://doc.perl6.org/routine/values" target="_blank" rel="external">values</a> 子例程.</p>
<h1 id="Custom-types"><a href="#Custom-types" class="headerlink" title="Custom types"></a>Custom types</h1><hr>
<p>这页描述的下标接口并不意味着和 Perl 6 的内置集合类型相排斥 - 你可以（并且应该）为任何想通过索引或键提供数据访问的自定义类型重用它们。</p>
<p>你不必手动重载  <a href="http://doc.perl6.org/routine/[%20]#postcircumfix_[_]" target="_blank" rel="external">postcircumfix [ ]</a> 和  <a href="http://doc.perl6.org/" target="_blank" rel="external">postcircumfix { }</a>  操作符并重新实现它们所有的戏法， 为了实现它， 相反，你可以依赖这个事实， 在幕后，它们的标准实现分派给了一个定义良好的底层方法集。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">当你这样写:	         这会在幕后调用如下底层方法:</div><div class="line">%foo&lt;aa&gt;	        %foo.AT-KEY(&quot;aa&quot;)</div><div class="line">%foo&lt;aa&gt;:delete	    %foo.DELETE-KEY(&quot;aa&quot;)</div><div class="line">@foo[3,4,5]	        @foo.AT-POS(3), @foo.AT-POS(4), @foo.AT-POS(5)</div><div class="line">@foo[*-1]	        @foo.AT-POS(@foo.elems - 1)</div></pre></td></tr></table></figure>
<p>所以， 为了让你的下标工作， 你只需要为你的自定义类型实现或委托那些底层方法（<a href="http://doc.perl6.org/language/subscripts#Methods_to_implement_for_positional_subscripting" target="_blank" rel="external">下面描述详情</a>）。</p>
<p>如果你这样做了， 你还应该让你的类型各自遵守 <a href="http://doc.perl6.org/type/Positional" target="_blank" rel="external">Positional</a> 或 <a href="http://doc.perl6.org/type/Associative" target="_blank" rel="external">Associative</a> role</p>
<h2 id="Custom-type-example"><a href="#Custom-type-example" class="headerlink" title="Custom type example"></a>Custom type example</h2><hr>
<p>设想一下 HTTP::Header 类型，尽管它作为一个有特定行为的自定义类，却能像散列那样索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my $request = HTTP::Request.new(GET =&gt; &quot;perl6.org&quot;);</div><div class="line">say $request.header.WHAT;  #-&gt; (HTTP::Header)</div><div class="line"></div><div class="line">$request.header&lt;Accept&gt; = &quot;text/plain&quot;;</div><div class="line">$request.header&#123;&apos;Accept-&apos; X~ &lt;Charset Encoding Language&gt;&#125; = &lt;utf-8 gzip en&gt;;</div><div class="line">$request.header.push(&apos;Accept-Language&apos; =&gt; &quot;fr&quot;);  # like .push on a Hash</div><div class="line"></div><div class="line">say $request.header&lt;Accept-Language&gt;.perl;  #-&gt; [&quot;en&quot;, &quot;fr&quot;]</div><div class="line"></div><div class="line">my $rawheader = $request.header.Str;  # stringify according to HTTP spec</div></pre></td></tr></table></figure>
<p>实现这个类的最简单的方法是，给它一个 Hash 类型的属性，并把所有的下标和迭代相关功能性委托给那个属性。（使用一个自定义类型约束来确保使用者不会在里面插入任何不合法的值）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class HTTP::Header does Associative is Iterable &#123;</div><div class="line">    subset StrOrArrayOfStr where Str | ( Array &amp; &#123;.all ~~ Str&#125; );</div><div class="line"></div><div class="line">    has %!fields of StrOrArrayOfStr</div><div class="line">                 handles &lt;AT-KEY EXISTS-KEY DELETE-KEY push</div><div class="line">                          iterator list kv keys values&gt;;</div><div class="line"></div><div class="line">    method Str &#123; #`[not shown, for brevity] &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而， HTTP header 字段名被认为是大小写无关的（更偏好驼峰法）。我们可以通过把 <code>*-key</code> 和 <code>push</code> 方法拿到 <code>handles</code> 列表的外面来容纳它， 并像这样各自实现它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">method AT-KEY     ($key) is rw &#123; %!fields&#123;normalize-key $key&#125;        &#125;</div><div class="line">method EXISTS-KEY ($key)       &#123; %!fields&#123;normalize-key $key&#125;:exists &#125;</div><div class="line">method DELETE-KEY ($key)       &#123; %!fields&#123;normalize-key $key&#125;:delete &#125;</div><div class="line">method push (*@_) &#123; #`[not shown, for brevity] &#125;</div><div class="line"></div><div class="line">sub normalize-key ($key) &#123; $key.subst(/\w+/, *.tc, :g) &#125;</div></pre></td></tr></table></figure>
<p>注意下标  <code>%!fields</code> 返回一个适当的 rw 容器， 而我们的 <code>AT-KEY</code> 能够简单地传递。</p>
<p>然而， 我们可能倾向于少一点对用户输入的限制， 相反我们自己关心字段值的消毒。那种情况下，我们可以移除 <code>%!fields</code> 上的 <code>StrOrArrayOfStr</code>  类型约束， 并在赋值时使用返回自定义的关心消毒值的 Proxy 容器来替换我们的 <code>AT-KEY</code> 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">multi method AT-KEY (::?CLASS:D: $key) is rw &#123;</div><div class="line">    my $element := %!fields&#123;normalize-key $key&#125;;</div><div class="line"></div><div class="line">    Proxy.new(</div><div class="line">        FETCH =&gt; method () &#123; $element &#125;,</div><div class="line"></div><div class="line">        STORE =&gt; method ($value) &#123;</div><div class="line">            $element = do given $value».split(/&apos;,&apos; \s+/).flat &#123;</div><div class="line">                when 1  &#123; .[0] &#125;    # a single value is stored as a string</div><div class="line">                default &#123; .Array &#125;  # multiple values are stored as an array</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意把方法声明为 <code>multi</code> 并把它限制为 <code>:D</code> (defined invocants) 确保未定义情况被传递给由 Any（这在自动复活中被调用） 提供的默认实现。（我去，翻译不来哦！）</p>
<h2 id="Methods-to-implement-for-positional-subscripting"><a href="#Methods-to-implement-for-positional-subscripting" class="headerlink" title="Methods to implement for positional subscripting"></a>Methods to implement for positional subscripting</h2><hr>
<p>为了通过  <a href="http://doc.perl6.org/routine/[%20]#postcircumfix_[_]" target="_blank" rel="external">postcircumfix [ ]</a>  让基于索引的下标在你的自定义类型中工作，你应该至少实现下面的  <code>elems</code>, <code>AT-POS</code> 和 <code>EXISTS-POS-</code> 还有其它可选项。</p>
<h3 id="elems-方法"><a href="#elems-方法" class="headerlink" title="elems 方法"></a>elems 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method elems (::?CLASS:D:)</div></pre></td></tr></table></figure>
<p>预期返回一个数字，用于表明对象中有多少个可标注的元素。 可能被用户直接调用， 并且当从末尾索引元素的时候， 还会被  <code>postcircumfix [ ]</code> 调用， 就像 <code>@foo[*-1]</code> 中那样。</p>
<p>如果没有实现这个方法， 你的类型会从 Any 继承默认的实现， 对定义过的调用者这总是返回 1 - 这最不可能是你想要的。 所以， 如果不能从你的位置类型知晓元素的个数， 那就添加一个 fails 或 dies 实现， 以避免沉默地做了错事。</p>
<h3 id="AT-POS-方法"><a href="#AT-POS-方法" class="headerlink" title="AT-POS 方法"></a>AT-POS 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method AT-POS (::?CLASS:D: $index)</div></pre></td></tr></table></figure>
<p>期望返回 <code>$index</code> 位置处的元素。这就是 <code>postcircumfix [ ]</code> 通常调用的方法。<br>如果你想让元素可变(像它们用于 Array 类型那样), 你就必须确保以 item 容器的形式返回它, 并在被赋值时更新它。(记得使用 <code>return-rw</code> 或 <code>rw</code> 子例程 trait 以使它工作; 查看例子。)</p>
<h3 id="EXISTS-POS-方法"><a href="#EXISTS-POS-方法" class="headerlink" title="EXISTS-POS 方法"></a>EXISTS-POS 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method EXISTS-POS (::?CLASS:D: $index)</div></pre></td></tr></table></figure>
<p>返回一个布尔值以表明在 <code>$index</code> 位置处是否有元素。这就是引用 <code>@foo[42]:exists</code> 时, <code>postcircumfix [ ]</code> 所调用的方法。</p>
<p>元素”存在”意味着什么, 取决于你的类型。</p>
<p>如果你没有实现它, 你的类型会从 <code>Any</code> 那儿继承默认的实现, 对于索引 0 它会返回 True, 对于 其它索引它会返回 <code>false</code> – 这可能不是你想要的。所以如果你的类型不能做元素存在检测, 那就添加一个 fails 或 die 实现, 以避免静默地做错事情。</p>
<h3 id="DELETE-POS-方法"><a href="#DELETE-POS-方法" class="headerlink" title="DELETE-POS 方法"></a>DELETE-POS 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method DELETE-POS (::?CLASS:D: $index)</div></pre></td></tr></table></figure>
<p>删除 <code>$index</code> 处的元素, 并返回它所删除的这个元素。这就是引用 <code>@foo[42]:delete</code> 时, <code>postcircumfix [ ]</code> 所调用的方法。</p>
<p>“删除”元素的意思是什么, 取决于你的类型。</p>
<p> 实现这个方法是可选的; 如果你没有实现它, 那么用户尝试从这种类型的对象中删除元素会得到一个合适的错误信息。</p>
<h3 id="ASSIGN-POS-方法"><a href="#ASSIGN-POS-方法" class="headerlink" title="ASSIGN-POS 方法"></a>ASSIGN-POS 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method ASSIGN-POS (::?CLASS:D: $index, $new)</div></pre></td></tr></table></figure>
<p>把 <code>$index</code> 位置处的元素设置为 <code>$new</code> 值。实现这个方法完全是可选的; 如果你没有实现这个方法, 那么会使用 <code>self.AT-POS($index) = $new</code>  代替, 如果你确实实现了该方法, 那么确保它拥有相同的效果。  </p>
<p>这意味着 opt-in 性能优化, 以至于简单的诸如 <code>@numbers[5] = &quot;five&quot;</code> 的赋值能在不调用 <code>AT-POS</code>(这必须创建并返回一个潜在的昂贵的容器对象) 方法时操作。</p>
<p>注意, 实现 <code>ASSIGN-POS</code> 不能解除让 <code>AT-POS</code> 变成一个 <code>rw</code> 方法, 因为诸如 <code>@numbers[5]++</code> 的不太重要的赋值/修改 仍旧会使用 <code>AT-POS</code>。</p>
<h3 id="BIND-POS-方法"><a href="#BIND-POS-方法" class="headerlink" title="BIND-POS 方法"></a>BIND-POS 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method BIND-POS (::?CLASS:D: $index, \new)</div></pre></td></tr></table></figure>
<p>把值或容器 <code>new</code> 绑定给位置 <code>$index</code> 处的插槽上, 替换那儿能找到的任何容器。这是当你这样写的时候所调用的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $x = 10;</div><div class="line">@numbers[5] := $x;</div></pre></td></tr></table></figure>
<p>一般的数组类支持这以允许创建复杂的链接数据结构,  但是对于更特定领域类型它可能没有意义, 所以不强求去实现它。如果你没有实现该方法, 用户会获得一个合适的错误信息, 当它们尝试绑定到这种类型的对象的一个位置插槽上时。</p>
<h2 id="Methods-to-implement-for-associative-subscripting"><a href="#Methods-to-implement-for-associative-subscripting" class="headerlink" title="Methods to implement for associative subscripting"></a>Methods to implement for associative subscripting</h2><hr>
<p>为了通过 <code>postcircumfix { }</code> 让基于键的下标能够工作于你的自定义类型中, 你应该至少实现 <code>AT-KEY</code> 和 <code>EXISTS-KEY</code> – 还有可选地实现下面的方法。</p>
<h3 id="AT-KEY-方法"><a href="#AT-KEY-方法" class="headerlink" title="AT-KEY 方法"></a>AT-KEY 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method AT-KEY (::?CLASS:D: $key)</div></pre></td></tr></table></figure>
<p>返回和 <code>$key</code> 相关联的元素。这正是 <code>postcircumfix { }</code> 通常所调用的方法。</p>
<p>如果你想让元素可变(就像它们是为了内置的 Hash 类型), 你必须确保以 item 容器的形式返回它, 并在被赋值时更新它。(记得使用 <code>return-rw</code> 或 <code>is rw</code> 子例程 trait 以使其有效; 查看例子。)</p>
<p>另一方面, 如果你想让你的集合只读, 请直接返回非容器值。</p>
<h3 id="EXISTS-KEY-方法"><a href="#EXISTS-KEY-方法" class="headerlink" title="EXISTS-KEY 方法"></a>EXISTS-KEY 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method EXISTS-KEY (::?CLASS:D: $key)</div></pre></td></tr></table></figure>
<p>返回一个布尔值以表明和 <code>$key</code> 相关联的元素是否存在。这就是引用 <code>%foo&lt;aa&gt;:exists</code> 时, <code>postcircumfix { }</code> 所调用的方法。</p>
<p>元素”存在”意味着什么, 取决于你的类型。</p>
<p>如果你没有实现它, 你的类型会从 <code>Any</code> 那儿继承默认的实现, 这通常返回 False – 这可能不是你想要的。所以如果你的类型不能做元素存在检测, 那就添加一个 fails 或 die 实现, 以避免静默地做错事情</p>
<h3 id="DELETE-KEY-方法"><a href="#DELETE-KEY-方法" class="headerlink" title="DELETE-KEY 方法"></a>DELETE-KEY 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method DELETE-KEY (::?CLASS:D: $key)</div></pre></td></tr></table></figure>
<p>删除和 <code>$key</code> 相关联的元素, 并返回它所删除的这个元素。这就是引用 <code>%foo&lt;aa&gt;:delete</code> 时, <code>postcircumfix { }</code> 所调用的方法。</p>
<p>“删除”元素的意思是什么, 取决于你的类型 – 尽管它通常让 <code>EXISTS-KEY</code> 因为那个键变为 <code>False</code>。</p>
<p> 实现这个方法是可选的; 如果你没有实现它, 那么用户尝试从这种类型的对象中删除元素会得到一个合适的错误信息。</p>
<h3 id="ASSIGN-KEY-方法"><a href="#ASSIGN-KEY-方法" class="headerlink" title="ASSIGN-KEY 方法"></a>ASSIGN-KEY 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method ASSIGN-KEY (::?CLASS:D: $key, $new)</div></pre></td></tr></table></figure>
<p>把和 <code>$key</code>  相关联的元素设置为 <code>$new</code> 值。实现这个方法完全是可选的; 如果你没有实现这个方法, 那么会使用 <code>self.AT-KEY($key) = $new</code> 代替, 如果你确实实现了该方法, 那么确保它拥有相同的效果。  </p>
<p>这意味着 opt-in 性能优化, 以至于简单的诸如 <code>%age&lt;Claire&gt; = 29</code> 的赋值能在不调用 <code>AT-KEY</code>(这必须创建并返回一个潜在的昂贵的容器对象) 方法时操作。</p>
<p>注意, 实现 <code>ASSIGN-KEY</code> 不能解除让 <code>AT-KEY</code> 变成一个 <code>rw</code> 方法, 因为诸如 <code>%age&lt;Claire&gt;++</code> 的不太重要的赋值/修改 仍旧会使用 <code>AT-KEY</code>。</p>
<h3 id="BIND-KEY-方法"><a href="#BIND-KEY-方法" class="headerlink" title="BIND-KEY 方法"></a>BIND-KEY 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi method BIND-KEY (::?CLASS:D: $key, \new)</div></pre></td></tr></table></figure>
<p>把值或容器 <code>new</code> 绑定给跟 <code>$key</code> 相关联的插槽上, 替换那儿能找到的任何容器。这是当你这样写的时候所调用的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $x = 10;</div><div class="line">%age&lt;Claire&gt; := $x;</div></pre></td></tr></table></figure>
<p>一般的散列类支持这以允许创建复杂的链接数据结构,  但是对于更特定领域类型它可能没有意义, 所以不强求去实现它。如果你没有实现该方法, 用户会获得一个合适的错误信息, 当它们尝试绑定到这种类型的对象的一个位置插槽上时。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何在Perl6中创建Grammar]]></title>
      <url>http://ohmycloud.github.io/2016/05/14/%E5%A6%82%E4%BD%95%E5%9C%A8Perl6%E4%B8%AD%E5%88%9B%E5%BB%BAGrammar/</url>
      <content type="html"><![CDATA[<p>检查 module 的名字是否 遵循 Perl 6 的命名规范。模块的名字可以是使用 2 个冒号分割的标识符, 例如  <code>File::Compare</code> 。标识符必须以字母字符 (a-z) 或下划线开头， 后面跟着 0 个 或多个字母数字字符。但是并没有那么简单, 有些模块的名字只有一个标识符而没有冒号，例如  Bailador ， 而其它模块可能有多个标识符和 <code>::</code> 组成。这看起来正符合 grammar 的胃口！</p>
<h2 id="定义-grammar"><a href="#定义-grammar" class="headerlink" title="定义 grammar"></a>定义 grammar</h2><hr>
<p>   Perl 6 Grammars 是由 regexes 构建的。 我需要 2 个 regexes： 一个用于匹配标识符, 一个用于匹配双冒号分隔符。对于标识符 regex， 我使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;[A..Za..z_]&gt;            # begins with letter or underscore</div><div class="line">&lt;[A..Za..z0..9]&gt; ** 0..* # zero or more alpanumeric</div></pre></td></tr></table></figure>
<p>   Perl 6 中，字符类是使用  <code>&lt;[ ... ]&gt;</code> 来定义的， 范围是使用 范围操作符 <code>..</code> 代替了短划线 <code>-</code>.  量词使用 <code>** 0..*</code> 代替了 <code>{0,}</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\:\: # colon pairs</div></pre></td></tr></table></figure>
<p>   使用 <code>grammar</code> 关键字定义 Grammars, 关键字后跟着 grammar 的名字. 我把这个 grammar 叫做 <code>Legal-Module-Name</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grammar Legal-Module-Name&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 现在我能把 regexes 作为 tokens 添加到 grammar 中了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">grammar Legal-Module-Name&#123;</div><div class="line">  token identifier  &#123;</div><div class="line">    # leading alpha or _ only</div><div class="line">    &lt;[A..Za..z_]&gt;</div><div class="line">    &lt;[A..Za..z0..9]&gt; ** 0..*</div><div class="line">  &#125;</div><div class="line">  token separator  &#123;</div><div class="line">    \:\: # colon pairs</div><div class="line">  &#125;&#125;</div></pre></td></tr></table></figure>
<p>每一个 Grammar 中都要有一个 叫做 <code>TOP</code> 的 token，它是这个 grammar 的起始点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">grammar Legal-Module-Name&#123;</div><div class="line">  token TOP  &#123; # identifier followed by zero or more separator identifier pairs</div><div class="line">    ^ &lt;identifier&gt; [&lt;separator&gt;&lt;identifier&gt;] ** 0..* $  </div><div class="line">  &#125;</div><div class="line">  token identifier  &#123;</div><div class="line">    # leading alpha or _ only</div><div class="line">    &lt;[A..Za..z_]&gt;</div><div class="line">    &lt;[A..Za..z0..9]&gt; ** 0..*</div><div class="line">  &#125;</div><div class="line">  token separator  &#123;</div><div class="line">    \:\: # colon pairs</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>TOP</code> 定义了一个合法的模块名，它以一个标识符 token 开始，然后是 0 个或多个 分隔符和标识符对儿。 这很好写并且很容易维护。假设我现在想要修改分隔符规则来包含短划线 (‘-‘)，我只需更新分隔符 token 的 regex， 不需要更新 <code>TOP</code> 了。</p>
<h2 id="使用-grammar"><a href="#使用-grammar" class="headerlink" title="使用 grammar"></a>使用 grammar</h2><hr>
<p>Grammar 的 <code>parse</code> 方法对一个字符串应用定义的 grammar， 如果解析成功就返回一个 match 对象。这段代码解析了 <code>$proposed_module_name</code> 字符串, 结果要么打印出 match 对象，要么打印错误信息如果模块名不合法的话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my $proposed_module_name = &apos;Super::New::Module&apos;;</div><div class="line">my $match_obj = Legal-Module-Name.parse($proposed_module_name);</div><div class="line"></div><div class="line">if $match_obj&#123;</div><div class="line">    say $match_obj;</div><div class="line">&#125;else&#123;</div><div class="line">    say &apos;Invalid module name!&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码打印:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">｢Super::New::Module｣</div><div class="line"> identifier =&gt; ｢Super｣</div><div class="line"> separator =&gt; ｢::｣</div><div class="line"> identifier =&gt; ｢New｣</div><div class="line"> separator =&gt; ｢::｣</div><div class="line"> identifier =&gt; ｢Module｣</div></pre></td></tr></table></figure>
<h2 id="从-match-object-中提取内容"><a href="#从-match-object-中提取内容" class="headerlink" title="从 match object 中提取内容"></a>从 match object 中提取内容</h2><hr>
<p>我们能从 match 对象中提取匹配的 tokens。这里会使用 Perl 6 中到处可见的 quoting 语法（例如 命名正则和散列键）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say $match_obj&lt;identifier&gt;[0].Str; # Super</div><div class="line">say $match_obj&lt;identifier&gt;[1].Str; # New</div><div class="line">say $match_obj&lt;identifier&gt;[2].Str; # Module</div><div class="line">say $match_obj&lt;identifier&gt;;        # all 3 captures</div></pre></td></tr></table></figure>
<h2 id="Action-类"><a href="#Action-类" class="headerlink" title="Action 类"></a>Action 类</h2><hr>
<p>Perl 6 允许你添加一个 action 类来为匹配到的 tokens 定义额外的行为。我想在模块名有太多的标识符时给出一个警告，换句话说，它是一个合法的名字，但是用户可能想要缩短简化它。 首先我定义了 action 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Module::Name::Actions&#123;</div><div class="line">  method TOP($/)</div><div class="line">  &#123;</div><div class="line">    if $&lt;identifier&gt;.elems &gt; 5</div><div class="line">    &#123;</div><div class="line">      warn &apos;Module name has a lot of identifiers, consider simplifying the name&apos;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是一个 Perl 6 的类的定义。 我添加了一个叫做 <code>TOP</code> 的方法，它匹配 grammar 中的第一个 token。 我使用 命名指正则语法来计算所有的标识符匹配，如果多于 5 个就发出警告。 这不会让代码停止运行， 但是会引起使用者重新考虑他们选择的模块名字。</p>
<p>然后我初始化了一个 action 对象，并且把它作为参数传递给了Grammar 的 <code>parse</code> 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $actions = Module::Name::Actions.new;</div><div class="line">my $match_obj = Legal-Module-Name.parse($proposed_module_name, :actions($actions));</div></pre></td></tr></table></figure>
<p>解析期间， 每当 这个 token (TOP) 出现时，都会调用一次匹配 action 类中的 TOP 方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Actions和抽象语法树]]></title>
      <url>http://ohmycloud.github.io/2016/05/12/Actions%E5%92%8C%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>有一段结构化的文本, 写一个 Grammar 来解析它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">name = Animal Facts</div><div class="line">author = jnthn</div><div class="line"></div><div class="line">[cat]</div><div class="line">desc = The smartest and cutest</div><div class="line">cuteness = 100000</div><div class="line"></div><div class="line">[dugong]</div><div class="line">desc = The cow of the sea</div><div class="line">cuteness = -10</div><div class="line"></div><div class="line">[magpie]</div><div class="line">desc = crow; raven; rook; jackdaw; chough; magpie; jay</div><div class="line">cuteness = 99</div></pre></td></tr></table></figure>
<p>每一段都是一个章节, 有的章节没有<code>[cat]</code>这样的标题, 要求 grammar 生成一个散列, 散列的键是方括号中的单词, 如果没有就默认为 <code>_</code> , 散列的值是一个散列的数组, 数组里面的每个散列的键为等号左边的单词, 键值为等号右边的字符。Grammar 如下:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="comment">#use Grammar::Debugger;</span></div><div class="line">grammar INIFile::Grammar &#123;</div><div class="line">    token TOP &#123;</div><div class="line">        ^</div><div class="line">        &lt;entries&gt;     <span class="comment"># 条目</span></div><div class="line">        &lt;section&gt;+    <span class="comment"># 章节</span></div><div class="line">        $</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token section &#123;</div><div class="line">        <span class="string">'['</span> ~ <span class="string">']'</span> &lt;key&gt; \n</div><div class="line">        &lt;entries&gt; <span class="comment"># 每个章节含有多个条目 entry</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token entries &#123;</div><div class="line">        [</div><div class="line">        | &lt;entry&gt; \n</div><div class="line">        | \n <span class="comment"># entry 可以为空</span></div><div class="line">        ]+</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token entry   &#123; &lt;key&gt; \h* <span class="string">'='</span> \h* &lt;value&gt; &#125;</div><div class="line">    token key     &#123; \w+                       &#125;</div><div class="line">    token value   &#123; \N+                       &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class INIFileActions &#123;</div><div class="line">    method entries($/) &#123;</div><div class="line">        <span class="keyword">my</span> %entries;</div><div class="line">        <span class="keyword">for</span> $&lt;entry&gt; -&gt; $e &#123;</div><div class="line">            %entries&#123;$e&lt;key&gt;&#125; := ~$e&lt;value&gt;;</div><div class="line">        &#125;</div><div class="line">        make %entries;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method TOP($/) &#123;</div><div class="line">        <span class="keyword">my</span> %result;</div><div class="line">        %result&lt;<span class="number">_</span>&gt; := $&lt;entries&gt;.ast;</div><div class="line">        <span class="keyword">for</span> $&lt;section&gt; -&gt; $sec &#123;</div><div class="line">            %result&#123;$sec&lt;key&gt;&#125; := $sec&lt;entries&gt;.ast;</div><div class="line">        &#125;</div><div class="line">        make %result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $m := INIFile::Grammar.parse(Q&#123;</div><div class="line">name = Animal Facts</div><div class="line">author = jnthn</div><div class="line"></div><div class="line">[cat]</div><div class="line">desc = The smartest <span class="keyword">and</span> cutest</div><div class="line">cuteness = <span class="number">100000</span></div><div class="line"></div><div class="line">[dugong]</div><div class="line">desc = The cow of the sea</div><div class="line">cuteness = -<span class="number">10</span></div><div class="line"></div><div class="line">[magpie]</div><div class="line">desc = crow; raven; rook; jackdaw; chough; magpie; jay</div><div class="line">cuteness = <span class="number">99</span></div><div class="line">&#125;, :actions(INIFileActions));</div><div class="line"></div><div class="line"><span class="keyword">my</span> %sections := $m.ast;</div><div class="line"></div><div class="line"><span class="keyword">for</span> %sections -&gt; $sec &#123;</div><div class="line">    <span class="keyword">say</span>(<span class="string">"章节: &#123;$sec.key&#125;"</span>);</div><div class="line">    <span class="keyword">for</span> $sec.value -&gt; $entry &#123;</div><div class="line">        <span class="keyword">say</span>(<span class="string">"    &#123;$entry.key&#125;: &#123;$entry.value&#125;"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>make</code> 是一个函数, 接收单个参数, <code>make</code> 的作用是, 对于每一个 <code>method</code> 中对应的 <code>$_</code> , 存储生成的抽象语法树(AST)(片段)到 <code>$/</code> 中。 <code>.ast</code> 用于从已保存的 AST 抽象语法树中检索提取 AST (片段), <code>»</code> 相当于一个循环, 即检索每一个 <code>$&lt;entry&gt;</code> 之类的语法树。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">grammar INIFile::Grammar &#123;</div><div class="line">    token TOP &#123;</div><div class="line">        ^</div><div class="line">        &lt;section&gt;+    <span class="comment"># 章节</span></div><div class="line">        $</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token section &#123;</div><div class="line">        [ <span class="string">'['</span> ~ <span class="string">']'</span> &lt;key&gt; \n ]?   <span class="comment"># [key] 这一行是可选的</span></div><div class="line">        &lt;entries&gt;                 <span class="comment"># 每个章节含有多个条目 entry</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token entries &#123;</div><div class="line">        [</div><div class="line">        | &lt;entry&gt; \n</div><div class="line">        | \n <span class="comment"># entry 可以为空</span></div><div class="line">        ]+</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token entry   &#123; &lt;key&gt; \h* <span class="string">'='</span> \h* &lt;value&gt; &#125;</div><div class="line">    token key     &#123; \w+                       &#125;</div><div class="line">    token value   &#123; \N+                       &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class INIFileActions &#123;</div><div class="line">    method key    ($/)  &#123; $/.make: ~$/                                 &#125;</div><div class="line">    method value  ($/)  &#123; $/.make: ~$/                                 &#125;</div><div class="line">    method entry  ($/)  &#123; $/.make: $&lt;key&gt;.<span class="string">ast =&gt;</span> $&lt;value&gt;.ast          &#125;</div><div class="line">    method entries($/)  &#123; $/.make: $&lt;entry&gt;».ast                       &#125;</div><div class="line">    method section($/)  &#123; $/.make: $&lt;key&gt;.ast // <span class="string">'_'</span> =&gt; $&lt;entries&gt;.ast &#125; <span class="comment"># 如果 key 不存在就默认为 `_`</span></div><div class="line"></div><div class="line">    method TOP($/) &#123;</div><div class="line">        $/.make: $&lt;section&gt;».ast;  <span class="comment"># 等价于 $/.make($&lt;section&gt;».ast);</span></div><div class="line">        <span class="comment"># '-' =&gt; $&lt;entries&gt;.ast    # '_' 没有 ast 方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $m = INIFile::Grammar.parse(Q&#123;</div><div class="line">name = Animal Facts</div><div class="line">author = jnthn</div><div class="line"></div><div class="line">[cat]</div><div class="line">desc = The smartest <span class="keyword">and</span> cutest</div><div class="line">cuteness = <span class="number">100000</span></div><div class="line"></div><div class="line">[dugong]</div><div class="line">desc = The cow of the sea</div><div class="line">cuteness = -<span class="number">10</span></div><div class="line"></div><div class="line">[magpie]</div><div class="line">desc = crow; raven; rook; jackdaw; chough; magpie; jay</div><div class="line">cuteness = <span class="number">99</span></div><div class="line">&#125;, :actions(INIFileActions)).ast;</div><div class="line"></div><div class="line"><span class="keyword">for</span> @$<span class="keyword">m</span> -&gt; $sec &#123;</div><div class="line">    <span class="keyword">say</span>(<span class="string">"章节: &#123;$sec.key&#125;"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> $sec.value -&gt; $entry &#123;</div><div class="line">        <span class="keyword">say</span>(<span class="string">"    &#123;$entry.key&#125;: &#123;$entry.value&#125;"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Grammar 的解析是从上至下的, 从 top-level (<code>TOP</code>) 开始, 到分支(branch)。 Actions 中的方法是随着解析而执行的, 但是抽象语法树(AST) 的存储和检索是自下而上的, 只有底部的存储完了, 其上层部分才可以使用<code>.ast</code> 或 <code>.made</code> 方法进行检索, 检索到之后各自进行处理后再次存储, 以供它的上层部分使用, 以此类推。</p>
<p>注意, 第一段代码中 <code>$m</code> 存储的死散列, 而第二段代码中, <code>$m</code> 存储的是数组! 这说明可以返回散列和数组两种形式。留待改天。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[输入Unicode字符]]></title>
      <url>http://ohmycloud.github.io/2016/05/11/%E8%BE%93%E5%85%A5Unicode%E5%AD%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="输入-Unicode-字符"><a href="#输入-Unicode-字符" class="headerlink" title="输入 Unicode 字符"></a>输入 Unicode 字符</h1><hr>
<p>Perl 6 允许把 unicode 字符用作变量名. 很多操作符使用 unicode 符号(特别是在 set/bag 操作符中)还有一些引号结构. 因此, 知道如何把这些符号输入编辑器, Perl 6 shell 和 命令行中是极好的, 特别是现实键盘中不存在那个符号的时候.</p>
<p>在各种操作系统和环境下关于输入 unicode 字符的通用信息可以在 Wikipedia <a href="https://en.wikipedia.org/wiki/Unicode_input" target="_blank" rel="external">unicode input page</a> 中找到.</p>
<h2 id="编辑器和-shell"><a href="#编辑器和-shell" class="headerlink" title="编辑器和 shell"></a>编辑器和 shell</h2><hr>
<h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><hr>
<p>在 Vim 中, unicode 字符是通过先按 <code>Ctrl-V</code>(也表示为 <code>^V</code>), 然后按下 <code>u</code> 和 要输入的 unicode 字符的十六进制值来输入的(在插入模式).  例如, 希腊字母  <code>λ</code> (lambda) 是通过组合键来输入的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^Vu03BB</div></pre></td></tr></table></figure>
<p>更多关于在 Vim 中输入特殊字符的信息可以在 Vim Wikia 页 <a href="http://vim.wikia.com/wiki/Entering_special_characters" target="_blank" rel="external"> entering special characters</a> 中找到.</p>
<h3 id="Emacs"><a href="#Emacs" class="headerlink" title="Emacs"></a>Emacs</h3><hr>
<p>在 Emacs 中, unicode 字符的输入是首先输入和弦 <code>Ctrl-x 8 Enter</code> , 然后再输入 unicode 代码点的十六进制数字, 然后回车. 因此, 要输入希腊字母 <code>λ (lambda)</code> 使用下面的组合键(命令之间添加了空格以使清晰):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ctrl-x 8 Enter 3bb Enter</div></pre></td></tr></table></figure>
<p>更多关于在 Emacs 中输入 unicode 字符的信息可以在 <a href="http://www.emacswiki.org/emacs/UnicodeEncoding" target="_blank" rel="external"> Unicode Encoding Emacs wiki page</a>  中找到.</p>
<h3 id="Unix-shell"><a href="#Unix-shell" class="headerlink" title="Unix shell"></a>Unix shell</h3><hr>
<p>在 bash shell 中, 要输入 unicode 字符先键入 <code>Ctrl-Shift-u</code>, 然后键入 unicode 代码点的值后回车. 例如, 要键入属于操作符(<code>∈</code>)这个 unicode 字符, 使用下面的组合键(添加的空白是为了清晰):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ctrl-Shift-u 2208 Enter</div></pre></td></tr></table></figure>
<p>如果在 Unix shell 中开启了 REPL, 这也是一种在 perl 6 的 REPL 中输入 unicode 字符的方式之一.</p>
<h2 id="Perl-6中有用的-Unicode-字符"><a href="#Perl-6中有用的-Unicode-字符" class="headerlink" title="Perl 6中有用的 Unicode 字符"></a>Perl 6中有用的 Unicode 字符</h2><hr>
<h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><hr>
<p>这些字符在法语和德语中是当作引号使用的. 在 Perl 6中, 它们仍然用作引号(在 POD 中是单引号, 在普通代码中是双引号), 还可以标示超运算符. 下面是这些符号和它们的 unicode 十六进制值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">符号 unicode代码点 ascii equivalent</div><div class="line">«	U+00AB	      &lt;&lt;</div><div class="line">»	U+00BB	      &gt;&gt;</div></pre></td></tr></table></figure>
<p>因此, 下面这些结构是可用的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C« fixed-width POD text »</div><div class="line">say (1, 2) »+« (3, 4);     # 4 6 ; element-wise add</div><div class="line">@array »+=» 42;            # add 42 to each element of @array</div><div class="line">say «moo»;                 # moo</div><div class="line">my $baa = 123; say «$baa»; # 123</div></pre></td></tr></table></figure>
<h3 id="Set-bag-操作符"><a href="#Set-bag-操作符" class="headerlink" title="Set/bag 操作符"></a>Set/bag 操作符</h3><hr>
<p>下面列出的 <a href="http://doc.perl6.org/language/setbagmix#Set%2FBag_Operators" target="_blank" rel="external">set/bag 操作符</a> 都有与集合理论相关的符号, unicode 代码点, 和它们的 ascii 等价物. 要构成这样的一个字符, 只需键入字符组合键(例如 Vim中的 <code>Ctrl-V u</code>, Bash 中的 <code>Ctrl-Shift-u</code>), 然后输入 unicode 代码点的十六进制数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">操作符	unicode代码点	ascii equivalent</div><div class="line">∈	  U+2208	    (elem)</div><div class="line">∉	  U+2209	    !(elem)</div><div class="line">∋	  U+220B	    (cont)</div><div class="line">∌	  U+220C	    !(cont)</div><div class="line">⊆	  U+2286	    (&lt;=)</div><div class="line">⊈	  U+2288	    !(&lt;=)</div><div class="line">⊂	  U+2282	    (&lt;)</div><div class="line">⊄	  U+2284	    !(&lt;)</div><div class="line">⊇	  U+2287	    (&gt;=)</div><div class="line">⊉	  U+2289	    !(&gt;=)</div><div class="line">⊃	  U+2283	    (&gt;)</div><div class="line">⊅	  U+2285	    !(&gt;)</div><div class="line">≼	  U+227C	    (&lt;+)</div><div class="line">≽	  U+227D	    (&gt;+)</div><div class="line">∪	  U+222A	    (|)</div><div class="line">∩	  U+2229	    (&amp;)</div><div class="line">∖	  U+2216	    (-)</div><div class="line">⊖	  U+2296	    (^)</div><div class="line">⊍	  U+228D	    (.)</div><div class="line">⊎	  U+228E	    (+)</div></pre></td></tr></table></figure>
<h3 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h3><hr>
<p>Wikipedia 包含了一个 <a href="https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode" target="_blank" rel="external">unicode 中数学操作符和符号</a> 的完整列表, 还有它们数学意义的链接.</p>
<h3 id="希腊字符"><a href="#希腊字符" class="headerlink" title="希腊字符"></a>希腊字符</h3><hr>
<p>希腊字符可以用作变量名了. 查看 <a href="https://en.wikipedia.org/wiki/Greek_alphabet#Greek_in_Unicode" target="_blank" rel="external">Greek in Unicode Wikipedia article</a> 列表获取希腊和埃及字符还有它们的 unicode 代码点.</p>
<p>例如, 把数值3赋值给 <code>π</code>, 在 Vim 中输入(添加的空格是为了清晰):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $Ctrl-V u 03C0 = 3;  # same as: my $π = 3;</div><div class="line">say $Ctrl-V u 03C0;     # 3    same as: say $π;</div></pre></td></tr></table></figure>
<h3 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h3><hr>
<p>使用 <code>U+207x</code>, <code>U+208x</code> 和 (less often)  <code>U+209x</code> 范围能直接创建一个有限的<a href="http://en.wikipedia.org/wiki/Superscripts_and_Subscripts" target="_blank" rel="external">上标和下标</a>的集合. 然而, 要生成一个值的平方或立方, 你需要使用 <code>U+00B2</code> 和 <code>U+00B3</code> , 因为这些被定义在 <a href="http://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block" target="_blank" rel="external"> Latin1 supplement Unicode block</a>) 中.</p>
<p>因此, 要书写泰勒级数展开, 你可以在 Vim 中输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exp(x) = 1 + x + xCtrl-V u 00B2/2! + xCtrl-V u 00B3/3! + ... + xCtrl-V u 207F/n!</div><div class="line"># which would appear as</div><div class="line">exp(x) = 1 + x + x²/2! + x³/3! + ... + xⁿ/n!</div></pre></td></tr></table></figure>
<p>或者指定列表中从1到k 的元素:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ACtrl-V u 2081, ACtrl-V u 2082, ..., ACtrl-V u 2096</div><div class="line"># which would appear as</div><div class="line">A₁, A₂, ..., Aₖ</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[列表解析]]></title>
      <url>http://ohmycloud.github.io/2016/05/11/%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h2><hr>
<p>列表解析即 List Comprehensions。</p>
<p>生成 <code>1x1, 2x2, 3x3, ..., 10x10</code> 的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">($_**2 for 1..10);</div></pre></td></tr></table></figure>
<p><code>for</code> 语句前面还可以添加 if 修饰符，这样我们就可以仅筛选出偶数的平方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">($_**2 if !($_ % 2) for 1..10)</div><div class="line">($_**2 if $_ % 2 == 1 for 1..10) # 同上</div></pre></td></tr></table></figure>
<p>组合多个 if 条件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @list = ($_ if $_ %2 == 1 &amp;&amp; $_ &gt; 2 for 1..6 )     # [3 5]</div></pre></td></tr></table></figure>
<p>还可以生成全排列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">($_ for &quot;ABC&quot;.comb X~ &quot;XYZ&quot;.comb) # (&quot;AX&quot;, &quot;AY&quot;, &quot;AZ&quot;, &quot;BX&quot;, &quot;BY&quot;, &quot;BZ&quot;, &quot;CX&quot;, &quot;CY&quot;, &quot;CZ&quot;)</div><div class="line"></div><div class="line">my @a = (1,3,4)                                                                       </div><div class="line">my @b = (2,4,6)                                                                     </div><div class="line">my @list = (@a X @b)    # 这儿也可以用圆括号, 也可以不用                                                      </div><div class="line"># [(1 2) (1 4) (1 6) (3 2) (3 4) (3 6) (4 2) (4 4) (4 6)]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; ($_ when /7$/ for 1..99)</div><div class="line">(7 17 27 37 47 57 67 77 87 97)</div></pre></td></tr></table></figure>
<p>大小写转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @a = &lt;Hello World IBM Apple&gt;;</div><div class="line">(.lc for @a)                # hello world ibm apple</div></pre></td></tr></table></figure>
<p>删除字符串末尾的空白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @freshfruit = &apos; banana&apos;, &apos; loganberry &apos;, &apos;passion fruit &apos;;</div><div class="line">(.trim for @freshfruit)     # &quot;banana&quot; &quot;loganberry&quot; &quot;passion fruit&quot;</div></pre></td></tr></table></figure>
<p>向量运算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my @vec = 2,4,6;</div><div class="line">(3*$_ for @vec)                     # 6 12 18</div><div class="line">(3*$_ if $_ &gt; 3 for @vec)   # 12 18</div><div class="line">(3*$_ if $_ &lt; 2 for @vec)   # ()</div></pre></td></tr></table></figure>
<p>嵌套数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @vec = 2,4,6;</div><div class="line">([$_, $_**2].perl for @vec)       # [2, 4] [4, 16] [6, 36]</div><div class="line">([$_, $_**2].WHAT for @vec) # (Array) (Array) (Array)</div></pre></td></tr></table></figure>
<p>Parcel:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(($_, $_**2).perl for @vec)       # (2, 4) (4, 16) (6, 36)</div><div class="line">(($_, $_**2).WHAT for @vec) # (Parcel) (Parcel) (Parcel)</div></pre></td></tr></table></figure>
<p>多个列表之间的列表解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my @vec1 = 2,4,6;</div><div class="line">my @vec2 = 4,3,-9;</div><div class="line">($_ for @vec1 X* @vec2)           # 8 6 -18 16 12 -36 24 18 -54</div><div class="line">($_ for @vec1 X+ @vec2)          # 5 -7 8 7 -5 10 9 -3</div><div class="line">($_ for @vec1 Z* @vec2)           # 8 12 -54</div><div class="line">($_ for @vec1 &gt;&gt;*&lt;&lt; @vec2)  # 8 12 -54</div></pre></td></tr></table></figure>
<p>使用列表解析处理矩阵:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; my @a = ([1,2,3], [4,5,6], [7,8,9]);</div><div class="line">&gt; @a[0]                                    # 1 2 3</div><div class="line">&gt; @a[0][1]                              # 2</div><div class="line">&gt; @a[0][2]                             # 3</div><div class="line">&gt; ($_[1] for @a)                   # 2 5 8</div><div class="line">&gt; ($_[2] for @a)                  # 3 6 9</div><div class="line">&gt; ($_[2]-1 for @a)               # 2 5 8</div><div class="line">&gt; (@a[$_][$_] for 0..2)     # 1 5 9</div></pre></td></tr></table></figure>
<p>矩阵转置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sub transpose (@m) &#123;</div><div class="line">    @m[0].keys.map: &#123;[ @m»[$_] ]&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @a = [&lt; a b c d e &gt;],</div><div class="line">        [&lt; f g h i j &gt;],</div><div class="line">        [&lt; k l m n o &gt;],</div><div class="line">        [&lt; p q r s t &gt;];</div><div class="line"></div><div class="line">(.say for @a.&amp;transpose);</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a f k p</div><div class="line">b g l <span class="keyword">q</span></div><div class="line">c h <span class="keyword">m</span> r</div><div class="line">d i n <span class="keyword">s</span></div><div class="line">e j o t</div></pre></td></tr></table></figure>
<p>一丢丢解释： <code>@m[0].keys</code> 获取 <code>column index</code> , 根据获取到的列索引, 使用超运算符 <code>»</code> 遍历数组中对应列索引位置的元素。注意 <code>[]</code> 实际上是后缀操作符, 原来使用 <code>».[]</code> 的语法是错误的。</p>
<p>使用 gather 进行列表解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @s = gather &#123; for ^100 &#123; take 2 * $_ if $_ ** 2 &gt; 3 &#125; &#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 1到20之间哪些数字组成直角？</div><div class="line">my $n = 20;</div><div class="line">my @a = gather for 1..$n -&gt; $x &#123;</div><div class="line">         for $x..$n -&gt; $y &#123;</div><div class="line">           for $y..$n -&gt; $z &#123;</div><div class="line">             take $x,$y,$z if $x*$x + $y*$y == $z*$z;</div><div class="line">           &#125;</div><div class="line">         &#125;</div><div class="line">       &#125;;</div><div class="line">say &quot;@a[]&quot;;</div><div class="line"></div><div class="line"># 3 4 5 5 12 13 6 8 10 8 15 17 9 12 15 12 16 20</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的操作符(二)]]></title>
      <url>http://ohmycloud.github.io/2016/05/02/Perl6%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<ul>
<li>infix:&lt;…&gt;, 序列操作符.</li>
</ul>
<p>作为一个中缀操作符， <code>...</code> 操作符的左右两侧都有一个列表，并且为了产生<code>想要的值</code>的序列，序列操作符 <code>...</code> 会尽可能地对序列进行惰性求值。列表被展平后求值。就像所有的中缀操作符一样， … 序列操作符比逗号的优先级要低，所以你没必要在逗号列表的两侧加上圆括号。</p>
<p>序列操作符 <code>...</code> 以右侧列表的第一个值开始。这只在右侧的列表中， … 序列操作符唯一感兴趣的值；any additional list elements are treasured up lazily to be returned after the … is done.</p>
<p> … 右侧的第一个值是序列的端点或界限，这是序列操作符 … 从左侧生成的。</p>
<p>一旦我们知道了序列的边界，左侧的列表会一项一项地被求值，并且普通数字或字符串值被无差异地传递（在右侧边界允许的程度内）如果序列中的任何值匹配到边界值，序列会终止，包括那个最后的边界值在内。要排除边界值，使用  …^ 代替。</p>
<p>在内部，这两种形式用于检测匿名的循环是否会终止，而循环返回序列中的值。假设下一个候选的值存储在 $x 中，并且右侧序列中的第一个值存储在 $limit 中，这两个操作符各自实现为：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...     <span class="keyword">last</span>($x) <span class="keyword">if</span> $x ~~ $limit;</div><div class="line">...^    <span class="keyword">last</span>     <span class="keyword">if</span> $x ~~ $limit;</div></pre></td></tr></table></figure>
<p>如果边界是 * ,序列就没有界限。如果边界是一个闭包，它会在当前候选对象中进行布尔真值求值，并且序列会一直继续只要闭包返回false。如果边界是一个含有一个或无限参数的闭包，</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $lim = <span class="number">0</span>;</div><div class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ...^ * &gt; $lim      <span class="comment"># returns (), since 1 &gt; 0</span></div></pre></td></tr></table></figure>
<p>这个操作符如果只能把左边的值原样返回就太乏味了。它的强大来自于能从旧值生成新值。你可以，例如，使用一个存在的生成器产生一个无穷列表：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>..* ... * &gt;= $lim</div><div class="line">@fib ... * &gt;= $lim</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">1</span>..* ... * &gt;= <span class="number">10</span>  <span class="comment"># 1 2 3 4 5 6 7 8 9 10</span></div></pre></td></tr></table></figure>
<p>更一般地，如果 … 操作符左侧列表中的下一项是一个闭包，它不会被返回。他会在已经存在的列表的末尾被调用以产生一个新值。闭包中变量的数目决定了要使用多少前置值作为输入来生成序列中的下一个值。例如，以2为步长计数只需要一个参数：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>, &#123; $^a + <span class="number">2</span> &#125; ... *           <span class="comment"># 2,4,6,8,10,12,14,16...</span></div></pre></td></tr></table></figure>
<p>生成裴波纳契序列一次需要两个参数：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, <span class="number">1</span>, &#123; $^a + $^b &#125; ... *      <span class="comment"># 1,1,2,3,5,8,13,21...</span></div></pre></td></tr></table></figure>
<p>任何特定的函数也有效，只要你把它作为列表中的一个值而不是调用它：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, <span class="number">1</span>, &amp;infix:&lt;+&gt; ... *         <span class="comment"># 1,1,2,3,5,8...</span></div><div class="line"><span class="number">1</span>, <span class="number">1</span>, &amp;[+] ... *               <span class="comment"># 同上</span></div><div class="line"><span class="number">1</span>, <span class="number">1</span>, *+* ... *                <span class="comment"># 同上</span></div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">sub</span> <span class="title">infix</span>:&lt;<span class="title">jia</span>&gt;</span>($a,$b)&#123; <span class="keyword">return</span> $a+$b &#125;</div><div class="line">&gt; <span class="number">1</span> jia <span class="number">5</span> <span class="comment"># 6</span></div><div class="line">&gt; <span class="number">1</span>,<span class="number">1</span>,&amp;[jia] ... * <span class="comment"># 1 1 2 3 5 8 13 21 34 55 89 144 233 377 ......</span></div></pre></td></tr></table></figure>
<p>更一般地，函数是一元的，这种情况下左侧列表中任何额外的值会被构建为人类可读的文档：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>, &#123; $_ + <span class="number">2</span> &#125; ... <span class="number">42</span>        <span class="comment">#  0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42</span></div></pre></td></tr></table></figure>
<p>使用闭包：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,-&gt; $init &#123;$init+<span class="number">2</span>&#125; ... <span class="number">42</span>   <span class="comment"># 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42</span></div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>, *+<span class="number">2</span> ... <span class="number">42</span>           <span class="comment"># same thing</span></div><div class="line">&lt;a b c&gt;, &#123; .succ &#125; ... *    <span class="comment"># same as 'a'..*</span></div></pre></td></tr></table></figure>
<p>函数也可以不是单调函数：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, -* ... *                <span class="comment"># 1, -1, 1, -1, 1, -1...</span></div><div class="line">False, &amp;prefix:&lt;!&gt; ... *   <span class="comment"># False, True, False...</span></div></pre></td></tr></table></figure>
<p>函数也可以是 0-ary 的， 这个时候让闭包成为第一个元素是 okay 的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; rand &#125; ... *             # 一组随机数</div></pre></td></tr></table></figure>
<p>函数还可以是吞噬的（n-ary），在这种情况下，所有前面的值都被传递进来（这意味着它们必须都被操作符缓存下来，所以性能会经受考验， 你可能会发现自己空间泄露了）</p>
<p>函数的数量不必与返回值的数量匹配， 但是如果确实匹配， 你可能会插入不相关的序列：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,<span class="number">1</span>,&#123; $^a + <span class="number">1</span>, $^b * <span class="number">2</span> &#125; ... *   <span class="comment"># 1,1,2,2,3,4,4,8,5,16,6,32...</span></div><div class="line"><span class="number">1</span>,<span class="number">1</span>, -&gt;$a,$b &#123;$a+<span class="number">1</span>,$b*<span class="number">2</span>&#125; ... *  <span class="comment"># 同上</span></div></pre></td></tr></table></figure>
<p>注意在这种情况下任何界限测试被应用到从函数返回的整个 parcel 上， 这个 parcel 包含两个值。</p>
<p>除了那些函数签名所隐含的约束，序列操作符从一个没有对序列作类型约束的显式函数中生成。如果函数的签名和已存在的值不匹配，那么序列终止。</p>
<p>S03-sequence/misc.t lines 5–12  </p>
<p>如果没有提供生成闭包， 并且序列是数字的，而且序列明显还是等差的或等比的（通过检查它的最后 3 个值），那么序列操作符就会推断出合适的函数：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> ... *    <span class="comment"># 奇数</span></div><div class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span> ... *    <span class="comment"># 2的幂</span></div><div class="line"><span class="number">10</span>,<span class="number">9</span>, <span class="number">8</span> ... <span class="number">0</span>    <span class="comment"># 倒数</span></div></pre></td></tr></table></figure>
<p>即， 假设我们调用了最后 3 个数字  <code>$a</code>, <code>$b</code>, 和 <code>$c</code>，然后定义：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ab = $b - $a;</div><div class="line">$bc = $c - $b;</div></pre></td></tr></table></figure>
<p>如果 <code>$ab == $bc</code> 并且 <code>$ab</code> 不等于0， 那么我们通过函数 <code>*+$ab</code> 可以推断出等差数列。如果 <code>$ab</code> 为 0，并且那3个值看起来像数字，那么函数推断为 <code>*+0</code>。</p>
<p>如果它们看起来不像数字，那么根据 <code>$b cmp $c</code> 的结果是 Increasing 还是 Decreasing 来决定选择的函数是 <code>*.succ</code> 还是 <code>*.pred</code>。</p>
<p>如果 <code>cmp</code> 返回 <code>Same</code> 那么会假定函数是同一个。</p>
<p>如果 <code>$ab != $bc</code> 并且 <code>none($a,$b,$c) == 0</code>， 那么会使用除法而非减法做类似的计算来决定是否需要一个等比数列。定义：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ab = $b / $a;</div><div class="line">$bc = $c / $b;</div></pre></td></tr></table></figure>
<p>如果两者的商相等（并且是有限的），那么会推断出等比函数  <code>{$_ * $bc}</code>。</p>
<p>如果目前为止只有 2 个值， $a 和 $b, 并且差值 $ab 不为 0, 那么我们就假定函数为 <code>*+$ab</code> 的等差数列。</p>
<p>如果 <code>$ab</code> 是 0， 那么再次， 我们使用  <code>*+0</code> 还是 <code>*.succ/*.pred</code> 取决于那两个值看起来是不是数字。</p>
<p>如果只有一个值，我们总是通过 <code>*.succ</code> 假定增量（这可能被强制为 .pred 通过检查界限，就像下面指定的那样）因此这些结果都是一样的：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> .. *</div><div class="line"><span class="number">1</span> ... *</div><div class="line"><span class="number">1</span>,<span class="number">2</span> ... *</div><div class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ... *</div><div class="line">&lt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>&gt; ... *</div></pre></td></tr></table></figure>
<p>同样地， 如果给定的值(s)不是数字， 就假定为 <code>.succ</code>, 所以这些结果是一样的：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">'a'</span> .. *</div><div class="line"><span class="string">'a'</span> ... *</div><div class="line"><span class="string">'a'</span>,<span class="string">'b'</span> ... *</div><div class="line"><span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span> ... *</div><div class="line">&lt;a b c&gt; ... *</div></pre></td></tr></table></figure>
<p>如果序列操作符的左侧是 <code>()</code>, 那我们使用函数 <code>{()}</code> 来生成一个无限的空序列。</p>
<p>如果给定了界限，那这个界限就必须被精确匹配。如果不能精确匹配，会产生无限列表。例如，因为”趋近”和“相等”不一样， 下面的两个序列都是无限列表，就像你把界限指定为了 * 而不是 0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1,1/2,1/4 ... 0    # like 1,1/2,1/4 ... *</div><div class="line">1,-1/2,1/4 ... 0   # like 1,-1/2,1/4 ... *</div></pre></td></tr></table></figure>
<p>同样地，这是所有的偶数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $end = 7;</div><div class="line">0,2,4 ... $end</div></pre></td></tr></table></figure>
<p>为了捕捉这样一种情况， 建议写一个不等式代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0,2,4 ...^ &#123; $_ &gt; $end &#125;</div></pre></td></tr></table></figure>
<p>当使用了显式的界限函数，他可能通过返回任意真值来终止它的列表。因为序列操作符是列表结合性的，内部函数后面可以跟着 … ，然后另外一个函数来继续列表，等等。因此：</p>
<p>S03-sequence/misc.t lines 34–100  </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,   *+<span class="number">1</span>   ... &#123; $_ ==   <span class="number">9</span> &#125;,</div><div class="line"><span class="number">10</span>,  *+<span class="number">10</span>  ... &#123; $_ ==  <span class="number">90</span> &#125;,</div><div class="line"><span class="number">100</span>, *+<span class="number">100</span> ... &#123; $_ == <span class="number">900</span> &#125;</div></pre></td></tr></table></figure>
<p>产生：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,</div><div class="line"><span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>,</div><div class="line"><span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>,<span class="number">900</span></div></pre></td></tr></table></figure>
<p>考虑到没有闭包的普通匹配规则，我们可以把上面的序列更简单地写为：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ... <span class="number">9</span>,</div><div class="line"><span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> ... <span class="number">90</span>,</div><div class="line"><span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span> ... <span class="number">900</span></div></pre></td></tr></table></figure>
<p>甚至仅仅是：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ...</div><div class="line"><span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> ...</div><div class="line"><span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span> ... <span class="number">900</span></div></pre></td></tr></table></figure>
<p>因为一个精确的匹配界限会被作为序列的一部分返回，所以提供的那个精确值是一个合适类型的值， 而非一个闭包。</p>
<p>对于左侧只有一个值的函数推断，最后的值被用于决定是 <code>*.succ</code> 还是 <code>*.pred</code> 更合适。 使用 cmp 来比较那两个值来决定前进的方向。</p>
<p>因此, 序列操作符能自动反转, 而范围操作符不会自动反转.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'z'</span> .. <span class="string">'a'</span>   <span class="comment"># 表示一个空的范围</span></div><div class="line"><span class="string">'z'</span> ... <span class="string">'a'</span>  <span class="comment"># z y x ... a</span></div></pre></td></tr></table></figure>
<p>你可以使用 <code>^...</code> 形式来排除第一个值:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'z'</span> ^... <span class="string">'a'</span> <span class="comment"># y x ... a</span></div><div class="line"><span class="number">5</span> ^... <span class="number">1</span>     <span class="comment"># 4, 3, 2, 1</span></div></pre></td></tr></table></figure>
<p>但是你要意识到, 如果列表的左侧很复杂, 特别是左侧是另一个序列时, 肯定会让你的读者困惑:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ^... *;                  <span class="comment"># 2, 3 ...  !</span></div><div class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ... <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> ^... *;   <span class="comment"># 2, 3 ...  !?!?</span></div></pre></td></tr></table></figure>
<p>是的, 对于极端喜欢对称性的那些人来说, 还有另外一种形式: <code>^...^</code></p>
<p>就像数字数值一样, 字符串匹配必须是精确的, 否则会产生无限序列.</p>
<p>注意下面这个序列:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.0</span>, *+<span class="number">0</span>.<span class="number">2</span> ... <span class="number">2.0</span></div></pre></td></tr></table></figure>
<p>是使用 <code>Rat</code> 算术计算的, 而不是 <code>Num</code>, 所以 2.0 精确地匹配了并结束了序列.</p>
<p>注意：只有在期望为一个 term 的地方，<code>...</code> 才会被识别为 yada 操作符。序列操作符只用于期望中缀操作符出现的地方。</p>
<p>如果你在 <code>...</code> 前面放置了一个逗号，那么 <code>...</code>会被识别为 yada 列表操作符 - 表达当列表到达那点时会失败的要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1..20, ... &quot;I only know up to 20 so far mister&quot;</div><div class="line">&gt; 1..20, fail &quot;I only know up to 20 so far mister&quot;  # I only know up to 20 so far mister</div></pre></td></tr></table></figure>
<p>序列的末端是一个代表单个代码点的字符串时，会抛出一个特殊的异常， 因为典型地，用户会把这样一个字符串看作是字符而非字符串。如果你像这样说：</p>
<p>S03-sequence/nonnumeric.t lines 36–101  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;A&apos; ... &apos;z&apos;</div><div class="line">&quot;\xff&quot; ... &quot;\0&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;  &apos;A&apos; ... &apos;z&apos; # A B C D ... Y Z [ \ ] ^ _ ` a  b c ... y z</div></pre></td></tr></table></figure>
<p>它会假定你对按字母顺序范围不感兴趣， 所以，代替对于字符串使用普通的 <code>.succ/.pred</code>， 它会像这样使用单调函数来增加或减少底层的代码点数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;A&apos;, &#123; $^prev.ord.succ.chr &#125; ... &apos;z&apos;;</div><div class="line">&quot;\xff&quot;, &#123; $^prev.ord.pred.chr &#125; ... &quot;\0&quot;;</div></pre></td></tr></table></figure>
<p>… 操作符是 “yada, yada, yada” 列表操作符, 它在其它东西之间用作函数原型中得主体。如果它曾经被执行过的话会强烈地抱怨（通过调用 fail）。变体 ??? 调用 <code>warn</code>, 而 !!! 调用 <code>die</code>。参数是可选的，但是如果提供了参数的话，会被传递给 <code>fail</code>、<code>warn</code> 或 <code>die</code> 。 否则系统会基于上下文为你编造信息，以标示你尝试执行了某些已经创建过的东西。</p>
<h2 id="Reduce-操作符"><a href="#Reduce-操作符" class="headerlink" title="Reduce 操作符"></a>Reduce 操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[+] [*] [&lt;] [\+] [\*] 等等.</div></pre></td></tr></table></figure>
<p>Sigils as coercions to roles</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sigil       Alpha variant</div><div class="line">-----       -------------</div><div class="line">$           Scalar</div><div class="line">@           Positional (or Iterable?)</div><div class="line">%           Associative</div><div class="line">&amp;           Callable</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(1,2 Z 3,4)      # Scalar((1,3),(2,4))</div><div class="line">@(1,2 Z 3,4)      # ((1,3),(2,4))</div><div class="line">%(1,2 Z 3,4)      # PairSeq(1 =&gt; 3, 2 =&gt; 4)</div><div class="line">$(1,2 X 3,4)      # Scalar((1,3),(1,4),(2,3),(2,4))</div><div class="line">@(1,2 X 3,4)      # ((1,3),(1,4),(2,3),(2,4))</div></pre></td></tr></table></figure>
<p><strong>-&gt;</strong> 变成了 <strong>.</strong> , 就像世界其它地方使用的一样。有一个产生编译时错误的伪后缀 <code>postfix:[&#39;-&gt;&#39;]</code> 操作符以提醒 Perl 5 用户使用点代替。（”pointy block” 在 Perl 6 中使用 <code>-&gt;</code> 要求它前面有空格，当箭头可能会和后缀混淆时，即，当期望一个中缀时。在 item 位置上不要求有前置空格。）</p>
<p>字符串连接由 <code>.</code> 变成 <code>~</code>。字符串追加同样变成 <code>~=</code>。</p>
<p>文件测试操作符不见了。我们现在使用 <em>Pair</em> 作为调用对象的方法的模式;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if $filename.IO ~~ :e &#123; say &quot;exists&quot; &#125;</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if so $filename.IO.e &#123; say &quot;exists&quot; &#125;</div></pre></td></tr></table></figure>
<p>Likewise</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if $filename.IO ~~ :!e &#123; say &quot;doesn&apos;t exist&quot; &#125;</div></pre></td></tr></table></figure>
<p>is the same as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if not $filename.IO.e &#123; say &quot;doesn&apos;t exist&quot; &#125;</div></pre></td></tr></table></figure>
<p>如果你不关心右侧某个位置上是什么元素，你可以把这个元素赋值给 <code>*</code> 记号。 最后的星号 <code>*</code> 丢弃掉列表的剩余部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">($a, *, $c) = 1, 2, 3;      # 丢弃数字 2</div><div class="line">($a, $b, $c, *) = 1..42;    # 丢弃 4..42</div></pre></td></tr></table></figure>
<p>(在签字语法中，一个裸的 <code>$</code> 也能忽略单个参数，而一个裸的 <code>*@</code> 可以忽略剩下的参数。)</p>
<p>列表赋值依次把右侧的列表提供给左侧的每个容器，而每个容器可以从右侧列表的前头接收一个或多个元素。如果左侧的元素有任何剩余，警告就会出现，除非左侧的列表以 <code>*</code> 字符结尾或者右侧的最后的迭代器是按照 <code>*</code> 定义的。因此下面没有一个会发出警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">($a, $b, $c, *) = 1..9999999;</div><div class="line">($a, $b, $c) = 1..*;</div><div class="line">($a, $b, $c) = 1 xx *;</div><div class="line">($a, $b, $c) = 1, 2, *;</div></pre></td></tr></table></figure>
<p>然而，这个会警告你信息缺失：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">($a, $b, $c) = 1, 2, 3, 4;</div></pre></td></tr></table></figure>
<p>把列表赋值给标量, 你可以这样写:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$a = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</div><div class="line">($a = <span class="number">1</span>), <span class="number">2</span>, <span class="number">3</span>; <span class="comment"># 2 和 3 的上下文为空</span></div></pre></td></tr></table></figure>
<p>显式的禁用或破坏 item 赋值解释:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];             <span class="comment"># 强制构建 (或许是最佳实践)</span></div><div class="line">$a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);             <span class="comment"># force grouping as syntactic item</span></div><div class="line">$a = list <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;          <span class="comment"># force grouping using listop precedence</span></div><div class="line">$a = @(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);            <span class="comment"># same thing</span></div><div class="line">@$a = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;              <span class="comment"># 强制列表赋值</span></div><div class="line">$a[] = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;             <span class="comment"># same thing</span></div></pre></td></tr></table></figure>
<p>如果一个函数是上下文不敏感的并且你想返回一个标量值，如果你想为了下标或右边强制为 <em>item</em> 上下文，那么你必须使用 <code>item</code>（或 <code>$</code> 或 <code>+</code> 或 <code>~</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@a[foo()] = bar();           # foo() 和 bar() 在列表上下文中调用</div><div class="line">@a[item foo()] = item bar(); # foo() 和 bar() 在标量上下文中调用</div><div class="line">@a[$(foo())] = $(bar());     # 同样的东西</div><div class="line">@a[+foo()] = +bar();         # foo() 和 bar() 在数值上下文中调用</div><div class="line">%a&#123;~foo()&#125; = ~bar();         # foo() 和 bar() 在字符串上下文中调用</div></pre></td></tr></table></figure>
<h1 id="Junctive-操作符"><a href="#Junctive-操作符" class="headerlink" title="Junctive 操作符"></a><a href="https://desgin.perl6.org/S03.html#Junctive_operators" target="_blank" rel="external">Junctive 操作符</a></h1><p><a href="https://github.com/perl6/roast/blob/master/S03-junctions/misc.t#L23-L151" target="_blank" rel="external">S03-junctions/misc.t lines 23–151</a><br><a href="https://github.com/perl6/roast/blob/master/S03-junctions/misc.t#L152-L157" target="_blank" rel="external">S03-junctions/misc.t lines 152–157</a><br><a href="https://github.com/perl6/roast/blob/master/S03-junctions/associative.t#L16-L37" target="_blank" rel="external">S03-junctions/associative.t lines 16–37</a><br><a href="https://github.com/perl6/roast/blob/master/S03-junctions/boolean-context.t#L5-L150" target="_blank" rel="external">S03-junctions/boolean-context.t lines 5–150</a></p>
<p><code>|</code>, <code>&amp;</code>, 和 <code>^</code> 不再是位操作符了(查看  <a href="https://desgin.perl6.org/S03.html#Changes_to_Perl_5_operators" target="_blank" rel="external">“Changes to Perl 5 operators”</a>)，而是担任更高的职务: 它们现在是 junction 构造器了。</p>
<p>junction 是等价于多个值的单个值。它们进行线程化操作符， 返回另一个代表结果的 junction：</p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-operators/misc.t#L68-L89" target="_blank" rel="external">S03-operators/misc.t lines 68–89</a><br><a href="https://github.com/perl6/roast/blob/master/S03-junctions/misc.t#L158-L168" target="_blank" rel="external">S03-junctions/misc.t lines 158–168</a><br><a href="https://github.com/perl6/roast/blob/master/S03-junctions/misc.t#L233-L499" target="_blank" rel="external">S03-junctions/misc.t lines 233–499</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(1|2|3) + 4;                            # 5|6|7</div><div class="line">(1|2) + (3&amp;4);                          # (4|5) &amp; (5|6)</div></pre></td></tr></table></figure>
<p>就像最后那个例子中解释的那样，当单个操作符应用到两个 junctions 中时，结果是一个代表左右可能值得组合的 junction。</p>
<p>Junctions 还有 <code>any</code>， <code>all</code>，<code>one</code>， <code>none</code> 的函数变体。</p>
<p>这为像这样的构造打开了大门。</p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-junctions/misc.t#L169-L191" target="_blank" rel="external">S03-junctions/misc.t lines 169–191</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if $roll == none(1..6) &#123; print &quot;Invalid roll&quot; &#125;</div><div class="line">if $roll == 1|2|3      &#123; print &quot;Low roll&quot;     &#125;</div></pre></td></tr></table></figure>
<p>Junctions 在下标中的表现:</p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-junctions/misc.t#L192-L207" target="_blank" rel="external">S03-junctions/misc.t lines 192–207</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">doit() if @foo[any(1,2,3)]</div></pre></td></tr></table></figure>
<p>Junctions 也是没有顺序的。 所以如果你这样写：</p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-junctions/misc.t#L208-L232" target="_blank" rel="external">S03-junctions/misc.t lines 208–232</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo() | bar() | baz() == 42</div></pre></td></tr></table></figure>
<p>这向编译器表明 junctional 参数之间没有连接（coupling）。它们可以以任意顺序求值或并行地求值。它们也可以是短路的, 只要它们中的任何一个返回 42, 并且其它的不会被运行。或者, 如果并行地运行, 第一个成功的线程会突然终止其它的线程。一般地, 在 junctions 中, 你可能需要避免带有副作用的代码。</p>
<p>把否定操作符和 junctions 用在一起可能会有问题如果原生地自动线程化的话。然而，就否定元操作符而言，通过定义 <code>!=</code> 和 <code>ne</code>，我们自动地得到了说英语的人所想要的 “not raising”。即：</p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-junctions/autothreading.t#L290-L367" target="_blank" rel="external">S03-junctions/autothreading.t lines 290–367</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if $a != 1 | 2 | 3 &#123;...&#125;</div></pre></td></tr></table></figure>
<p>实际上意味着：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if $a ![==] 1 | 2 | 3 &#123;...&#125;</div></pre></td></tr></table></figure>
<p>其中元操作符被重写为某些像高阶函数这样的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">negate((* == *), $a, (1|2|3));</div></pre></td></tr></table></figure>
<p>它最终等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if not $a == 1 | 2 | 3 &#123;...&#125;</div></pre></td></tr></table></figure>
<p>它是说英语的人所期望的语义，你自己写出后面那种风格的形式可能会更好。</p>
<p>作用在数组、列表和集合中得 Junctive 方法就像对应的列表操作符那样工作。然而，作用在散列身上的 junctive 方法，只会对散列的键进行连结(junction)。使用 listop 形式(或者一个显式的 <code>.pairs</code>) 来连结(junction) pairs。</p>
<p>各种用于集合和 bags （交集、并集等）的操作符也拥有 junctive 优先级（除了那些返回布尔值得之外，它们实际上被归类为链式操作符）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-From-Wikipedia]]></title>
      <url>http://ohmycloud.github.io/2016/04/26/Perl-6-From-Wikipedia/</url>
      <content type="html"><![CDATA[<p>Perl 6 是 Perl 编程语言家族中的一员. 它仍旧在开发中, 几个解释器和编译器在同时进行. 它引入了很多现代和历史语言的元素. Perl 6 打算有很多实现. 和 Perl 5 兼容不是它的目标, 尽管兼容模式是它的计划书的一部分. Perl 6 的设计程序是从 2000 年开始的. 2015 年 9 月 预期会发布候选版, 并在 12 月 发布最终版.</p>
<p>Perl 6 第一个完成度最高的实现是 <a href="https://en.wikipedia.org/wiki/Pugs" target="_blank" rel="external">Pugs</a> , 开始于 2005 年, 今天已经有多个 Perl 6 实现的工程了. <a href="https://en.wikipedia.org/wiki/Rakudo_Perl" target="_blank" rel="external">Rakudo Perl</a> 是基于 NQP (Not Quite Perl) 并使用 <a href="https://en.wikipedia.org/wiki/MoarVM" target="_blank" rel="external">MoarVM</a> 或 <a href="https://en.wikipedia.org/wiki/Java_Virtual_Machine" target="_blank" rel="external">Java 虚拟机</a> 作为运行时环境的一个 Perl 6 实现, 并且每个月会发布一个新版本;  在 2010 年 七月, 该项目发布了第一次 Rakudo Star 分发,  一个有用和可用的 Perl 6 实现和相关东西的集合. Larry Wall 维护了一个众所周知的叫做 STD.pm6 的引用文法, 它是用 Perl 6 写的, 并使用 Perl 5 驱动 (<a href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers" target="_blank" rel="external">bootstrapped</a>))</p>
<p>Niecza, 另一个主要的 Perl 6 实现, 专注于优化和效率研究. 它的目标是 <a href="https://en.wikipedia.org/wiki/Common_Language_Infrastructure" target="_blank" rel="external">Common Language Infrastructure</a></p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><hr>
<blockquote>
<p>在 Perl 6 中, 我们决定修复语言而非修正使用者  — Larry Wall</p>
</blockquote>
<p>Perl 6 的设计程序首先是在 2000.7.19 , 在 Perl 大会的第四天, 由 Larry Wall 在它的”洋葱头的状态 2000” 演讲上宣布的.  那时候, 主要的目标是移除语言中的”历史毒瘤”; 容易的事情应该保持容易, 困难的事情应该变得更简单, 不可能的事情应该变得可能.开始整理内部设计和 APIs. 程序开始于一系列<a href="https://en.wikipedia.org/wiki/Request_for_Comments" target="_blank" rel="external">请求评论</a> 或者 ‘RFCs’. 这个过程对所有贡献者公开, 让语言的各个方面都保持可变状态.</p>
<p>一旦 RFC 完成 , Larry Wall  评估并归类了每个请求（收到了 361个请求）。 他开始写了几个”启示”，他本来打算再写一部 Programming Perl 的。</p>
<p>有 3 个主要的场所来学习 Perl 6： <a href="irc://irc.freenode.net/#perl6" target="_blank" rel="external">#perl6 IRC 频道</a> ， <a href="https://en.wikipedia.org/wiki/Mailing_list" target="_blank" rel="external">邮件列表</a> 和 <a href="https://en.wikipedia.org/wiki/Source_code_repository" target="_blank" rel="external">Git 源代码仓库</a></p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><hr>
<p>解决 Perl 5 的历史毒瘤。过去那些年， Perl 6 在方向上经历了几个抉择。早期受 Python 和 Ruby 的影响引入了一些概念， 但是因为 Pugs 解释器是用 Haskell 写的， Perl 6 设计团队吸收了很多函数式编程的思想。</p>
<h2 id="吉祥物"><a href="#吉祥物" class="headerlink" title="吉祥物"></a>吉祥物</h2><hr>
<p>Perl 6 的吉祥物是一只蝴蝶，代表着 Perl 6 的虫子。 蝴蝶的翅膀上嵌入了类似字符 “P6”的螺旋形设计，那是 Perl 6 的昵称。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><hr>
<p>到 2015 年， 只有 Rakudo Perl 还在活跃开发中。没有实现会成为 Perl 6 的官方实现；当然啦，”只要通过官方测试套件的实现就是 Perl 6”。</p>
<p>Rakudo Perl 是在几种虚拟机之上的 Perl 6 实现， 例如 MoarVM， Java 虚拟机，和 Javascript。 MoarVM 是为渐进类型编程语言设计的虚拟机，主要用于 Perl 6. 在 Perl 6 和 虚拟机之间有一个叫做 Not Quite Perl 或 NQP 的层， 它实现了解析 Perl 6 的 <a href="https://en.wikipedia.org/wiki/Perl_6_rules" target="_blank" rel="external">Perl 6 规则</a>, 还有一个<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">抽象语法树</a> 和 特定后端的<a href="https://en.wikipedia.org/wiki/Code_generation_(compiler" target="_blank" rel="external">代码生成</a>). Perl 6 的大部分都是用 Perl 6 自身写成的， 或用它的子集 NQP 写成。 Rakudo 既不是一个完全自举的实现， 此时也不会有具体的计划让 Rakudo 成为一个 bootstrapping 编译器。</p>
<h2 id="历史上的实现"><a href="#历史上的实现" class="headerlink" title="历史上的实现"></a>历史上的实现</h2><hr>
<p>那时候最早出现的 Perl 6 实现是 Pugs，它是用 Haskell 写的。Pugs 过去是完成度最高的 Perl 6 实现，但是自从 2007 年年中，它就基本上蛰伏了。 到 2014 年 11 月， Pugs 就不再被积极维护了。</p>
<p>2007 年，v6-MiniPerl6 (“mp6”） 和它的重新实现， v6-KindaPerl6 (“kp6”) 被写出来， 它使用Perl 5来驱动 Perl-6.0.0 STD。 STD 对于 Perl 6 是完整的 grammar， 并用 Perl 6 写成。 理论上， 任何能解析 STD并生成可执行代码的东西对于Perl 6 都是合适的驱动系统。 kp6 目前由 mp6 编译，并且能工作在多个后端上。 mp6 和 kp6 不是完全的 Perl 6 实现， 它们被设计为实现用于驱动一个完整 Perl 6 编译器的最少功能集合。</p>
<p>Yapsi 是一个 Perl 6 编译器， 并且运行时是用 Perl 6 自身写的。 作为结果， 为了运行，它要求先存在一个 Perl 6 解释器， 例如 Rakudo Star 的发布之一。</p>
<h2 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h2><hr>
<p>Perl 6 计划书要求模块由名字，版本和作者标识。 只加载指定版本的模块， 或两个同名但版本或作者不同的版本。</p>
<h2 id="相对-Perl-5来说主要的变化"><a href="#相对-Perl-5来说主要的变化" class="headerlink" title="相对 Perl 5来说主要的变化"></a>相对 Perl 5来说主要的变化</h2><hr>
<p>Perl 5 和 Perl 6从根本上就是不同的两种语言，主要的变化是使新手和专家更容易掌握该语言， 使容易的事情更容易， 困难的事情变得可能。</p>
<h3 id="计划书"><a href="#计划书" class="headerlink" title="计划书"></a>计划书</h3><hr>
<p>Perl 6 是从计划书开始的。这意味着 Perl 6可以在需要时被重新实现。</p>
<h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><hr>
<p>在 Perl 6 中， Perl 5 的动态类型系统通过额外的静态类型被增强了。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my Int $i = 0;</div><div class="line">my Rat $r = 3.142;</div><div class="line">my Str $s = &quot;Hello, world&quot;;</div></pre></td></tr></table></figure>
<p>然而， 静态类型仍旧是可选的， 所以编程人员可以不用任何显式的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $i = &quot;25&quot; + 10; # $i is 35</div></pre></td></tr></table></figure>
<p>Perl 6 提供了混合类型系统， 靠这点儿， 程序员可以选择使用静态类型、使用动态类型、或混合使用这两种类型。</p>
<h3 id="形式的子例程参数列表"><a href="#形式的子例程参数列表" class="headerlink" title="形式的子例程参数列表"></a>形式的子例程参数列表</h3><hr>
<p>Perl 5 定义子例程时一点儿也没使用形式参数。传递进来的子例程参数被存储到数组 <code>@_</code> 中，数组中的每个参数都是对应形式参数的别名，如果 <code>@_</code>  中的元素被修改了， 变化会被反映到原数据上。</p>
<p>Perl 6 引入了真正的形式参数。 在Perl 6 中， 子例程像这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub do_something(Str $thing, Int $other) &#123;</div><div class="line">     . . .</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>就像在 Perl 5中那样， 形参（i.e. 参数列表中的变量）是实参（传递进来的值）的别名， 但是默认的， 这种别名是常量的，所以不能被修改。 它们可以被显式地声明为可读-可写，作为原值或原值的副本， 使用 <code>is rw</code> 或 <code>is copy</code> 指令。</p>
<h3 id="参数传递模式"><a href="#参数传递模式" class="headerlink" title="参数传递模式"></a>参数传递模式</h3><hr>
<p>Perl 6 提供 3 种基本的参数传递模式</p>
<ul>
<li><p>位置的</p>
</li>
<li><p>具名的</p>
</li>
<li><p>Slurpy</p>
<p>​</p>
</li>
</ul>
<p>位置参数是大多数编程语言中都使用的典型的有序参数列表。所有的参数也可以一种无序的方式， 通过使用它们的名字传递。 具名参数只能通过指定它们的名字被传递（即，它从来不会捕获位置参数），具名参数用一个前置的 <code>:</code> 标示。吞噬参数(由参数名字前面的 <code>*</code> 标示) 是 Perl 6 中创建可变函数的工具。吞噬散列会捕获剩下的按名字传递的参数， 而吞噬数组会捕获剩下的按位置传递的参数。</p>
<p>下面是一个使用 3 种参数传递模式的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub somefunction($a, $b, :$c, :$d, *@e) &#123;</div><div class="line">  . . .</div><div class="line">&#125;</div><div class="line"></div><div class="line">somefunction(1, 2, :d(3), 4, 5, 6); # $a=1, $b=2, $d=3, @e=(4,5,6)</div><div class="line">somefunction(:b&lt;2&gt;, :a&lt;1&gt;);         # $a=&quot;1&quot;, $b=&quot;2&quot;</div></pre></td></tr></table></figure>
<p>诸如上面使用的位置参数，总是必须的， 除非它后面跟着一个 <code>?</code> 以标示它们是可选的。 具名参数默认是可选的， 但是能够通过在变量名的后面添加一个  <code>!</code> 把它标记为必选参数。吞噬参数总是可选的。</p>
<h3 id="Blocks-和-闭包"><a href="#Blocks-和-闭包" class="headerlink" title="Blocks 和 闭包"></a>Blocks 和 闭包</h3><hr>
<p>参数能被传递给任意的块儿， 这些块儿充当着闭包。 即， 举个例子， <code>for</code> 和 <code>while</code> 的循环变量可以被命名。在下面的例子中， 遍历一个列表， 每次 3 个元素，<code>$a,$b,$c</code> 作为变量被传递给循环的块儿。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for @list -&gt; $a, $b, $c &#123;</div><div class="line">     . . .</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这通常被引用为  <code>pointy sub</code>  或  <code>pointy block</code>,  箭头表现的几乎和 <code>sub</code> 关键字相同，它引入了一个匿名的闭包（或者用 Perl 5 的专业术语来说，引入了一个匿名子例程）。</p>
<h3 id="符号不变性"><a href="#符号不变性" class="headerlink" title="符号不变性"></a>符号不变性</h3><hr>
<p>在 Perl 5 中，变量名字前面的标点符号字符， 根据变量的使用方式而变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Perl 5 code</div><div class="line">my @array = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;);</div><div class="line">my $element = $array[1];    # $element equals &apos;b&apos;,</div><div class="line">my @extract = @array[1, 2]; # @extract equals (&apos;b&apos;, &apos;c&apos;)</div><div class="line">my $element = @array[1];    # &apos;b&apos; comes with a warning (5.10 option)</div></pre></td></tr></table></figure>
<p>在 Perl 6 中， 符号是不变的，这意味着，它不会根据它是一个数组还是一个数组元素而改变变量名前的符号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Perl 6 code</div><div class="line">my @array = &apos;a&apos;, &apos;b&apos;, &apos;c&apos;;</div><div class="line">my $element = @array[1];    # $element equals &apos;b&apos;</div><div class="line">my @extract = @array[1];    # @extract equals (&apos;b&apos;)</div><div class="line">my @extract = @array[1, 2]; # @extract equals (&apos;b&apos;, &apos;c&apos;)</div></pre></td></tr></table></figure>
<p>Perl 5 中的变体是受英语中的数字契约和其它很多自然语言影响的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;This apple.&quot;                    # $a        CORRECT</div><div class="line">&quot;These apples.&quot;                  # @a        CORRECT</div><div class="line">&quot;This third apple.&quot;              # $a[3]     CORRECT</div><div class="line">&quot;These third apple.&quot;             # @a[3]     WRONG</div></pre></td></tr></table></figure>
<p>然而， 当有了引用之后， 这种概念的映射就不起作用了， 因为它们可能引用的数据结构， 尽管它们是标量。 因此， 在单个 term 中，处理嵌套的数据结构可能既需要单数， 也需要复数形式的表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Perl 5 code: retrieve a list from the leaf of a hash containing hashes that contain arrays</div><div class="line">my @trans_verbs = @&#123; $dictionary&#123; &apos;verb&apos; &#125;&#123; &apos;transitive&apos; &#125; &#125;;</div></pre></td></tr></table></figure>
<p>相比来说， 在 Perl 6 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Perl 6 code: retrieve a list from the leaf of a hash containing hashes that contain arrays</div><div class="line">my @trans_verbs = %dictionary&#123; &apos;verb&apos; &#125;&#123; &apos;transitive&apos; &#125;.list;</div></pre></td></tr></table></figure>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><hr>
<p>Perl 5 通过 blessing 机制支持面向对象的编程。 任何引用都可以被 blessed 到特定类的对象中。</p>
<p>例如， 一个封装了笛卡尔点的类可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Point is rw &#123;</div><div class="line">   has $.x;</div><div class="line">   has $.y;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> my $point = Point.new( x =&gt; 1.2, y =&gt; -3.7 );</div><div class="line"></div><div class="line"> # Now change x (note method &quot;x&quot; used as lvalue):</div><div class="line"> $point.x = 2;</div><div class="line"> say &quot;Point is at X location: &quot;, $point.x;</div></pre></td></tr></table></figure>
<p>在 Perl 6 的专业术语中， <code>$.x</code> 叫做”属性”。有些语言叫这个 字段或成员。用于访问属性的方法叫做 “存取器”。自动存取器是自动创建的方法， 就像上面的 <code>x</code> 方法一样。 这些存取器函数返回属性的值。 当使用 <code>is rw</code> 修饰符声明一个类或单独的属性时，能传递一个新值给自动存取器来设置给属性， 或者它能作为一个左值被直接赋值（就像例子中的一样）。 自动存取器能被用户自定义的方法替换，程序员应该想要接口更丰富的属性。 属性只能在类的定义中被直接访问。 所有其它的访问方式必须经过存取器方法。</p>
<h3 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h3><hr>
<p>Perl 6 中的 roles 具有 Java 中的接口、 Ruby 中的 mixins 和 Smalltalk 中 traits 的功能。 这些都很像类， 但是它们是完全抽象的。 这些 Roles 在和类一块儿使用时， 用于执行混合而不是添加到类的继承链中。 Roles 定义名义上的类型， 它们为行为和状态集合提供了语义上的名字。role 和 类的最重要的区别就是， 类是可继承的， 而 roles 不是。</p>
<p>本质上， role 是一束不使用继承，添加到类中的方法和属性。 role 甚至可以被添加到单独的对象中。这时， Perl 6 会创建一个匿名的子类， 并把 role 添加到子类中， 并把对象的类改为匿名的子类。</p>
<p>例如， 狗（Dog）是一种哺乳动物（Mammal）。Dogs 从 Mammals 那儿继承某些特征， 诸如乳腺和脊柱（通过 Mammals的父类， 脊椎动物 Vetebrate）。 Dogs 可能有几个不同类型的行为； 例如， 一个 Dog 可能是 Pet， Stray， 或 导盲犬。 然而， 这些只是一组可以添加给一个 Dog 的额外的行为； Cat 能等同于 一个 Pet 或 Stray， 举个例子， 因此， Dog 和 Mammal 是类， 而 Pet， Stray， 和 导盲犬是 roles。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Mammal is Vertebrate &#123;</div><div class="line">     . . .</div><div class="line"> &#125;</div><div class="line"> class Dog is Mammal &#123;</div><div class="line">     . . .</div><div class="line"> &#125;</div><div class="line"> role Pet &#123;</div><div class="line">     . . .</div><div class="line"> &#125;</div><div class="line"> role Stray &#123;</div><div class="line">     . . .</div><div class="line"> &#125;</div><div class="line"> role Guide &#123;</div><div class="line">     . . .</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>通过使用 <code>does</code> 关键字把 Roles  添加到类中， 与继承的关键字 <code>is</code> 相对。关键字反应了两种功能的不同意义： role 混合给类一个行为的 role， 但是不继承表明它和 role 是同样的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class GuideDog is Dog does Guide &#123;</div><div class="line">    . . .</div><div class="line">&#125;   # Subclass composes role</div><div class="line"></div><div class="line">my $dog = new Dog;</div><div class="line">$dog does Guide;                         # Individual object composes role</div></pre></td></tr></table></figure>
<p>尽管 role 和 类不同， 但它们都是类型， 所以 role 能出现在变量声明的地方， 这个地方通常会放置一个类。例如， 一个用于 Human 的 导盲犬 role 可以包含 Guide 类型的属性； 这个属性可以包含 一个 Guide Dog， 一个 Guide Horse， 一个 Guide Human， 或者甚至一个 Guide Machine。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">    has Dog $dog;                        # Can contain any kind of Dog, whether it does the</div><div class="line">    ...                                  # Guide role or not</div><div class="line">&#125;</div><div class="line">role Blind &#123;</div><div class="line">    has Guide $guide;                    # Can contain any object that does the Guide role,</div><div class="line">    ...                                  # whether it is a Dog or something else</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><hr>
<p>主要文章 ： <a href="https://en.wikipedia.org/wiki/Perl_6_rules" target="_blank" rel="external">Perl 6 rules</a></p>
<h3 id="链式比较"><a href="#链式比较" class="headerlink" title="链式比较"></a>链式比较</h3><hr>
<p>Perl 6 允许链式比较， 即诸如下面这样的比较序列是被允许的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if 20 &lt;= $temperature &lt;= 25 &#123;</div><div class="line">     say &quot;Room temperature is between 20 and 25!&quot;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><hr>
<p>Perl 6 使用列表的惰性列表求值技术，惰性求值已经是诸如 Haskell 等函数式编程语言的功能亮点了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@integers = 0..Inf; # integers from 0 to infinity</div></pre></td></tr></table></figure>
<p>上面的代码在尝试把一个无限列表赋值给数组 <code>@integers</code> 时既不会崩溃， 也不会在尝试搜索某个限定的点以扩展列表时无限挂起。</p>
<p>这简化了很多普通的 Perl 6 任务， 包括输入/输出操作， 列表转换 和参数传递。</p>
<h3 id="Gather"><a href="#Gather" class="headerlink" title="Gather"></a>Gather</h3><hr>
<p>跟惰性求值相关的就是使用 <code>gather</code> 和 <code>take</code> 构建惰性列表， 这跟 Python 中的生成器有点像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $squares = gather for 0..Inf &#123;</div><div class="line">     take $_ * $_;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p><code>$squares</code> 会是一个平方数字的无限列表， 但是 <code>gather</code> 的惰性求值确保了值只在被访问时才被计算。</p>
<h3 id="Junctions"><a href="#Junctions" class="headerlink" title="Junctions"></a>Junctions</h3><hr>
<p>Perl 6 引入了 junctions 概念：由其它值混合而成的值。在 Perl 6 早期的设计中， 它们被叫做 “叠加”， 与量子物理中的量子叠加概念类似 — 波形能同时占据几种状态直到观测使它们坍缩。</p>
<p>在它们的最简单的形式中， 通过使用 junctive 操作符组合一组值来创建 junctions ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $any_even_digit = 0 | 2 | 4 | 6 | 8; # any(0, 2, 4, 6, 8)</div><div class="line">my $all_odd_digits = 1 &amp; 3 &amp; 5 &amp; 7 &amp; 9; # all(1, 3, 5, 7, 9)</div></pre></td></tr></table></figure>
<p><code>|</code> 表明一个要么等于它左边的参数， 要么等于它右边的参数的值。 <code>&amp;</code> 表明一个即等于它左边的参数又等于它右边参数的值。这些值能像普通值那样用在任何代码中。 对 Junction 执行的操作会同等地作用在 junction 的每一个成员身上， 并根据 junctive 操作符进行组合。 所以, <code>(&quot;apple&quot;|&quot;banana&quot;) ~ &quot;s&quot;</code>  会产生 <code>&quot;apples&quot;|&quot;bananas&quot;</code>.  在比较操作中， junction 会返回单个 True 或 False。 <code>any</code> junction 会返回 true， 如果junction的任一元素的比较为真的话。 <code>all</code> junctions 会返回真， 如果 junction 的所有元素的比较为真的话。</p>
<p>Junctions 通过引入用于约束 junctions 类型的一般编程风格，也能用于极大地增强类型系统：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub get_tint(RGB_Color | CMYK_Color $color, Num $opacity) &#123;</div><div class="line">     . . .</div><div class="line"> &#125;</div><div class="line"> sub store_record(Record &amp; Storable $rec) &#123;</div><div class="line">     . . .</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="Autothreading"><a href="#Autothreading" class="headerlink" title="Autothreading"></a>Autothreading</h3><hr>
<p>Junctions 是无序的， <code>1|2|3</code> 和 <code>3|2|1</code> 代表相同的值。没有顺序意味着 Perl 6 编译器能并行地选择计算 junctive 表达式。例如， 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if $string ~~ all(@list_of_regexes) &#123;</div><div class="line">    . . .</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将会对编译器表明， 字符串和一组正则表达式的所有匹配能被并发地被执行， 可能在单独的线程中。这个功能被授予 <code>autothreading</code>. autothreading 的并行化尚未在任一编译器中实现。</p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><hr>
<p>Perl 6 会利用 Lisp-like 的宏概念。 这种宏的强大源自这样的事实， 它像高级数据结构一样操作程序， 而非像普通的文本那样。</p>
<p>Perl 6 中宏的定义很像子例程或方法定义， 能作用在未解析的字符串上、AST 那样预解析的代码、或两者的组合。 一个宏定义就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">macro hello($what) &#123;</div><div class="line">  quasi &#123; say &quot;Hello &#123; &#123;&#123;&#123;$what&#125;&#125;&#125; &#125;&quot; &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><hr>
<p>Hello World</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &apos;Hello, world&apos;;</div></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr>
<p>一个使用函数式编程范式的有效实现能使用 Perl 6 简洁地写出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Empty list sorts to the empty list</div><div class="line">multi quicksort([]) &#123; () &#125;</div><div class="line"></div><div class="line"># Otherwise, extract first item as pivot...</div><div class="line">multi quicksort([$pivot, *@rest]) &#123;</div><div class="line">    # Partition.</div><div class="line">    my @before = @rest.grep(* &lt; $pivot);</div><div class="line">    my @after  = @rest.grep(* &gt;= $pivot);</div><div class="line"></div><div class="line">    # Sort the partitions.</div><div class="line">    (quicksort(@before), $pivot, quicksort(@after))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><hr>
<p>在计算机科学上汉诺塔通常用于介绍递归编程。这个实现使用 Perl 6 的多重分派机制和参数限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">multi sub hanoi(0, $, $, $) &#123; &#125;                         # No disk, so do not do anything</div><div class="line">multi sub hanoi($n, $a = &apos;A&apos;, $b = &apos;B&apos;, $c = &apos;C&apos;) &#123;     # Start with $n disks and three pegs A, B, C</div><div class="line">     hanoi $n - 1, $a, $c, $b;                          # firstly move top $n - 1 disks from A to B</div><div class="line">     say &quot;Move disk $n from peg $a to peg $c&quot;;          # then move last disk from A to C</div><div class="line">     hanoi $n - 1, $b, $a, $c;                          # lastly move $n - 1 disks from B to C</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Meta-Operator]]></title>
      <url>http://ohmycloud.github.io/2016/04/25/Meta-Operator/</url>
      <content type="html"><![CDATA[<h2 id="快速构造散列"><a href="#快速构造散列" class="headerlink" title="快速构造散列"></a>快速构造散列</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; my %hash = @lowers Z=&gt; @nums</div><div class="line">a =&gt; 1, b =&gt; 2, c =&gt; 3</div></pre></td></tr></table></figure>
<p>未完待续</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的特性(一)]]></title>
      <url>http://ohmycloud.github.io/2016/04/22/Perl6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7-%E4%B8%80/</url>
      <content type="html"><![CDATA[<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><hr>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @primes = (2,3,5,7,11,13,17,19,23);   # an array gets filled like in Perl 5</div><div class="line"># my @primes =  2,3,5,7,11,13,17,19,23 ; # same thing, since unlike P5 round braces just do group</div><div class="line"># my @primes = &lt;2 3 5 7 11 13 17 19 23&gt;; # dito, &lt;&gt; is the new qw()</div><div class="line"></div><div class="line">say @primes[];                           # 2 3 5 7 11 13 17 19 23</div><div class="line">my $arrayref = [2,3,5,7,11,13,17,19,23]; # in scalar context you get automatically a reference</div><div class="line">say @$arrayref;                          # 2 3 5 7 11 13 17 19 23</div><div class="line"></div><div class="line">my $arrayref = item @primes;             # same thing, more explicit</div><div class="line">say $arrayref;</div><div class="line"></div><div class="line">my $arrayref = [13,];                    # comma is the new array generator</div><div class="line">say $arrayref;</div><div class="line"></div><div class="line">my @primes = 2;                          # array with one element</div><div class="line">my @primes = [2,3,5,7,11,13,17,19,23];   # array with one element (arrayref)</div><div class="line">say @primes;                             # 2 3 5 7 11 13 17 19 23</div><div class="line"></div><div class="line">my @dev    = &#123;&apos;dan&apos; =&gt; &apos;parrot&apos;&#125;;        # array with one element (hashref)</div><div class="line">say @dev;                                # (&quot;dan&quot; =&gt; &quot;parrot&quot;).hash</div><div class="line"></div><div class="line"></div><div class="line">my @data   = [1..5],[6..10],[11..15];    # Array of Arrays (AoA)</div><div class="line">say @data.perl;                          # Array.new([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15])</div><div class="line"></div><div class="line"># my @list   = lol @data;                # no change</div><div class="line"># say @list.perl;</div><div class="line">my @list   = flat @data;                 # returns 1..15</div><div class="line">say @list;                               # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my @array = 1,3,5,7,9;</div><div class="line"></div><div class="line">my @arrayplus3 = map( *+3, @array);</div><div class="line">say @arrayplus3;</div><div class="line"></div><div class="line">my @arrayplusab = map( *+*+3, @array,11);</div><div class="line">say @arrayplusab;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line">my @rray=17,21,34,47,58,69;</div><div class="line"></div><div class="line">say &apos;the array has element&apos; if  ? @rray;   # boolean context, Bool::True if array has any value in it, even if its a 0</div><div class="line">say &apos;the array has &apos;,+ @rray ~&apos; element&apos;;  # numeric context, number of elements (like in Perl 5 scalar @a)</div><div class="line">say ~ @rray;              # string context, you get content of all cells, stringified and joined, same as &quot;@primes[]&quot;</div><div class="line"></div><div class="line">say @rray.elems;          # same as + @rray</div><div class="line">say @rray.end;            # number of the last element, equal to @rray.elems-1, # 5</div><div class="line"># say @rray.cat;          # same ~ @rray</div><div class="line">say @rray.join(&apos;-&apos;);      # also same result, you can put another string as parameter that gets between all values</div><div class="line">say @rray.unshift(7);     # prepend one value to the array, # 7 1 2 3 4 5 6</div><div class="line">say @rray.shift;          # remove the first value and return it # 7</div><div class="line">say @rray.push(8);        # add one value on the end # 1 2 3 4 5 6 8</div><div class="line">say @rray.pop;            # remove one value from the end and return it # 8</div><div class="line"></div><div class="line">my $n=2;</div><div class="line">my $pos=1;</div><div class="line">my @ind=0..3;</div><div class="line">say @rray.splice($pos,$n);# remove on $pos $n values and replace them with values that follow that two parameter</div><div class="line">say @rray:delete(@ind);   # delete all cell with indecies of @ind # 1 4 5 6</div><div class="line">say @rray:exists(@ind);   # Bool::True if all indecies of @ind have a value (can be 0 or &apos;&apos;)</div><div class="line"></div><div class="line">say &apos;-&apos; x 18;</div><div class="line">say @rray;</div><div class="line">say @rray.pick([$n]);     # return $n (default is 1) randomly selected values, without duplication</div><div class="line">say @rray.roll([$n]);     # return $n (default is 1) randomly selected values, duplication possible (就像掷筛子)</div><div class="line">say @rray.reverse;        # all elements in reversed order</div><div class="line">say @rray.rotate(-$n);    # returns a list where $n times first item is taken to last position if $n is positive, if negative the other way around</div><div class="line"># @rray.sort($coderef); # returns a sorted list by a userdefined criteria, default is alphanumerical sorting</div><div class="line">say @rray.min;            # numerical smallest value of that array</div><div class="line">say @rray.max;            # numerical largest value of that array</div><div class="line">my ($a,$b)= @rray.minmax;  # both at once, like in .sort . min or .max a sorting algorith can be provided</div><div class="line">say $a,&quot;   $b&quot;;</div><div class="line"># @rray.map($coderef);  # high oder map function, runs $coderef with every value as $_ and returns the list or results</div><div class="line"># @rray.classify($cr);  # kind of map, but creates a hash, where keys are the results of $cr and values are from @rray</div><div class="line"># @rray.categorize($cr);# kind of classify, but closure can have no (Nil) or several results, so a key can have a list of values</div><div class="line">say @rray.grep(&#123;$_&gt;40&#125;);   # high order grep, returns only these elements that pass a condition ($cr returns something positive)</div><div class="line"># @rray.first($coder);  # kind of grep, return just the first matching value</div><div class="line"># say @rray.zip;            # join arrays by picking first element left successively from here and then there</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my  @primes=&lt;1 3 5 7 9 11 13 15 17&gt;;</div><div class="line">say @primes;                       # all values as list</div><div class="line">say @primes.values;                # same thing</div><div class="line">say @primes.keys;                  # list of all indices</div><div class="line">say &quot;@primes[]&quot;;                   # insert all values in a string, uses [] as distinction from mail adresses</div><div class="line">my  $prime = @primes[0];           # get the first prime</div><div class="line">say $prime;</div><div class="line"></div><div class="line">my $last_prime = @primes[*-1];    # get the last one</div><div class="line">say $last_prime;</div><div class="line"></div><div class="line">my @some = @primes[2..5];         # get several</div><div class="line">say @some;</div><div class="line"></div><div class="line">my @data   = [1..5],[6..10],[11..15];  # Array of Arrays (AoA)</div><div class="line">my $cell = @data[1][2];                # get 8, third value of second value (list)</div><div class="line">say $cell;</div><div class="line"></div><div class="line">my  $same_cell = @data[1,2];           # same thing, shorten syntax</div><div class="line">say $same_cell;                        # 6 7 8 9 10 11 12 13 14 15</div><div class="line"></div><div class="line">my @numbers = @data[1];                # get a copy of the second subarray (6..10)</div><div class="line">say @numbers;</div><div class="line">my @copy = @data;                      # copy the whole AoA, no more reference passing, use binding instead</div><div class="line">say @copy.perl;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my @original = [1,2],[3,4];</div><div class="line">say @original.perl;</div><div class="line">my $copy = @original[0]; # $copy points to [1,2]</div><div class="line">say $copy;</div><div class="line">@original[0][0] = &apos;fresh stuff&apos;; # $copy[0] holds still 1</div><div class="line">say @original;</div><div class="line">say $copy;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my @names = &lt;Patrick Jonathan Larry Moritz Audrey&gt;;</div><div class="line">say .key, &quot;\t&quot;, ~.values</div><div class="line">    for @names.classify( *.chars );</div><div class="line"># 根据字符串的字符个数分类</div><div class="line"># Output:</div><div class="line"># 7	Patrick</div><div class="line"># 8	Jonathan</div><div class="line"># 5	Larry</div><div class="line"># 6	Moritz Audrey</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#.say for slurp(&quot;README.txt&quot;)\           # whole file into string</div><div class="line">#         .words()\                      # split into list of words</div><div class="line">#         .classify( *.Str );</div><div class="line"></div><div class="line">my @a = slurp(&quot;README.txt&quot;).words;</div><div class="line"># .say  for @a.classify( *.Str );</div><div class="line"># output:</div><div class="line">#  可见输出的是一个散列</div><div class="line"># that =&gt; that that that that that that that that that that that</div><div class="line"># the =&gt; the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the</div><div class="line"># is =&gt; is is is is is is is is is is is is is is is is</div><div class="line">my %hash = @a.classify( *.Str );</div><div class="line">for %hash.sort(&#123;-.value.elems&#125;).hash.kv.[^20] -&gt; $key, $value &#123;</div><div class="line">    say $key ,&quot;\t&quot;, $value.elems;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.say for slurp(&quot;README.txt&quot;)\           # whole file into string</div><div class="line">         .words()\                      # split into list of words</div><div class="line">         .classify( *.Str )\            # group words with multiplicity</div><div class="line">         .map(&#123;;.key =&gt; .value.elems &#125;)\</div><div class="line">                                        # turn lists into lengths</div><div class="line">         .sort( &#123; -.value &#125; )\          # sort descending</div><div class="line">         .[ ^10 ];                      # 10 most common words</div><div class="line"></div><div class="line"># Output:</div><div class="line"># the =&gt; 40</div><div class="line"># to =&gt; 21</div><div class="line"># is =&gt; 16</div><div class="line"># a =&gt; 16</div><div class="line"># that =&gt; 11</div><div class="line"># be =&gt; 11</div><div class="line"># stack =&gt; 10</div><div class="line"># implementation =&gt; 8</div><div class="line"># link =&gt; 8</div><div class="line"># it =&gt; 7</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $range = &apos;a&apos; .. &apos;f&apos;;</div><div class="line">for $range.list -&gt; $elem &#123;</div><div class="line">    say $elem;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.say for @( $range );</div><div class="line"># .say for $list.list;</div><div class="line">.say for $range.flat;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my @a=&lt;aa bb cc dd ee ff &gt;;</div><div class="line">for @a -&gt; $x,$y,$z &#123;</div><div class="line">say $x,$y,$z;</div><div class="line">&#125;</div><div class="line">say $*PROGRAM_NAME;</div><div class="line"></div><div class="line">aabbcc</div><div class="line">ddeeff</div><div class="line">three.p6</div></pre></td></tr></table></figure>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $a = bag &lt;a a a b b c&gt;;</div><div class="line">my $b = bag &lt;a b b b&gt;;</div><div class="line"></div><div class="line">say $a (|) $b;</div><div class="line">say $a (&amp;) $b;</div><div class="line">say $a (+) $b;</div><div class="line">say $a (.) $b;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"># my %words := KeyBag.new;</div><div class="line"># for slurp.comb(/\w+/).map(*.lc) -&gt; $word &#123;</div><div class="line">    # %words&#123;$word&#125;++;</div><div class="line"># &#125;</div><div class="line">my %words := Bag.new(slurp.comb(/\w+/).map(*.lc));</div><div class="line"></div><div class="line">say &quot;%words&#123;&#125;&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my %words;</div><div class="line">for slurp.comb(/\w+/).map(*.lc) -&gt; $word &#123;</div><div class="line">    %words&#123;$word&#125;++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for %words.pairs.sort(-*.value).map(&#123; $_.key, $_.value &#125;) -&gt; $word, $count &#123;</div><div class="line">    say &quot;$word: $count&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">my %words := Bag.new(slurp.comb(/\w+/).map(*.lc));</div><div class="line"># say %words.pairs.list.join(&quot;\n&quot;);</div><div class="line"># .say for %words.pairs.sort(-*.value);  # 按键值从大到小排序，然后打印，- 号是降序</div><div class="line"># &quot;and&quot; =&gt; 12</div><div class="line"># &quot;the&quot; =&gt; 11</div><div class="line"># &quot;our&quot; =&gt; 6</div><div class="line"># &quot;be&quot; =&gt; 6</div><div class="line"># &quot;man&quot; =&gt; 6</div><div class="line"># &quot;your&quot; =&gt; 6</div><div class="line"># &quot;us&quot; =&gt; 5</div><div class="line"># &quot;you&quot; =&gt; 5</div><div class="line"># &quot;for&quot; =&gt; 5</div><div class="line"># &quot;o&quot; =&gt; 5</div><div class="line"># &quot;to&quot; =&gt; 5</div><div class="line"></div><div class="line">for %words.pairs.sort(-*.value).map(&#123; $_.key, $_.value &#125;) -&gt; $word, $count &#123;</div><div class="line">    say &quot;$word: $count&quot;;</div><div class="line">&#125;</div><div class="line"># .say for %words.pairs.sort(-*.value).fmt(&quot;%-15s=&gt;%4d\n&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %words := bag slurp.comb(/\w+/).map(*.lc);</div><div class="line"></div><div class="line">for %words.pairs.sort(-*.value).map(&#123; $_.key, $_.value &#125;) -&gt; $word, $count &#123;</div><div class="line">    say &quot;$word: $count&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line">my %dev =  &apos;pugs&apos;=&gt;&apos;audreyt&apos;, &apos;pct&apos;=&gt;&apos;pm&apos;, &quot;STD&quot;=&gt;&apos;larry&apos;;</div><div class="line">my %same_dev = :rakudo(&apos;jnthn&apos;), :testsuite(&apos;moritz&apos;);            # adverb (pair) syntax works as well</div><div class="line">my %too_dev = (&apos;audreyt&apos;, &apos;pugs&apos;, &apos;pm&apos;, &apos;pct&apos;, &apos;larry&apos;, &quot;STD&quot;);  # lists get autoconverted in hash context</div><div class="line">my %compiler = Parrot =&gt; &#123;Rakudo =&gt; &apos;jnthn&apos;&#125;, SMOP =&gt; &#123;Mildew =&gt; &apos;ruoso&apos;&#125;;       # hash of hashes (HoH)</div><div class="line">say %dev.perl;</div><div class="line">say %same_dev.perl;</div><div class="line">say %too_dev.perl;</div><div class="line">say %compiler.perl;</div><div class="line"></div><div class="line"># Hash Slices</div><div class="line">my $name=&apos;pugs&apos;;</div><div class="line">my $value = %dev&#123;&apos;pugs&apos;&#125;;      # just give me the value related to that key, like in P5</div><div class="line">my $value1 = %dev&lt;STD&gt;;         # &lt;&gt; autoquotes like qw() in P5</div><div class="line">my $value2 = %dev&lt;&lt;$name&gt;&gt;;     # same thing, just with eval</div><div class="line">say $value;</div><div class="line">say $value2;</div><div class="line"></div><div class="line">my @values = %dev&#123;&apos;pugs&apos;, &apos;STD&apos;&#125;;</div><div class="line">my @values2 = %dev&lt;pugs STD&gt;;</div><div class="line">my @values3 = %dev&lt;&lt;pugs STD $name&gt;&gt;;</div><div class="line">say @values;</div><div class="line">say @values2;</div><div class="line">say @values3;</div><div class="line"></div><div class="line">say %compiler&lt;Parrot&gt;&lt;Rakudo&gt;; # value in a HoH, returns &apos;jnthn&apos;</div><div class="line">say %compiler&lt;SMOP&gt;;           # returns the Pair: Mildew =&gt; &apos;ruoso&apos;</div><div class="line"></div><div class="line"># %dev   &#123;&apos;audrey&apos;&#125;;         # error, spaces between varname and braces (postcircumfix operator) are no longer allowed</div><div class="line">say %dev\  &#123;&apos;pugs&apos;&#125;;        # works, quote the space</div><div class="line"># %dev   .&lt;dukeleto&gt;;        # error</div><div class="line">say %dev\ .&#123;&apos;pugs&apos;&#125;;        # works too, &quot;long dot style&quot;, because its its an object in truth</div><div class="line">say %dev.&#123;&apos;pugs&apos;&#125;;</div><div class="line"></div><div class="line"></div><div class="line"># Hash Methods</div><div class="line">say &apos;this hash has some pairs&apos; if ? %dev;                    # bool context, true if hash has any pairs</div><div class="line">say &apos;this hash has &apos;~ + %dev ~&apos; pairs&apos;;                      # numeric context, returns number of pairs(keys)</div><div class="line">say ~ %dev;                    # string context, nicely formatted 2 column table using \t and \n</div><div class="line"></div><div class="line">my $table = %dev;             # same as ~ %dev</div><div class="line">say $table;                   # (&quot;pugs&quot; =&gt; &quot;audreyt&quot;, &quot;pct&quot; =&gt; &quot;pm&quot;, &quot;STD&quot; =&gt; &quot;larry&quot;).hash</div><div class="line">say %dev.say;                 # stringified, but only $key and $value are separated by \t  #(&quot;pugs&quot; =&gt; &quot;audreyt&quot;, &quot;pct&quot; =&gt; &quot;pm&quot;, &quot;STD&quot; =&gt; &quot;larry&quot;).hash</div><div class="line">my  @pairs = %dev;             # list of all containing pairs</div><div class="line">say @pairs;                    # &quot;pugs&quot; =&gt; &quot;audreyt&quot; &quot;pct&quot; =&gt; &quot;pm&quot; &quot;STD&quot; =&gt; &quot;larry&quot;</div><div class="line">say %dev.pairs;                 # same thing in all context  # &quot;pugs&quot; =&gt; &quot;audreyt&quot; &quot;pct&quot; =&gt; &quot;pm&quot; &quot;STD&quot; =&gt; &quot;larry&quot;</div><div class="line">say %dev.elems;                 # same as + %dev or + %dev.pairs  # 3</div><div class="line">say %dev.keys;                  # returns the list with all keys</div><div class="line">say %dev.values;                # list of all values</div><div class="line">say %dev.kv;                    # flat list with key1, value1, key 2 ...</div><div class="line">say %dev.invert;                # reverse all key =&gt; value relations</div><div class="line">say %dev.push(@pairs);         # inserts a list of pairs, if a key is already present in %dev, both values gets added to an array</div><div class="line"># (&quot;pugs&quot; =&gt; [&quot;audreyt&quot;, &quot;audreyt&quot;], &quot;pct&quot; =&gt; [&quot;pm&quot;, &quot;pm&quot;], &quot;STD&quot; =&gt; [&quot;larry&quot;, &quot;larry&quot;]).hash</div><div class="line"></div><div class="line">my @another_pairs=&apos;Rakudo&apos;=&gt;&apos;Perl6&apos;;</div><div class="line">say %same_dev.push(@another_pairs);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># You can also destructure hashes (and classes, which you&apos;ll learn about later !)</div><div class="line"># The syntax is basically `%hash-name (:key($variable-to-store-value-in))`.</div><div class="line"># The hash can stay anonymous if you only need the values you extracted.</div><div class="line">sub key-of(% (:value($val), :qua($qua))) &#123;</div><div class="line">  say &quot;Got val $val, $qua times.&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># Then call it with a hash: (you need to keep the brackets for it to be a hash)</div><div class="line">key-of(&#123;value =&gt; &apos;foo&apos;, qua =&gt; 1&#125;);</div><div class="line">my %hash = value =&gt; &apos;Perl6&apos;, qua =&gt; &apos;2016&apos;;</div><div class="line">key-of(%hash); # the same (for an equivalent `%hash`);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $bag = bag &quot;red&quot; =&gt; 2, &quot;blue&quot; =&gt; 10;</div><div class="line">say $bag.roll(10); # 随机生成 10 组</div><div class="line">say $bag.pick(*).join(&quot;\n&quot;);</div><div class="line"></div><div class="line">$bag = bag &quot;red&quot; =&gt; 20000000000000000001, &quot;blue&quot; =&gt; 100000000000000000000;</div><div class="line">say $bag.roll(10);</div><div class="line">say $bag.pick(10).join(&quot; &quot;);</div></pre></td></tr></table></figure>
<h3 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line">my @a := 1..Inf;</div><div class="line">say @a[^10]; # 1 2 3 4 5 6 7 8 9 10</div><div class="line"></div><div class="line">my @primes  := @a.grep(*.is-prime);</div><div class="line">say @primes[^10]; # 2 3 5 7 11 13 17 19 23 29</div><div class="line"></div><div class="line">my @nprimes := @primes.map(&#123; &quot;&#123;++state $n&#125;: $_&quot; &#125;);</div><div class="line">.say for @nprimes[^10];</div><div class="line"></div><div class="line">.say for (1..Inf</div><div class="line">    ==&gt; grep(*.is-prime)</div><div class="line">    ==&gt; map(&#123; &quot;&#123;++state $n&#125;: $_&quot; &#125;)</div><div class="line">    )[^10];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my @a := (1, 2, 3);</div><div class="line">say @a.WHAT;</div><div class="line">say @a.elems;</div><div class="line"></div><div class="line">my @b = (1, 2, 3);</div><div class="line">@b[0] := my $x;</div><div class="line">$x = 42;</div><div class="line">say @b;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $original = 5;say $original;</div><div class="line">my $mirror;</div><div class="line">$original := $mirror;       # normal binding, done on runtime</div><div class="line"></div><div class="line">say $mirror;</div><div class="line"></div><div class="line">$original ::= $mirror;      # same thing, but done during compile time</div><div class="line">say $mirror;</div><div class="line">$original = 3;</div><div class="line">say $mirror;                # prints 3</div><div class="line">$original =:= $mirror;       # true, because their bound together</div><div class="line">$original === $mirror;       # alsotrue, because content and type are equal</div></pre></td></tr></table></figure>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">my $total = 0;</div><div class="line">for @files -&gt; $filename &#123;</div><div class="line">    $total += lines($filename.IO).grep(</div><div class="line">        &#123; $_ !~~ /&lt;&amp;insigline&gt;/ &#125;</div><div class="line">).elems;</div><div class="line"> CATCH &#123;</div><div class="line">        when X::IO &#123;</div><div class="line">            note &quot;Couldn&apos;t read $filename&quot;;</div><div class="line">&#125; &#125;</div><div class="line">&#125;</div><div class="line">say $total;</div><div class="line"># As CATCH goes inside of the scope,we can see the scope&apos;s lexicals!</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"># create a file</div><div class="line">my $f = open &quot;foo&quot;,:w;</div><div class="line">$f.print(time);</div><div class="line">$f.close;</div><div class="line"></div><div class="line"># copy</div><div class="line">my $io = IO::Path.new(&quot;foo&quot;);</div><div class="line">$io.copy(&quot;foo2&quot;);</div><div class="line"></div><div class="line"># clean up</div><div class="line">unlink (&quot;foo2&quot;);</div><div class="line"></div><div class="line"># move</div><div class="line">$io.rename(&quot;foo2&quot;);</div><div class="line"></div><div class="line"># clean up</div><div class="line">unlink (&quot;foo2&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"># create a file</div><div class="line">my $f = open &quot;foo&quot;,:w;</div><div class="line">$f.print(time);</div><div class="line">$f.close;</div><div class="line"></div><div class="line">unlink &quot;foo&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1428936330</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1428936330</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $fn =  $?FILE;</div><div class="line"></div><div class="line">my Instant $i = $fn.IO.accessed;</div><div class="line">my $dt = $i.to-posix;</div><div class="line"></div><div class="line">say :$dt.perl;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># slurp 读入到数组后只是一个元素</div><div class="line">my @lines = slurp(&apos;3col.txt&apos;);</div><div class="line">say @lines.elems;</div><div class="line"></div><div class="line">my $fh = open(&apos;3col.txt&apos;);</div><div class="line">for $fh.lines -&gt; $line &#123;</div><div class="line">    say $line;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">﻿&gt; 15 + 27</div><div class="line">42</div><div class="line">&gt; &lt;beer vodka whisky&gt;.pick</div><div class="line">beer</div><div class="line">&gt; &lt;beer vodka whisky&gt;.pick(2)</div><div class="line">beer whisky</div><div class="line">&gt; (1, 1, *+* ... *)[20]</div><div class="line">10946</div><div class="line">&gt;  dir&gt;&gt;.path</div><div class="line">&gt; dir&gt;&gt;.path ==&gt; grep /\.p6$/</div><div class="line">REPL.p6 slides.p6</div><div class="line"></div><div class="line">&gt; type REPL.p6 | perl6 -e &quot;$*IN.slurp-rest.comb(/\w+/) ==&gt; sort *.chars ==&gt; @temp ==&gt; reverse @temp ==&gt; @reverse ==&gt; say @reverse</div><div class="line">&gt; type REPL.p6 | perl6 -e &quot;$*IN.slurp-rest.comb(/\w+/) ==&gt; sort *.chars ==&gt; reverse @() ==&gt; join \&quot;\n\&quot; ==&gt; say @()&quot;</div><div class="line">&gt; type Hamlet.txt | perl6 -e &quot;say [max] $*IN.slurp-rest.comb(/\d+/)&quot;</div><div class="line"></div><div class="line"># slurp reads a file into a scalar</div><div class="line">&gt; dir&gt;&gt;.path ==&gt; grep /\.p6$/ ==&gt; sort &#123; slurp($_).chars &#125;</div><div class="line">slurp_feed.p6 REPL.p6 slides.p6</div><div class="line"></div><div class="line"># lines reads the lines of a file into an array</div><div class="line">&gt; dir&gt;&gt;.path ==&gt; grep /\.p6$/ ==&gt; sort &#123; +lines($_) &#125;</div><div class="line">REPL.p6 slides.p6 slurp_feed.p6</div><div class="line"># 求出所有 words的和</div><div class="line">&gt; type 3col.txt | perl6 -e &quot;say [+] $*IN.lines&gt;&gt;.words&quot;</div><div class="line">&gt; type 3col.txt | perl6 -e &quot;say [+] $*IN.lines&gt;&gt;.words&gt;&gt;.elems # word 的个数</div><div class="line">&gt; type 3col.txt | perl6 -e &quot;say [+] $*IN.lines&gt;&gt;.words&gt;&gt;.[2]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my %words;</div><div class="line">for slurp.comb(/\w+/).map(*.lc) -&gt; $word &#123;</div><div class="line">    %words&#123;$word&#125;++;</div><div class="line">&#125;</div><div class="line">say %words:kv;</div></pre></td></tr></table></figure>
<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><hr>
<p>Classes In Perl 6</p>
<p>使用带有 block 的 class 关键字引入一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Puppy &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 或使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Puppy;</div><div class="line">...</div><div class="line">1;</div></pre></td></tr></table></figure>
<p>把类相关的东西<code>单独</code>写进一个文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Enemy &#123;</div><div class="line">    method attack-with-arrows   &#123; say &quot;peow peow peow&quot; &#125;</div><div class="line">    method attack-with-swords   &#123; say &quot;swish cling clang&quot; &#125;</div><div class="line">    method attack-with-fireball &#123; say &quot;sssSSS fwoooof&quot; &#125;</div><div class="line">    method attack-with-camelia  &#123; say &quot;flap flap RAWWR!&quot; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 创建一个方法筛选器， 方法名以 attack-with- 开头</div><div class="line"># 对象的 ^methods 方法返回该对象所有的方法，包括自定义的方法</div><div class="line">my $selector = &#123; .name ~~ /^ &apos;attack-with-&apos; / &#125;;</div><div class="line">given Enemy.new -&gt; $e &#123;</div><div class="line">    my $attack-strategy</div><div class="line">        = $e.^methods().grep($selector).pick();</div><div class="line"></div><div class="line">    $e.$attack-strategy();           # call a random method</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Parent &#123;</div><div class="line">    method frob &#123;</div><div class="line">        say &quot;the parent class frobs&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Child is Parent &#123;</div><div class="line">    method frob &#123;</div><div class="line">        say &quot;the child&apos;s somewhat more fancy frob is called&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"># 对象的实际类型决定了要调用哪个方法</div><div class="line">my Parent $test;</div><div class="line">$test = Child.new;</div><div class="line">$test.frob;          # calls the frob method of Child rather than Parent</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Dog &#123;</div><div class="line">    has $.name is rw;</div><div class="line">    has $.color;</div><div class="line"></div><div class="line">    method kugo &#123;</div><div class="line">       say &quot;hello &quot;,$.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">my $pet = Dog.new(</div><div class="line">    name =&gt; &apos;Spot&apos;, color =&gt; &apos;Black&apos;</div><div class="line">);</div><div class="line">$pet.kugo();</div><div class="line">$pet.name = &apos;Fido&apos;; # OK</div><div class="line">$pet.kugo();</div><div class="line">$pet.color = &apos;White&apos;; # Fails</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $.origin;</div><div class="line">    has $.destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $.notes is rw;</div><div class="line"></div><div class="line">    method add_traveller($name) &#123;</div><div class="line">        if $name ne any(@!travellers) &#123;</div><div class="line">            push @!travellers, $name;</div><div class="line">        &#125; else &#123;</div><div class="line">            warn &quot;$name is already going on the journey!&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method describe() &#123;</div><div class="line">        &quot;From $!origin to $!destination&quot;;</div><div class="line">    &#125;</div><div class="line">    # Private method</div><div class="line">    method !do-something-private($x) &#123;</div><div class="line">       ($x + 120)*0.88; # 先加价，再打折！</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method price($x) &#123;</div><div class="line">        self!do-something-private(2*$x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">my $vacation = Journey.new(</div><div class="line">    origin      =&gt; &apos;China&apos;,</div><div class="line">    destination =&gt; &apos;Sweden&apos;,</div><div class="line">    notes       =&gt; &apos;Pack hiking&apos;</div><div class="line">);</div><div class="line"></div><div class="line">say $vacation.origin;</div><div class="line">$vacation.notes = &apos;Pack hiking gear and sunglasses!&apos;;</div><div class="line">say $vacation.notes;</div><div class="line">$vacation.add_traveller(&apos;Larry Wall&apos;);</div><div class="line">say $vacation.price(40);</div><div class="line">$vacation.add_traveller(&apos;Larry Wall&apos;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use MethodModifiers;</div><div class="line">class C &#123;</div><div class="line">method m() is before &#123; say &quot;before&quot;; &#125; method m() &#123; say &quot;in the method&quot;; &#125; method m() is after &#123; say &quot;after&quot;; &#125;</div><div class="line">&#125; C.m;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $.origin;</div><div class="line">    has $.destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $.notes is rw;</div><div class="line"></div><div class="line">    method add_traveller($name) &#123;</div><div class="line">        if $name ne any(@!travellers) &#123;</div><div class="line">            push @!travellers, $name;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            warn &quot;$name is already going on the journey!&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method describe() &#123;</div><div class="line">        &quot;From $!origin to $!destination&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y = 2 * $!x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $p = Point.new( x =&gt; 1, y =&gt; 2);</div><div class="line">say &quot;x: &quot;, $p.x;</div><div class="line">say &quot;y: &quot;, $p.y;</div><div class="line"></div><div class="line">my $p2 = Point.new( x =&gt; 5 );</div><div class="line"># the given value for x is used to calculate the right</div><div class="line"># value for y.</div><div class="line">say &quot;x: &quot;, $p2.x;</div><div class="line">say &quot;y: &quot;, $p2.y;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $.origin;</div><div class="line">    has $.destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $.notes;  # 没有添加 is rw 限制时, 属性默认是只读的!</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $j = Journey.new(</div><div class="line">    origin      =&gt; &apos;Sweden&apos;,</div><div class="line">    destination =&gt; &apos;China&apos;,</div><div class="line">    notes       =&gt; &apos;Be careful your money!&apos;</div><div class="line">);</div><div class="line"></div><div class="line">say $j.origin;</div><div class="line">say $j.destination;</div><div class="line">say $j.notes;</div><div class="line"></div><div class="line"># now, try to change notes</div><div class="line">$j.notes = &apos;gun nima dan&apos;; # Cannot modify an immutable Str</div><div class="line">say $j.notes;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $.origin;</div><div class="line">    has $.destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $.notes is rw;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># Create a new instance of the class.</div><div class="line">my $vacation = Journey.new(</div><div class="line">    origin      =&gt; &apos;Sweden&apos;,</div><div class="line">    destination =&gt; &apos;Switzerland&apos;,</div><div class="line">    notes       =&gt; &apos;Pack hiking gear!&apos;</div><div class="line">);</div><div class="line"></div><div class="line"># 使用取值器, 这输出 Sweden.</div><div class="line">say $vacation.origin;</div><div class="line"># 使用 rw 存取器修改属性的值</div><div class="line">$vacation.notes = &apos;Pack hiking gear and sunglasses!&apos;;</div><div class="line">say $vacation.notes;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Paper   &#123; &#125;</div><div class="line">class Scissor &#123; &#125;</div><div class="line">class Stone   &#123; &#125;</div><div class="line"></div><div class="line">multi win(Paper   $a, Stone   $b) &#123; 1 &#125;</div><div class="line">multi win(Scissor $a, Paper   $b) &#123; 1 &#125;</div><div class="line">multi win(Stone   $a, Scissor $b) &#123; 1 &#125;</div><div class="line">multi win(Any     $a, Any     $b) &#123; 0 &#125;</div><div class="line"></div><div class="line">say win(Paper.new, Scissor.new); # 0</div><div class="line">say win(Stone.new, Stone.new); #0</div><div class="line">say win(Paper.new, Stone.new); #1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Point2D &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line"></div><div class="line">    submethod BUILD(:$!x, :$!y) &#123;</div><div class="line">        say &quot;Initalizing Point2D&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class InvertiblePoint2D is Point2D &#123;</div><div class="line">    submethod BUILD() &#123;</div><div class="line">        say &quot;Initilizing InvertiblePoint2D&quot;;</div><div class="line">    &#125;</div><div class="line">    method invert &#123;</div><div class="line">        self.new(x =&gt; - $.x, y =&gt; - $.y);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say InvertiblePoint2D.new( x =&gt; 1, y =&gt; 2);</div></pre></td></tr></table></figure>
<h2 id="Junctions"><a href="#Junctions" class="headerlink" title="Junctions"></a>Junctions</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my @bad_ext = (&apos;plx&apos;, &apos;pm&apos;, &apos;pl&apos;, &apos;p6&apos;);</div><div class="line">my $file_ext = &apos;p6&apos;;</div><div class="line">if lc($file_ext) eq any(@bad_ext) &#123;</div><div class="line">    say &quot;$file_ext files is  allowed, You are a Perler&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $filename = &quot;temp.txt&quot;;</div><div class="line">my $fh = open $filename, :w;</div><div class="line"></div><div class="line">for dir(test =&gt; all(/p6$/, /^&lt;-[._]&gt;/ )) -&gt; $file &#123;</div><div class="line">    $fh.say(“```perl66”);</div><div class="line">    my $string = slurp $file;</div><div class="line">    $fh.say($string);</div><div class="line">    $fh.say(“```”);</div><div class="line">    $fh.say();</div><div class="line">&#125;</div><div class="line"></div><div class="line">$fh.close;</div></pre></td></tr></table></figure>
<h2 id="Lazy-List"><a href="#Lazy-List" class="headerlink" title="Lazy List"></a>Lazy List</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my @integers = 1..*;</div><div class="line">    for @integers -&gt; $i &#123;</div><div class="line">        say $i;</div><div class="line">        last if $i % 17 == 0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.</div><div class="line"></div><div class="line"># Some attributes of a list comprehension are that:</div><div class="line"># 1. They should be distinct from (nested) for loops within the syntax of the language.</div><div class="line"># 2. They should return either a list or an iterator (something that returns successive members of a collection, in order).</div><div class="line"># 3. The syntax has parts corresponding to that of set-builder notation.</div><div class="line"></div><div class="line"># Write a list comprehension that builds the list of all Pythagorean triples with elements between 1 and n. If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.</div><div class="line"></div><div class="line">use v6;</div><div class="line"></div><div class="line">my $n = 20;</div><div class="line">my @list := gather for 1..$n -&gt; $x &#123;</div><div class="line">         for $x..$n -&gt; $y &#123;</div><div class="line">           for $y..$n -&gt; $z &#123;</div><div class="line">             take $x,$y,$z if $x*$x + $y*$y == $z*$z;</div><div class="line">           &#125;</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">.say for  @list;</div><div class="line"></div><div class="line"># Note that gather/take is the primitive in Perl 6 corresponding to generators or coroutines in other languages. It is not, however, tied to function call syntax in Perl 6. We can get away with that because lists are lazy, and the demand for more of the list is implicit; it does not need to be driven by function calls.</div></pre></td></tr></table></figure>
<h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">my $row-count = 6;</div><div class="line"></div><div class="line">constant $peg = &quot;*&quot;;</div><div class="line">constant @coin-icons = &quot;\c[UPPER HALF BLOCK]&quot;, &quot;\c[LOWER HALF BLOCK]&quot;;</div><div class="line"></div><div class="line">sub display-board(@positions, @stats is copy, $halfstep) &#123;</div><div class="line">    my $coin = @coin-icons[$halfstep.Int];</div><div class="line"></div><div class="line">    state @board-tmpl = &#123;</div><div class="line">        # precompute a board</div><div class="line">        my @tmpl;</div><div class="line">        sub out(*@stuff) &#123;</div><div class="line">            @tmpl.push: @stuff&gt;&gt;.ords.item;</div><div class="line">        &#125;</div><div class="line">        # three lines of space above</div><div class="line">        for (1..3) &#123;</div><div class="line">            out &quot;  &quot;, &quot; &quot; x (2 * $row-count);</div><div class="line">        &#125;</div><div class="line">        # $row-count lines of pegs</div><div class="line">        for ($row-count...1) Z (1...$row-count) -&gt; $spaces, $pegs &#123;</div><div class="line">            out &quot;  &quot;, &quot; &quot; x $spaces, ($peg xx $pegs).join(&quot; &quot;), &quot; &quot; x $spaces;</div><div class="line">        &#125;</div><div class="line">        # four lines of space below</div><div class="line">        for (1..4) &#123;</div><div class="line">            out &quot;  &quot;, &quot; &quot; x (2 * $row-count);</div><div class="line">        &#125;</div><div class="line">        @tmpl</div><div class="line">    &#125;();</div><div class="line"></div><div class="line">    my $midpos = $row-count + 2;</div><div class="line"></div><div class="line">    my @output;</div><div class="line">    &#123;</div><div class="line">        # collect all the output and output it all at once at the end</div><div class="line">        sub say(Str $foo) &#123;</div><div class="line">            @output.push: $foo, &quot;\n&quot;;</div><div class="line">        &#125;</div><div class="line">        sub print(Str $foo) &#123;</div><div class="line">            @output.push: $foo;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # make some space above the picture</div><div class="line">        say &quot;&quot; for ^10;</div><div class="line"></div><div class="line">        my @output-lines = map &#123; [map *.clone, @$_].item &#125;, @board-tmpl;</div><div class="line">        # place the coins</div><div class="line">        for @positions.kv -&gt; $line, $pos &#123;</div><div class="line">            next unless $pos.defined;</div><div class="line">            @output-lines[$line][$pos + $midpos] = $coin.ord;</div><div class="line">        &#125;</div><div class="line">        # output the board with its coins</div><div class="line">        for @output-lines -&gt; @line &#123;</div><div class="line">            say @line&gt;&gt;.chr.join(&quot;&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # show the statistics</div><div class="line">        my $padding = 0;</div><div class="line">        while any(@stats) &gt; 0 &#123;</div><div class="line">            $padding++;</div><div class="line">            print &quot;  &quot;;</div><div class="line">            @stats = do for @stats -&gt; $stat &#123;</div><div class="line">                given $stat &#123;</div><div class="line">                    when 1 &#123;</div><div class="line">                        print &quot;\c[UPPER HALF BLOCK]&quot;;</div><div class="line">                        $stat - 1;</div><div class="line">                    &#125;</div><div class="line">                    when * &lt;= 0 &#123;</div><div class="line">                        print &quot; &quot;;</div><div class="line">                        0</div><div class="line">                    &#125;</div><div class="line">                    default &#123;</div><div class="line">                        print &quot;\c[FULL BLOCK]&quot;;</div><div class="line">                        $stat - 2;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            say &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        say &quot;&quot; for $padding...^10;</div><div class="line">    &#125;</div><div class="line">    say @output.join(&quot;&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub simulate($coins is copy) &#123;</div><div class="line">    my $alive = True;</div><div class="line"></div><div class="line">    sub hits-peg($x, $y) &#123;</div><div class="line">        if 3 &lt;= $y &lt; 3 + $row-count and -($y - 2) &lt;= $x &lt;= $y - 2 &#123;</div><div class="line">            return not ($x - $y) %% 2;</div><div class="line">        &#125;</div><div class="line">        return False;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    my @coins = Int xx (3 + $row-count + 4);</div><div class="line">    my @stats = 0 xx ($row-count * 2);</div><div class="line">    # this line will dispense coins until turned off.</div><div class="line">    @coins[0] = 0;</div><div class="line">    while $alive &#123;</div><div class="line">        $alive = False;</div><div class="line">        # if a coin falls through the bottom, count it</div><div class="line">        given @coins[*-1] &#123;</div><div class="line">            when *.defined &#123;</div><div class="line">                @stats[$_ + $row-count]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # move every coin down one row</div><div class="line">        for ( 3 + $row-count + 3 )...1 -&gt; $line &#123;</div><div class="line">            my $coinpos = @coins[$line - 1];</div><div class="line"></div><div class="line">            @coins[$line] = do if not $coinpos.defined &#123;</div><div class="line">                Nil</div><div class="line">            &#125; elsif hits-peg($coinpos, $line) &#123;</div><div class="line">                # when a coin from above hits a peg, it will bounce to either side.</div><div class="line">                $alive = True;</div><div class="line">                ($coinpos - 1, $coinpos + 1).pick;</div><div class="line">            &#125; else &#123;</div><div class="line">                # if there was a coin above, it will fall to this position.</div><div class="line">                $alive = True;</div><div class="line">                $coinpos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        # let the coin dispenser blink and turn it off if we run out of coins</div><div class="line">        if @coins[0].defined &#123;</div><div class="line">            @coins[0] = Nil</div><div class="line">        &#125; elsif --$coins &gt; 0 &#123;</div><div class="line">            @coins[0] = 0</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # smooth out the two halfsteps of the animation</div><div class="line">        my $start-time;</div><div class="line">        ENTER &#123; $start-time = now &#125;</div><div class="line">        my $wait-time = now - $start-time;</div><div class="line"></div><div class="line">        sleep 0.1 - $wait-time if $wait-time &lt; 0.1;</div><div class="line">        for @coin-icons.keys &#123;</div><div class="line">            sleep $wait-time max 0.1;</div><div class="line">            display-board(@coins, @stats, $_);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub MAIN($coins = 20, $peg-lines = 6) &#123;</div><div class="line">    $row-count = $peg-lines;</div><div class="line">    simulate($coins);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> #!/usr/bin/env perl6</div><div class="line"></div><div class="line">    constant @months = &lt;January February March April May June July</div><div class="line">                        August September October November December&gt;;</div><div class="line">    constant @days = &lt;Su Mo Tu We Th Fr Sa&gt;;</div><div class="line"></div><div class="line"></div><div class="line">    sub center(Str $text, Int $width) &#123;</div><div class="line">        my $prefix = &apos; &apos; x ($width - $text.chars) div 2;</div><div class="line">        my $suffix = &apos; &apos; x $width - $text.chars - $prefix.chars;</div><div class="line">        return $prefix ~ $text ~ $suffix;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sub MAIN(:$year = Date.today.year, :$month = Date.today.month) &#123;</div><div class="line">        my $dt = Date.new(:year($year), :month($month), :day(1) );</div><div class="line">        my $ss = $dt.day-of-week % 7;</div><div class="line">        my @slots = &apos;&apos;.fmt(&quot;%2s&quot;) xx $ss;</div><div class="line"></div><div class="line">        my $days-in-month = $dt.days-in-month;</div><div class="line">        for $ss ..^ $ss + $days-in-month &#123;</div><div class="line">            @slots[$_] = $dt.day.fmt(&quot;%2d&quot;);</div><div class="line">            $dt++</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        my $weekdays = @days.fmt(&quot;%2s&quot;).join: &quot; &quot;;</div><div class="line">        say center(@months[$month-1] ~ &quot; &quot; ~ $year, $weekdays.chars);</div><div class="line">        say $weekdays;</div><div class="line">        for @slots.kv -&gt; $k, $v &#123;</div><div class="line">            print &quot;$v &quot;;</div><div class="line">            print &quot;\n&quot; if ($k+1) %% 7 or $v == $days-in-month;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     # April 2014</div><div class="line"># Su Mo Tu We Th Fr Sa</div><div class="line">       # 1  2  3  4  5</div><div class="line"> # 6  7  8  9 10 11 12</div><div class="line"># 13 14 15 16 17 18 19</div><div class="line"># 20 21 22 23 24 25 26</div><div class="line"># 27 28 29 30</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">﻿# Perl 6 supports writing a MAIN subroutine that is invoked at startup.</div><div class="line"># Automatically maps arguments to parameters and generates usage instructions.</div><div class="line"></div><div class="line"></div><div class="line">sub MAIN($number, Bool :$upto) &#123;</div><div class="line">    my @fib = 1, 1, *+* ... Inf;</div><div class="line">    if $upto &#123;</div><div class="line">    say join &apos;,&apos;, @fib[0 ..^ $number];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        say @fib[$number - 1];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#`(</div><div class="line">&gt; perl6 MAIN.p6 10</div><div class="line">55</div><div class="line"></div><div class="line">&gt; perl6 MAIN.p6 10 --upto</div><div class="line">Usage:</div><div class="line">  MAIN.p6 [--upto] &lt;number&gt;</div><div class="line"></div><div class="line"># 可选参数写在必选参数前面</div><div class="line">&gt; perl6 MAIN.p6 --upto 10</div><div class="line">1,1,2,3,5,8,13,21,34,55</div><div class="line">)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">sub MAIN($file1, $file2) &#123;</div><div class="line">    my $words1 = bag slurp($file1).comb(/\w+/).map(*.lc);</div><div class="line">    my $words2 = set slurp($file2).comb(/\w+/).map(*.lc);</div><div class="line">    my $unique = ($words1 (-) $words2);</div><div class="line">    for $unique.list.sort(&#123; -$words1&#123;$_&#125; &#125;)[^10] -&gt; $word &#123;</div><div class="line">        say &quot;$word: &#123; $words1&#123;$word&#125; &#125;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><hr>
<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my %hash = &apos;Perl&apos;=&gt;80,</div><div class="line">         &apos;Python&apos;=&gt;100,</div><div class="line">             &apos;Go&apos;=&gt;95,</div><div class="line">            &apos;CMD&apos;=&gt;20,</div><div class="line">            &quot;Php&quot;=&gt;80,</div><div class="line">           &quot;Java&quot;=&gt;85;</div><div class="line"></div><div class="line">for %hash.sort(&#123;-.value&#125;).hash.keys -&gt; $key &#123;</div><div class="line">    say $key, &quot;\t&quot;, %hash&#123;&quot;$key&quot;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my %grade = &quot;example.txt&quot;.IO.lines.map: &#123;</div><div class="line">    m:s/^(\w+) (&lt;[A..F]&gt;&lt;[+-]&gt;?)$/</div><div class="line">        or die &quot;Can&apos;t parse line &apos;$_&apos;&quot;;</div><div class="line"></div><div class="line">    ~$0 =&gt; ~$1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say %grade;</div><div class="line"></div><div class="line">say &quot;Zsófia&apos;s grade: %grade&lt;Zsófia&gt;&quot;;</div><div class="line">say &quot;List of students with a failing grade:&quot;;</div><div class="line"></div><div class="line">say &quot; &quot; ~%grade.grep(*.value ge &apos;F&apos;)».key.join(&quot; &quot;);</div><div class="line"></div><div class="line">say &quot;Distribution of grades by letter:&quot;;</div><div class="line">say &quot;  &#123;.key&#125;: &#123;+.value&#125; student&#123;&quot;s&quot; if .value != 1&#125;&quot;</div><div class="line">    for %grade.classify(*.value.comb[0]).sort(*.key);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"># Sort an array of composite structures by a key. For example, if you define a composite structure that presents a name-value pair (in pseudocode):</div><div class="line"># Define structure pair such that:</div><div class="line">   # name as a string</div><div class="line">   # value as a string</div><div class="line"></div><div class="line"></div><div class="line"># and an array of such pairs:</div><div class="line"># x: array of pairs</div><div class="line"></div><div class="line"></div><div class="line"># then define a sort routine that sorts the array x by the key name.</div><div class="line"></div><div class="line"># This task can always be accomplished with Sorting Using a Custom Comparator. If your language is not listed here, please see the other article.</div><div class="line"></div><div class="line"># Works with: Rakudo Star version 2010.08</div><div class="line"></div><div class="line">my class Employee &#123;</div><div class="line">   has Str $.name;</div><div class="line">   has Rat $.wage;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $boss     = Employee.new( name =&gt; &quot;Frank Myers&quot;     , wage =&gt; 6755.85 );</div><div class="line">my $driver   = Employee.new( name =&gt; &quot;Aaron Fast&quot;      , wage =&gt; 2530.40 );</div><div class="line">my $worker   = Employee.new( name =&gt; &quot;John Dude&quot;       , wage =&gt; 2200.00 );</div><div class="line">my $salesman = Employee.new( name =&gt; &quot;Frank Mileeater&quot; , wage =&gt; 4590.12 );</div><div class="line"></div><div class="line">my @team = $boss, $driver, $worker, $salesman;</div><div class="line"></div><div class="line">my @orderedByName = @team.sort( *.name )&gt;&gt;.name;</div><div class="line">my @orderedByWage = @team.sort( *.wage )&gt;&gt;.name;</div><div class="line"></div><div class="line">say &quot;Team ordered by name (ascending order):&quot;;</div><div class="line">say @orderedByName.join(&apos;  &apos;);</div><div class="line">say &quot;Team ordered by wage (ascending order):&quot;;</div><div class="line">say @orderedByWage.join(&apos;  &apos;);</div><div class="line"></div><div class="line"># this produces the following output:</div><div class="line"># Team ordered by name (ascending order):</div><div class="line"># Aaron Fast   Frank Mileeater   Frank Myers   John Dude</div><div class="line"># Team ordered by wage (ascending order):</div><div class="line"># John Dude   Aaron Fast   Frank Mileeater   Frank Myers</div><div class="line"></div><div class="line"></div><div class="line"># Note that when the sort receives a unary function, it automatically generates an appropriate comparison function based on the type of the data.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Student &#123;</div><div class="line">    has Str $.name;</div><div class="line">    has Int $.grade is rw;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $stu1 = Student.new(name =&gt; &quot;zhangwuji&quot;, grade =&gt; 124);</div><div class="line">my $stu2 = Student.new(name =&gt; &quot;yangguo&quot;,   grade =&gt; 128);</div><div class="line">my $stu3 = Student.new(name =&gt; &quot;zhaomin&quot;,   grade =&gt; 145);</div><div class="line">my $stu4 = Student.new(name =&gt; &quot;sunyizhe&quot;,  grade =&gt; 145);</div><div class="line">my $stu5 = Student.new(name =&gt; &quot;zhouziruo&quot;, grade =&gt; 128);</div><div class="line">my $stu6 = Student.new(name =&gt; &quot;qiaofeng&quot;,  grade =&gt; 124);</div><div class="line"></div><div class="line">my @students = $stu1, $stu2,$stu3,$stu4,$stu5,$stu6;</div><div class="line"></div><div class="line"># classify</div><div class="line"># classify 返回一个散列</div><div class="line">for @students.classify( *.grade ).sort -&gt; $group &#123;</div><div class="line">    say &quot;These students got grade $group.key():&quot;;</div><div class="line">    say .name for $group.value.list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"># sort</div><div class="line">my @c = @students.sort: -&gt; $a, $b &#123;$a.grade &lt;=&gt; $b.grade&#125;;</div><div class="line">say @c.perl;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"> my $file = open &apos;scores&apos;;</div><div class="line"> my @names = $file.get.words;</div><div class="line"></div><div class="line"> my %matches;</div><div class="line"> my %sets;</div><div class="line"></div><div class="line"> for $file.lines -&gt; $line &#123;</div><div class="line"> my ($pairing, $result) = $line.split(&apos; | &apos;);</div><div class="line"> my ($p1, $p2) = $pairing.words;</div><div class="line"> my ($r1, $r2) = $result.split(&apos;:&apos;);</div><div class="line"></div><div class="line"> %sets&#123;$p1&#125; += $r1;</div><div class="line"> %sets&#123;$p2&#125; += $r2;</div><div class="line"></div><div class="line"> if $r1 &gt; $r2 &#123;</div><div class="line"> %matches&#123;$p1&#125;++;</div><div class="line"> &#125; else &#123;</div><div class="line"> %matches&#123;$p2&#125;++;</div><div class="line"> &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> my @sorted = @names.sort(&#123; %sets&#123;$_&#125; &#125;).sort(&#123; %matches&#123;$_&#125; &#125;).reverse;</div><div class="line"></div><div class="line"> for @sorted -&gt; $n &#123;</div><div class="line"> say &quot;$n has won %matches&#123;$n&#125; matches and %sets&#123;$n&#125; sets&quot;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="Subset"><a href="#Subset" class="headerlink" title="Subset"></a>Subset</h2><hr>
<ul>
<li>限制字符串长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">subset NonEmptyString</div><div class="line">    of Str</div><div class="line">    where *.chars &gt; 0; # 可以把约束条件写到多行</div><div class="line"></div><div class="line">sub firstName(NonEmptyString $name) &#123;</div><div class="line">    say &quot;your name is $name&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">firstName(&apos;Larry&apos;);</div><div class="line">firstName(&apos;&apos;);</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">your name is Larry</div><div class="line">Constraint type check failed for parameter &apos;$name&apos;</div><div class="line">  in sub firstName at subset.p6:5</div><div class="line">  in block &lt;unit&gt; at subset.p6:10</div></pre></td></tr></table></figure></p>
<ul>
<li>限制值域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">subset PointLimit of Int where -10 &lt;= * &lt;= 10;</div><div class="line">sub test(PointLimit $number) &#123;</div><div class="line">    say $number;</div><div class="line">&#125;</div><div class="line">test(-5); # -5</div><div class="line"></div><div class="line">subset SmallInt of Int where -10 .. 10;</div><div class="line">sub small(SmallInt $number) &#123;</div><div class="line">    say $number;</div><div class="line">&#125;</div><div class="line">small(8);</div></pre></td></tr></table></figure>
<ul>
<li>检测密码是否合法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"># 安全的密码</div><div class="line"># 至少 8 位</div><div class="line"># 包含大写字母、小写字母</div><div class="line"># subset 不能使用 set(*.comb)  形式？</div><div class="line"></div><div class="line">subset Password of Str where *.chars &gt;=8 &amp;&amp; any(&apos;A&apos;..&apos;Z&apos;,&apos;a&apos;..&apos;z&apos;) ∈ *.comb.Set;</div><div class="line"></div><div class="line">sub passwordCheck(Password $password) &#123;</div><div class="line">    say &quot;Password is Valid&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">passwordCheck(&quot;abcdABCD&quot;);</div></pre></td></tr></table></figure>
<ul>
<li>检测密码是否有效并提醒</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">subset Length8    of Str where *.chars &lt; 8;</div><div class="line">subset UpCase     of Str where none(&apos;A&apos;..&apos;Z&apos;) ∈ *.comb.Set;</div><div class="line">subset LowerCase  of Str where none(&apos;a&apos;..&apos;z&apos;) ∈ *.comb.Set;</div><div class="line">subset IntNumber  of Str where none(&apos;0&apos;..&apos;9&apos;) ∈ *.comb.Set;</div><div class="line"></div><div class="line">my $guess = prompt(&apos;Enter your password:&apos;);</div><div class="line"></div><div class="line">given $guess &#123;</div><div class="line">    when Length8   &#123; say &apos;密码长度必须为 8 位 以上&apos;; proceed &#125;</div><div class="line">    when  UpCase   &#123; say &apos;密码必须包括大写字母&apos;;     proceed &#125;</div><div class="line">    when LowerCase &#123; say &apos;密码必须包含小写字母&apos;;     proceed &#125;</div><div class="line">    when IntNumber &#123; say &apos;密码必须包含数字&apos;;                 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该程序具有可扩展性， 要增加一种密码验证， 只有添加一个 subset 就好了，然后在 given/when 里面增加一个处理。<br>proceed 相当于 continue， 不像 C 里面的 falling through， Perl 6 里面的 proceed 在继续执行 when 语句时会计算 when 后面的条件</p>
<p>when 可以作为语句修饰符单独使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">doit() when 42</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">doit() when $_ ~~ 42</div></pre></td></tr></table></figure>
<p>这在列表解析里面很有用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @lucky = ($_ when /7/ for 1..100);</div><div class="line">7 17 27 37 47 57 67 70 71 72 73 74 75 76 77 78 79 87 97</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">subset NonEmptyString</div><div class="line">    of Str</div><div class="line">    where *.chars &gt; 0;</div><div class="line"></div><div class="line">sub firstName(NonEmptyString $name) &#123;</div><div class="line">    say &quot;your name is $name&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">firstName(&apos;Larry&apos;);</div><div class="line">firstName(&apos;&apos;);</div></pre></td></tr></table></figure>
<h2 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">sub add (Int $inputA, Int $inputB --&gt; Int)</div><div class="line">&#123;</div><div class="line">    my $result = $inputA+$inputB;</div><div class="line"></div><div class="line">    say $result;         # Oops, this is the last statement, so its return value is used for the subroutine</div><div class="line">&#125;</div><div class="line"></div><div class="line"># my $sum = add(5,6);</div><div class="line"># Type check failed for return value; expected &apos;Int&apos; but got &apos;Bool&apos;</div><div class="line"></div><div class="line">sub add2 (Int $inputA, Int $inputB --&gt; Int)</div><div class="line">&#123;</div><div class="line">    my $result = $inputA+$inputB;</div><div class="line"></div><div class="line">    return $result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $sum2 = add2(5,6);</div><div class="line">say $sum2;</div><div class="line"></div><div class="line">sub add3 (Int $inputA, Int $inputB) returns Int</div><div class="line">&#123;</div><div class="line">    my $result = $inputA+$inputB;</div><div class="line"></div><div class="line">    return $result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $sum3 = add3(5,6);</div><div class="line">say $sum3;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">sub fib(Int $nth where * &gt;= 0) &#123;</div><div class="line">  given $nth &#123;</div><div class="line">    when 0 &#123; 0 &#125;</div><div class="line">    when 1 &#123; 1 &#125;</div><div class="line">    default &#123; fib($nth-1) + fib($nth-2) &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">say fib(3);</div><div class="line">#say fib(-3);</div><div class="line"></div><div class="line">subset FirstName</div><div class="line">    of Str</div><div class="line">  where 0 &lt; *.chars &amp;&amp; *.chars &lt; 256;</div><div class="line"></div><div class="line">sub first_name(FirstName $name)&#123;</div><div class="line">    say &quot;$name&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">first_name(&quot;Wall&quot;);</div><div class="line"></div><div class="line">subset PointLimit of Int where -10 &lt;= * &lt;= 10;</div><div class="line">sub test(PointLimit $number) &#123;</div><div class="line">    say $number;</div><div class="line">&#125;</div><div class="line">test(-5);</div><div class="line"></div><div class="line">subset SmallInt of Int where -10 .. 10;</div><div class="line">sub small(SmallInt $number) &#123;</div><div class="line">    say $number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">small(8);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">multi sub trait_mod:&lt;is&gt;(Routine $r, :$doubles!) &#123;</div><div class="line">    $r.wrap(&#123;</div><div class="line">        2 * callsame;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub square($x) is doubles &#123;</div><div class="line">    $x * $x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say square 3;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @list of Int = 1..10000;</div><div class="line">say @list[99].WHAT;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">sub divide(Int $a,</div><div class="line">           Int $b where &#123; $^n != 0 &#125;) &#123;</div><div class="line">    return $a / $b;</div><div class="line">&#125;</div><div class="line">say divide(120, 3); # 42</div><div class="line"># say divide(100, 0); # Type check failure</div><div class="line"></div><div class="line"># Here is an example of using subtypes to distinguish between two candidates</div><div class="line"></div><div class="line">multi say_short(Str $x) &#123;</div><div class="line">    say $x;</div><div class="line">&#125;</div><div class="line">multi say_short(Str $x</div><div class="line">                  where &#123; $_.chars &gt;= 12 &#125;) &#123;</div><div class="line">   say substr($x, 0, 10) ~ &apos;...&apos;;</div><div class="line">&#125;</div><div class="line">say_short(&quot;Beer!&quot;);         # Beer!</div><div class="line">say_short(&quot;BeerBeerBeer!&quot;); # BeerBeerBe...</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Typed Parameters Can restrict a parameter to only accept arguments of a certain type.</div><div class="line">sub show_dist(Str $from, Str $to, Int $kms) &#123;</div><div class="line">    say &quot;From $from to $to is $kms km.&quot;;</div><div class="line">&#125;</div><div class="line">show_dist(&apos;Copenhagen&apos;, &apos;Beijing&apos;, 7305);</div><div class="line">show_dist(7305, &apos;Copenhagen&apos;, &apos;Beijing&apos;);</div></pre></td></tr></table></figure>
<h2 id="Twigils"><a href="#Twigils" class="headerlink" title="Twigils"></a>Twigils</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> class Point &#123;</div><div class="line">        has $.x;</div><div class="line">        has $.y;</div><div class="line"></div><div class="line">        method Str() &#123;</div><div class="line">           return ($.x, $.y); # 注意我们这次使用 . 而不是 !</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">my $p = Point.new(x=&gt;10,y=&gt;20);</div><div class="line">my ($height,$wide) = $p.Str();</div><div class="line">say &quot;高度:$height&quot;;</div><div class="line">say &quot;宽度:$wide&quot;;</div><div class="line"></div><div class="line"></div><div class="line"> class SaySomething &#123;</div><div class="line">        method a() &#123; say &quot;a&quot;; &#125;</div><div class="line">        method b() &#123; say $.a; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SaySomething.a; # prints &quot;a&quot;</div><div class="line">    SaySomething.b;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">my @fave_foods = &lt;hanbao pingguo TV&gt;;</div><div class="line">for @fave_foods -&gt; $food &#123;</div><div class="line">    say &quot;Jonathan likes to eat $food&quot;;</div><div class="line">&#125;</div><div class="line"># The bit between the curly braces is done for each thing in the array</div><div class="line"># -&gt; $name means “declare $name and put the current thing into it”</div><div class="line"></div><div class="line"># $^identifier 变量用于块中:</div><div class="line"></div><div class="line">my @str = &lt;a very long but shorthand really&gt;;</div><div class="line">my @sorted = sort &#123; $^a.chars &lt;=&gt; $^b.chars&#125;, @str;</div><div class="line">say @sorted;</div><div class="line"></div><div class="line"># sort 可以更简洁</div><div class="line">my @s = sort &#123; .chars &#125;, @str;</div><div class="line">say @s;</div><div class="line"></div><div class="line">my $block = &#123;</div><div class="line">    $^a + $^b;</div><div class="line">&#125;;</div><div class="line">say $block(1,99);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"># Twigils影响变量的作用域。请记住, twigils 对基本的魔符插值没有影响，那就是:</div><div class="line"># 如果  $a 内插， $^a, $*a, $=a, $?a, $.a, 等等也会内插. 它仅仅取决于 $.</div><div class="line"></div><div class="line">    my $lexical   = 1;</div><div class="line">    my $*dynamic1 = 10;</div><div class="line">    my $*dynamic2 = 100;</div><div class="line"></div><div class="line">    sub say-all() &#123;</div><div class="line">        say &quot;$lexical, $*dynamic1, $*dynamic2&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    # prints 1, 10, 100</div><div class="line">    say-all();</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        my $lexical   = 2;</div><div class="line">        my $*dynamic1 = 11;</div><div class="line">        $*dynamic2    = 101;</div><div class="line"></div><div class="line">        # prints 1, 11, 101 ,why 2, 11 ,101?</div><div class="line">        # $lexical isn&apos;t looked up in the caller&apos;s scope but in the scope &amp;say-all was defined in.</div><div class="line">        # The two dynamic variables are looked up in the callers scope and therefore have the values 11 and 101.</div><div class="line">        # 翻译过来就是, $lexical 不是在调用者的作用域内被查找, 而是在 &amp;say-all 被定义的作用域那儿</div><div class="line">        # 也就是第一行的 $lexical = 1 了. 另外两个动态作用域变量在调用者的作用域内被查找, 所以值为 11 和 101</div><div class="line">        say-all();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    # prints 1, 10, 101</div><div class="line">    say-all();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"># ? twigil 编译常量</div><div class="line">say &quot;$?FILE: $?LINE&quot;; # wenhao.p6: 4</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># ^ twigil 为block 块 或 子例程 申明了一个形式位置参数.</div><div class="line"># 形如 $^variable 的变量是一种占位变量. 它们可用在裸代码块中来申明代码块的形式参数. 看下面代码中的块:</div><div class="line"></div><div class="line">for ^4 &#123;</div><div class="line">    say &quot;$^seconds follows $^first&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 1 follows 0</div><div class="line"># 3 follows 2</div></pre></td></tr></table></figure>
<h2 id="Whatever"><a href="#Whatever" class="headerlink" title="Whatever"></a>Whatever</h2><hr>
<p> 当作为一个项使用时， 我们把 <em> 叫做 “whatever”<br> 当不是实际值时，它用作占位符<br> 例如, 1, 2, 3 … </em><br> 意思是没有终结点的自然数序列</p>
<p> Whatever 闭包<br> Whatever 最强大的用处是 Whatever 闭包</p>
<p> 对于 whatever 没有特殊意义的普通操作符：<br>     把 whatever 当作参数传递时就创建了一个闭包！<br> 所以，举个例子，  <code>* + 1</code> 等价于 <code>-&gt; $a { $a + 1 }</code><br> <code>* + *</code> 等价于 <code>-&gt; $a, $b { $a + $b }</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@list.grep(* &gt; 10) # 返回 @list 数组中所有大于 10 的元素</div><div class="line">@list.map(* + *)   # 返回 @list 中每对儿的和</div></pre></td></tr></table></figure>
<p>如果给 @a[ ] 的方括号里面传递一个闭包， 它会把 @a 数组的元素个数作为参数传递并计算！</p>
<ul>
<li>数组的最后一个元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @a =  1,22,33,11;</div><div class="line">say @a[*-1];</div><div class="line">say @a[-&gt;$a &#123;$a-1&#125;]; # $a  即为数组@a 的元素个数</div></pre></td></tr></table></figure>
<ul>
<li>数组的倒数第二个元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say @a[*-2];</div><div class="line">say @a[-&gt;$a &#123;$a-2&#125;];</div></pre></td></tr></table></figure>
<p>所以 <code>@a[*/2]</code> 是 @a 数组的中间元素<br><code>@a[1..*-2]</code>  是@a 中不包含首尾元素的其它元素<br><code>1, 1, * + * ... *</code>  是一个无限列表</p>
<ul>
<li><ul>
<li><ul>
<li>是后来值的生成规则， 最后一个 * 表示没有终结测试。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 把闭包存储在标量中</div><div class="line">my $a = -&gt; $b &#123; $b + 1 &#125;</div><div class="line">$a(3) # 4</div></pre></td></tr></table></figure>
<p>Perl 6 的列表求值是惰性的<br>只要你不要求最后一个元素， 无限列表是没问题的。<br>使用绑定 (:=) 操作符把列表赋值给变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @fib := 1, 1, * + * ... *</div></pre></td></tr></table></figure>
<p>如果我稍后要 @fib[40] 的值， 会生成足够多的元素以获取数组的第 41 个元素<br>那些生成的元素会被记忆。<br>尽管未来， 如果列表未绑定给变量， 之前的值会被忘记<br>大部分 Perl 6 列表函数能作用并生成惰性列表<br>@a.map 和 @a.grep 都生成惰性列表， 即使 @a 不是惰性的。<br>@fib.grep(* %% 2) 是一个偶数惰性列表，例如<br>@fib Z @a 生成一个惰性列表： @fib[0], @a[0], @fib[1], @a[1] …<br>给 for 循环传递一个无限列表是没问题的， 它会循环直到停止。</p>
<h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># given 和 when：</div><div class="line"># given 接收一个参数和一个 block</div><div class="line"># given 把它接收的参数设置为 $_, 然后调用后面的 block</div><div class="line"># when 也接收一个参数和一个 block</div><div class="line"># when 将 $_ 和 when 接收的参数进行智能匹配</div><div class="line"># 如果结果是 True， 则执行代码块</div><div class="line"># 然后控制就跳出 when 的包围圈</div><div class="line"></div><div class="line">my $ticks = 0;</div><div class="line">given $ticks &#123;</div><div class="line">    when 1   &#123;say &quot;&quot;;      &#125;</div><div class="line">    when 1/2 &#123;say &quot;/&quot;;     &#125;</div><div class="line">    when Int &#123;say $_.Str;  &#125;</div><div class="line">    when Rat &#123;say $_.perl; &#125;</div><div class="line">    die &quot;Duration must be Int or Rat, but it&apos;s &#123; $_.WHAT &#125;&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># given 和 when 可以单独使用</div><div class="line"># 设置了 $_,  进行一系列操作时，given 比较方便</div><div class="line"># 当 $_ 被设置后 ， when 可以用在任何地方</div><div class="line"># when 在 for 循环中很方便</div><div class="line"></div><div class="line">my $boring-lines = 0;</div><div class="line">for $*IN.lines &#123;</div><div class="line">    when /&quot;Lunasa&quot; | &quot;Altan&quot;/ &#123; say &quot;Found band!&quot;;       &#125;</div><div class="line">    when /&quot;fiddle&quot; | &quot;flute&quot;/ &#123; say &quot;Found instrument!&quot;; &#125;</div><div class="line">    $boring-lines++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Smart-Matching"><a href="#Smart-Matching" class="headerlink" title="Smart-Matching"></a>Smart-Matching</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">constant A = 100;</div><div class="line">constant B = 100;</div><div class="line"></div><div class="line">my (%powers, %count);</div><div class="line"></div><div class="line"># find bases which are powers of a preceeding root base</div><div class="line"># store decomposition into base and exponent relative to root</div><div class="line">for 2..Int(sqrt A) -&gt; \a &#123;</div><div class="line">    next if a ~~ %powers;</div><div class="line">    %powers&#123;a, a**2, a**3 ...^ * &gt; A&#125; = a X=&gt; 1..*;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># count duplicates</div><div class="line">for %powers.values -&gt; \p &#123;</div><div class="line">    for 2..B -&gt; \e &#123;</div><div class="line">        # raise to power \e</div><div class="line">        # classify by root and relative exponent</div><div class="line">        ++%count&#123;p.key =&gt; p.value * e&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># add +%count as one of the duplicates needs to be kept</div><div class="line">say (A - 1) * (B - 1) + %count - [+] %count.values;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my %lilei     =&apos;Math&apos;=&gt;98,&apos;Chinese&apos;=&gt;&apos;72&apos;,&apos;English&apos;=&gt;&apos;128&apos;;</div><div class="line">my %hanmeimei =&apos;Math&apos;=&gt;98,&apos;Chinese&apos;=&gt;&apos;72&apos;,&apos;English&apos;=&gt;&apos;128&apos;;</div><div class="line">say &quot;they have the same course&quot; if %lilei.keys ~~ %hanmeimei.keys;</div><div class="line">say &apos;true&apos; if %lilei&#123;%hanmeimei.keys&#125; ~~ %hanmeimei.values;</div><div class="line"></div><div class="line">my $a = 2</div><div class="line">say so $a ~~ 1..3</div><div class="line">say so $a ~~ Int</div><div class="line">say so $a ~~ 23</div><div class="line">say so $a ~~ &#123;$_.Str ne $_.perl&#125;</div><div class="line">say so (1..3).ACCEPTS($a)</div></pre></td></tr></table></figure>
<h2 id="Regexes"><a href="#Regexes" class="headerlink" title="Regexes"></a>Regexes</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">print &apos;ok&apos; if &apos;1,2,3&apos; ~~ / \d+ % &apos;,&apos; /; # ok</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># caps 方法返回所有的捕获，命名的和位置的，按照它们匹配的文本在原始字符串中出现的顺序返回。返回的值是一个 Pair 对象列表。键是捕获的名字或数量，键值是对应的 Match 对象。</div><div class="line"></div><div class="line">if &apos;abc&apos; ~~ m/(.) &lt;alpha&gt; (.) / &#123;</div><div class="line">            say $/.caps.WHAT; # (Parcel)</div><div class="line">            my @a = $/.caps;  </div><div class="line">            say @a;           # 0 =&gt; ｢a｣ alpha =&gt; ｢b｣ 1 =&gt; ｢c｣ ( 0 =&gt; ｢a｣ 是一个 Pair 对象</div><div class="line">            say &quot; -&gt; 这次匹配有  @a.elems() 个 Pair&quot;;</div><div class="line">               for $/.caps &#123;</div><div class="line">                    say .key, &apos; =&gt; &apos;, .value.Str; # 键值是 对应的Match 对象, 需要调用 Str 方法, 得到字符串.</div><div class="line"></div><div class="line">             &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> # Output:</div><div class="line"> #          0 =&gt; a</div><div class="line"> #      alpha =&gt; b</div><div class="line"> #          1 =&gt; c</div><div class="line"></div><div class="line"></div><div class="line">#  复习下 Parcel</div><div class="line"># Parcel 由 () &lt;&gt;  逗号分割的列表, 或其它引用结构</div><div class="line"># ()</div><div class="line"># 1,2,3</div><div class="line"># &lt;a b c&gt;</div><div class="line"># &lt;&lt;a b c&gt;&gt;</div><div class="line"># qw/a b c/</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $s = &apos;the quick brown fox jumped over the the lazy dog&apos;;</div><div class="line">if $s ~~ m/ &lt;&lt; (\w+) \W+ $0 &gt;&gt; / &#123; # if 不再需要圆括号</div><div class="line">    say &quot;Found &apos;$0&apos; twice in a row&quot;;</div><div class="line">    say &quot;Found &apos;$/[0]&apos; twice in a line&quot; # $/[0]  可以简写为 $0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> my $ingredients = &apos;milk, flour, eggs and sugar&apos;;</div><div class="line"> # prints &quot;milk, flour, eggs&quot;, 如果 say $/[0] 只会打印 || , 因为[] 是非捕获组!</div><div class="line"> $ingredients ~~ m/ [\w+]+ % [\,\s*] / &amp;&amp; say &quot;|$/|&quot;;</div><div class="line"># |milk, flour, eggs|</div><div class="line"># 这里 \w+ 匹配一个单词，并且 [\w+]+ % [\,\s*]  匹配至少一个单词，并且单词之间用逗号和任意数量的空白分隔。</div><div class="line"> &apos;1,2,3&apos; ~~ / \d+ % &apos;,&apos; / &amp;&amp; say &quot;|$/|&quot;;</div><div class="line"># |1,2,3|</div><div class="line"># %必须要跟在量词后面，否则报错。</div><div class="line"># 在 [\w+] 里面 [ ] 是非捕获组</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># 如果你在捕获后面加上量词，匹配对象中的对应的项是一列其它对象：</div><div class="line"></div><div class="line">use v6;</div><div class="line">my $ingredients = &apos;eggs, milk, sugar and flour&apos;;</div><div class="line"></div><div class="line">if $ingredients ~~ m/(\w+)+ % [\,\s*] \s* &apos;and&apos; \s* (\w+)/ &#123;</div><div class="line">    say &apos;list: &apos;, $/[0].join(&apos; | &apos;);</div><div class="line">    say &apos;end: &apos;, &quot;$/[1]&quot;;</div><div class="line">    say $/.elems; # 数组 $/ 中含有 2 个元素</div><div class="line">    say $/[0].WHAT;  # ARRAY, 第一个捕获 $/[0] 其实是一个数组</div><div class="line">    say $/[0].elems; # 3, 第一个 (\w+) 匹配了 3 次</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 这打印:</div><div class="line"># list: eggs | milk | sugar</div><div class="line"># end: flour</div><div class="line"></div><div class="line">#  第一个捕获(\w+)被量词化了，所以$/[0]包含一列单词。代码调用 .join方法将它转换为字符串。</div><div class="line">#  不管第一个捕获匹配了多少次（并且有$/[0]中有多少元素），第二个捕获$/[1]始终可以访问。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;Germany was reunited on 1990-10-03, peacefully&apos;;</div><div class="line"></div><div class="line">if $str ~~ m/ (\d**4) \- (\d\d) \- (\d\d) / &#123;</div><div class="line">    say $/.WHAT;  # Match</div><div class="line">    say $/.elems; # 3</div><div class="line">    say &apos;Year: &apos;,&quot;$/[0]&quot;;</div><div class="line">    say &apos;Month: &apos;,&quot;$/[1]&quot;;</div><div class="line">    say &apos;Day: &apos;,&quot;$/[2]&quot;;</div><div class="line"></div><div class="line">    # usage as an array:</div><div class="line">    say $/.join(&apos;-&apos;); # prints 1990-10-03</div><div class="line">&#125;</div><div class="line"></div><div class="line"># Year: 1990</div><div class="line"># Month: 10</div><div class="line"># Day: 03</div><div class="line"># 1990-10-03</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">my $s = &apos;the quick brown fox jumped over the the lazy dog&apos;;</div><div class="line">my regex word &#123; \w+ [ \&apos; \w+ ]?              &#125;</div><div class="line">my regex dup  &#123; « &lt;danci=&amp;word&gt; \W+ $&lt;danci&gt; » &#125; # 要使用 &amp;name 调用正则, 就像调用子例程一样 &amp;sub , 调用后的结果起名为 danci, 就像给子例程起名字一样</div><div class="line">if $s ~~ m/ &lt;dupword=&amp;dup&gt; / &#123;</div><div class="line">    say &quot;Found &apos;&#123;$&lt;dupword&gt;&lt;danci&gt;&#125;&apos; twice in a row&quot;;</div><div class="line">    # say $/.keys(); # dupword, 获取散列的键</div><div class="line">    say $/;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 这段代码引入了一个名为 word 的正则表达式，它至少匹配一个单词字符，后面跟着一个可选的单引号和更多的单词字符。</div><div class="line"># 另外一个名为 dup （duplcate的缩写，副本的意思）的正则包含一个单词边界锚点。</div><div class="line"></div><div class="line"># 在正则里面，语法 &lt;&amp;word&gt; 在当前词法作用域内查找名为word的正则并匹配这个正则表达式。</div><div class="line"># &lt;name=&amp;regex&gt; 语法创建了一个叫做 name 的捕获，它记录了 &amp;regex 匹配的内容。</div><div class="line"></div><div class="line"># 在这个例子中，dup 调用了名为 word 正则，随后匹配至少一个非单词字符，之后再匹配相同的字符串（ 前面word 正则匹配过的）一次，它以另外一个字符边界结束。这种向后引用的语法记为美元符号 $  后面跟着用尖括号包裹着捕获的名字。</div><div class="line"></div><div class="line"># 在 if 代码块里， $&lt;dupword&gt; 是  $/&#123;&apos;dupword&apos;&#125; 的快捷写法。因为 $/ 是一个特殊的散列, 所以可以通过键 &#123;&apos;dupword&apos;&#125; 访问到散列的值. 它访问正则 dup 产生的匹配对象。</div><div class="line"># dup 也有一个叫 danci 的子规则。从那个调用产生的匹配对象用 $&lt;dupword&gt;&lt;danci&gt;来访问。</div><div class="line"></div><div class="line"># 直接打印 $/ 的结果, $/ 这里又变成了一个特殊的散列, fuck, 上次它不是一个特殊的数组吗? 百变星君啊,擦!</div><div class="line">#</div><div class="line"></div><div class="line"># ｢the the｣</div><div class="line">#  dupword =&gt; ｢the the｣</div><div class="line">#   danci =&gt; ｢the｣</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $ingredients = &apos;eggs, milk, sugar and flour&apos;;</div><div class="line"></div><div class="line">if $ingredients ~~ m/(\w+)+ % [\,\s*] \s* &apos;and&apos; \s* (\w+)/ &#123;</div><div class="line">say &apos;list: &apos;, $/[0].join(&apos; | &apos;);</div><div class="line">say &apos;end: &apos;, &quot;$1&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;Germany was reunited on 1990-10-03, peacefully&apos;;</div><div class="line"></div><div class="line">if $str ~~ m/ (\d**4) \- (\d\d) \- (\d\d) / &#123;</div><div class="line">say &apos;Year: &apos;,&quot;$/[0]&quot;;</div><div class="line">say &apos;Month: &apos;,&quot;$/[1]&quot;;</div><div class="line">say &apos;Day: &apos;,&quot;$/[2]&quot;;</div><div class="line"># usage as an array:</div><div class="line">say $/.join(&apos;-&apos;); # prints 1990-10-03</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">my regex insigline &#123;</div><div class="line">^ \s* [ &lt;?&gt; | &apos;#&apos; .* | &apos;&#123;&apos; | &apos;&#125;&apos; ] \s* $</div><div class="line">&#125;</div><div class="line">  sub MAIN(*@files) &#123;</div><div class="line">      my $total = 0;</div><div class="line">      for @files -&gt; $filename &#123;</div><div class="line">           try &#123;</div><div class="line">           $total += lines($filename.IO).grep(</div><div class="line">              &#123; $_ !~~ /&lt;&amp;insigline&gt;/ &#125; ).elems;</div><div class="line">      &#125;</div><div class="line">     note &quot;can&apos;t read $filename &quot; if $!;</div><div class="line">   &#125;</div><div class="line">say $total;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"> my $ingredients = &apos;eggs, milk, sugar and flour&apos;;</div><div class="line"></div><div class="line"> if $ingredients ~~ m/:s ( \w+ )+ % \,&apos;and&apos; (\w+)/ &#123;</div><div class="line"> say &apos;list: &apos;, $/[0].join(&apos; | &apos;);</div><div class="line"> say &apos;end: &apos;, &quot;$/[1]&quot;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="Subroutine"><a href="#Subroutine" class="headerlink" title="Subroutine"></a>Subroutine</h2><hr>
<p><code>--&gt;</code> 在 Perl 6 中是什么意思？<br><code>--&gt;</code> 就是指定返回值的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">sub add (Int $inputA, Int $inputB --&gt; Int)</div><div class="line">&#123;</div><div class="line">    my $result = $inputA+$inputB;</div><div class="line"></div><div class="line">    say $result; # this is the last statement, so its return value is used for the subroutine</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $sum = add(5,6);</div><div class="line"># Type check failed for return value; expected &apos;Int&apos; but got &apos;Bool&apos;</div><div class="line"></div><div class="line"></div><div class="line">sub add2 (Int $inputA, Int $inputB --&gt; Int)</div><div class="line">&#123;</div><div class="line">    my $result = $inputA+$inputB;</div><div class="line"></div><div class="line">    return $result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $sum2 = add2(5,6);</div><div class="line">say $sum2;</div></pre></td></tr></table></figure>
<p>使用  <code>return</code> 约束更清晰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub add3 (Int $inputA, Int $inputB) returns Int</div><div class="line">&#123;</div><div class="line">    my $result = $inputA+$inputB;</div><div class="line"></div><div class="line">    return $result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $sum3 = add3(5,6);</div><div class="line">say $sum3;</div></pre></td></tr></table></figure>
<h2 id="Signatures"><a href="#Signatures" class="headerlink" title="Signatures"></a>Signatures</h2><hr>
<p>签名的几种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sub optional               &#123;...&#125;</div><div class="line">sub basic($foo)            &#123;...&#125;</div><div class="line">sub default($foo = 3)      &#123;...&#125;</div><div class="line">sub named(:$name)          &#123;...&#125;</div><div class="line">sub typed(Bool $is_foo)    &#123;...&#125;</div><div class="line">sub constraint(Str $name</div><div class="line">    where *.chars &gt; 0)     &#123;...&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line">my @a=1,2,3;</div><div class="line">my $s=&apos;Escape Plan&apos;;</div><div class="line">my %h=&apos;Rakudo&apos;=&gt;&apos;Star&apos;,&apos;STD&apos;=&gt;&apos;Larry&apos;;</div><div class="line"></div><div class="line"># 捕获就是一系列实参的签名</div><div class="line">my $capture = \(@a,$s,%h);      # creating a capture, &quot;\&quot; was free since there are no references anymore</div><div class="line">say(|$capture).perl;            # flatten into argument list (hash like context)</div><div class="line"># ||$cap;                       # flatten into semicolon list (array like context)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line"># A set of parameters form a signature. 一组形参组成签名</div><div class="line"># A set of arguments form a capture.    一组实参组成捕获</div><div class="line"></div><div class="line">sub greet($name, :$greeting = &apos;Hi&apos;) &#123;</div><div class="line">    say &quot;$greeting, $name!&quot;;</div><div class="line">&#125;</div><div class="line">greet(&apos;Лена&apos;, greeting =&gt; &apos;Привет&apos;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub rectangle(:$width!, :$height!, :$char = &apos;X&apos;) &#123;</div><div class="line">    say $char x $width for ^$height;</div><div class="line">&#125;</div><div class="line"></div><div class="line">rectangle char =&gt; &apos;o&apos;, width =&gt; 8, height =&gt; 4;</div><div class="line">rectangle :width(20), :height&lt;5&gt;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line"># Sometimes, you need to do some more powerful validation on arguments.</div><div class="line"></div><div class="line">sub discount($price, $percent</div><div class="line">             where (1 &lt;= $percent &lt;= 100)) &#123;</div><div class="line">    say &quot;You get $percent% off! Pay EUR &quot; ~ $price - ($price * $percent / 100);</div><div class="line">&#125;</div><div class="line">discount(100, 20);</div><div class="line">discount(100, 200);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line"># Be careful about using type constraints on arrays and hashes. The type constraints the elements.</div><div class="line"># 在对数组和散列使用类型限制时要小心. 类型限制的是元素!</div><div class="line"></div><div class="line">sub total(Array @distances) &#123; # 限制数组 @distances 中的每个元素为数组.</div><div class="line">    # WRONG! Takes an Array of Arrays!</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub total(Int @distances) &#123;</div><div class="line">    # Correct, takes an array of Ints.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line"># Dispatch By Arity(he number of arguments that a function can take)</div><div class="line"># Example (from Test.pm): dispatch by different number of parameters</div><div class="line"></div><div class="line">multi sub todo($reason, $count) is export &#123;</div><div class="line">    $todo_upto_test_num = $num_of_tests_run + $count;</div><div class="line">    $todo_reason = &apos;# TODO &apos; ~ $reason;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub todo($reason) is export &#123;</div><div class="line">    $todo_upto_test_num = $num_of_tests_run + 1;</div><div class="line">    $todo_reason = &apos;# TODO &apos; ~ $reason;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line"># Can use multiple dispatch with constraints to do a lot of &quot;write what you know&quot; style solutions</div><div class="line"></div><div class="line"># Factorial:</div><div class="line"># fact(0) = 1</div><div class="line"># fact(n) = n * fact(n - 1)</div><div class="line"></div><div class="line">multi fact(0)  &#123; 1 &#125;;</div><div class="line">multi fact($n) &#123; $n * fact($n - 1) &#125;;</div><div class="line"></div><div class="line">say fact(10);</div><div class="line"></div><div class="line"></div><div class="line"># Fibonacci Sequence:</div><div class="line"># fib(0) = 0</div><div class="line"># fib(1) = 1</div><div class="line"># fib(n) = fib(n - 1) + fib(n - 2)</div><div class="line"></div><div class="line"># mutil 声明的子例程语句结尾不需要跟分号;</div><div class="line">multi fib(0)  &#123; 0 &#125;</div><div class="line">multi fib(1)  &#123; 1 &#125;</div><div class="line">multi fib($n) &#123; fib($n - 1) + fib($n - 2) &#125;</div><div class="line"></div><div class="line">say fib(10);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line"># Example: part of a JSON emitter</div><div class="line"></div><div class="line">multi to-json(Array $a) &#123;</div><div class="line">    return &apos;[ &apos; ~</div><div class="line">        $a.values.map(&#123; to-json($_) &#125;).join(&apos;, &apos;) ~</div><div class="line">        &apos; ]&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi to-json(Hash $h) &#123;</div><div class="line">    return &apos;&#123; &apos; ~</div><div class="line">        $h.pairs.map(&#123;</div><div class="line">            to-json(.key) ~ &apos;: &apos; ~ to-json(.value)</div><div class="line">        &#125;).join(&apos;, &apos;) ~</div><div class="line">        &apos; &#125;&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub fst(*@ [$fst])&#123;</div><div class="line">    say $fst;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fst(1);</div><div class="line">fst(1,2);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sub is-in(@array, $elem) &#123;</div><div class="line">  # this will `return` out of the `is-in` sub</div><div class="line">  # once the condition evaluated to True, the loop won&apos;t be run anymore</div><div class="line">  map(&#123; return True if $_ ==  $elem &#125;, @array);</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @array = 1,2,3,4,5;</div><div class="line">is-in(@array,3);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">sub escape ($str) &#123;</div><div class="line">    $_ = $str;</div><div class="line">    # Puts a slash before non-alphanumeric characters</div><div class="line">    s:g[&lt;-alpha-digit&gt;] = &quot;\\$/&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say escape &quot;foobar&quot;;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    sub escape ($str) &#123;</div><div class="line">        $_ = $str;</div><div class="line">        # Writes each non-alphanumeric character in its hexadecimal escape</div><div class="line">        s:g[&lt;-alpha-digit&gt;] = &quot;\\x[&#123; $/.base(16) &#125;]&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    say escape &quot;foo#bar?&quot;; # foo\x[23]bar\x[3F]</div><div class="line">&#125;</div><div class="line"></div><div class="line"># Back to original escape function</div><div class="line">say escape &quot;foo#bar?&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub greet($name, $greeting = &apos;Ahoj&apos;) &#123;</div><div class="line">    say &quot;$greeting, $name!&quot;;</div><div class="line">&#125;</div><div class="line">greet(&apos;Anna&apos;); # Ahoj Anna</div><div class="line">greet(&apos;Лена&apos;, &apos;Привет &apos;); # Привет, Лена&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"># In Perl 6, passing an array or hash works like passing a reference</div><div class="line"># 在 Perl 6中, 传递数组或散列就像传递引用那样</div><div class="line"></div><div class="line">sub example(@array, %hash) &#123;</div><div class="line">    say @array.elems;</div><div class="line">    say %hash.keys.join(&apos;, &apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @numbers = 1,2,3,4;</div><div class="line">my %ages = Jnthn =&gt; 25, Noah =&gt; 120;</div><div class="line">example(@numbers, %ages);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"># Empty list sorts to the empty list</div><div class="line">multi quicksort([]) &#123; () &#125;</div><div class="line"></div><div class="line"># Otherwise, extract first item as pivot...</div><div class="line">multi quicksort([$pivot, *@rest]) &#123;</div><div class="line"></div><div class="line">    # Partition.</div><div class="line">    my @before = @rest.grep(* &lt; $pivot);</div><div class="line">    my @after  = @rest.grep(* &gt;= $pivot);</div><div class="line">    # Sort the partitions.</div><div class="line">    (quicksort(@before), $pivot, quicksort(@after))</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @unsorted = &lt;13 1 9 12 4 2015&gt;;</div><div class="line">say quicksort(@unsorted); # 1  4  9  12  13  2015</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">sub convert_currency($amount, $rate) &#123;</div><div class="line">    $amount = $amount * $rate;</div><div class="line">    return $amount;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub convert_currency_copy($amount is copy, $rate) &#123;</div><div class="line">    $amount = $amount * $rate;</div><div class="line">    return $amount;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub convert_currency_rw($amount is rw, $rate) &#123;</div><div class="line">    $amount = $amount * $rate;</div><div class="line">    return $amount;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">my $price = 99;</div><div class="line">$price = convert_currency($price, 11.1);</div><div class="line">$price_copy = convert_currency_copy($price, 11.1);</div><div class="line">$price_rw = convert_currency_rw($price, 11.1);</div><div class="line"></div><div class="line">say $price;</div><div class="line">say $price_copy;</div><div class="line">say $price_rw;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"># In Perl 6, every value knows its type.</div><div class="line"></div><div class="line">say 42.WHAT;</div><div class="line">say &quot;camel&quot;.WHAT;</div><div class="line">say [1, 2, 3].WHAT;</div><div class="line">say (sub ($n) &#123; $n * 2 &#125;).WHAT;</div><div class="line"></div><div class="line"># (Int)</div><div class="line"># (Str)</div><div class="line"># (Array)</div><div class="line"># (Sub)</div><div class="line"></div><div class="line"># A type name in Perl 6 represents all possible values of that type.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line"># Sometimes, you want to accept any type, but then transform it into another type before binding to the parameter</div><div class="line"># 强制类型转换</div><div class="line"></div><div class="line">sub show_dist($from, $to, $kms as Int) &#123;</div><div class="line">   say &quot;From $from to $to is $kms km.&quot;;</div><div class="line">&#125;</div><div class="line">show_dist(&apos;Kiev&apos;, &apos;Lviv&apos;, &apos;469&apos;);</div><div class="line">show_dist(&apos;Kiev&apos;, &apos;Lviv&apos;, 469.35);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"># Can restrict a parameter to only accept arguments of a certain type.</div><div class="line"></div><div class="line"></div><div class="line">sub show_dist(Str $from, Str $to, Int $kms) &#123;</div><div class="line">    say &quot;From $from to $to is $kms km.&quot;;</div><div class="line">&#125;</div><div class="line">show_dist(&apos;Kiev&apos;, &apos;Lviv&apos;, 469);</div><div class="line">show_dist(469, &apos;Kiev&apos;, &apos;Lviv&apos;); #  Error!</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sub  foo(@array [$fst, $snd]) &#123;</div><div class="line">  say &quot;My first is $fst, my second is $snd ! All in all, I&apos;m @array[].&quot;;</div><div class="line">  # (^ remember the `[]` to interpolate the array)</div><div class="line">&#125;</div><div class="line">my @tail = 1,2;</div><div class="line">foo(@tail);</div><div class="line"></div><div class="line"> #=&gt; My first is 2, my second is 3 ! All in all, I&apos;m 2 3</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"># Can extract values by attribute (only those that are declared with accessors)</div><div class="line"></div><div class="line">sub nd($r as Rat (:$numerator, :$denominator)) &#123;</div><div class="line">    say &quot;$r = $numerator/$denominator&quot;;</div><div class="line">&#125;</div><div class="line">nd(4.2);</div><div class="line">nd(3/9);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub slurp-in-array(@ [$fst, *@rest]) &#123; # You could keep `*@rest` anonymous</div><div class="line">  say $fst + @rest.elems;   # `.elems` returns a list&apos;s length.</div><div class="line">                            # Here, `@rest` is `(3,)`, since `$fst` holds the `2`.</div><div class="line">&#125;</div><div class="line">my @array = &lt;2 3 4 5&gt;;</div><div class="line">slurp-in-array(@array);</div></pre></td></tr></table></figure>
<h2 id="Built-in-types-and-functions"><a href="#Built-in-types-and-functions" class="headerlink" title="Built-in types and functions"></a>Built-in types and functions</h2><hr>
<h3 id="classify"><a href="#classify" class="headerlink" title=".classify"></a>.classify</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.say for slurp(&quot;README.txt&quot;)\    # whole file into string</div><div class="line">         .words()\               # split into list of words</div><div class="line">         .classify( *.Str );</div><div class="line"></div><div class="line">my @a = slurp(&quot;README.txt&quot;).words;</div><div class="line">.say  for @a.classify( *.Str );</div><div class="line"></div><div class="line"># 输出的是一个散列</div><div class="line"># that =&gt; that that</div><div class="line"># the  =&gt; the the the the the the the the the</div><div class="line"># is   =&gt; is is is</div><div class="line"># ......</div><div class="line"></div><div class="line">my %hash = @a.classify( *.Str );</div><div class="line"># 输出前 10 个最常见的单词</div><div class="line">for %hash.sort(&#123;-.value.elems&#125;).hash.kv.[^20] -&gt; $key, $value &#123;</div><div class="line">    say $key ,&quot;\t&quot;, $value.elems;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>分类后，生成一个散列， 键是  分类依据（可以根据字符数，字符等），下面这例是根据字符数分类， 它会把字符数相同的元素归为一类， 键值就是数组里的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">my @names = &lt;Patrick Jonathan Larry Moritz Audrey&gt;;</div><div class="line">say .key, &quot;\t&quot;, ~.values</div><div class="line">     for @names.classify( *.chars );</div><div class="line"></div><div class="line"># Output:</div><div class="line"># 5       Larry</div><div class="line"># 6       Moritz Audrey</div><div class="line"># 7       Patrick</div><div class="line"># 8       Jonathan</div><div class="line"></div><div class="line">.say for slurp(&quot;README&quot;)\            # whole file into string</div><div class="line">         .words()\                   # split into list of words</div><div class="line">         .classify( *.Str )\         # group words w/ multiplicity</div><div class="line">         .map(&#123;; .key =&gt; .value.elems &#125;)\   # 分号的作用是什么？</div><div class="line">                                     # turn lists into lengths</div><div class="line">         .sort( &#123; -.value &#125; )\       # sort descending</div><div class="line">         .[ ^10 ];                   # 10 most common words</div><div class="line">`#(</div><div class="line">*.Str</div><div class="line">I =&gt; I I I I, On =&gt; On On, a =&gt; a a a, black =&gt; black black black black black, day =&gt; day day day day, love =&gt; love, read =&gt; read, summer =&gt; summer summer, sunny =&gt; sunny sunny, to =&gt; to</div><div class="line"></div><div class="line"> .map(&#123;; .key =&gt; .value.elems &#125;)\</div><div class="line">On =&gt; 2 a =&gt; 3 sunny =&gt; 2 summer =&gt; 2 day =&gt; 4 I =&gt; 4 black =&gt; 5 love =&gt; 1 to =&gt; 1 read =&gt; 1  </div><div class="line"></div><div class="line"> .sort( &#123; -.value &#125; )\</div><div class="line">black =&gt; 5 day =&gt; 4 I =&gt; 4 a =&gt; 3 On =&gt; 2 sunny =&gt; 2 summer =&gt; 2 love =&gt; 1 to =&gt; 1 read =&gt; 1  </div><div class="line">)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Student &#123;</div><div class="line">    has Str $.name;</div><div class="line">    has Int $.grade is rw;</div><div class="line">&#125;</div><div class="line">my $stu1 = Student.new(name =&gt; &quot;zhangwuji&quot;, grade =&gt; 124);</div><div class="line">my $stu2 = Student.new(name =&gt; &quot;yangguo&quot;,   grade =&gt; 128);</div><div class="line">my $stu3 = Student.new(name =&gt; &quot;zhaomin&quot;,   grade =&gt; 145);</div><div class="line">my $stu4 = Student.new(name =&gt; &quot;sunyizhe&quot;,  grade =&gt; 134);</div><div class="line"></div><div class="line">my @students = $stu1, $tu2,$stu3,$stu4;</div><div class="line">my Student @students = get-students();</div><div class="line"></div><div class="line">for @students.classify( *.grade ).sort -&gt; $group &#123;</div><div class="line">    say &quot;These students got grade $group.key():&quot;;</div><div class="line">    say .name for $group.value.list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="pick-and-roll"><a href="#pick-and-roll" class="headerlink" title=".pick and .roll"></a>.pick and .roll</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say @deck.pick();                   # pick a card, any card...</div><div class="line"></div><div class="line">say @deck.pick(5);                  # poker hand</div><div class="line"></div><div class="line">my @shuffled = @deck.pick(*);       # here, &apos;*&apos; means &apos;keep going&apos;</div><div class="line"></div><div class="line">my @urn = &lt;black white white&gt;;      # beads, 1/3 black, 2/3 white</div><div class="line">.say for @urn.roll(50);             # like .pick, but new each time</div><div class="line"></div><div class="line">for @urn.roll(*) &#123;</div><div class="line">    .say;                           # infinite bead selector</div><div class="line">&#125;</div><div class="line"></div><div class="line">say [+] (1..6).roll(4);             # 4d6</div><div class="line"></div><div class="line">class Enemy &#123;</div><div class="line">    method attack-with-arrows   &#123; say &quot;peow peow peow&quot;    &#125;</div><div class="line">    method attack-with-swords   &#123; say &quot;swish cling clang&quot; &#125;</div><div class="line">    method attack-with-fireball &#123; say &quot;sssSSS fwoooof&quot;    &#125;</div><div class="line">    method attack-with-camelia  &#123; say &quot;flap flap RAWWR!&quot;  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $selector = &#123; .name ~~ /^ &apos;attack-with-&apos; / &#125;;</div><div class="line">given Enemy.new -&gt; $e &#123;</div><div class="line">    my $attack-strategy</div><div class="line">        = $e.^methods().grep($selector).pick();</div><div class="line"></div><div class="line">    $e.$attack-strategy();           # call a random method</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title=".sort"></a>.sort</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># 1 if $a is higher, -1 if $b is higher, 0 if equal</div><div class="line">$a &lt;=&gt; $b;</div><div class="line"></div><div class="line"># 根据分数排序 students</div><div class="line">@students.sort: -&gt; $a, $b &#123; $a.grade &lt;=&gt; $b.grade &#125;;</div><div class="line"></div><div class="line"># same thing</div><div class="line">@students.sort: &#123; $^a.grade &lt;=&gt; $^b.grade &#125;;</div><div class="line"></div><div class="line"># same thing</div><div class="line">@students.sort: &#123; .grade &#125;;</div><div class="line"></div><div class="line"># same thing</div><div class="line">@students.sort: *.grade;</div><div class="line"></div><div class="line"># leg gives -1, 0 or 1 according to lexicographic ordering</div><div class="line"># &apos;leg&apos; is for Str, &apos;cmp&apos; is now for type-agnostic sort</div><div class="line">$a leg $b;</div><div class="line"></div><div class="line"># sort students by name (Unicode order)</div><div class="line">@students.sort: &#123; $^a.name leg $^b.name &#125;;</div><div class="line"></div><div class="line"># same thing</div><div class="line">@students.sort: *.name;</div><div class="line"></div><div class="line"># don&apos;t worry, things are properly cached; no re-evaluations</div><div class="line">@items.sort: *.expensive-calculation();</div><div class="line"></div><div class="line"># ...which means this works (and is a fair shuffle)</div><div class="line">@deck.sort: &#123; rand &#125;</div><div class="line"></div><div class="line"># ...but this is cuter :)</div><div class="line">@deck.pick(*);</div></pre></td></tr></table></figure>
<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;±&gt;($number, $fuzz) &#123;</div><div class="line">    $number - $fuzz + rand * 2 * $fuzz;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say 15 ± 5;                          # somewhere between 10 and 20</div><div class="line"></div><div class="line">sub postfix:&lt;!&gt;($n) &#123; [*] 1..$n &#125;</div><div class="line">say 5!;                              # 120</div><div class="line"></div><div class="line">class Physical::Unit &#123;</div><div class="line">    has Int $.kg = 0;                # these attrs denote powers of units</div><div class="line">    has Int $.m  = 0;                # eg $.kg == 2 means that this object</div><div class="line">    has Int $.s  = 0;                # has a kg**2 unit</div><div class="line"></div><div class="line">    has Numeric $.payload;</div><div class="line"></div><div class="line">    method multiply(Physical::Unit $other) &#123;</div><div class="line">        Physical::Unit.new(</div><div class="line">            :kg( $.kg + $other.kg ),</div><div class="line">            :m( $.m + $other.m ),</div><div class="line">            :s( $.s + $other.s ),</div><div class="line">            :payload( $.payload * $other.payload )</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method invert() &#123;</div><div class="line">        Physical::Unit.new(</div><div class="line">            :kg( -$.kg ), :m( -$.m ), :s( -$.s ),</div><div class="line">            :payload( 1 / $.payload )</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method Str &#123;</div><div class="line">        $.payload</div><div class="line">        ~ ($.kg ?? ($.kg == 1 ?? &quot; kg&quot; !! &quot;kg**$.kg&quot;) !! &quot;&quot;)</div><div class="line">        ~ ($.m  ?? ($.m  == 1 ?? &quot; m&quot;  !! &quot;m**$.m&quot;)   !! &quot;&quot;)</div><div class="line">        ~ ($.s  ?? ($.s  == 1 ?? &quot; s&quot;  !! &quot;s**$.s&quot;)   !! &quot;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub postfix:&lt;kg&gt;(Numeric $payload) &#123; Physical::Unit.new( :kg(1), :$payload ) &#125;</div><div class="line">sub postfix:&lt;m&gt;(Numeric $payload) &#123; Physical::Unit.new( :m(1), :$payload ) &#125;</div><div class="line">sub postfix:&lt;s&gt;(Numeric $payload) &#123; Physical::Unit.new( :s(1), :$payload ) &#125;</div><div class="line"></div><div class="line"># Note how we now use &apos;multi sub&apos;, so as not to shadow the original infix:&lt;*&gt;</div><div class="line">multi sub infix:&lt;*&gt;(Physical::Unit $a, $b) &#123;</div><div class="line">    $a.clone( :payload($a.payload * $b) );</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub infix:&lt;*&gt;($a, Physical::Unit $b) &#123;</div><div class="line">    $b.clone( :payload($a * $b.payload) );</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub infix:&lt;*&gt;(Physical::Unit $a, Physical::Unit $b) &#123;</div><div class="line">    $a.multiply($b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub infix:&lt;/&gt;(Physical::Unit $a, $b) &#123;</div><div class="line">    $a.clone( :payload($a.payload / $b) );</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub infix:&lt;/&gt;($a, Physical::Unit $b) &#123;</div><div class="line">    $b.invert.clone( :payload($a / $b.payload) );</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub infix:&lt;/&gt;(Physical::Unit $a, Physical::Unit $b) &#123;</div><div class="line">    $a.multiply($b.invert);</div><div class="line">&#125;</div><div class="line"></div><div class="line">say 5m / 2s;                         # 2.5 m s**-1</div><div class="line">say 100kg * 2m / 5s;                 # 40 kg m s**-1</div></pre></td></tr></table></figure>
<h3 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"># Z (the &apos;zip operator&apos;) means &quot;mix these lists together&quot;</div><div class="line">my @tastes = &lt;spicy sweet bland&gt;;</div><div class="line">my @foods = &lt;soup potatoes tofu&gt;;</div><div class="line">@tastes Z @foods; # &lt;spicy soup sweet potatoes bland tofu&gt;</div><div class="line"></div><div class="line">class Student &#123;</div><div class="line">    has Str $.name;</div><div class="line">    has Int $.grade is rw;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $stu1 = Student.new(name =&gt; &quot;zhangwuji&quot;, grade =&gt; 124);</div><div class="line">my $stu2 = Student.new(name =&gt; &quot;yangguo&quot;,   grade =&gt; 128);</div><div class="line">my $stu3 = Student.new(name =&gt; &quot;zhaomin&quot;,   grade =&gt; 145);</div><div class="line">my $stu4 = Student.new(name =&gt; &quot;sunyizhe&quot;,  grade =&gt; 145);</div><div class="line">my $stu5 = Student.new(name =&gt; &quot;zhouziruo&quot;, grade =&gt; 128);</div><div class="line">my $stu6 = Student.new(name =&gt; &quot;qiaofeng&quot;,  grade =&gt; 124);</div><div class="line"></div><div class="line">my @students = $stu1, $stu2,$stu3,$stu4,$stu5,$stu6;</div><div class="line"># » 为每个元素调用方法</div><div class="line">.say for @students».grade;   # all the grades</div><div class="line"></div><div class="line">for @students».name Z @students».grade -&gt; $name, $grade &#123;</div><div class="line">    say &quot;$name got a $grade this year&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># Note that the latter list is infinite -- it works anyway</div><div class="line">for @students».name Z (1..6).roll(*) -&gt; $name, $roll &#123;</div><div class="line">    say &quot;$name rolls a $roll&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># you can also Z together two lists with an infix op</div><div class="line">my @total-scores = @first-scores Z+ @second-scores;</div><div class="line"></div><div class="line"># strings as keys, the appropriate number of 1s as values</div><div class="line">my %hash = @names Z=&gt; 1 xx *;    # xx is list repeat</div><div class="line"></div><div class="line"># line people up with increasing numbers</div><div class="line">my %people2numbers = @people Z=&gt; 1..*;</div><div class="line"></div><div class="line"># don&apos;t have a good op? roll your own!</div><div class="line">sub infix:&lt;likes&gt;($liker, $likee) &#123; &quot;$liker is fond of $likee&quot; &#125;</div><div class="line"># note how the op infix:&lt;Zlikes&gt; is automatically available</div><div class="line">my @relations = @likers Zlikes @likees;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; sub infix:&lt;likes&gt;($liker, $likee) &#123; &quot;$liker is fond of $likee&quot; &#125;</div><div class="line">sub infix:&lt;likes&gt; (Any $liker, Any $likee) &#123; #`(Sub+&#123;Precedence&#125;|140676897934560) ... &#125;</div><div class="line">&gt; &quot;aaa&quot; likes &quot;bbb&quot;</div><div class="line">aaa is fond of bbb</div><div class="line">&gt; my @a = &lt;a b c&gt;;</div><div class="line">a b c</div><div class="line">&gt; my @b = &lt;1 2 3&gt;;</div><div class="line">1 2 3</div><div class="line">&gt; @a Zlikes @b</div><div class="line">a is fond of 1 b is fond of 2 c is fond of 3</div><div class="line">&gt; .say for @a Zlikes @b</div><div class="line">a is fond of 1</div><div class="line">b is fond of 2</div><div class="line">c is fond of 3</div></pre></td></tr></table></figure>
<h3 id="infix-lt-…-gt"><a href="#infix-lt-…-gt" class="headerlink" title="infix:&lt;…&gt;"></a>infix:&lt;…&gt;</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">1 ... $n                                    # integers 1 to $n</div><div class="line">$n ... 1                                    # and backwards</div><div class="line"></div><div class="line">1, 3 ... $n                                 # odd numbers to $n</div><div class="line">1, 3, ... *                                 # odd numbers</div><div class="line">1, 2, 4 ... *                               # powers of two</div><div class="line">map &#123; $_ * $_ &#125;, (1 ... *)                  # squares</div><div class="line"></div><div class="line">1, 1, -&gt; $a, $b &#123; $a + $b &#125; ... *           # fibonacci</div><div class="line">1, 1, &#123; $^a + $^b &#125; ... *                   # ditto</div><div class="line">1, 1, *+* ... *                             # ditto</div><div class="line"></div><div class="line">&apos;Camelia&apos;, *.chop ... &apos;&apos;;                   # all prefixes of &apos;Camelia&apos;</div><div class="line"># Camelia Cameli Camel Came Cam Ca C</div><div class="line"># See http://blog.plover.com/CS/parentheses.html</div><div class="line"># for the principle behind this</div><div class="line">sub next-balanced-paren-string($s) &#123;</div><div class="line">    $s ~~ /^ ( &apos;(&apos;+ ) ( &apos;)&apos;+ ) &apos;(&apos; /;</div><div class="line">    [~] $s.substr(0, $/.from),</div><div class="line">        &quot;()&quot; x ($1.chars - 1),</div><div class="line">        &quot;(&quot; x ($0.chars - $1.chars + 2),</div><div class="line">        &quot;)&quot;,</div><div class="line">        $s.substr($/.to);</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $N = 3;</div><div class="line"></div><div class="line">my $start = &quot;()&quot; x $N;</div><div class="line">my &amp;step = &amp;next-balanced-paren-string;</div><div class="line">my $end = &quot;(&quot; x $N ~ &quot;)&quot; x $N;</div><div class="line"></div><div class="line">for $start, &amp;step ... $end -&gt; $string &#123;</div><div class="line">    say $string;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># Output:</div><div class="line"># ()()()</div><div class="line"># (())()</div><div class="line"># ()(())</div><div class="line"># (()())</div><div class="line"># ((()))</div></pre></td></tr></table></figure>
<h2 id="Chained-Comparisons"><a href="#Chained-Comparisons" class="headerlink" title="Chained Comparisons"></a>Chained Comparisons</h2><hr>
<h2 id="Muti-dispatch"><a href="#Muti-dispatch" class="headerlink" title="Muti dispatch"></a>Muti dispatch</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">multi foo(Int $x) &#123; 1 &#125;</div><div class="line">multi foo(Int $x) is default &#123; 2 &#125;</div><div class="line">say foo(1); # 2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># Operator overloading in Perl 6 will be done by multi-dispatch routines</div><div class="line"># (In fact, all of the built-in operators are invoked by a multi-dispatch.</div><div class="line"></div><div class="line"># Dispatch By Arity</div><div class="line"># 􏰀 Arity = number of arguments that a routine takes</div><div class="line">#􏰀  Could do the previous example as:</div><div class="line"></div><div class="line">multi sub greet($name) &#123;</div><div class="line">    say &quot;Ahoj, $name!&quot;;</div><div class="line">&#125;</div><div class="line">multi sub greet($name, $greeting) &#123;</div><div class="line">    say &quot;$greeting, $name!&quot;;</div><div class="line">&#125;</div><div class="line">greet(&apos;Anna&apos;); # Ahoj Anna</div><div class="line">greet(&apos;Лена&apos;, &apos;Привет &apos;); # Привет, Лена&quot;</div><div class="line"></div><div class="line"># Type-Based Dispatch</div><div class="line">#  􏰀 We can write types in a signature</div><div class="line">#􏰀   They are used to help decide which candidate to call</div><div class="line"></div><div class="line">multi sub double(Int $x) &#123;</div><div class="line">    return 2 * $x;</div><div class="line">&#125;</div><div class="line">multi sub double(Str $x) &#123;</div><div class="line">    return &quot;$x $x&quot;;</div><div class="line">&#125;</div><div class="line">say double(21);      # 42</div><div class="line">say double(&quot;he&quot;);   # he he</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">multi sub MAIN(&apos;send&apos;, $filename) &#123;</div><div class="line"> ...</div><div class="line">&#125;</div><div class="line">multi sub MAIN(&apos;fetch&apos;, $filename) &#123;</div><div class="line"> ...</div><div class="line">&#125;</div><div class="line">multi sub MAIN(&apos;compare&apos;, $file1, $file2) &#123;</div><div class="line"> ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">#`(</div><div class="line">... 是 yadayadayada 占位符</div><div class="line">&gt; perl6 &quot;multiple_MAIN.p6&quot;</div><div class="line">Usage:</div><div class="line">  multiple _MAIN.p6 send &lt;filename&gt;</div><div class="line">  multiple _MAIN.p6 fetch &lt;filename&gt;</div><div class="line">  multiple _MAIN.p6 compare &lt;file1&gt; &lt;file2&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="Module-management"><a href="#Module-management" class="headerlink" title="Module management"></a>Module management</h2><hr>
<h2 id="Native-Library-Calls"><a href="#Native-Library-Calls" class="headerlink" title="Native Library Calls"></a>Native Library Calls</h2><hr>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">my @suits  = &lt;♣ ♢ ♡ ♠&gt;;</div><div class="line">my @ranks  = 2..10, &lt;J Q K A&gt;;</div><div class="line"></div><div class="line"># concatenate each rank with each suit (2♣ 2♢ 2♡ ... A♠)</div><div class="line">my @deck = @ranks X~ @suits;</div><div class="line"></div><div class="line"># build a hash of card names to point values</div><div class="line"># 52 张牌， 4 种花色， A 的值为 11 ， J、Q、K 为 10</div><div class="line">my %points = @deck Z @( (2..10, 10, 10, 10, 11) Xxx 4 );</div><div class="line"></div><div class="line"># 把牌打乱</div><div class="line">@deck .= pick(*); # shuffle the deck</div><div class="line">my @hand = @deck.splice(0, 5); # 抓取前 5 张牌</div><div class="line">say ~@hand; #  显示抓取的是哪 5 张</div><div class="line">say [+] %points&#123;@hand&#125;; # 这 5 张牌面的值加起来是多少</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sub postfix:&lt;!&gt;($n where $n &gt; 0) &#123;</div><div class="line">   [*] 2..$n</div><div class="line">&#125;</div><div class="line">say 5!;</div><div class="line"></div><div class="line">constant fact = 1, [\*] 1..*;</div><div class="line">say fact[5];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $file = open &apos;flip_flop.txt&apos;;</div><div class="line">for $file.lines -&gt; $line &#123;</div><div class="line">say $line if !($line ~~ m/^\;/ ff $line ~~ m/^\&quot;/);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#`(</div><div class="line">flip_flop.txt 内容如下：</div><div class="line">; next is some lines to skip,include this line</div><div class="line">fuck fuck fuck</div><div class="line">dam dam dam</div><div class="line">mie mie mie</div><div class="line">&quot; next is subject</div><div class="line">There is more than one way to do it</div><div class="line">                                -- Larry Wall</div><div class="line"></div><div class="line">We hope Perl6 is wrote by the hole Socfilia</div><div class="line">                                -- Larry Wall</div><div class="line">; next is some lines to skip,include this line</div><div class="line">fuck fuck fuck</div><div class="line">dam dam dam</div><div class="line">mie mie mie</div><div class="line">&quot; next is subject</div><div class="line">programming is hard,Let&apos;s go shopping</div><div class="line">                               -- Larry Wall</div><div class="line">Ruby is Another Perl6</div><div class="line">                               -- Larry Wall</div><div class="line">输出：</div><div class="line">There is more than one way to do it</div><div class="line">                                -- Larry Wall</div><div class="line">We hope Perl6 is wrote by the hole Socfilia</div><div class="line">                                -- Larry Wall</div><div class="line">programming is hard,Let&apos;s go shopping</div><div class="line">                               -- Larry Wall</div><div class="line">Ruby is Another Perl6</div><div class="line">                               -- Larry Wall</div><div class="line">圣诞节中的例子：</div><div class="line"></div><div class="line">)</div><div class="line">for 1..20 &#123;.say if $_==9 ff $_==16&#125;</div><div class="line">say &apos;-&apos; x 10;</div><div class="line">for 1..20 &#123;.say if $_==9 ^ff $_==16&#125;</div><div class="line">say &apos;-&apos; x 10;</div><div class="line">for 1..20 &#123;.say if $_==9 ff^ $_==16&#125;</div><div class="line">say &apos;-&apos; x 10;</div><div class="line">for 1..20 &#123;.say if $_==9 ^ff^ $_==16&#125;</div></pre></td></tr></table></figure>
<h2 id="Awesome-Operators"><a href="#Awesome-Operators" class="headerlink" title="Awesome Operators"></a>Awesome Operators</h2><hr>
<p>In Perl 6 we have a few new operators…</p>
<h2 id="Junctions-1"><a href="#Junctions-1" class="headerlink" title="Junctions"></a>Junctions</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if $status eq &apos;error&apos; || $status eq &apos;warning&apos; &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Perl 6 里面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if $status eq &apos;error&apos; | &apos;warning&apos; &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Perl 5 里面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while $value &lt; $limit1 &amp;&amp; $value &lt; $limit2 &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Perl 6 里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while $value &lt; $limit1 &amp; $limit2 &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Sequences</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">say 1, 2, 4 ... 1024;</div><div class="line">1 2 4 8 16 32 64 128 256 512 1024</div><div class="line"></div><div class="line">my @fib = 1, 1, *+* ... *;</div><div class="line">say @fib[0..9]</div><div class="line">1 1 2 3 5 8 13 21 34 55 89</div></pre></td></tr></table></figure>
<ul>
<li>^ (zero up to…)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @fib = 1, 1, *+* ... *;</div><div class="line">say @fib[^10]</div><div class="line">1 1 2 3 5 8 13 21 34 55 89</div></pre></td></tr></table></figure>
<ul>
<li>Awesome Meta-operators</li>
<li>Higher order operators</li>
<li><p>Operators that <strong>operate on operators</strong></p>
</li>
<li><p>Reduction<br>Puts an operator between every element in a list</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">say [*] 1..10</div><div class="line">3628800</div><div class="line"></div><div class="line">my @sorted = 1,4,7,9,11;</div><div class="line">my @unsorted = 3, 1, 9, 25;</div><div class="line"></div><div class="line">say [&lt;] @sorted;</div><div class="line">say [&lt;] @unsorted;</div><div class="line"></div><div class="line">Bool::True</div><div class="line">Bool::False</div></pre></td></tr></table></figure>
<ul>
<li>Zip<br>Take elements from two or more lists and combine them with some operator</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say 1 .. 6 Z~ &apos;A&apos;..&apos;F’</div><div class="line">1A 2B 3C 4D 5E 6F</div></pre></td></tr></table></figure>
<ul>
<li>Cross</li>
<li>All permutations of two or more lists, combined with some operator</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say 1 .. 3 X~ &apos;A&apos;..&apos;F‘</div><div class="line">1A 1B 1C 1D 1E 1F 2A 2B 2C 2D 2E 2F 3A 3B 3C 3D 3E 3F</div></pre></td></tr></table></figure>
<ul>
<li><p>Your Awesome Operators</p>
<p>What if Perl 6 built in operators are not enough?</p>
<p>You can add your own!</p>
</li>
<li><p>Factorial<br>Add a ! operator to do factorial</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub postfix:&lt;!&gt;($n) &#123; [*] 1..$n &#125;</div><div class="line">say 10!</div><div class="line">3628800</div></pre></td></tr></table></figure>
<pre><code># And you have all of unicode!
# Insert In Middle
## Operator to add an element to the middle of an array
</code></pre><ul>
<li>中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;中&gt;(@array, $ins) &#123;</div><div class="line">    @array.splice(+@array / 2, 0, $ins);</div><div class="line">    return @array;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @a = 1,2,4,5;</div><div class="line">say @a 中 3;</div><div class="line"></div><div class="line">1 2 3 4 5</div></pre></td></tr></table></figure>
<h2 id="Feeds"><a href="#Feeds" class="headerlink" title="Feeds"></a>Feeds</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use Test;</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    my @data = &lt;1 2 4 5 7 8&gt;;</div><div class="line">    my @odds = &lt;1 5 7&gt;;</div><div class="line"></div><div class="line">    eval_dies_ok(&apos;@data &lt;== grep &#123;$_ % 2&#125; &lt;== @data&apos;, &apos;a chain of feeds may not begin and end with the same array&apos;);</div><div class="line"></div><div class="line">    @data = &lt;1 2 4 5 7 8&gt;;</div><div class="line">    @data &lt;== grep &#123;$_ % 2&#125; &lt;== eager @data;</div><div class="line">    # rakudo 2 todo &apos;feeds + eager&apos;</div><div class="line">    is(~@data, ~@odds, &apos;@arr &lt;== grep &lt;== eager @arr works&apos;);</div><div class="line"></div><div class="line">    @data = &lt;1 2 4 5 7 8&gt;;</div><div class="line">    @data &lt;== eager grep &#123;$_ % 2&#125; &lt;== @data;</div><div class="line">    is(~@data, ~@odds, &apos;@arr &lt;== eager grep &lt;== @arr works&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">use Test;</div><div class="line"></div><div class="line"># L&lt;S06/&quot;Feed operators&quot;&gt;</div><div class="line"># L&lt;S03/&quot;Feed operators&quot;&gt;</div><div class="line"></div><div class="line">=begin pod</div><div class="line"></div><div class="line">Tests for the feed operators</div><div class="line"></div><div class="line">    ==&gt; and &lt;==</div><div class="line"></div><div class="line">=end pod</div><div class="line"></div><div class="line">plan 24;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    my @a = (1, 2);</div><div class="line">    my (@b, @c);</div><div class="line"></div><div class="line">    @a ==&gt; @b;</div><div class="line">    @c &lt;== @a;</div><div class="line"></div><div class="line">    is(~@b, ~@a, &quot;ltr feed as simple assignment&quot;);</div><div class="line">    is(~@c, ~@a, &quot;rtl feed as simple assignment&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    my @a = (1 .. 5);</div><div class="line">    my @e = (2, 4);</div><div class="line"></div><div class="line">    my (@b, @c);</div><div class="line">    @a ==&gt; grep &#123; ($_ % 2) == 0 &#125; ==&gt; @b;</div><div class="line">    @c &lt;== grep &#123; ($_ % 2) == 0 &#125; &lt;== @a;</div><div class="line">    my @f = do &#123;@a ==&gt; grep &#123;($_ % 2) == 0&#125;&#125;;</div><div class="line">    my @g = (@a ==&gt; grep &#123;($_ % 2) == 0&#125;);</div><div class="line"></div><div class="line">    is(~@b, ~@e, &quot;array ==&gt; grep ==&gt; result&quot;);</div><div class="line">    is(~@c, ~@e, &quot;result &lt;== grep &lt;== array&quot;);</div><div class="line">    is(~@f, ~@e, &apos;result = do &#123;array ==&gt; grep&#125;&apos;);</div><div class="line">    is(~@g, ~@e, &apos;result = (array ==&gt; grep)&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    my ($got_x, $got_y, @got_z);</div><div class="line">    sub foo ($x, $y?, *@z) &#123;</div><div class="line">        $got_x = $x;</div><div class="line">        $got_y = $y;</div><div class="line">        @got_z = @z;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    my @a = (1 .. 5);</div><div class="line"></div><div class="line">    @a ==&gt; foo &quot;x&quot;;</div><div class="line"></div><div class="line">    is($got_x, &quot;x&quot;, &quot;x was passed as explicit param&quot;);</div><div class="line">    #?rakudo 2 todo &apos;feeds + signatures&apos;</div><div class="line">    ok(!defined($got_y), &quot;optional param y was not bound to fed list&quot;);</div><div class="line">    is(~@got_z, ~@a, &apos;...slurpy array *@z got it&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    my @data = &lt;1 2 4 5 7 8&gt;;</div><div class="line">    my @odds = &lt;1 5 7&gt;;</div><div class="line"></div><div class="line">    eval_dies_ok(&apos;@data &lt;== grep &#123;$_ % 2&#125; &lt;== @data&apos;, &apos;a chain of feeds may not begin and end with the same array&apos;);</div><div class="line"></div><div class="line">    @data = &lt;1 2 4 5 7 8&gt;;</div><div class="line">    @data &lt;== grep &#123;$_ % 2&#125; &lt;== eager @data;</div><div class="line">    #?rakudo 2 todo &apos;feeds + eager&apos;</div><div class="line">    is(~@data, ~@odds, &apos;@arr &lt;== grep &lt;== eager @arr works&apos;);</div><div class="line"></div><div class="line">    @data = &lt;1 2 4 5 7 8&gt;;</div><div class="line">    @data &lt;== eager grep &#123;$_ % 2&#125; &lt;== @data;</div><div class="line">    is(~@data, ~@odds, &apos;@arr &lt;== eager grep &lt;== @arr works&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"># checking the contents of a feed: installing a tap</div><div class="line">&#123;</div><div class="line">    my @data = &lt;0 1 2 3 4 5 6 7 8 9&gt;;</div><div class="line">    my @tap;</div><div class="line"></div><div class="line">    @data &lt;== map &#123;$_ + 1&#125; &lt;== @tap &lt;== grep &#123;$_ % 2&#125; &lt;== eager @data;</div><div class="line">    is(@tap, &lt;1 3 5 7 9&gt;, &apos;@tap contained what was expected at the time&apos;);</div><div class="line">    #?rakudo todo &apos;feeds + eager&apos;</div><div class="line">    is(@data, &lt;2 4 6 8 10&gt;, &apos;final result was unaffected by the tap variable&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"># &lt;&lt;== and ==&gt;&gt; pretending to be unshift and push, respectively</div><div class="line"># rakudo skip &apos;double-ended feeds&apos;</div><div class="line">&#123;</div><div class="line">    my @odds = &lt;1 3 5 7 9&gt;;</div><div class="line">    my @even = &lt;0 2 4 6 8&gt;;</div><div class="line"></div><div class="line">    my @numbers = do &#123;@odds ==&gt;&gt; @even&#125;;</div><div class="line">    is(~@numbers, ~(@even, @odds), &apos;basic ==&gt;&gt; test&apos;);</div><div class="line"></div><div class="line">    @numbers = do &#123;@odds &lt;&lt;== @even&#125;;</div><div class="line">    is(~@numbers, ~(@odds, @even), &apos;basic &lt;&lt;== test&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"># feeding to whatever using ==&gt; and ==&gt;&gt;</div><div class="line"></div><div class="line"># rakudo skip &apos;double-ended feeds&apos;</div><div class="line">&#123;</div><div class="line">    my @data = &apos;a&apos; .. &apos;e&apos;;</div><div class="line"></div><div class="line">    @data ==&gt; *;</div><div class="line">    is(@(*), @data, &apos;basic feed to whatever&apos;);</div><div class="line"></div><div class="line">    &lt;a b c d&gt; ==&gt;  *;</div><div class="line">    0 .. 3    ==&gt;&gt; *;</div><div class="line">    is(@(*), &lt;a b c d 0 1 2 3&gt;, &apos;two feeds to whatever as array&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"># feed and Inf</div><div class="line"># nieza skip &quot;unhandled exception</div><div class="line">&#123;</div><div class="line">  lives_ok &#123; my @a &lt;== 0..Inf &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># nieza skip &quot;Unhandled exception&quot;</div><div class="line">&#123;</div><div class="line">  my $call-count = 0;</div><div class="line">  my @a &lt;== gather for 1..10 -&gt; $i &#123; $call-count++; take $i &#125;;</div><div class="line">  @a[0];</div><div class="line">  #?rakudo todo &quot;isn&apos;t lazy&quot;</div><div class="line">  is $call-count, 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># no need for temp variables in feeds: $(*), @(*), %(*)</div><div class="line"># rakudo skip &apos;* feeds&apos;</div><div class="line"># DOES 4</div><div class="line">&#123;</div><div class="line">    my @data = &apos;a&apos; .. &apos;z&apos;;</div><div class="line">    my @out  = &lt;a e i o u y&gt;;</div><div class="line"></div><div class="line">    @data ==&gt; grep &#123;/&lt;[aeiouy]&gt;/&#125; ==&gt; is($(*), $(@out), &apos;basic test for $(*)&apos;);</div><div class="line">    @data ==&gt; grep &#123;/&lt;[aeiouy]&gt;/&#125; ==&gt; is(@(*), @(@out), &apos;basic test for @(*)&apos;);</div><div class="line">    @data ==&gt; grep &#123;/&lt;[aeiouy]&gt;/&#125; ==&gt; is(%(*), %(@out), &apos;basic test for %(*)&apos;);</div><div class="line"></div><div class="line">    # XXX: currently the same as the @(*) test above. Needs to be improved</div><div class="line">    @data ==&gt; grep &#123;/&lt;[aeiouy]&gt;/&#125; ==&gt; is(@(*).slice, @(@out).slice, &apos;basic test for @(*).slice&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">done;</div><div class="line"></div><div class="line"># vim: ft=perl6</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use Test;</div><div class="line">&#123;</div><div class="line">    my ($got_x, $got_y, @got_z);</div><div class="line">    sub foo ($x, $y?, *@z) &#123;</div><div class="line">        $got_x = $x;</div><div class="line">        $got_y = $y;</div><div class="line">        @got_z = @z;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    my @a = (1 .. 5);</div><div class="line"></div><div class="line">    @a ==&gt; foo &quot;x&quot;;</div><div class="line"></div><div class="line">    is($got_x, &quot;x&quot;, &quot;x was passed as explicit param&quot;);</div><div class="line">    # rakudo 2 todo &apos;feeds + signatures&apos;</div><div class="line">    ok(!defined($got_y), &quot;optional param y was not bound to fed list&quot;);</div><div class="line">    is(~@got_z, ~@a, &apos;...slurpy array *@z got it&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">﻿my @a =slurp(&apos;Hamlet.txt&apos;).comb(/\w+/);</div><div class="line">my @result = (@a ==&gt; sort *.chars ==&gt;  reverse @() ==&gt; join &quot;\n&quot;);</div><div class="line">say  @result; # @() 不使用临时数组存储中间变量</div></pre></td></tr></table></figure>
<h2 id="Hyper-Operator"><a href="#Hyper-Operator" class="headerlink" title="Hyper Operator"></a>Hyper Operator</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">sub add($x) &#123;</div><div class="line">    sleep 3;</div><div class="line">    $x ** 2 + 1;</div><div class="line">&#125;</div><div class="line"># hyper  运算符现在还未实现并行， 该程序 sleep 了 9 秒</div><div class="line">my @array = 1, 3, 5;</div><div class="line">.say for @array».&amp;add;</div></pre></td></tr></table></figure>
<p>超运算符能运用在自定义的子例程上面：</p>
<p>为什么会使用 <code>.&amp;</code> 语法呢？<br>因为 $obj.method 确实是一个方法调用， 而 <code>$obj.$coderef</code> 不是<br>add 函数的名字是 <code>&amp;add</code>,  就像 foo 标量的名字是 <code>$foo</code>, 数组 foo 的名字叫做 @foo 一样<br>在 Perl 6 中， 如果你提到一个子例程却不带 &amp; 符号， 那就是调用了它。在 add 前面加上 &amp;  符号才能引用一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt; sub add($x) &#123;$x * 2 + 1&#125;</div><div class="line">sub add (Any $x) &#123; #`(Sub|140286460109400) ... &#125;</div><div class="line">&gt; 2.add</div><div class="line">Method &apos;add&apos; not found for invocant of class &apos;Int&apos;</div><div class="line">&gt; 2.&amp;add</div><div class="line">5</div><div class="line">&gt; add(2)</div><div class="line">5</div><div class="line">&gt; my $function = sub add($x) &#123;$x * 2 + 1&#125;</div><div class="line">sub add (Any $x) &#123; #`(Sub|140286460109552) ... &#125;</div><div class="line">&gt; 2.$function</div><div class="line">5</div><div class="line">&gt; $function(2)</div><div class="line">5</div><div class="line">&gt; my @a = 1, 2, 3</div><div class="line">1 2 3</div><div class="line">&gt; @a&gt;&gt;.$function</div><div class="line">3 5 7</div><div class="line">&gt; say $function.WHAT</div><div class="line">(Sub)</div><div class="line"></div><div class="line"></div><div class="line">$obj.$function 等价于 $function($obj)</div></pre></td></tr></table></figure>
<h2 id="Meta-Operators"><a href="#Meta-Operators" class="headerlink" title="Meta Operators"></a>Meta Operators</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line">my @lines = slurp(&apos;3col.txt&apos;);</div><div class="line">for @lines -&gt; $line &#123;</div><div class="line">   my @b = $line.comb(/\d+/);</div><div class="line">   say &quot;@b[]&quot;;</div><div class="line">   say &quot;-&quot; x 45;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 没有打印出满意的结果, 因为 slurp 是把所有文本作为一个字符串吸入的.</div><div class="line"></div><div class="line">#`(</div><div class="line">my $fh = open(&apos;3col.txt&apos;);</div><div class="line">my $num;</div><div class="line">for $fh.lines -&gt; $line &#123;</div><div class="line">    $num += $line.words.[2];</div><div class="line">&#125;</div><div class="line">say $num;</div><div class="line">)</div><div class="line"></div><div class="line">my $fh = open(&apos;3col.txt&apos;);</div><div class="line"># say [+] ($fh.lines&gt;&gt;.words).[2];</div><div class="line">my @l = $fh.lines&gt;&gt;.comb(/\d+/);</div><div class="line">say @l.elems;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line"># 该源文件必须保存为 UTF8 格式 才不会报 UTF-8 错误, 即使是中文注释</div><div class="line"></div><div class="line">sub infix:&lt;中&gt;(@array, $ins) &#123;</div><div class="line">    @array.splice(+@array / 2, 0, $ins);</div><div class="line">    return @array;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @a = 1,2,4,5;</div><div class="line">say @a 中 3;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># Loop over multiple arrays (or lists or tuples or whatever they&apos;re called in your language) and print the ith element of each. Use your language&apos;s &quot;for each&quot; loop if it has one, otherwise iterate through the collection in order with some other loop.</div><div class="line"></div><div class="line"># For this example, loop over the arrays (a,b,c), (A,B,C) and (1,2,3) to produce the output</div><div class="line"># aA1</div><div class="line"># bB2</div><div class="line"># cC3</div><div class="line"></div><div class="line">for &lt;a b c&gt; Z &lt;A B C&gt; Z 1, 2, 3 -&gt; $x, $y, $z &#123;</div><div class="line">   say $x, $y, $z;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># The Z operator stops emitting items as soon as the shortest input list is exhausted. However, short lists are easily extended by replicating all or part of the list, or by appending any kind of lazy list generator to supply default values as necessary.</div><div class="line"></div><div class="line"># Note that we can also factor out the concatenation by making the Z metaoperator apply the ~ concatenation operator across each triple:</div><div class="line">for &lt;a b c&gt; Z~ &lt;A B C&gt; Z~ 1, 2, 3 -&gt; $line &#123;</div><div class="line">   say $line;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># We could also use the zip-to-string with the reduction metaoperator:</div><div class="line">.say for [Z~] [&lt;a b c&gt;], [&lt;A B C&gt;], [1,2,3]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line">class PowerBy2 &#123;</div><div class="line">    has $.number;</div><div class="line"></div><div class="line">	method power_by2() &#123;</div><div class="line">	    return  $.number ** 2;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my  $test = PowerBy2.new(number=&gt;10);</div><div class="line">say $test.power_by2;</div><div class="line"></div><div class="line">my @a = &lt;1 2 3 4&gt;;</div><div class="line">my @b = @a&gt;&gt;.power_by2;</div><div class="line">say @b;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @scores = &apos;Ana&apos; =&gt; 8, &apos;Dave&apos; =&gt; 6, &apos;Charlie&apos; =&gt; 4, &apos;Beth&apos; =&gt; 4;</div><div class="line"></div><div class="line">my $screen-width = 30;</div><div class="line"></div><div class="line">my $label-area-width = 1 + [max] @scores».key».chars;</div><div class="line">my $max-score = [max] @scores».value;</div><div class="line">my $unit = ($screen-width - $label-area-width) / $max-score;</div><div class="line">my $format = &apos;%- &apos; ~ $label-area-width ~ &quot;s%s\n&quot;;</div><div class="line"></div><div class="line">for @scores &#123;</div><div class="line">printf $format, .key, &apos;X&apos; x ($unit * .value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use List::Utils;</div><div class="line"></div><div class="line">my @array = &lt;1 3 4 6 7&gt;;</div><div class="line">my @b = sliding-window(@array,2);</div><div class="line">.say for @b;</div><div class="line">say &apos;-&apos; x 15;</div><div class="line">my @c = combinations(@array);</div><div class="line">.say for @c;</div><div class="line">say &apos;-&apos; x 15;</div><div class="line"></div><div class="line">my @d = combinations(@array,3);</div><div class="line">.say for @d;</div><div class="line"></div><div class="line">say &apos;-&apos; x 15;</div><div class="line">my @e = combinations(@array,4);</div><div class="line">.say for @e;</div><div class="line"></div><div class="line">say &apos;-&apos; x 15;</div><div class="line">my @take = take-while((1...*), * &lt;= 10);</div><div class="line">.say for @take;</div><div class="line"></div><div class="line">say &apos;-&apos; x 15;</div><div class="line">my @takerange = take-while((1...*), * + 4 &lt; 10);</div><div class="line">.say for @takerange;</div><div class="line"></div><div class="line">say &apos;-&apos; x 15;</div><div class="line">my @aa = uniq-by(&lt;A B C a b c d D e&gt;, *.uc);</div><div class="line">my @bb = uniq-by((1..* Z -2..*), *.abs)[^10];</div><div class="line">my @cc = uniq-by((1..* Z -2..*), *+1)[^10];</div><div class="line">.say for @aa;</div><div class="line">say &apos;-&apos; x 15;</div><div class="line">.say for @bb;</div><div class="line">say &apos;-&apos; x 15;</div><div class="line">.say for @cc;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use Test;</div><div class="line">use List::Utils;</div><div class="line"></div><div class="line">is take-while((1...*), * &lt;= 10), ~(1...10), &quot;take-while works on a basic infinite loop&quot;;</div><div class="line">is take-while((1...*), * &lt;= -1), &quot;&quot;, &quot;take-while works if condition is initially false&quot;;</div><div class="line"></div><div class="line">done;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my @a = 0..9;</div><div class="line">my @b = &apos;a&apos;..&apos;z&apos;;</div><div class="line">my @guess = @a X~ @b;</div><div class="line">say @guess;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line">my @a=1,2,3;</div><div class="line">my @b=4,5,6;</div><div class="line">my @c=7,8,9;</div><div class="line">for zip(@a; @b; @c) -&gt; $a, $b, $c &#123;say $a,$b,$c;&#125;</div><div class="line"></div><div class="line"># 多行注释</div><div class="line">my $things = #`( i wonder how many of these</div><div class="line"> I will need, hm maybe 3, or 4, better 5 ) 5; # same as $things = 5;</div><div class="line">say $things;</div><div class="line"></div><div class="line">say Q/hello/;</div><div class="line">say Q&#123;world&#125;;</div><div class="line">say Q|1234|;</div><div class="line">say Q,comma,;</div><div class="line">say Q[maohao];</div><div class="line">say Q*askiles*;</div><div class="line">say Q:a/@a[0]/;  # 1</div><div class="line">say @a[1];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @a = &lt;王 孙 刘&gt;;</div><div class="line">my @b = &lt;伟 亦 百&gt;;</div><div class="line">my @c = &lt;霆 哲 爽&gt;;</div><div class="line">for zip(@a;@b;@c) -&gt; $a,$b,$c &#123;</div><div class="line">    say &quot;$a$b$c&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @a=&lt;aa bb cc dd ee ff &gt;;</div><div class="line">for @a -&gt; $x,$y,$z &#123;</div><div class="line">    say $x,$y,$z;</div><div class="line">&#125;</div><div class="line">say $*PROGRAM_NAME;</div><div class="line">say $*CWD;</div><div class="line"># aabbcc</div><div class="line"># ddeeff</div><div class="line"># three.p6</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">One place infinite lazy lists do not work are the hyper meta operators</div><div class="line">The idea is that conceptually they work on the entire list at once</div><div class="line">Indeed, they are allowed to work on its elements in any order, and in parallel</div><div class="line">(In practice, none of the Perl 6 compilers handle parallel processing yet)</div><div class="line">Our first example of a meta operator: an operator built from a simpler operator</div><div class="line">@a »+« @b produces an array which is the sum of the other two arrays</div><div class="line">@a »%%» 2 produces an array of Bools telling which elements of @a are divisible by 2</div><div class="line">~«@a is effectively the same as @a».Str -- it returns an array of strings</div><div class="line"></div><div class="line">当无限惰性列表遇到 hyper 元操作符时, 就不起作用了。从概念上来讲, 它们实际上立即作用于整个列表, 它们被允许以任意顺序作用它们的元素</div><div class="line">还能并行。（事实上, 目前没有一个 Perl 6 编译器能处理并行）</div><div class="line">我们第一个关于元操作符的例子：一个构建自简单操作符的操作符 `@a »+« @b` 生成了一个数组, 这个数组是另外两个数组对应元素的和。</div><div class="line">@a »%%» 2 生成一个布尔值的数组, @a 中的哪个元素能被 2 整除。</div><div class="line">~«@a 和 @a».Str 一样 -- 返回一个字符串的数组。</div><div class="line"></div><div class="line">如果你需要对两个无限惰性列表的元素进行求和, 你可以使用 `zip` 元操作符, 使用 `@a Z+ @b` 代替 `@a »+« @b`。</div><div class="line">`Z+` 对列表进行惰性求值并按需返回它们的值。</div><div class="line">等价于  `(@a Z @b).map(* + *)`。</div><div class="line">&lt;a b c&gt; Z~ &lt;1 2 3&gt; 返回 a1 b2 c3</div><div class="line">同样地 , 交叉操作符 X 有一个等价的 元操作符</div><div class="line">&lt;a b c&gt; X~ &lt;1 2 3&gt; 返回 a1 a2 a3 b1 b2 b3 c1 c2 c3</div><div class="line"></div><div class="line">If you do need to sum the elements of two infinite lazy lists, you can use the zip meta operator</div><div class="line">Instead of @a »+« @b, you can do @a Z+ @b</div><div class="line">Z+ evaluates the lists lazily and returns its values lazily</div><div class="line">It&apos;s effectively doing (@a Z @b).map(* + *)</div><div class="line">&lt;a b c&gt; Z~ &lt;1 2 3&gt; returns a1 b2 c3</div><div class="line">Likewise, the cross operator X has a meta operator equivalent</div><div class="line">&lt;a b c&gt; X~ &lt;1 2 3&gt; returns a1 a2 a3 b1 b2 b3 c1 c2 c3</div><div class="line"></div><div class="line">另外一个作用于数组/列表的元操作符是 reduce:</div><div class="line">`[+] @a` 对 @a 的所有元素进行求和并返回和, 这在功能上等价于 `@a[0] + @a[1] + ... + @a[*-1]`</div><div class="line">任何中缀操作符都能用在 `+` 那个位置上, 显然这对无限惰性列表没有作用。</div><div class="line">但是有另外一种形式的 reduce 元操作符, 它能返回一个惰性列表。</div><div class="line">`[\*] 1..*` 返回一个惰性列表  `1, 1*2, 1*2*3, 1*2*3*4 ...`</div><div class="line">那就是说, it returns each internal step of the evaluation of [*]</div><div class="line"></div><div class="line">Another meta operator which works on arrays/lists is reduce:</div><div class="line">[+] @a sums all of the elements of @a and returns the sum</div><div class="line">It&apos;s functionally equivalent to @a[0] + @a[1] + ... + @a[*-1]</div><div class="line">Any infix operator can be used in place of + there</div><div class="line">Obviously this will not work for infinite lazy lists</div><div class="line">But there is another form of the reduce meta operator which returns a lazy list</div><div class="line">[\*] 1...* returns the lazy list 1, 1*2, 1*2*3, 1*2*3*4 ...</div><div class="line">That is to say, it returns each internal step of the evaluation of [*]</div><div class="line"></div><div class="line">其它元操作符：</div><div class="line">赋值： 传统 op= (eg +=)</div><div class="line">取反： 中缀关系操作符能用作 !op, 即 ` $a !eq $b ` 等价于 `!($a eq $b)`。</div><div class="line">反转： Rop 反转了 op 的参数, 所以 $a R- $b 和 $b - $a 相同。</div><div class="line"></div><div class="line">Other meta operators:</div><div class="line">Assignment: The traditional op= (eg +=)</div><div class="line">Negation: Infix relational operators can be used as !op</div><div class="line">That is, $a !eq $b is equivalent to !($a eq $b)</div><div class="line">Reversing: Rop reverses the arguments to op</div><div class="line">So $a R- $b is the same as $b - $a</div><div class="line"></div><div class="line">&quot;自然地&quot;, 元操作符能嵌套起来</div><div class="line">&quot;Naturally,&quot; meta operators can be nested</div><div class="line">&lt;a b c&gt; X~ &lt;1 2 3&gt;   is a1 a2 a3 b1 b2 b3 c1 c2 c3</div><div class="line">&lt;a b c&gt; RX~ &lt;1 2 3&gt;  is 1a 1b 1c 2a 2b 2c 3a 3b 3c</div><div class="line">&lt;a b c&gt; RXR~ &lt;1 2 3&gt; is a1 b1 c1 a2 b2 c2 a3 b3 c3</div><div class="line">That&apos;s one of the few useful applications of this I know of :)</div><div class="line"></div><div class="line">New operators can be defined just like any other sub</div><div class="line">multi sub infix:&lt;+&gt;(MyInt $a, MyInt $b) overloads addition for MyInt</div><div class="line">sub postfix:&lt;!&gt;(Int $a) &#123; [*] 1..$a; &#125; creates a factorial operator:</div><div class="line">5! yields 120, just as you would expect</div><div class="line">sub prefix:&lt;$$$&gt;($a) &#123; &quot;$a billion dollars&quot; &#125;</div><div class="line">$$$10 yields the string 10 billion dollars</div><div class="line">In theory, these new operators can be used with meta operators too</div><div class="line"></div><div class="line">You may have the impression that Perl 6 is operator crazy</div><div class="line">If so, you are right</div><div class="line">Part of the Perl 6 philosophy is to have a very rich set of operators</div><div class="line">It&apos;s up to programmers not to abuse this</div><div class="line">eg As an infix, + (by itself) should always refer to mathematical addition</div><div class="line">But that&apos;s a convention, not a hard technical rule of the language</div><div class="line"></div><div class="line">prefix:&lt;+&gt; is just sugar for calling an object&apos;s Numeric conversion method</div><div class="line">Operators which start with + are numeric operators</div><div class="line">For instance, +&amp; converts both its arguments to Int and does bitwise AND on them</div><div class="line">prefix:&lt;?&gt; is sugar for .Bool, and ?| converts its arguments to Bool and ORs them</div><div class="line">prefix:&lt;~&gt; is sugar for .Str, conversion to a string</div></pre></td></tr></table></figure>
<h2 id="Syntax-flexibility"><a href="#Syntax-flexibility" class="headerlink" title="Syntax flexibility"></a>Syntax flexibility</h2><hr>
<h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><hr>
<h2 id="Phasers"><a href="#Phasers" class="headerlink" title="Phasers"></a>Phasers</h2><hr>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><hr>
<h2 id="Meta-Object-Programming"><a href="#Meta-Object-Programming" class="headerlink" title="Meta-Object Programming"></a>Meta-Object Programming</h2><hr>
<h2 id="Lexing-and-Parsing"><a href="#Lexing-and-Parsing" class="headerlink" title="Lexing and Parsing"></a>Lexing and Parsing</h2><hr>
<h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h2><hr>
<p>所以到底什么是 role 呢？ 零个或多个方法和属性的集合。</p>
<p>role 不像class，它不能被实例化（如果你尝试了，会生成一个 class）。Perl 6 中 Classes 是可变的，而 roles 是不可变的。</p>
<p>声明 Roles 就像声明 Class 一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">role DebugLog &#123;</div><div class="line">    has @.log_lines;</div><div class="line">&#125;</div><div class="line"></div><div class="line">has $.log_size is rw = 100;</div><div class="line"></div><div class="line">method log_message($message) &#123;</div><div class="line">@!log_lines.shift if</div><div class="line">    @!log_lines.elems &gt;= $!log_size;</div><div class="line">    @!log_lines.push($message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 <code>does</code> trait 将 role 组合到 Class 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class WebCrawler does DebugLog &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这会把方法和属性添加到 class WebCrawler 里面去。结果就像它们起初被写到 class 中一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">role Bull-Like &#123;</div><div class="line">    has Bool $.castrated = False;</div><div class="line">    method steer &#123;</div><div class="line">        # Turn your bull into a steer</div><div class="line">        $!castrated = True;</div><div class="line">        return self;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">role Steerable &#123;</div><div class="line">    has Real $.direction;</div><div class="line">    method steer (Real $d = 0) &#123;</div><div class="line">        $!direction += $d;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Taurus does Bull-Like does Steerable &#123;</div><div class="line">    method steer ($!direction?) &#123;</div><div class="line">        self.Steerable::steer($!direction?);</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">role Hammering &#123;</div><div class="line">    method hammer($stuff) &#123;</div><div class="line">        say &quot;You hammer on $stuff. BAM BAM BAM!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Hammer does Hammering &#123;&#125;</div><div class="line">class Gavel  does Hammering &#123;&#125;</div><div class="line">class Mallet does Hammering &#123;&#125;</div><div class="line"></div><div class="line">my $hammer = Hammer.new;    # create a new hammer object</div><div class="line">say $hammer ~~ Hammer;      # &quot;Bool::True&quot; -- yes, this we know</div><div class="line">say $hammer ~~ Hammering;   # &quot;Bool::True&quot; -- ooh!</div><div class="line"></div><div class="line">my $unkown_object = Gavel.new;</div><div class="line">if $unkown_object ~~ Hammering &#123;</div><div class="line">    $unkown_object.hammer(&quot;that nail over there&quot;);     # will always work</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">role Serializable &#123;</div><div class="line">    method serialize() &#123;</div><div class="line">        self.perl; # very primitive serialization</div><div class="line">    &#125;</div><div class="line">    method deserialize($buf) &#123;</div><div class="line">        EVAL $buf; # reverse operation to .perl</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Point does Serializable &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">&#125;</div><div class="line">my $p = Point.new(:x(1), :y(2));</div><div class="line">my $serialized = $p.serialize;      # method provided by the role</div><div class="line">say $serialized;</div><div class="line">my $clone-of-p = Point.deserialize($serialized);</div><div class="line">say $clone-of-p.x;      # 1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">﻿role Observable &#123;</div><div class="line">    has @!observers;</div><div class="line"></div><div class="line">    method subscribe($observer) &#123;</div><div class="line">        push @!observers, $observer;</div><div class="line">        $observer</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method unsubscribe($observer) &#123;</div><div class="line">        @!observers .= grep(&#123; $^o !=== $observer &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method publish($obj) &#123;</div><div class="line">        @!observers&gt;&gt;.handle($obj)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ReadLineSource does Observable &#123;</div><div class="line">    has $.fh;</div><div class="line">    method enterloop() &#123;</div><div class="line">        loop &#123;</div><div class="line">            self.publish($.fh.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi grep($matcher, Observable $ob) &#123;</div><div class="line">    my class GrepSubscriber does Observable &#123;</div><div class="line">        has $.matcher;</div><div class="line">        method handle($obj) &#123;</div><div class="line">            if $obj ~~ $.matcher &#123;</div><div class="line">                self.publish($obj);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    $ob.subscribe(GrepSubscriber.new(:$matcher))</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $src = ReadLineSource.new(fh =&gt; $*IN);</div><div class="line">$src</div><div class="line">    ==&gt; grep(/^\d+$/)</div><div class="line">    ==&gt; into my $nums;</div><div class="line"></div><div class="line">$nums</div><div class="line">    ==&gt; grep(*.Int.is-prime)</div><div class="line">    ==&gt; call(-&gt; $p &#123; say &quot;That&apos;s prime!&quot; &#125;);</div><div class="line"></div><div class="line">$nums</div><div class="line">    ==&gt; map(-&gt; $n &#123;</div><div class="line">            state $total += $n;</div><div class="line">            $total &gt;= 100 ?? &apos;More than 100&apos; !! ()</div><div class="line">        &#125;)</div><div class="line">    ==&gt; first()</div><div class="line">    ==&gt; call(-&gt; $msg &#123; say $msg &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">role Point &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">    method abs &#123; sqrt($.x * $.x + $.y * $.y) &#125;</div><div class="line">&#125;</div><div class="line">say Point.new(x =&gt; 6, y =&gt; 8).abs;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">role Sleeping &#123;</div><div class="line">    method lie &#123;</div><div class="line">        say &quot;Reclining horizontally...&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">role Lying &#123;</div><div class="line">    method lie &#123;</div><div class="line">        say &quot;Telling an untruth...&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 如果解决方法同名的冲突呢？</div><div class="line"># 在 class 中定义一个同名的方法即可</div><div class="line">class SleepingLiar does Sleeping does Lying &#123;</div><div class="line">    method lie &#123;</div><div class="line">        say &quot;Lying in my sleep....&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $sleep = SleepingLiar.new;</div><div class="line">$sleep.lie; # Lying in my sleep....</div><div class="line"></div><div class="line"># 调用其中之一的 roles 的 lie 方法</div><div class="line">class SleepingSheep does Sleeping does Lying &#123;</div><div class="line">    method lie &#123;</div><div class="line">        self.Sleeping::lie;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $sleepSheep = SleepingSheep.new;</div><div class="line">$sleepSheep.lie; # Reclining horizontally...</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">role Paintable &#123;</div><div class="line">    has $.colour is rw;</div><div class="line">    method paint &#123; ... &#125;</div><div class="line">&#125;</div><div class="line">class Shape &#123;</div><div class="line">    method area &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Rectangle is Shape does Paintable &#123;</div><div class="line">    has $.width;</div><div class="line">    has $.height;</div><div class="line">    method area &#123;</div><div class="line">        $!width * $!height;</div><div class="line">    &#125;</div><div class="line">    method paint() &#123;</div><div class="line">        for 1..$.height &#123;</div><div class="line">            say &apos;x&apos; x $.width;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.new(width =&gt; 8, height =&gt; 3).paint;</div><div class="line"># 这打印下面 3 行</div><div class="line">xxxxxxxx</div><div class="line">xxxxxxxx</div><div class="line">xxxxxxxx</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">role Serializable &#123;</div><div class="line">    method serialize() &#123;</div><div class="line">        self.perl; # very primitive serialization</div><div class="line">    &#125;</div><div class="line">    method deserialization-code($buf) &#123;</div><div class="line">        EVAL $buf; # reverse operation to .perl</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Point does Serializable &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">&#125;</div><div class="line">my $p = Point.new(:x(1), :y(2));</div><div class="line">my $serialized = $p.serialize;      # method provided by the role</div><div class="line">my $clone-of-p = Point.deserialization-code($serialized);</div><div class="line">say $clone-of-p.x;      # 1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">role Sleeping &#123;</div><div class="line">    method lie &#123;</div><div class="line">        say &quot;Reclining horizontally...&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">role Lying &#123;</div><div class="line">    method lie &#123;</div><div class="line">        say &quot;Telling an untruth...&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SleepingLiar does Sleeping does Lying &#123;&#125;    # CONFLICT!</div><div class="line"></div><div class="line"># Method &apos;lie&apos; must be resolved by class SleepingLiar because it exists in multiple roles (Lying, Sleeping)</div></pre></td></tr></table></figure>
<h2 id="rosettacode"><a href="#rosettacode" class="headerlink" title="rosettacode"></a>rosettacode</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 问题： 你有 100 扇关着的门排成一排， 然后你穿过这些门 100 次。第一次穿过的时候，穿越每一扇门， 如果门是开着的就关闭它， 如果门是关着的就打开它。第二次穿越的时候，每两扇门穿越一下，（第 2、4、6扇门）；第三次穿越的时候， 每 3 扇门（第 3、6、9），等等， 直到你穿过第 100 扇门为止。</div><div class="line"># 问： 最后一次穿过门之后， 每扇门的状态是开是关？</div><div class="line"># 提示： 剩下开着的门就是那些能开方的整数the only doors that remain open are whose numbers are perfect squares of integers</div><div class="line">#`(</div><div class="line">my @doors = False xx 101;</div><div class="line"></div><div class="line">($_ = !$_ for @doors[0, * + $_ ...^ * &gt; 100]) for 1..100;</div><div class="line"></div><div class="line">say &quot;Door $_ is &quot;, &lt;closed open&gt;[ @doors[$_] ] for 1..100;</div><div class="line">)</div><div class="line"></div><div class="line">say &quot;Door $_ is open&quot; for map &#123;$^n ** 2&#125;, 1..10;</div><div class="line"></div><div class="line">say &quot;Door $_ is open&quot; for 1..10 X** 2;</div><div class="line"></div><div class="line">say &quot;Door $_ is &quot;, &lt;closed open&gt;[.sqrt == .sqrt.floor] for 1..100;</div><div class="line"></div><div class="line"># « U+00AB  , » U+00BB  Vim =&gt; Ctrl+V =&gt; u =&gt; 00AB</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Works with: Rakudo Star version 2010.08</div><div class="line">for 10 ... 0 &#123;</div><div class="line">    .say;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Works with: Rakudo Star version 2010.08</div><div class="line">loop &#123;</div><div class="line">    say &apos;SPAM&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># In addition, there are various ways of writing lazy, infinite lists in Perl 6:</div><div class="line">print &quot;SPAM\n&quot; xx *;      # repetition operator</div><div class="line">print &quot;SPAM\n&quot;, ~* ... *; # sequence operator</div><div class="line">map &#123;say &quot;SPAM&quot;&#125;, ^Inf;   # upto operator</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.</div><div class="line"></div><div class="line"># Some attributes of a list comprehension are that:</div><div class="line"># 1. They should be distinct from (nested) for loops within the syntax of the language.</div><div class="line"># 2. They should return either a list or an iterator (something that returns successive members of a collection, in order).</div><div class="line"># 3. The syntax has parts corresponding to that of set-builder notation.</div><div class="line"></div><div class="line"># Write a list comprehension that builds the list of all Pythagorean triples with elements between 1 and n. If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.</div><div class="line"></div><div class="line">use v6;</div><div class="line"></div><div class="line">my $n = 20;</div><div class="line">my @list := gather for 1..$n -&gt; $x &#123;</div><div class="line">         for $x..$n -&gt; $y &#123;</div><div class="line">           for $y..$n -&gt; $z &#123;</div><div class="line">             take $x,$y,$z if $x*$x + $y*$y == $z*$z;</div><div class="line">           &#125;</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">.say for  @list;</div><div class="line"></div><div class="line"># Note that gather/take is the primitive in Perl 6 corresponding to generators or coroutines in other languages. It is not, however, tied to function call syntax in Perl 6. We can get away with that because lists are lazy, and the demand for more of the list is implicit; it does not need to be driven by function calls.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># Loop over multiple arrays (or lists or tuples or whatever they&apos;re called in your language) and print the ith element of each. Use your language&apos;s &quot;for each&quot; loop if it has one, otherwise iterate through the collection in order with some other loop.</div><div class="line"></div><div class="line"># For this example, loop over the arrays (a,b,c), (A,B,C) and (1,2,3) to produce the output</div><div class="line"># aA1</div><div class="line"># bB2</div><div class="line"># cC3</div><div class="line"></div><div class="line">for &lt;a b c&gt; Z &lt;A B C&gt; Z 1, 2, 3 -&gt; $x, $y, $z &#123;</div><div class="line">   say $x, $y, $z;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># The Z operator stops emitting items as soon as the shortest input list is exhausted. However, short lists are easily extended by replicating all or part of the list, or by appending any kind of lazy list generator to supply default values as necessary.</div><div class="line"></div><div class="line"># Note that we can also factor out the concatenation by making the Z metaoperator apply the ~ concatenation operator across each triple:</div><div class="line">for &lt;a b c&gt; Z~ &lt;A B C&gt; Z~ 1, 2, 3 -&gt; $line &#123;</div><div class="line">   say $line;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># We could also use the zip-to-string with the reduction metaoperator:</div><div class="line">.say for [Z~] [&lt;a b c&gt;], [&lt;A B C&gt;], [1,2,3]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># 给定一组排好序的数， 如果数字是连续的，就用 - 符号连接 头和尾</div><div class="line"># 例如 -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20</div><div class="line"># 处理后变为： -6,-3-1,3-5,7-11,14,15,17-20</div><div class="line"># Task:编写一个函数， 将范围连接起来</div><div class="line">#  0,  1,  2,  4,  6,  7,  8, 11, 12, 14,</div><div class="line">#  15, 16, 17, 18, 19, 20, 21, 22, 23, 24,</div><div class="line">#  25, 27, 28, 29, 30, 31, 32, 33, 35, 36,</div><div class="line">#  37, 38, 39</div><div class="line"></div><div class="line">sub range-extraction (*@ints) &#123;</div><div class="line">    my $prev = NaN;</div><div class="line">    my @ranges;</div><div class="line"></div><div class="line">    for @ints -&gt; $int &#123;</div><div class="line">        if $int == $prev + 1 &#123;</div><div class="line">            @ranges[*-1].push: $int;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            @ranges.push: [$int];</div><div class="line">        &#125;</div><div class="line">        $prev = $int;</div><div class="line">    &#125;</div><div class="line">    join &apos;,&apos;, @ranges.map: -&gt; @r &#123; @r &gt; 2 ?? &quot;@r[0]-@r[*-1]&quot; !! @r &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say range-extraction</div><div class="line">    -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20;</div><div class="line"></div><div class="line">say range-extraction</div><div class="line">    0,  1,  2,  4,  6,  7,  8, 11, 12, 14,</div><div class="line">    15, 16, 17, 18, 19, 20, 21, 22, 23, 24,</div><div class="line">    25, 27, 28, 29, 30, 31, 32, 33, 35, 36,</div><div class="line">    37, 38, 39;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># The sleep function argument is in units of seconds, but these may be fractional (to the limits of your system&apos;s clock).</div><div class="line">my $sec = prompt(&quot;Sleep for how many microfortnights? &quot;) * 1.2096;</div><div class="line">say &quot;Sleeping...&quot;;</div><div class="line">sleep $sec;</div><div class="line">say &quot;Awake!&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"># Sort an array of composite structures by a key. For example, if you define a composite structure that presents a name-value pair (in pseudocode):</div><div class="line"># Define structure pair such that:</div><div class="line">   # name as a string</div><div class="line">   # value as a string</div><div class="line"></div><div class="line"></div><div class="line"># and an array of such pairs:</div><div class="line"># x: array of pairs</div><div class="line"></div><div class="line"></div><div class="line"># then define a sort routine that sorts the array x by the key name.</div><div class="line"></div><div class="line"># This task can always be accomplished with Sorting Using a Custom Comparator. If your language is not listed here, please see the other article.</div><div class="line"></div><div class="line"># Works with: Rakudo Star version 2010.08</div><div class="line"></div><div class="line">my class Employee &#123;</div><div class="line">   has Str $.name;</div><div class="line">   has Rat $.wage;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $boss     = Employee.new( name =&gt; &quot;Frank Myers&quot;     , wage =&gt; 6755.85 );</div><div class="line">my $driver   = Employee.new( name =&gt; &quot;Aaron Fast&quot;      , wage =&gt; 2530.40 );</div><div class="line">my $worker   = Employee.new( name =&gt; &quot;John Dude&quot;       , wage =&gt; 2200.00 );</div><div class="line">my $salesman = Employee.new( name =&gt; &quot;Frank Mileeater&quot; , wage =&gt; 4590.12 );</div><div class="line"></div><div class="line">my @team = $boss, $driver, $worker, $salesman;</div><div class="line"></div><div class="line">my @orderedByName = @team.sort( *.name )&gt;&gt;.name;</div><div class="line">my @orderedByWage = @team.sort( *.wage )&gt;&gt;.name;</div><div class="line"></div><div class="line">say &quot;Team ordered by name (ascending order):&quot;;</div><div class="line">say @orderedByName.join(&apos;  &apos;);</div><div class="line">say &quot;Team ordered by wage (ascending order):&quot;;</div><div class="line">say @orderedByWage.join(&apos;  &apos;);</div><div class="line"></div><div class="line"># this produces the following output:</div><div class="line"># Team ordered by name (ascending order):</div><div class="line"># Aaron Fast   Frank Mileeater   Frank Myers   John Dude</div><div class="line"># Team ordered by wage (ascending order):</div><div class="line"># John Dude   Aaron Fast   Frank Mileeater   Frank Myers</div><div class="line"></div><div class="line"></div><div class="line"># Note that when the sort receives a unary function, it automatically generates an appropriate comparison function based on the type of the data.</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[reddit编程题-詹妮的水果篮]]></title>
      <url>http://ohmycloud.github.io/2016/04/12/reddit%E7%BC%96%E7%A8%8B%E9%A2%98-%E8%A9%B9%E5%A6%AE%E7%9A%84%E6%B0%B4%E6%9E%9C%E7%AF%AE/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><hr>
<p>小詹妮拿着 5 美元去超市买东西,  为新搬来的邻居买水果篮礼物。因为她是个勤奋并缺乏想象力的孩纸, 她打算正好花 5 美元, 不多也不少。</p>
<p>事实上超市里水果的价格并非整数, 正好花光 5 美元并不容易。 - 但是詹妮已经准备好了。她从背包里拿出上网本, 输入她看到过的水果的单价, 并且开启了一个程序为她收集 — 就是这样, 5 美元能买的水果的组合就出现在屏幕上。</p>
<p><strong>挑战</strong> : 用你选择的语言展示詹妮的程序是什么样子。</p>
<ul>
<li>目标就是 500 美分 (等于 5 美元)</li>
<li>解决方法可以包含多种同类型的水果 - 假设它们数量没有限制</li>
<li>解决方法没有必要包含所有水果类型</li>
<li>对给定的输入检测所有可能的方法</li>
</ul>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><hr>
<p>每行一种水果 — 规定了水果的<strong>名字</strong>(不含空格的单词)和水果的单价(单位为美分, 整数)</p>
<h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><hr>
<p>每个解决方法一行 — 用以逗号分割的数量+名字对儿, 描述了那种类型要买的水果数。</p>
<p>不要列出数量为 0 的水果。 如果为复数就给名字加 <strong>s</strong>。</p>
<h4 id="输入样本"><a href="#输入样本" class="headerlink" title="输入样本"></a>输入样本</h4><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">banana 32</div><div class="line">kiwi 41</div><div class="line">mango 97</div><div class="line">papaya 254</div><div class="line">pineapple 399</div></pre></td></tr></table></figure>
<h4 id="输出样本"><a href="#输出样本" class="headerlink" title="输出样本"></a>输出样本</h4><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">6 kiwis, 1 papaya</div><div class="line">7 bananas, 2 kiwis, 2 mangos</div></pre></td></tr></table></figure>
<h4 id="有挑战的输入"><a href="#有挑战的输入" class="headerlink" title="有挑战的输入"></a>有挑战的输入</h4><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">apple 59</div><div class="line">banana 32</div><div class="line">coconut 155</div><div class="line">grapefruit 128</div><div class="line">jackfruit 1100</div><div class="line">kiwi 41</div><div class="line">lemon 70</div><div class="line">mango 97</div><div class="line">orange 73</div><div class="line">papaya 254</div><div class="line">pear 37</div><div class="line">pineapple 399</div><div class="line">watermelon 500</div></pre></td></tr></table></figure>
<p>注意, 这种输入有 180 种解决方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">my (@names, @prices) := ($_»[0], $_»[1]».Int given lines».words);</div><div class="line"></div><div class="line">for find-coefficients(500, @prices) -&gt; @quantities &#123;</div><div class="line">    say (@names Z @quantities)</div><div class="line">        .map(-&gt; [$name, $qty] &#123; &quot;$qty $name&quot;~(&quot;s&quot; if $qty &gt; 1) if $qty &#125;)</div><div class="line">        .join(&quot;, &quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub find-coefficients ($goal, @terms) &#123;</div><div class="line">    gather &#123;</div><div class="line">        my @coefficients;</div><div class="line"></div><div class="line">        loop (my $i = 0; $i &lt; @terms; @coefficients[$i]++) &#123;</div><div class="line">            given [+](@coefficients Z* @terms) &lt;=&gt; $goal &#123;</div><div class="line">                when Less &#123; $i = 0                      &#125;</div><div class="line">                when More &#123; @coefficients[$i] = 0; $i++ &#125;</div><div class="line">                when Same &#123; take @coefficients.values   &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>For each iteration of the loop, the array <code>@coefficients</code> is “incremented by one” as if its elements were the digits of a number - but not one with a fixed base: instead, it overflows the “digits” whenever the search condition has been exceeded (sum &gt; goal).</p>
<p>The same could possibly be done more elegantly with recursion. And for those who don’t like naive bruteforce solutions, this challenge could also be a nice opportunity to try some <a href="https://en.wikipedia.org/wiki/Dynamic_programming" target="_blank" rel="external">dynamic programming</a> techniques.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">my @fruits = lines».split(&quot; &quot;).sort(-*[1]);</div><div class="line">my @names  = @fruits»[0];</div><div class="line">my @prices = @fruits»[1]».Int;</div><div class="line"></div><div class="line">for find-coefficients(500, @prices) -&gt; @quantities &#123;</div><div class="line">    say (@names Z @quantities)</div><div class="line">        .map(-&gt; [$name, $qty] &#123; &quot;$qty $name&quot;~(&quot;s&quot; if $qty &gt; 1) if $qty &#125;)</div><div class="line">        .join(&quot;, &quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub find-coefficients ($goal, @terms) &#123;</div><div class="line">    gather &#123;</div><div class="line">        my @initial = 0 xx @terms;</div><div class="line"></div><div class="line">        my %partials = (0 =&gt; [@initial,]);</div><div class="line">        my @todo = (@initial,);</div><div class="line">        my %seen-partials := SetHash.new;</div><div class="line">        my %seen-solutions := SetHash.new;</div><div class="line"></div><div class="line">        while @todo &#123;</div><div class="line">            my @current := @todo.shift;</div><div class="line">            my $sum = [+] @current Z* @terms;</div><div class="line"></div><div class="line">            next if $sum &gt; $goal;</div><div class="line"></div><div class="line">            %partials&#123;$sum&#125;.push: @current;</div><div class="line"></div><div class="line">            # Find solutions by adding known partials to the current partial</div><div class="line">            for %partials&#123;$goal - $sum&#125;[*] -&gt; @known &#123;</div><div class="line">                .take if !%seen-solutions&#123;~$_&#125;++ given list @current Z+ @known;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            # Schedule additional iterations</div><div class="line">            if $sum &lt;= $goal div 2 &#123;</div><div class="line">                for @terms.keys &#123;</div><div class="line">                    my @next = @current;</div><div class="line">                    @next[$_]++;</div><div class="line">                    @todo.push: @next if !%seen-partials&#123;~@next&#125;++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>For the challenge input <em>(solution space = 1,127,153,664)</em> it needs only 4296 iterations, at the cost of several hash lookups per iteration.</li>
</ul>
<p>Perl 5 的解决方案。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#可以求解三元以上的，只是个思路，可以推广。</span></div><div class="line"></div><div class="line"><span class="keyword">use</span> strict;</div><div class="line"><span class="keyword">use</span> warnings;</div><div class="line"><span class="comment">#计算二元方程组</span></div><div class="line"><span class="comment">#2x+3y=21</span></div><div class="line"></div><div class="line"><span class="keyword">my</span> @number;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(&lt;DATA&gt;) &#123;</div><div class="line">    <span class="keyword">chomp</span>;</div><div class="line">    <span class="keyword">my</span> ($name, $number) = <span class="keyword">split</span>;</div><div class="line">    <span class="keyword">push</span> @number,$number;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"@number\n"</span>;</div><div class="line"> $_=<span class="string">"1"</span> <span class="keyword">x</span> <span class="number">500</span>;</div><div class="line"><span class="keyword">my</span> %seen;</div><div class="line"><span class="keyword">my</span> $num = <span class="number">31</span>;</div><div class="line"><span class="keyword">my</span> $count = <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">$_=~<span class="keyword">m</span>&#123;</div><div class="line">  (.*)\<span class="number">1</span>&#123;$num&#125;</div><div class="line">  (.*)\<span class="number">2</span><span class="string">&#123;40&#125;</span></div><div class="line">  (.*)\<span class="number">3</span><span class="string">&#123;96&#125;</span></div><div class="line">  (.*)\<span class="number">4</span><span class="string">&#123;253&#125;</span></div><div class="line">  (.*)\<span class="number">5</span><span class="string">&#123;398&#125;</span></div><div class="line"></div><div class="line">  (?&#123;</div><div class="line">  <span class="keyword">my</span> $a=<span class="keyword">split</span> <span class="regexp">//</span>,$1;</div><div class="line">  <span class="keyword">my</span> $b=<span class="keyword">split</span> <span class="regexp">//</span>,$2;</div><div class="line">  <span class="keyword">my</span> $x=<span class="keyword">split</span> <span class="regexp">//</span>,$3;</div><div class="line">  <span class="keyword">my</span> $y=<span class="keyword">split</span> <span class="regexp">//</span>,$4;</div><div class="line">  <span class="keyword">my</span> $d=<span class="keyword">split</span> <span class="regexp">//</span>,$5;</div><div class="line">  $seen&#123;<span class="string">"x=$a,y=$b,a=$x,b=$y,d=$d"</span>&#125;=<span class="number">1</span> <span class="keyword">if</span> ($1 <span class="keyword">x</span> $number[<span class="number">0</span>]) . ($2 <span class="keyword">x</span> $number[<span class="number">1</span>]) . ($3 <span class="keyword">x</span> $number[<span class="number">2</span>]) . ($4 <span class="keyword">x</span> $number[<span class="number">3</span>]) . ($5 <span class="keyword">x</span> $number[<span class="number">4</span>]) eq $_ ;</div><div class="line">  &#125;)</div><div class="line">  (?!)&#125;<span class="keyword">x</span>;</div><div class="line"></div><div class="line"><span class="keyword">foreach</span> <span class="keyword">my</span> $result (<span class="keyword">sort</span> <span class="keyword">keys</span> %seen) &#123;</div><div class="line">  <span class="keyword">print</span> <span class="string">"$result\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">__DATA__</div><div class="line">banana 32</div><div class="line">kiwi 41</div><div class="line">mango 97</div><div class="line">papaya 254</div><div class="line">pineapple 399</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的函数签名]]></title>
      <url>http://ohmycloud.github.io/2016/04/12/Perl6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/</url>
      <content type="html"><![CDATA[<h2 id="签名也是对象"><a href="#签名也是对象" class="headerlink" title="签名也是对象"></a><a href="http://doc.perl6.org/type/Signature" target="_blank" rel="external">签名</a>也是对象</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; sub a($a, $b) &#123;&#125;;</div><div class="line">&gt; &amp;a.signature.perl.say</div><div class="line">:($a, $b)</div><div class="line">&gt; my $b = -&gt; $a, $b &#123;&#125;;</div><div class="line">&gt; $b.signature.perl.say</div><div class="line">:($a, $b)</div></pre></td></tr></table></figure>
<p>签名是一个对象, 就像 Perl 6 中的任何其它东西一样。 任何 <strong>Callable</strong> 类型中都有签名, 并且它能使用 <code>.signature</code>方法获取到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Signature &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>签名是代码对象参数列表的静态描述。即, 签名描述了你需要什么参数和多少参数传递给代码或函数以调用它们。</p>
<p>传递参数给签名把包含在 <strong>Capture</strong> 中的参数绑定到了签名上。</p>
<h2 id="签名字面量"><a href="#签名字面量" class="headerlink" title="签名字面量"></a>签名字面量</h2><hr>
<p>签名出现在子例程和方法名后面的圆括号中, 还出现在 blocks 里面的 <code>-&gt;</code>或 <code>&lt;-&gt;</code>后面, 或者作为变量声明符(例如 <code>my</code> )的输入, 或者以冒号开头作为单独的项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sub f($x) &#123; &#125;</div><div class="line">#    ^^^^ sub f 的签名</div><div class="line">method x() &#123; &#125;</div><div class="line">#       ^^ 方法 x 的签名</div><div class="line">my $s = sub (*@a) &#123; &#125;</div><div class="line">#           ^^^^^ 匿名函数的签名</div><div class="line"></div><div class="line">for @list -&gt; $x &#123; &#125;</div><div class="line">#            ^^    block 的签名</div><div class="line"></div><div class="line">my ($a, @b) = 5, (6,7,8);</div><div class="line">#  ^^^^^^^^ 变量声明符的签名</div><div class="line"></div><div class="line">my $sig = :($a, $b);</div><div class="line">#          ^^^^^^^^ 独立的签名对象</div></pre></td></tr></table></figure>
<p>签名字面量可以用于定义回调或闭包的签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub f(&amp;c:(Int))&#123;&#125;</div><div class="line">sub will-work(Int)&#123;&#125;</div><div class="line">sub won&apos;t-work(Str)&#123;&#125;</div><div class="line">f(&amp;will-work);</div><div class="line">f(&amp;won&apos;t-work); # fails at runtime</div><div class="line">f(-&gt; Int &#123; &apos;this works too&apos; &#125; );</div></pre></td></tr></table></figure>
<h3 id="参数分隔符"><a href="#参数分隔符" class="headerlink" title="参数分隔符"></a>参数分隔符</h3><hr>
<p>签名由逗号分割的0个或多个参数组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:($a, @b, %c)</div><div class="line">sub add ($a, $b) &#123; $a + $b &#125;</div></pre></td></tr></table></figure>
<p>作为一个例外, 签名中的第一个参数后面可以跟着一个冒号而非逗号来标记方法的调用者。调用者是用于调用方法的东西, 它通常通过在签名中指定它来绑定给 <strong>self</strong>, 你可以更改所绑定的变量的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">:($a: @b, %c)  # 第一个参数是调用者</div><div class="line"></div><div class="line">class Foo &#123;</div><div class="line">    method whoami ($me:) &#123;</div><div class="line">        &quot;Well I&apos;m class $me.^name(), of course!&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say Foo.whoami; # Well I&apos;m class Foo, of course!</div></pre></td></tr></table></figure>
<h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><hr>
<p>参数可以可选地拥有一个类型约束(默认为 <code>Any</code>)。这些能用于限制函数允许的输入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:(Int $a, Str $b)</div><div class="line">sub divisors (Int $n) &#123; $_ if $n %% $_ for 1..$n &#125;</div><div class="line">divisors 2.5; # !!! Calling &apos;divisors&apos; will never work with argument types (Rat)</div></pre></td></tr></table></figure>
<p>匿名的参数也行, 如果参数只需要它的类型约束的话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">:($, @, %a)         # 两个匿名参数和一个 &quot;正常的(有名字的)&quot;参数</div><div class="line">:(Int, Positional)  # 只有类型也行(两个参数)</div><div class="line">sub baz (Str) &#123;&quot;Got a String&quot;&#125;</div><div class="line">baz(&quot;hello&quot;);</div></pre></td></tr></table></figure>
<p>类型约束也可以是类型捕获(<a href="http://doc.perl6.org/type/Signature#Type_Captures" target="_blank" rel="external">type captures</a>)。</p>
<p>除了这些名义上的类型之外, 额外的约束可以以代码块的形式加到参数上, 代码块必须返回一个真值以通过类型检测。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub f(Real $x where &#123; $x &gt; 0 &#125;, Real $y where &#123; $y &gt;= $x &#125;) &#123; &#125;</div></pre></td></tr></table></figure>
<p>事实上, where 后面不需要是一个代码块, <code>where</code>-block右侧的任何东西都会被用于和参数智能匹配。所以你也可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">multi factorial(Int $ where 0) &#123; 1 &#125;</div><div class="line">multi factorial(Int $x) &#123; $x * factorial($x - 1) &#125;</div></pre></td></tr></table></figure>
<p>第一个还能简化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi factorial(0) &#123; 1 &#125;</div></pre></td></tr></table></figure>
<p>你可以直接把字面量用作类型而值约束到匿名参数上。</p>
<h4 id="约束定义值和未定义值"><a href="#约束定义值和未定义值" class="headerlink" title="约束定义值和未定义值"></a>约束定义值和未定义值</h4><hr>
<p>通常, 类型约束只检查传递的值是否是正确的<strong>类型</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sub limit-lines (Str $s, Int $limit) &#123;</div><div class="line">    my @lines = $s.lines;</div><div class="line">    @lines[0 ..^ min @lines.elems, $limit].join(&quot;\n&quot;)</div><div class="line">&#125;</div><div class="line">say (limit-lines &quot;a \n b \n c \n d \n&quot;, 3).perl; # &quot;a \n b \n c &quot;</div><div class="line">say limit-lines Str,      3;  # Uh-oh. Dies with &quot;Cannot call &apos;lines&apos;;&quot;</div><div class="line">say limit-lines &quot;a \n b&quot;, Int # Always returns the max number of lines</div></pre></td></tr></table></figure>
<p>这样的情况, 我们其实只想处理定义了的字符串。要这样做, 我们使用 <code>:D</code>类型约束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub limit-lines (Str:D $s, Int $limit) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">say limit-lines Str, 3;</div><div class="line"># Dies with &quot;参数 &apos;$s&apos; 需要一个实例, 但是函数 limit-lines 中却传递了一个类型对象。</div></pre></td></tr></table></figure>
<p>如果传递一个诸如 <strong>Str</strong> 这样的类型对象进去, 那么就会报错。这样的失败方式比以前更好了, 因为失败的原因更清晰了。</p>
<p>也有可能未定义的类型是子例程唯一有意义的接收值。这可以使用 <code>:U</code>类型约束来约束它。例如, 我们可以把 <code>&amp;limit-lines</code>转换成 multi 函数以使用 <code>:U</code>约束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">multi  limit-lines (Str $s, Int:D $limit) &#123;</div><div class="line">    my @lines = $s.lines;</div><div class="line">    @lines[0 ..^ min @lines.elems, $limit].join(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi limit-lines (Str $s, Int:U $) &#123;$s&#125; # 如果传递给我一个未定义的类型对象, 就返回整个字符串</div><div class="line"></div><div class="line">say limit-lines &quot;a \n b \n c&quot;, Int;      # &quot;a \n b \n c&quot;</div></pre></td></tr></table></figure>
<p>为了显式地标示常规的行为,  可以使用<code>:_</code>,  但这不是必须的。 <code>:(Num:_ $)</code> 和 <code>Num $</code>相同。</p>
<h4 id="约束返回类型"><a href="#约束返回类型" class="headerlink" title="约束返回类型"></a>约束返回类型</h4><hr>
<p><code>--&gt;</code>标记后面跟着一个类型会强制在子例程执行成功时进行类型检测。返回类型箭头必须放在参数列表的后面。跟在签名声明后面的 <code>returns</code> 关键字有同样的功能。<code>Nil</code>在类型检测中被认为是定义了的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub foo(--&gt; Int) &#123; 1 &#125;;</div><div class="line">sub foo() returns Int &#123; 1 &#125;;        # 同上</div><div class="line">sub does-not-work(--&gt; Int) &#123; &quot; &quot; &#125;; # throws X::TypeCheck::Return</div></pre></td></tr></table></figure>
<p>如果类型约束是一个常量表达式, 那么它被用于子例程的<strong>返回值</strong>。那个子例程中的任何<strong>return</strong>语句必须是不含参数的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub foo(--&gt; 123) &#123; return &#125;</div></pre></td></tr></table></figure>
<p><code>Nil</code>和 <code>Failure</code>总是被允许作为返回<strong>类型</strong>, 不管类型约束是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub foo(--&gt; Int) &#123; Nil &#125;;</div><div class="line">say foo.perl; # Nil</div></pre></td></tr></table></figure>
<p>不支持类型捕获和强制类型。</p>
<h3 id="吞噬参数-或长度可变参数"><a href="#吞噬参数-或长度可变参数" class="headerlink" title="吞噬参数(或长度可变参数)"></a>吞噬参数(或长度可变参数)</h3><hr>
<p>数组或散列参数可以通过前置一个星号(s)被标记为吞噬参数, 这意味着它可以被绑定给任意数量的参数(0 个或 多个)。</p>
<p>它们被叫做吞噬参数, 因为它们吞完函数中的任何剩余参数, 就像有些人吞吃面条那样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:($a, @b)  # 正好两个参数, 而第二个参数必须是 Positional 的</div><div class="line">:($a, *@b) # 至少一个参数, @b 吞噬完任何剩余的参数</div><div class="line">:(*%h)     # 没有位置参数, 除了任意数量的具名参数</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sub one-arg (@)  &#123; &#125;;</div><div class="line">sub slury   (*@) &#123; &#125;;</div><div class="line"></div><div class="line">one-arg(5, 6, 7);  # !!! 参数个数太多</div><div class="line">one-arg (5, 6, 7); # ok, 和 one-arg((5,6,7))相同, 传递的是一个数组</div><div class="line"></div><div class="line">slurp (5, 6, 7);   # ok</div><div class="line">one-arg 5, 6, 7;   # 调用 one-arg(Int, Int, Int) 绝对不会工作, 使用声明的签名 (@), 参数个数太多</div><div class="line">slurp 5, 6, 7;     # ok</div><div class="line"></div><div class="line">one-arg (5);       # Calling one-arg(Int) will never work with declared signature (@)</div><div class="line">one-arg (5,);      # ok</div></pre></td></tr></table></figure>
<p>one-arg 函数需要的参数是<strong>一个</strong>列表(或数组), 而不是多个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; (5).WHAT.say</div><div class="line">(Int)</div><div class="line">&gt; (5,).WHAT.say</div><div class="line">(List)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub named-names (*%named-args) &#123; %named-args.keys &#125;;</div><div class="line">say named-names :foo(42) :bar&lt;hahaha&gt;  # =&gt; foo bar</div></pre></td></tr></table></figure>
<p>注意位置参数不允许出现在吞噬参数的后面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:(*@args, $last) # !!! 不能把必要参数放在可变长度参数的后面</div></pre></td></tr></table></figure>
<p>带有一个星号的吞噬参数会通过消融一层或多层裸的可迭代对象来展平参数。 带有两个星号的吞噬参数不会展平参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub a (*@a)  &#123; @a.join(&quot;|&quot;).say &#125;;</div><div class="line">sub b (**@b) &#123; @b.join(&quot;|&quot;).say &#125;;</div><div class="line"></div><div class="line">a(1,[1,2],([3,4],5));    #  1|1|2|3|4|5</div><div class="line">b(1,[1,2],([3,4],5));    # 1|1 2|3 4 5</div></pre></td></tr></table></figure>
<p>通常, 吞噬参数会创建一个数组, 为每个 argument 创建一个标量容器, 并且把每个参数的值赋值给那些标量。如果在该过程中原参数也有一个中间的标量分量, 那么它在调用函数中是访问不到的。</p>
<p>吞噬参数在和某些<a href="http://doc.perl6.org/type/Signature#Parameter_Traits_and_Modifiers" target="_blank" rel="external">traits and modifiers</a>组合使用时会有特殊行为, 像下面描述的那样。</p>
<h3 id="类型捕获"><a href="#类型捕获" class="headerlink" title="类型捕获"></a>类型捕获</h3><hr>
<p>类型捕获允许把类型约束的说明推迟到函数被调用时。它们允许签名和函数体中的类型都可以引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sub f(::T $p1, T $p2, ::C) &#123;</div><div class="line">    # $p1 和 $p2 的类型都为 T, 但是我们还不知道具体类型是什么</div><div class="line">    # C 将会保存一个源于类型对象或值的类型</div><div class="line">    my C $closure = $p1 / $p2;</div><div class="line">    return sub (T $p1) &#123;</div><div class="line">        $closure * $p1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 第一个参数是 Int 类型, 所以第二个参数也是</div><div class="line"># 我们从调用用于 &amp;f 中的操作符导出第三个类型</div><div class="line">my &amp;s = f(10,2, Int.new / Int.new);</div><div class="line">say s(2);  # 10 / 2 * 2  == 10</div></pre></td></tr></table></figure>
<h3 id="Positional-vs-Named"><a href="#Positional-vs-Named" class="headerlink" title="Positional vs. Named"></a>Positional vs. Named</h3><hr>
<p>参数可以是跟位置有关的或者是具名的。所有的参数都是 positional 的, 除了吞噬型散列参数和有前置冒号标记的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">:($a)   # 位置参数</div><div class="line">:(:$a)  # 名字为 a 的具名参数</div><div class="line">:(*@a)  # 吞噬型位置参数</div><div class="line">:(*%h)  # 吞噬型具名参数</div></pre></td></tr></table></figure>
<p>在调用者这边, 位置参数的传递顺序和它们声明顺序相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub pos($x, $y) &#123; &quot;x = $x y = $y&quot; &#125;;</div><div class="line">pos(4, 5); #  x = 4 y = 5</div></pre></td></tr></table></figure>
<p>对于具名实参和具名形参, 只用名字用于将实参映射到形参上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub named(:$x, :$y) &#123; &quot;x=$x y=$y&quot; &#125;</div><div class="line">named( y =&gt; 5, x =&gt; 4);</div></pre></td></tr></table></figure>
<p>具名参数也可以和变量的名字不同:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub named(:official($private)) &#123; &quot;公务&quot; if $private &#125;</div><div class="line">named :official;</div></pre></td></tr></table></figure>
<p>别名也是那样做的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub paint( :color(:colour($c)) ) &#123; &#125; # &apos;color&apos; 和 &apos;colour&apos; 都可以</div><div class="line">sub paint( :color(:$colour) )    &#123; &#125; # same API for the caller</div></pre></td></tr></table></figure>
<p>带有具名参数的函数可以被动态地调用, 使用 <code>|</code>非关联化一个 Pair 来把它转换为一个具名参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">multi f(:$named) &#123; note &amp;?ROUTINE.signature &#125;;</div><div class="line">multi f(:$also-named) &#123; note &amp;?ROUTINE.signature &#125;;</div><div class="line"></div><div class="line">for &apos;named&apos;, &apos;also-named&apos; -&gt; $n &#123;</div><div class="line">    f(|($n =&gt; rand))      # «(:$named)␤(:$also-named)␤»</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $pair = :named(1);</div><div class="line">f |$pair; # «(:$named)␤»</div></pre></td></tr></table></figure>
<p>同样的语法也可以用于将散列转换为具名参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %pairs = also-named =&gt; 4;</div><div class="line">f |%pairs;        # (:$also-named)</div></pre></td></tr></table></figure>
<h3 id="可选参数和强制参数"><a href="#可选参数和强制参数" class="headerlink" title="可选参数和强制参数"></a>可选参数和强制参数</h3><hr>
<p>Positional 参数默认是强制的,  也可以用默认值或结尾的问号使参数成为可选的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:(Str $id)         # 必要参数 required parameter</div><div class="line">:($base = 10)      # 可选参数, 默认为 10</div><div class="line">:(Int $x?)         # 可选参数, 默认为 Int 类型的对象</div></pre></td></tr></table></figure>
<p>具名参数默认是可选的, 可以通过在参数末尾加上一个感叹号使它变成强制参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:(:%config)        # 可选参数</div><div class="line">:(:$debug = False) # 可选参数, 默认为 False</div><div class="line">:(:$name!)         # 名为 name 的强制具名参数</div></pre></td></tr></table></figure>
<p>默认值可以依靠之前的参数, 并且每次调用都会被重新计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:($goal, $accuracy = $goal / 100);</div><div class="line">:(:$excludes = [&apos;.&apos;, &apos;..&apos;]); # a new Array for every call</div></pre></td></tr></table></figure>
<h3 id="解构参数"><a href="#解构参数" class="headerlink" title="解构参数"></a>解构参数</h3><hr>
<p>参数后面可以跟着一个由括号括起来的 <code>sub-signature</code>, 子签名会解构给定的参数。解构的列表就是它的元素:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub first (@array ($first, *@rest)) &#123; $first &#125;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub first ([$first, *@]) &#123; $first &#125;</div></pre></td></tr></table></figure>
<p>而散列的解构是它的键值对儿:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub all-dimensions (% (:length(:$x), :width(:$y), :depth(:$z))) &#123;</div><div class="line">    sx andthen $y andthen $z andthen True</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>andthen</code> 返回第一个未定义的值, 否则返回最后一个元素。短路操作符。<code>andthen</code> 左侧的结果被绑定给 <code>$_</code> 用于右侧, 或者作为参数传递, 如果右侧是一个 <code>block</code> 或 <code>pointy block</code> 的话。</p>
<p>一般地, 对象根据它的属性结构。通用的惯用法是在 <em>for</em> 循环中解包一个 <code>Pair</code>的键和值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for @guest-list.pairs -&gt; (:key($index), :value($guest)) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而, 这种把对象解包为它们的属性只是默认行为。为了让对象按照不同的方解构, 改变它们的 <code>Capture</code>方法。</p>
<h3 id="捕获参数"><a href="#捕获参数" class="headerlink" title="捕获参数"></a>捕获参数</h3><hr>
<p>在参数前前置一个垂直的 <code>|</code>会让参数变为 <code>Capture</code>, 并使用完所有剩下的位置参数和具名参数。</p>
<p>这常用在 <code>proto</code>定义中( 像 <code>proto foo (|) {*}</code> ) 来标示子例程的 <code>multi</code>定义可以拥有任何类型约束。</p>
<h3 id="参数特性和修饰符"><a href="#参数特性和修饰符" class="headerlink" title="参数特性和修饰符"></a>参数特性和修饰符</h3><hr>
<p>默认地, 形式参数被绑定到它们的实参上并且被标记为只读。你可以使用 traits 特性更改参数的只读特性。</p>
<p><code>is copy</code>特性让参数被复制, 并允许在子例程内部修改参数的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub count-up ($x is copy) &#123;</div><div class="line">    $x = Inf if $x ~~ Whatever;</div><div class="line">    .say for 1..$x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>is rw</code>特性让参数只绑定到变量上(或其它可写的容器)。 赋值给参数会改变调用一侧的变量的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub swap($x is rw, $y is rw) &#123;</div><div class="line">    ($x, $y) = ($y, $x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于吞噬参数, <code>is rw</code> 由语言设计者保留做将来之用</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><hr>
<h3 id="params-方法"><a href="#params-方法" class="headerlink" title="params 方法"></a>params 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method params(Signature:D:) returns Positional</div></pre></td></tr></table></figure>
<p>返回 <code>Parameter</code>对象列表以组成签名。</p>
<h3 id="arity-方法"><a href="#arity-方法" class="headerlink" title="arity 方法"></a>arity 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method arity(Signature:D:) returns Int:D</div></pre></td></tr></table></figure>
<p>返回所必须的最小数量的满足签名的位置参数</p>
<h3 id="count-方法"><a href="#count-方法" class="headerlink" title="count 方法"></a>count 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method count(Signature:D:) returns Real:D</div></pre></td></tr></table></figure>
<p>返回能被绑定给签名的最大数量的位置参数。如果有吞噬位置参数则返回 <code>Inf</code>。</p>
<h3 id="returns-方法"><a href="#returns-方法" class="headerlink" title="returns 方法"></a>returns 方法</h3><hr>
<p>签名返回的任意约束是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:($a, $b --&gt; Int).returns # Int</div></pre></td></tr></table></figure>
<h3 id="ACCEPTS-方法"><a href="#ACCEPTS-方法" class="headerlink" title="ACCEPTS 方法"></a>ACCEPTS 方法</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">multi method ACCEPTS(Signature:D: Capture $topic)</div><div class="line">multi method ACCEPTS(Signature:D: @topic)</div><div class="line">multi method ACCEPTS(Signature:D: %topic)</div><div class="line">multi method ACCEPTS(Signature:D: Signature $topic)</div></pre></td></tr></table></figure>
<p>前三个方法会看参能否绑定给 capture, 例如, 如果带有那个 Signature 的函数能使用 <code>$topic</code>调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(1,2, :foo) ~~ :($a, $b, :foo($bar)) # true</div><div class="line">&lt;a b c d&gt; ~~ :(Int $a)               # False</div></pre></td></tr></table></figure>
<p>最后一个会为真如果 <code>$topic</code>能接收的任何东西也能被 <code>Signature</code>接收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:($a, $b) ~~ :($foo, $bar, $baz?)   # True</div><div class="line">:(Int $n) ~~ :(Str)                 # False</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[正则替换]]></title>
      <url>http://ohmycloud.github.io/2016/04/07/%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>想把 Desgin Perl 6 中的 pod/html 转为 Markdown 格式,  Perl 6 的 pod2markdown 不能用, 只能下载 html 格式的了, 然后用 <code>pandoc test.html  -o result.markdown</code> 转换了, 但是也不理想, 里面还有很多  html 标签,  写个脚本批量替换下吧。<br>token 中的空白要显式地使用 <code>\s</code>、<code>\h</code>、<code>\t</code> 等表示, rule 中 <code>:sigspace</code> 是开启的。程序很丑, 仅仅是记录一下。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">use v6;</div><div class="line"></div><div class="line">my rule r1 &#123;&apos;&lt;&apos;span id\=&apos;&quot;&apos;line_\\d+&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos; &apos;&lt;&apos;span id\=&apos;&quot;&apos;line_\\d+&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos;( &apos;&lt;&apos;span)?$&#125;</div><div class="line">my rule r2 &#123;id\=&apos;&quot;&apos;line_\d+&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos; &apos;&lt;&apos;span id\=&apos;&quot;&apos;line_\d+&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos;( &apos;&lt;&apos;span)?$&#125;</div><div class="line">my rule r3 &#123;^id\=&apos;&quot;&apos;line_\d+&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos;$&#125;</div><div class="line">my rule r4 &#123;&apos;&lt;&apos;div class\=&apos;&quot;&apos;smartlink&apos;&quot;&apos;&apos;&gt;&apos;&#125;</div><div class="line">my rule r5 &#123;&apos;&lt;&apos;&apos;/&apos;div&apos;&gt;&apos;&#125;</div><div class="line">my rule r6 &#123;&apos;&lt;&apos;div class\=&apos;&quot;&apos;indexgroup&apos;&quot;&apos;&apos;&gt;&apos;&#125;</div><div class="line">my rule r7 &#123;&apos;&lt;&apos;span id\=&apos;&quot;&apos;__top&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos;&#125;</div><div class="line">my token r8 &#123;^  \s* &apos;&lt;&apos;span$&#125;</div><div class="line">my rule r9 &#123;^id\=&apos;&quot;&apos;line_\d+&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos; &apos;&lt;&apos;span id\=&apos;&quot;&apos;line_\d+&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos;$&#125;</div><div class="line">my rule r10 &#123;id\=&apos;&quot;&apos;line_\d+&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos; &apos;&lt;&apos;span id\=&apos;&quot;&apos;line_\d+&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos;(\s&apos;&lt;&apos;span)?$&#125;</div><div class="line">my token r11 &#123;^ \s* id\=&apos;&quot;&apos;line_\d+&apos;&quot;&apos;&apos;&gt;&apos;&apos;&lt;&apos;&apos;/&apos;span&apos;&gt;&apos;&#125;</div><div class="line">my token r12 &#123;^ \s* &apos;&lt;&apos; span \s $&#125;</div><div class="line"></div><div class="line">for dir(test =&gt; /.markdown$/) -&gt; $file  &#123;</div><div class="line">    my $f = $file;</div><div class="line">    $f ~~ s/.markdown//;</div><div class="line">    my @lines = $file.lines;</div><div class="line">    my $out = open $f ~ &quot;.md&quot;, :w;</div><div class="line">    for @lines -&gt; $line is rw &#123;</div><div class="line">        $line ~~ s/&lt;r1&gt;//;</div><div class="line">        $line ~~ s/&lt;r2&gt;//;</div><div class="line">        $line ~~ s/&lt;r3&gt;//;</div><div class="line">        $line ~~ s/&lt;r4&gt;//;</div><div class="line">        $line ~~ s/&lt;r5&gt;//;</div><div class="line">        $line ~~ s/&lt;r6&gt;//;</div><div class="line">        $line ~~ s/&lt;r7&gt;//;</div><div class="line">        $line ~~ s/&lt;r8&gt;//;</div><div class="line">        $line ~~ s/&lt;r9&gt;//;</div><div class="line">        $line ~~ s/&lt;r10&gt;//;</div><div class="line">        $line ~~ s/&lt;r11&gt;//;</div><div class="line">        $line ~~ s/&lt;r12&gt;//;</div><div class="line">        $out.say($line);</div><div class="line">    &#125;</div><div class="line">    $out.close;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的术语]]></title>
      <url>http://ohmycloud.github.io/2016/03/26/Perl6%E4%B8%AD%E7%9A%84%E6%9C%AF%E8%AF%AD/</url>
      <content type="html"><![CDATA[<h2 id="匿名"><a href="#匿名" class="headerlink" title="匿名"></a>匿名</h2><hr>
<p>子例程、方法或子方法，当它们不能通过名字调用时，就被称为匿名的</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># named subroutine</span></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">double</span>($<span class="title">x</span>) </span>&#123; <span class="number">2</span> * $x &#125;;</div><div class="line"><span class="comment"># 匿名子例程,存储在一个具名的标量里</span></div><div class="line"><span class="keyword">my</span> $double = <span class="function"><span class="keyword">sub</span> ($<span class="title">x</span>) </span>&#123; <span class="number">2</span> * $x &#125;;</div></pre></td></tr></table></figure>
<p>注意，匿名子例程仍然可以有名字</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用 anon 关键字使子例程匿名</span></div><div class="line"><span class="keyword">my</span> $s = anon <span class="function"><span class="keyword">sub</span> <span class="title">triple</span>($<span class="title">x</span>) </span>&#123; <span class="number">3</span> * $x &#125;</div><div class="line"><span class="keyword">say</span> $s.name;        <span class="comment"># triple</span></div></pre></td></tr></table></figure>
<h2 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h2><hr>
<p>通常, 副词是函数的命名参数.  也有一些其它特殊语法形式允许副词出现在某些合适的地方:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">q</span>:w<span class="string">"foo bar"</span>   <span class="comment"># ":w" is a Quotelike form modifier adverb</span></div><div class="line"><span class="keyword">m</span>:g/a|b|c/     <span class="comment"># ":g" is also</span></div><div class="line"><span class="number">4</span> +&gt; <span class="number">5</span> :rotate <span class="comment"># ":rotate" is an operator adverb</span></div><div class="line">@h<span class="string">&#123;3&#125;</span>:<span class="keyword">exists</span>   <span class="comment"># ":exists" is also, but is known as a subscript adverb</span></div></pre></td></tr></table></figure>
<p>副词通常使用冒号对儿标记来表示, 因为这个原因, 冒号对儿标记法也以副词对儿形式著称:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:a(<span class="number">4</span>)          <span class="comment"># Same as "a" =&gt; 4</span></div></pre></td></tr></table></figure>
<h2 id="Autothreading"><a href="#Autothreading" class="headerlink" title="Autothreading"></a>Autothreading</h2><hr>
<p><code>Autothreading</code> 是这样的: 如果你传递一个 <code>junction</code> 给子例程, 该子例程期望的参数类型为<code>Any</code> 或它的子类型. 那么这个子例程调用会被执行多次, 每次使用一个不同的 junction 状态. 这些调用的结果被组合成一个跟原 <code>junction</code> 同类型的 <code>junction</code>. </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">f</span>($<span class="title">x</span>) </span>&#123; <span class="number">2</span> * $x &#125;;</div><div class="line"><span class="keyword">if</span> f(<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>) == <span class="number">4</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">'success'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 <code>f()</code> 是含有一个参数的子例程，然而因为它没有显式的类型声明，它就被隐式的声明为 <code>Any</code> 型。 Junction 参数使 <code>f(1|2|3)</code> 调用在内部作为 <code>f(1)|f(2)|f(3)</code> 执行,而结果是跟原 <code>junction</code> 同类型的 <code>junction</code> , 即  <code>2|4|6</code>.  这种把一个 <code>Junction</code> 分成对多次函数调用的处理就叫做 <code>autothreading</code>.</p>
<h2 id="Colon-Pair-and-Colon-List"><a href="#Colon-Pair-and-Colon-List" class="headerlink" title="Colon Pair and Colon List"></a>Colon Pair and Colon List</h2><hr>
<p>冒号对儿是用于创建或 Pair 对象的便捷语法. 两种最常见的形式是:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:a(<span class="number">4</span>)          <span class="comment"># Same as "a" =&gt; 4,   same as Pair.new(:key&lt;a&gt;,:value(5))</span></div><div class="line">:a&lt;<span class="number">4</span>&gt;          <span class="comment"># Same as "a" =&gt; "4", same as Pair.new(:key&lt;a&gt;,:value&lt;5&gt;)</span></div></pre></td></tr></table></figure>
<p>这也是人们熟知的副词对儿形式. 注意, 当冒号后面括号前面的部分不是一个合法的标识符的时候, 会应用其它语义, 不是所有的副词对儿都创建 <code>Pair</code> 对象.<br>另外两个常见的形式是:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:a             <span class="comment"># Same as :a(True)</span></div><div class="line">:!a            <span class="comment"># Same as :a(False)</span></div></pre></td></tr></table></figure>
<p>一个 colon 列表是一个仅包含冒号对儿的列表, 不需要逗号, 甚至不需要空格:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:a(<span class="number">4</span>):c:!d:c   <span class="comment"># Same as a =&gt; 4, c =&gt; True, d =&gt; False, c =&gt; True</span></div></pre></td></tr></table></figure>
<h2 id="Constraint"><a href="#Constraint" class="headerlink" title="Constraint"></a>Constraint</h2><hr>
<p>约束是给参数或 subset 类型添加的限制. 通过单词 where 引入约束. 在下面的例子中, 约束用于确保 , 当调用一个名为 abbreviate 的子例程, 其参数为一个长度小于 10 个字符的字符串时,会抛出一个错误:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">abbreviate</span> (<span class="title">Str</span> $<span class="title">thing</span> <span class="title">where</span> </span>&#123; .chars &gt;= <span class="number">10</span> &#125;) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>上例中的 Str 也是一个约束, 但是经常作为”类型约束”.</p>
<h2 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h2><hr>
<p>类的实例在其它编程语言中也叫对象. 对象存储属性, 通常是 new 方法调用的返回值, 或者是对象字面量.<br>大部分类型的实例被定义为 True, 例如 <code>defined($instance)</code> 为 True.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> Str $str = <span class="string">"hello"</span>;  <span class="comment">## 这使用内建类型,例如 Str</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">defined</span>($str) &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Oh, yeah. I'm defined."</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No. Something off? "</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">## if you wanted objects...</span></div><div class="line">class A &#123;</div><div class="line">    <span class="comment"># nothing here for now.</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">my</span> $an_instance = A.new;</div><div class="line"><span class="keyword">say</span> $an_instance.defined.perl;<span class="comment"># defined($an_instance) works too.</span></div></pre></td></tr></table></figure>
<p>类拥有方法和属性的所有蓝图, 而类的实例把蓝图带到真实世界中.</p>
<h2 id="Invocant"><a href="#Invocant" class="headerlink" title="Invocant"></a>Invocant</h2><hr>
<p>在 Perl 6 中调用方法的对象叫做调用者. 在方法中它就是 <code>self</code> 引用的东西.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> <span class="string">'str'</span>.uc;   <span class="comment"># 'str' 是 方法 uc 的调用者</span></div></pre></td></tr></table></figure>
<h2 id="Literal"><a href="#Literal" class="headerlink" title="Literal"></a>Literal</h2><hr>
<p>字面量是一块直接代表对象的代码, 通常指向对象自身.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $x = <span class="number">2</span>;      <span class="comment"># the 2 is a literal</span></div><div class="line"><span class="keyword">say</span> $x;         <span class="comment"># $x is not a literal, but a variable</span></div></pre></td></tr></table></figure>
<h2 id="lvalue"><a href="#lvalue" class="headerlink" title="lvalue"></a>lvalue</h2><hr>
<p> lvalue 或者左值是能出现在赋值操作符左侧的任何东西; 典型的左值有变量,私有属性和 <code>is rw</code>属性, 变量列表和左值子例程.<br>左值的例子:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Declaration             lvalue          Comments</div><div class="line"><span class="keyword">my</span> $x;                  $x</div><div class="line"><span class="keyword">my</span> ($a, $b);            ($a, $b)</div><div class="line">has $!attribute;        $!attribute     Only inside classes</div><div class="line">has $.attrib is rw;     $.attrib</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">a</span> <span class="title">is</span> <span class="title">rw</span> </span>&#123; $x &#125;;     a()</div></pre></td></tr></table></figure>
<p>不是左值的例子:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>                        <span class="comment"># literals</span></div><div class="line">constant <span class="keyword">x</span> = <span class="number">3</span>;          <span class="comment"># constants</span></div><div class="line">has $.attrib;            <span class="comment"># attributes; you can only assign to $!attrib</span></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">f</span> </span>&#123; &#125;; f();          <span class="comment"># "normal" subs are not writable</span></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">f</span>($<span class="title">x</span>) </span>&#123; $x = <span class="number">3</span> &#125;;    <span class="comment"># error - parameters are read-only by default</span></div></pre></td></tr></table></figure>
<h2 id="Mainline"><a href="#Mainline" class="headerlink" title="Mainline"></a>Mainline</h2><hr>
<p><code>mainline</code> 是程序中不属于任何 block 的程序文本.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;     <span class="comment"># mainline</span></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">f</span> </span>&#123;</div><div class="line">            <span class="comment"># not in mainline, in sub f</span></div><div class="line">&#125;</div><div class="line">f();        <span class="comment"># in mainline again</span></div></pre></td></tr></table></figure>
<h2 id="Slurpy"><a href="#Slurpy" class="headerlink" title="Slurpy"></a>Slurpy</h2><hr>
<p>子例程或方法中的形参如果能接收任意数量的参数, 那这个形参就会被认为是 <code>slurpy</code> 的. 它由参数名字前面的星号标出.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">sum</span> (*@<span class="title">numbers</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [+] @numbers;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Type-Object"><a href="#Type-Object" class="headerlink" title="Type Object"></a>Type Object</h2><hr>
<p>类型对象是一个代表类 <code>/role/package/grammar/enum</code> 的对象. 它通常和类型名相同.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class A &#123; &#125;;</div><div class="line"><span class="keyword">say</span> A;              <span class="comment"># A is the type object</span></div><div class="line"><span class="keyword">my</span> $x = A.new();    <span class="comment"># same here</span></div><div class="line"><span class="keyword">my</span> $x = class &#123;</div><div class="line">    method greet() &#123;</div><div class="line">        <span class="keyword">say</span> <span class="string">"hi"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># $x now holds a type object returned from the</span></div><div class="line"><span class="comment"># anonymous class definition</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的操作符(三)]]></title>
      <url>http://ohmycloud.github.io/2016/03/23/Perl6%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6-%E4%B8%89/</url>
      <content type="html"><![CDATA[<h2 id="范围和范围迭代器语法"><a href="#范围和范围迭代器语法" class="headerlink" title="范围和范围迭代器语法"></a>范围和范围迭代器语法</h2><p><code>..</code> 范围操作符有各种在两端带有 <code>^</code>符号的变体以表明把那个端点排除在范围之外。 它总会产生一个 Range 对象。 Range 对象是不可变的， 主要用于匹配间隔。</p>
<p>1..2 是从1到2包含端点的间隔，  而 1^..^2 不包含端点但是匹配任何在它俩之间的实数。</p>
<p>对于不同类型的数字参数， 范围会被强制为更宽的类型，所以：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> .. <span class="number">1.5</span></div></pre></td></tr></table></figure>
<p>被看作为：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.0</span> .. <span class="number">1.5</span></div></pre></td></tr></table></figure>
<p>这些强制由 multi 签名定义。（其它类型可能有不同的强制策略。）特别要说明的是， 使用 Range 作为末端是非法的：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span> ..^ <span class="number">10</span>  <span class="comment"># 0 .. 9</span></div><div class="line"><span class="number">0</span> .. ^<span class="number">10</span>  <span class="comment"># ERROR</span></div></pre></td></tr></table></figure>
<p>如果范围右侧是非数字类型， 那么右侧的参数被强转为数字， 然后按上面那样使用。</p>
<p>因此，第二个参数中的 Array 类型会被假定用作数字， 如果左侧的参数是数字的话：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span> ..^ @x    <span class="comment"># okay</span></div><div class="line"><span class="number">0</span> ..^ +@x   <span class="comment"># same thing</span></div></pre></td></tr></table></figure>
<p> 对于字符串也类似：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span> .. <span class="string">'1.5'</span>  <span class="comment"># okay</span></div><div class="line"><span class="number">0</span> .. +<span class="string">'1.5'</span> <span class="comment"># same thing</span></div></pre></td></tr></table></figure>
<p>Whatever 类型也支持代表 -Inf/+Inf。 如果端点之一是一个 WhateverCode, 那么范围会被引导为另一个 WhateverCode。</p>
<p>Range 对象支持代表它们的左侧和右侧参数的 .min 和 .max 方法。 .bounds 方法返回一个含有那两个值的列表以代表间隔。 Ranges 不会自动反转：</p>
<p>2..1 总是一个 null 范围。（然而， 序列操作符 .. 能够自动反转，看下面。）</p>
<p>在 Range 的每个端点处， Range 对象支持代表排除（有^）或包含（没有^）的 <code>.excludes_min</code> and <code>.excludes_max</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Range      | .min | .max | .excludes_min | .excludes_max</div><div class="line">-----------+------+------+---------------+------------</div><div class="line">1..10      | 1    | 10   | Bool::False   | Bool::False</div><div class="line">2.7..^9.3  | 2.7  | 9.3  | Bool::False   | Bool::True</div><div class="line">&apos;a&apos;^..&apos;z&apos;  | &apos;a&apos;  | &apos;z&apos;  | Bool::True    | Bool::False</div><div class="line">1^..^10    | 1    | 10   | Bool::True    | Bool::True</div></pre></td></tr></table></figure>
<p>如果用在列表上下文中， Range 对象返回一个迭代器， 它产生一个以最小值开头，以最大值结尾的序列。</p>
<p>任一端点可以使用 ^ 排除掉。因此 1..2 产生 (1,2) 但是 <code>1^..^2</code> 等价于 2..1 并不产生值， 就像 () 做的那样。要指定一个倒数的序列， 使用反转：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">reverse</span> <span class="number">1</span>..<span class="number">2</span></div><div class="line"><span class="keyword">reverse</span> <span class="string">'a'</span>..<span class="string">'z'</span></div></pre></td></tr></table></figure>
<p>作为选择， 对于数字序列， 你能使用序列操作符代替范围操作符：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">100</span>,<span class="number">99</span>,<span class="number">98</span> ... <span class="number">0</span></div><div class="line"><span class="number">100</span>, *-<span class="number">1</span> ... <span class="number">0</span>      <span class="comment"># same thing</span></div></pre></td></tr></table></figure>
<p>换句话说，任何用作列表的 Range 会假定 .succ 语义， 绝对不会是 <code>.pred</code> 语义。 没有其它的增量被允许；如果你想通过某个不是 1 的增量数字来增加一个数字序列，</p>
<p>你必须使用 … 序列操作符。（Range 操作符的 <code>:by</code> 副词因此被废弃了。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0, *+0.1 ... 100    # 0, 0.1, 0.2, 0.3 ... 100</div></pre></td></tr></table></figure>
<p>只有正念叨的类型支持 .succ 方法的 Range 才能被迭代。如果它不支持， 任何迭代尝试都会失败。</p>
<h2 id="一元区间"><a href="#一元区间" class="headerlink" title="一元区间"></a><a href="https://desgin.perl6.org/S03.html#Unary_ranges" target="_blank" rel="external">一元区间</a></h2><p>一元操作符 ^ 生成一个从 0 直到 其参数（不包括该参数）的区间。所以 ^4 等价于  0..^4.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for ^4 &#123; say $_ &#125; # 0, 1, 2, 3</div></pre></td></tr></table></figure>
<h2 id="范围的自动填充"><a href="#范围的自动填充" class="headerlink" title="范围的自动填充"></a><a href="https://desgin.perl6.org/S03.html#Auto-priming_of_ranges" target="_blank" rel="external">范围的自动填充</a></h2><p>[这一节是推断的，并且可能会在 6.0 中被忽略.]<br>因为在 item 上下文中 Range 对象通常是无意义的，用作标量操作符的 Range 对象一般会尝试把操作分配给终点并返回另外一个适当的修改过的 Range 代替。<br>很像两个项的连结(junction), 但是只使用合适的间隔语义。 (值得注意的这种自动线程化的例外包括 <code>infix:&lt;~~&gt;</code>, 它是做智能匹配的, 还有 <code>prefix:&lt;+&gt;</code>, 它返回范围的长度。) 因此如果你想使用长度而不是终点来做切片， 你可以这样说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@foo[ start() + ^$len ]</div></pre></td></tr></table></figure>
<p>它是下面这种形式的简写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@foo[ start() + (0..^$len) ]</div></pre></td></tr></table></figure>
<p>它有点等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@foo[ list do &#123; my $tmp = start(); $tmp ..^ $tmp+$len &#125; ]</div></pre></td></tr></table></figure>
<p>换句话说，数值化的操作符和其它有顺序的类型通常被重载以在 Range 身上完成某些有意义的事情。</p>
<h1 id="链式比较"><a href="#链式比较" class="headerlink" title="链式比较"></a><a href="https://desgin.perl6.org/S03.html#Chained_comparisons" target="_blank" rel="external">链式比较</a></h1><p><a href="https://github.com/perl6/roast/blob/master/S03-operators/relational.t#L102-L238" target="_blank" rel="external">S03-operators/relational.t lines 102–238</a>  </p>
<p>Perl 6 支持比较操作符的自然扩展, 它允许多个操作数:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="number">1</span> &lt; $a &lt; <span class="number">100</span>                        &#123; <span class="keyword">say</span> <span class="string">"Good, you picked a number *between* 1 and 100."</span> &#125;</div><div class="line"><span class="keyword">if</span> <span class="number">3</span> &lt; $roll &lt;= <span class="number">6</span>                      &#123; <span class="keyword">print</span> <span class="string">"High roll"</span>  &#125;</div><div class="line"><span class="keyword">if</span> <span class="number">1</span> &lt;= $roll1 == $roll2 &lt;= <span class="number">6</span>          &#123; <span class="keyword">print</span> <span class="string">"Doubles!"</span>   &#125;</div></pre></td></tr></table></figure>
<p>如果第一个比较失败了则产生比较短路链:</p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-operators/short-circuit.t#L236-L297" target="_blank" rel="external">S03-operators/short-circuit.t lines 236–297</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 &gt; 2 &gt; die(&quot;this is never reached&quot;);</div></pre></td></tr></table></figure>
<p>链子中得每个参数至多会被求值一次:</p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-operators/short-circuit.t#L226-L235" target="_blank" rel="external">S03-operators/short-circuit.t lines 226–235</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 &gt; $x++ &gt; 2    # $x 只精确地增长一次</div></pre></td></tr></table></figure>
<p>注意: 任何以  <em>&lt;</em> 开头的操作符必须在前面拥有空格，否则它会被解释为散列的下标。</p>
<h1 id="调用者标记"><a href="#调用者标记" class="headerlink" title="调用者标记"></a><a href="https://desgin.perl6.org/S03.html#Invocant_marker" target="_blank" rel="external">调用者标记</a></h1><p>当使用 Perl 6 方法调用的「间接对象」语法时追加的 <code>:</code> 标记了调用者(invocant)。下面的两个语句是等价的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$hacker.feed(&apos;Pizza and cola&apos;);</div><div class="line">feed $hacker: &apos;Pizza and cola&apos;;</div></pre></td></tr></table></figure>
<p>冒号也可以用在普通方法调用中以标示它应该被解析为列表操作符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$hacker.feed: &apos;Pizza and cola&apos;;</div></pre></td></tr></table></figure>
<p>这个冒号是一个单独的令牌(token)。副词前面的冒号不是单独的令牌(token)。因此，在最长令牌(longest-token)规则下,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$hacker.feed:xxx(&apos;Pizza and cola&apos;);</div></pre></td></tr></table></figure>
<p>被标记为应用到方法上作为它的「最高层级的在前面的操作符」(“toplevel preceding operator”)的副词:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$hacker.feed :xxx(&apos;Pizza and cola&apos;);</div></pre></td></tr></table></figure>
<p>不是作为 <code>.feed</code> 参数列表中的 xxx sub:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$hacker.feed: xxx(&apos;Pizza and cola&apos;);  # wrong</div></pre></td></tr></table></figure>
<p>如果你两种意义的冒号你都想要，为了既提供副词又提供某种位置参数, 你必须放置两次冒号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$hacker.feed: :xxx(&apos;Pizza and cola&apos;), 1,2,3;</div></pre></td></tr></table></figure>
<p>(因为类型的原因它需要把空格放在标签的冒号之后。)</p>
<p>要特别注意因为副词的优先级:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 + $hacker.feed :xxx(&apos;Pizza and cola&apos;);</div></pre></td></tr></table></figure>
<p>会把 <code>:xxx</code> 副词应用到 <code>+</code> 操作符上, 而不是应用到方法调用上。这是不可能成功的。</p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-operators/adverbial-modifiers.t#L7-L201" target="_blank" rel="external">S03-operators/adverbial-modifiers.t lines 7–201</a></p>
<h1 id="流操作符"><a href="#流操作符" class="headerlink" title="流操作符"></a><a href="https://desgin.perl6.org/S03.html#Feed_operators" target="_blank" rel="external">流操作符</a></h1><p>S03-feeds/basic.t lines 6–163  </p>
<p>新的操作符 <code>==&gt;</code> 和 <code>&lt;==</code> 就像Unix里的管道一样，但是它作用于函数或语句，接受并返回列表.因为这些列表由不相关联的对象组成并不流动， 我们把它们叫做喂食（feed）操作符而非管道。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@result = map &#123; floor($^x / 2) &#125;,</div><div class="line">         grep &#123; /^ \d+ $/      &#125;,</div><div class="line">         @data;</div></pre></td></tr></table></figure>
<p>也能写成向右偏的流操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@data ==&gt; grep &#123; /^ \d+ $/       &#125;</div><div class="line">      ==&gt; map  &#123; floor($^x / 2)  &#125;</div><div class="line">      ==&gt; @result;</div></pre></td></tr></table></figure>
<p>或者使用左方向的流操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@result &lt;== map &#123; floor($^x / 2) &#125;</div><div class="line">        &lt;== grep &#123; /^ \d+ $/     &#125;</div><div class="line">        &lt;== @data;</div></pre></td></tr></table></figure>
<p>每一种形式更清晰地表明了数据的流动。查看 <a href="http://design.perl6.org/S06.html" target="_blank" rel="external">S06</a>  了解更多关于这两个操作符的信息。</p>
<h1 id="元操作符"><a href="#元操作符" class="headerlink" title="元操作符"></a><a href="https://desgin.perl6.org/S03.html#Meta_operators" target="_blank" rel="external">元操作符</a></h1><p>Perl 6 的操作符被极大地规范化了，例如，通过分别在数字、字符串和布尔操作符前前置 <code>+</code>、<code>~</code>、<code>?</code> 来表明按位操作是作用在数字、字符串还是单个位身上。但是那只是一种命名约定，并且如果你想添加一个新的按位 <code>¬</code> 操作符， 你必须自己添加  <code>+¬</code>, <code>~¬</code>, 和 <code>?¬</code> 操作符。 类似地，范围中排除末端的脱字符(<code>^</code>)在那里只是约定而已。</p>
<p>和它相比， Perl 6 有 8 个标准的元操作符用于把已存在的给定操作符转换为相关的更强大的操作符（或者至少不是一般的强大）。换句话说，这些元操作符正是高阶函数（以其它函数作为参数的函数）的便捷形式。</p>
<p>包含元操作符的结构被认为是 “metatokens”， 这意味着它们不受普通匹配规则的制约， 尽管它们的部件受制约。 然而，像普通的 tokens 那样， metatokens 不允许在它们的子部件之间有空格。</p>
<h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><p>S03-operators/autovivification.t lines 4–111  </p>
<p>C 和 Perl 程序员对于赋值操作符已经司空见惯了。（尽管 .= 操作符现在意味着在左边对象的身上调用一个可变方法， ~= 是字符串连结。）</p>
<p>大部分非关系中缀操作符能通过后缀 = 被转换为对应的赋值操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A op= B;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A = A op B;</div></pre></td></tr></table></figure>
<h2 id="否定关系操作符"><a href="#否定关系操作符" class="headerlink" title="否定关系操作符"></a>否定关系操作符</h2><p>任何能返回 Bool 值的中缀关系操作符都可以通过前置一个 <code>!</code> 将它转换为否定的关系操作符。有几个关系操作符还有传统的便捷写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Full form   Shortcut</div><div class="line">---------   --------</div><div class="line">!==         !=</div><div class="line">!eq         ne</div></pre></td></tr></table></figure>
<p>但是大部分关系操作符没有传统的便捷写法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">!~~</div><div class="line">!&lt;</div><div class="line">!&gt;=</div><div class="line">!ge</div><div class="line">!===</div><div class="line">!eqv</div><div class="line">!=:=</div></pre></td></tr></table></figure>
<p>为了避免 <code>!!</code> 操作符迷惑视线， 你不可以修改任何已经以<code>!</code> 开头的操作符。</p>
<p>否定操作符的优先级和基（base）操作符的优先级相同。</p>
<p>你只可以否定那些返回 Bool 值的操作符。 注意诸如 <code>||</code> 和 <code>^^</code> 的逻辑操作符不返回 Bool 值， 而是返回其中之一的操作数。</p>
<h2 id="翻转操作符"><a href="#翻转操作符" class="headerlink" title="翻转操作符"></a>翻转操作符</h2><p>在任意中缀操作符上前置一个 R，会翻转它的两个参数。例如，反向比较：</p>
<ul>
<li>Rcmp</li>
<li>Rleg</li>
<li>R&lt;=&gt;</li>
</ul>
<p>任何翻转操作符的优先级和根操作符的优先级是一样的。结合性没有被翻转。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[R-] <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>   <span class="comment"># produces 2 from 3 - (2 - 1)</span></div></pre></td></tr></table></figure>
<p>要得到另外一种效果，可以先翻转列表：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[-] <span class="keyword">reverse</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>  <span class="comment"># produces 0</span></div></pre></td></tr></table></figure>
<h2 id="超运算符"><a href="#超运算符" class="headerlink" title="超运算符"></a>超运算符</h2><p>Unicode 字符  <code>»</code> (\x[BB]) 和 <code>«</code> (\x[AB]) 和它们的 ASCII连字 <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> 用于表示<code>列表操作</code>, 它作用于列表中的每个元素, 然后返回单个列表(或数组)作为结果. 换句话说,  超运算符在 item 上下文中计算它的参数, 但是随后将操作符分派到每个参数身上，结果作为列表返回。</p>
<p>当书写超运算符时， 里面不允许出现空格， 即， 两个 “hyper” 标记之间不能有空格， 并且该操作符是能修改参数的。 在外面空格策略和它的 base 操作符相同。 同样地， 超运算符的优先级和它的 base 操作符相同。 这意味着对于大部分操作符，你必须使用圆括号括起你使用逗号分割的列表。。</p>
<p>例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-« (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);                   <span class="comment"># (-1, -2, -3)</span></div><div class="line">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>) »+« (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>);  <span class="comment"># (2,3,5,8,13)，尖括号都朝内时，两边列表元素的个数必须相同</span></div></pre></td></tr></table></figure>
<p>（如果你发现你自己这样做了， 问问你自己是否真的在使用对象或列表； 在后一种情况中， 可能其它的诸如 Z 或 X 的元操作符更合适， 并且不需要括号）</p>
<p>一元超运算符（要么前缀，要么后缀）只有一个 hyper 标记， 位于它的参数那边， 而中缀操作符通常在参数的每一边以表明有两个参数。</p>
<h3 id="一元超运算符"><a href="#一元超运算符" class="headerlink" title="一元超运算符"></a>一元超运算符</h3><p>一元超运算符的意思取决于操作符是否是结构非关联的操作符。 大部分操作符不是结构的。</p>
<p>对于中缀操作符，如果两者其中之一的一个参数的长度不够，那么 Perl 会「提高」它，但是只有你把 hyper 标记「尖」的那一端指向它时，Perl 才会提升长度不够的那一端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(3,8,2,9,3,8) &gt;&gt;-&gt;&gt; 1;          # (2,7,1,8,2,7)</div><div class="line">@array »+=» 42;                 # add 42 to each element</div></pre></td></tr></table></figure>
<p>实际上，对于一个无序的诸如 Bag 的类型来说，一个提升过的标量是唯一能工作于该类型中的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bag(3,8,2,9,3,8) &gt;&gt;-&gt;&gt; 1;       # Bag(2,7,1,8,2,7) === Bag(1,2,2,7,7,8)</div><div class="line"># Cannot modify an immutable Bag</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;  Bag(3,8,2,9,3,8)  # Bag 的用法以改变</div><div class="line">bag(9, 8(2), 3(2), 2)</div></pre></td></tr></table></figure>
<p>换句话说，把小于号那端指向一个参数告诉超运算符在那边做我想要做的(dwim, do what i means)。如果你不知道一边或是另一边会是 underdimensioned，那么你可以在两边都做我想做的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$left «*» $right</div></pre></td></tr></table></figure>
<p>注意：如果你担心 Perl 会被像这样的东西所迷惑：Note: if you are worried about Perl getting confused by something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func «*»</div></pre></td></tr></table></figure>
<p>那么你无需担心，因为不想之前的版本， Perl 6 从来不会猜测下一个东西是一个项(term)还是一个操作符。在这种情况下，它总是期望一个项除非 func 被预先定义为一个类型或值的名字。<br>升级绝对不会发生在 hyper 的「钝」的那一端上。如果你这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$bigger «*« $smaller</div><div class="line">$smaller »*» $bigger</div></pre></td></tr></table></figure>
<p>那么会抛出异常，而如果你这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$foo »*« $bar</div></pre></td></tr></table></figure>
<p>那么你要求形状的两边是一样长的，否则会抛出异常。</p>
<p>对于所有 hyper dwimminess，如果运算符的另一边期望列表的地方出现的是一个标量，那么那个标量会被当做一个重复了 <code>*</code> 次的那个元素的列表。</p>
<p>一旦我们有两个列表要处理，那么我们不得不决定使两边的元素长度相一致。如果两边都是 dwimmy，那么较短的那个列表会重复尽可能多的次数以使元素的个数合适。</p>
<p>如果只有一边是 dwimmy，那么那一端的列表只会被增长或截断以适应另一边的 non-dwimmy 的那个列表。</p>
<p>不管从数组的形状的 dwim 是强制的还是自然发生的，一旦选择了 dwim 的那一端，在 dwimmy 端的 dwim 语义总是：</p>
<p>下面是一些例子:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) »+« (<span class="number">1</span>,<span class="number">2</span>)    <span class="comment"># always error，尖括号都朝内时，两边元素必须个数相同</span></div><div class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) «+» (<span class="number">1</span>,<span class="number">2</span>)    <span class="comment"># 2,4,4,6     rhs dwims to 1,2,1,2</span></div><div class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   «+» (<span class="number">1</span>,<span class="number">2</span>)    <span class="comment"># 2,4,4       rhs dwims to 1,2,1</span></div><div class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) «+« (<span class="number">1</span>,<span class="number">2</span>)    <span class="comment"># 2,4         lhs dwims to 1,2</span></div><div class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) »+» (<span class="number">1</span>,<span class="number">2</span>)    <span class="comment"># 2,4,4,6     rhs dwims to 1,2,1,2</span></div><div class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   »+» (<span class="number">1</span>,<span class="number">2</span>)    <span class="comment"># 2,4,4       rhs dwims to 1,2,1</span></div><div class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   »+» <span class="number">1</span>        <span class="comment"># 2,3,4       rhs dwims to 1,1,1</span></div></pre></td></tr></table></figure>
<p>当使用<code>一元</code>操作符时, 你总是把钝的那端对准单个运算对象, 因为没有出现重复的东西:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@negatives = -« @positives;</div><div class="line">@positions»++;            <span class="comment"># Increment all positions</span></div><div class="line">@positions.»++;           <span class="comment"># Same thing, dot form</span></div><div class="line">@positions».++;           <span class="comment"># Same thing, dot form 报错</span></div><div class="line">@positions.».++;          <span class="comment"># Same thing, dot form</span></div><div class="line">@positions\  .»\  .++;    <span class="comment"># Same thing, unspace form</span></div><div class="line">@objects.».run();</div><div class="line">(<span class="string">"f"</span>,<span class="string">"oo"</span>,<span class="string">"bar"</span>).».chars; <span class="comment"># (1,2,3)</span></div></pre></td></tr></table></figure>
<p>注意方法调用实际上是后缀操作符, 而非中缀操作符, 所以,  你不能在点号后面放上一个 <code>«</code></p>
<p>超运算符在嵌套数组中是被递归地定义的， 所以：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-« [[<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>]              <span class="comment">#    [-«[1, 2], -«3] 得到 -1 -2 -3</span></div><div class="line">                            <span class="comment"># == [[-1, -2], -3]</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[1, 2], 3] «+» [4, [5, 6]]  #    [[1,2] «+» 4, 3 «+» [5, 6]]，得到 5 6 8 9</div><div class="line">                             # == [[5, 6], [8, 9]]</div></pre></td></tr></table></figure>
<p>超运算符也能作用于散列，就像作用于数组一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%foo «+» %bar;</div></pre></td></tr></table></figure>
<p>得到两个键的交集（对应的键值相加）</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span> %foo = <span class="string">"Tom"</span> =&gt; <span class="number">98</span>, <span class="string">"Larry"</span> =&gt; <span class="number">100</span>, <span class="string">"Bob"</span> =&gt; <span class="string">"49"</span>;</div><div class="line">(<span class="string">"Tom"</span> =&gt; <span class="number">98</span>, <span class="string">"Larry"</span> =&gt; <span class="number">100</span>, <span class="string">"Bob"</span> =&gt; <span class="string">"49"</span>).hash</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span> %bar = <span class="string">"Tom"</span> =&gt; <span class="number">98</span>, <span class="string">"Larry"</span> =&gt; <span class="number">100</span>, <span class="string">"Vivo"</span> =&gt; <span class="number">86</span></div><div class="line">(<span class="string">"Tom"</span> =&gt; <span class="number">98</span>, <span class="string">"Larry"</span> =&gt; <span class="number">100</span>, <span class="string">"Vivo"</span> =&gt; <span class="number">86</span>).hash</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; %foo «+» %bar</div><div class="line">(<span class="string">"Tom"</span> =&gt; <span class="number">196</span>, <span class="string">"Larry"</span> =&gt; <span class="number">200</span>).hash</div></pre></td></tr></table></figure>
<p>而：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;  %foo »+« %bar;</div><div class="line">(<span class="string">"Tom"</span> =&gt; <span class="number">196</span>, <span class="string">"Larry"</span> =&gt; <span class="number">200</span>, <span class="string">"Bob"</span> =&gt; <span class="number">49</span>, <span class="string">"Vivo"</span> =&gt; <span class="number">86</span>).hash</div></pre></td></tr></table></figure>
<p>得到两个键的并集（键值相加）</p>
<p>不对称的 hypers 也有用; 例如， 如果你说：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%outer »+» %inner;</div></pre></td></tr></table></figure>
<p>只有在 %outer 中已经存在的 %inner 键才会出现在结果中.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span> %inner = <span class="string">"a"</span> =&gt; <span class="number">11</span>;</div><div class="line">&gt; <span class="keyword">my</span> %outer = <span class="string">"a"</span> =&gt; <span class="number">9</span>, <span class="string">"b"</span> =&gt; <span class="number">12</span>;</div><div class="line">&gt; %outer »+» %inner <span class="comment"># a =&gt; 20, b =&gt; 12</span></div></pre></td></tr></table></figure>
<p>然而，</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%outer »+=« %inner;</div></pre></td></tr></table></figure>
<p>假设你想让 %outer 拥有键的并集，累加键值</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span> %inner = <span class="string">"a"</span> =&gt; <span class="number">11</span>;</div><div class="line">&gt; <span class="keyword">my</span> %outer = <span class="string">"a"</span> =&gt; <span class="number">9</span>, <span class="string">"b"</span> =&gt; <span class="number">12</span>;</div><div class="line">&gt; %outer »+=« %inner;  <span class="comment"># a =&gt; 20, b =&gt; 12</span></div><div class="line">&gt; <span class="keyword">say</span> %outer           <span class="comment"># a =&gt; 20, b =&gt; 12</span></div><div class="line">&gt; <span class="keyword">say</span> %inner           <span class="comment"># a =&gt; 11</span></div></pre></td></tr></table></figure>
<p>注意， hypers 允诺你不必关心处理以怎样的顺序发生，只保证结果的结构和输入的形式保持一致。从系统角度也不能保证操作是并行化的。</p>
<p>高效的并行化要求某种程度的不带更多额外工作的工作分割，系统被允许平衡并行处理的惰性需求。</p>
<p>例如， 一个算法想把一个列表分成2个等长的子列表是不会起作用的， 如果你不得不提前计算好列表长度， 因为你不是总能计算出长度。可以采取各种方法：</p>
<p>按需切换要并行处理的群组， 或交错循环地使用一组 N 个核心的处理器，或任何东西。在该限制下， 一个简单、非并行、逐项的惰性实现就在 sepc 之中了，但是不太可能高效的使用多核。‘</p>
<p>不考虑性能要求，如果算法依赖于这些采用的方法， 那也是错误的。</p>
<h2 id="Reduction-操作符"><a href="#Reduction-操作符" class="headerlink" title="Reduction 操作符"></a>Reduction 操作符</h2><p>任何中缀操作符（除了 non-associating 操作符）都可以在 term 位置处被方括号围住， 以创建使用使用该操作符进行换算的列表操作符：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[+] <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;      <span class="comment"># 1 + 2 + 3 = 6</span></div><div class="line"><span class="keyword">my</span> @a = (<span class="number">5</span>,<span class="number">6</span>);</div><div class="line">[*] @a;           <span class="comment"># 5 * 6 = 30</span></div></pre></td></tr></table></figure>
<p>对于所有的元操作符来说,  在 <code>metatoken</code> 里面是不允许有空格的.</p>
<p>换算操作符和列表前缀的优先级相同。 实际上， 换算操作符就是一个列表前缀，被当作一个操作符来调用。因此， 你可以以两种方式的任何一种来实现换算操作符。要么你也能写一个显式的列表操作符：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">multi prefix:&lt;[+]&gt; (*@args) is default &#123;</div><div class="line">    <span class="keyword">my</span> $accum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (@args) &#123;</div><div class="line">        $accum += @args.shift();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $accum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者你能让系统根据对应的中缀操作符为你自动生成一个：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&amp;prefix:&lt;[*]&gt;  ::= &amp;reduce.assuming(&amp;infix:&lt;*&gt;, <span class="number">1</span>);</div><div class="line">&amp;prefix:&lt;[**]&gt; ::= &amp;reducerev.assuming(&amp;infix:&lt;**&gt;);</div></pre></td></tr></table></figure>
<p>如果换算操作符和中缀操作符的定义是独立的， 那换算操作符和该操作符的结合性要相同：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[-] <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>;      <span class="comment"># 4-3-2 = (4-3)-2 = -1</span></div><div class="line">[**] <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>;     <span class="comment"># 4**3**2 = 4**(3**2) = 262144</span></div></pre></td></tr></table></figure>
<p>对于  list-associative 操作符（优先级表中的 X），实现必须把参数的 listiness 考虑在内； 即，如果重复地应用一个二元版本的操作符会产生错误的结果，那么它就不会被那样实现。 例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[^^] $a, $b, $c;  <span class="comment"># means ($a ^^ $b ^^ $c), NOT (($a ^^ $b) ^^ $c)</span></div></pre></td></tr></table></figure>
<p>对于 chain-associative 操作符（像 &lt;）， 所有的参数被一块儿接收， 就像你显式地写出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&lt;] 1, 3, 5;      # 1 &lt; 3 &lt; 5</div></pre></td></tr></table></figure>
<p>对于列表中缀操作符， 输入列表不会被展平， 以至于多个 parcels 可以以逗号分割形式的参数传递进来：  </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[X~] (<span class="number">1</span>,<span class="number">2</span>), &lt;a b&gt;;  <span class="comment"># 1,2 X~ &lt;a b&gt;</span></div></pre></td></tr></table></figure>
<p>如果给定的参数少于 2 个， 仍然会用给定的参数尝试分派， 并根据那个分派的接受者来处理少于 2 个参数的情况。 注意，默认的列表操作符签名是最通用的， 所以， 你被允许根据类型去定义不同的方式处理单个参数的情况：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">multi prefix:&lt;[foo]&gt; (Int $x) &#123; <span class="number">42</span> &#125;</div><div class="line">multi prefix:&lt;[foo]&gt; (Str $x) &#123; fail <span class="string">"Can't foo a single Str"</span> &#125;</div></pre></td></tr></table></figure>
<p>然而， 0 参数的情况不能使用这种方式定义， 因为没有类型信息用于分派。操作符要想指定一个同一值应该通过指定一个接收 0 个参数的 multi 变体来实现这：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi prefix:&lt;[foo]&gt; () &#123; <span class="number">0</span> &#125;</div></pre></td></tr></table></figure>
<p>在内建操作符中，举个例子，  <code>[+]()</code> 返回 0 ， <code>[*]()</code> 返回 1 。</p>
<p>默认地， 如果有一个参数， 内建的换算操作符就返回那个参数。 然而， 这种默认对于像 <code>&lt;</code> 那样返回类型和接收参数不同的操作符没有效果，所以这种类型的操作符重载了单个参数的情况来返回更有意义的东西。为了和链式语义保持一致， 所有的比较操作符都对于 1 个或 0 个参数返回 Bool::True。</p>
<p>你也可以搞一个逗号操作符的换算操作符。 这正是 <code>circumfix:&lt;[ ]&gt;</code> 匿名数组构建器的列表操作符形式：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]     <span class="comment"># make new Array: 1,2,3</span></div><div class="line">[,] <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>   <span class="comment">#  与上相同</span></div></pre></td></tr></table></figure>
<p>内置换算操作符返回下面的同一值：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">[**]()      <span class="comment"># 1     (arguably nonsensical)</span></div><div class="line">[*]()       <span class="comment"># 1</span></div><div class="line">[<span class="regexp">/]()       # fail  (换算没有意义)</span></div><div class="line">[%]()       # fail  (换算没有意义)</div><div class="line">[x]()       # fail  (换算没有意义)</div><div class="line">[xx]()      # fail  (换算没有意义)</div><div class="line">[+&amp;]()      # -1    (from +^0, the 2's complement in arbitrary precision)</div><div class="line">[+&lt;]()      # fail  (换算没有意义)</div><div class="line">[+&gt;]()      # fail  (换算没有意义)</div><div class="line">[~&amp;]()      # fail  (sensical but 1's length indeterminate)</div><div class="line">[~&lt;]()      # fail  (换算没有意义)</div><div class="line">[~&gt;]()      # fail  (换算没有意义)</div><div class="line">[+]()       # 0</div><div class="line">[-]()       # 0</div><div class="line">[~]()       # ''</div><div class="line">[+|]()      # 0</div><div class="line">[+^]()      # 0</div><div class="line">[~|]()      # ''    (length indeterminate but 0's default)</div><div class="line">[~^]()      # ''    (length indeterminate but 0's default)</div><div class="line">[&amp;]()       # all()</div><div class="line">[|]()       # any()</div><div class="line">[^]()       # one()</div><div class="line">[!==]()     # Bool::True    (also for 1 arg)</div><div class="line">[==]()      # Bool::True    (also for 1 arg)</div><div class="line">[before]()  # Bool::True    (also for 1 arg)</div><div class="line">[after]()   # Bool::True    (also for 1 arg)</div><div class="line">[&lt;]()       # Bool::True    (also for 1 arg)</div><div class="line">[&lt;=]()      # Bool::True    (also for 1 arg)</div><div class="line">[&gt;]()       # Bool::True    (also for 1 arg)</div><div class="line">[&gt;=]()      # Bool::True    (also for 1 arg)</div><div class="line">[~~]()      # Bool::True    (also for 1 arg)</div><div class="line">[!~~]()     # Bool::True    (also for 1 arg)</div><div class="line">[eq]()      # Bool::True    (also for 1 arg)</div><div class="line">[!eq]()     # Bool::True    (also for 1 arg)</div><div class="line">[lt]()      # Bool::True    (also for 1 arg)</div><div class="line">[le]()      # Bool::True    (also for 1 arg)</div><div class="line">[gt]()      # Bool::True    (also for 1 arg)</div><div class="line">[ge]()      # Bool::True    (also for 1 arg)</div><div class="line">[=:=]()     # Bool::True    (also for 1 arg)</div><div class="line">[!=:=]()    # Bool::True    (also for 1 arg)</div><div class="line">[===]()     # Bool::True    (also for 1 arg)</div><div class="line">[!===]()    # Bool::True    (also for 1 arg)</div><div class="line">[eqv]()     # Bool::True    (also for 1 arg)</div><div class="line">[!eqv]()    # Bool::True    (also for 1 arg)</div><div class="line">[&amp;&amp;]()      # Bool::True</div><div class="line">[||]()      # Bool::False</div><div class="line">[^^]()      # Bool::False</div><div class="line">[/<span class="regexp">/]()      # Any</span></div><div class="line">[min]()     # +Inf</div><div class="line">[max]()     # -Inf</div><div class="line">[=]()       # Nil    (same for all assignment operators)</div><div class="line">[,]()       # []</div><div class="line">[Z]()       # []</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[=] $x, @y, $z, 0</div><div class="line">[+=] $x, @y, $z, 1</div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$x = @y[0] = @y[1] = @y[2] ... @y[*-1] = $z = 0</div><div class="line">$x += @y[0] += @y[1] += @y[2] ... @y[*-1] += $z += 1</div></pre></td></tr></table></figure>
<p>而不是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$x = @y = $z = 0;</div><div class="line">$x += @y += $z += 1;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my :($b, $c);               # okay</div><div class="line">sub foo :($a,$b) &#123;...&#125;      # okay</div></pre></td></tr></table></figure>
<p> <code>-&gt;</code> “pointy block” token 也引入签名, 但是这种情况你必须省略冒号和括号. 例如, 如果你在定义 loop block 的 “循环变量”:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> @dogpound -&gt; Dog $fido &#123; ... &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$foo.bar.baz.bletch.whatever.attr[] = 1,2,3;</div></pre></td></tr></table></figure>
<p>空的 [] 和 .[] 后缀操作符被解释为 0 维下标, 这返回整个数组, 不是作为一个一维的空切片, 返回空元素.  这同样适用于散列上的  {} 和 .{} , 还有  <code>&lt;&gt;</code>, <code>.&lt;&gt;</code>,<code>«»</code>, 和 <code>.«»</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的-Bailador-Web-框架(简介)]]></title>
      <url>http://ohmycloud.github.io/2016/03/20/Perl6%E4%B8%AD%E7%9A%84BailadorWeb%E6%A1%86%E6%9E%B6-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="开始-Bailador"><a href="#开始-Bailador" class="headerlink" title="开始 Bailador"></a>开始 Bailador</h1><p><a href="https://github.com/tadzik/Bailador/" target="_blank" rel="external">Bailador</a> 是对 <a href="http://perldancer.org/" target="_blank" rel="external">Perl Dancer</a> Web 开发框架的模仿。<br>安装方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">panda install Bailador</div><div class="line"># or</div><div class="line">zef install Bailador</div></pre></td></tr></table></figure>
<p>我们来创建一个脚本 <strong>first.pl</strong>，打印 “hello world”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use Bailador;</div><div class="line"></div><div class="line">get &apos;/&apos; =&gt; sub &#123;</div><div class="line">    &quot;hello world&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">baile;</div></pre></td></tr></table></figure>
<p>运行：perl6 first.pl 它会启动一个小型的 Web 服务器，你可以在3000端口上访问它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 first.pl</div><div class="line">Entering the development dance floor: http://0.0.0.0:3000</div><div class="line">[2016-05-05T12:57:31Z] Started HTTP server.</div></pre></td></tr></table></figure>
<p>在 Bailador 中，我们需要把 <strong>HTTP</strong> 请求方法和服务器上的路径映射给一个匿名子例程, 这个子例程会返回它里面的内容。在这个例子中，我们把我们告诉它的网站根路径的 <strong>get</strong> HTTP 请求映射为返回字符串 <strong>hello world</strong>。如果你启动这个程序并用浏览器打开 <a href="http://0.0.0.0:3000/" target="_blank" rel="external">http://0.0.0.0:3000/</a> 你就会看到这个文本。</p>
<p>我们还可以映射其它路径(path-es):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get &apos;/about&apos; =&gt; sub &#123;</div><div class="line">    &quot;关于我&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这会把 <a href="http://0.0.0.0:3000/about" target="_blank" rel="external"> http://0.0.0.0:3000/about</a> url 映射为返回 「关于我」。</p>
<h2 id="路径中的占位符"><a href="#路径中的占位符" class="headerlink" title="路径中的占位符"></a>路径中的占位符</h2><p>路径中的一部分可以是以冒号开头的占位符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get &apos;/hello/:name&apos; =&gt; sub ($name) &#123;</div><div class="line">    &quot;Hello $name!&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>:name</strong> 部分能匹配除了斜线 <strong>/</strong> 之外的任何字符串，并且它所匹配到的值会被赋值给匿名子例程中的 <strong>$name</strong> 变量。</p>
<p>这样的占位符你可以拥有多个，并且占位符的实际名字是什么无关紧要。占位符所捕获到的值会按照它们出现在 url 中的顺序赋值给函数的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get &apos;/hello/:first/:family&apos; =&gt; sub ($fname, $lname) &#123;</div><div class="line">    &quot;Hello $fname! And hi $lname&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在这个例子中，无论 <strong>:first</strong> 占位符捕获到的是什么，它都会被赋值给 <strong>$fname</strong> 参数，无论 <strong>:family</strong> 捕获到的是什么，它都会被赋值给 <strong>:$lname</strong>。例如 url <a href="http://0.0.0.0:3000/hello/Foo/Bar" target="_blank" rel="external">http://0.0.0.0:3000/hello/Foo/Bar</a> 会生成如下响应:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello Foo! And hi Bar!</div></pre></td></tr></table></figure>
<p>当然，让占位符的名字和参数的名字相同可能会让代码更易读。这是第二个脚本的完整版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use Bailador;</div><div class="line"></div><div class="line">get &apos;/&apos; =&gt; sub &#123;</div><div class="line">    &quot;hello world&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">get &apos;/hello/:first/:family&apos; =&gt; sub ($fname, $lname) &#123;</div><div class="line">    &quot;Hello $fname! And hi $lname&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">baile;</div></pre></td></tr></table></figure>
<h1 id="使用-Bailador-回显文本"><a href="#使用-Bailador-回显文本" class="headerlink" title="使用 Bailador 回显文本"></a>使用 Bailador 回显文本</h1><p>我们来看看怎么从用户那儿接收输入并把输入回显给用户。</p>
<h2 id="使用-POST-回显"><a href="#使用-POST-回显" class="headerlink" title="使用 POST 回显"></a>使用 POST 回显</h2><p>对于这，我们必须创建两个路由(routes)因为现在 Bailador 还不能处理 GET 参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># echo_post.p6</div><div class="line"></div><div class="line">use v6;</div><div class="line">use Bailador;</div><div class="line"></div><div class="line">get &apos;/&apos; =&gt; sub &#123;</div><div class="line">	&apos;&lt;form method=&quot;POST&quot; action=&quot;/echo&quot;&gt;&lt;input name=&quot;text&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">post &apos;/echo&apos; =&gt; sub &#123;</div><div class="line">  my $text = request.params&lt;text&gt; // &apos;&apos;;</div><div class="line">	my $html = &apos;You said (in a POST request) &apos;;</div><div class="line">	$html ~= $text;</div><div class="line">	return $html;</div><div class="line">&#125;</div><div class="line"></div><div class="line">baile;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-569a4158b27cc4d0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>我们能看到怎么创建一个路由来处理 POST 请求。</p>
<p>第一个路由 <strong>get ‘/‘ =&gt; {</strong> 会发送一个 <strong>GET</strong> 请求并且它会返回一个包含在这个脚本中的 HTML 片段。(我知道，我们很快就会使用模板了) 那个 HTML 片段包含了一个带有单个文本框的表单和一个提交按钮。这个表单有一个通向 <strong>/echo</strong> URL 的 <strong>action</strong>，并且表单拥有 <strong>method=”POST”</strong>。这意味着，当用户点击提交按钮时，浏览器会发送回 POST 请求。</p>
<p>第二个路由 <strong>post ‘/echo’ =&gt; sub {</strong> 会处理 <strong>/echo</strong> 路径的 POST 请求。</p>
<p>Bailador 提供的 <strong>request</strong> 函数以 <a href="https://github.com/tadzik/Bailador/blob/master/lib/Bailador/Request.pm" target="_blank" rel="external">Bailador::Request</a>的形式返回代表当前请求的对象。</p>
<p><strong>request</strong> 函数有几个方法，其中一个是 <strong>params</strong> 方法，它返回一个散列，其中散列的键是参数的名字（在我们这个例子中是 <strong>text</strong>），值是提交的值。</p>
<p>我们把那个值保存在 <strong>$text</strong> 变量中，并且我们使用 ‘//‘ defined-or 操作符来设置变量的值为空，在用户没有提供任何值的情况下。然后我们连接用户提供的值组成 “html” 字符串。最后发送回那个字符串，我们这个小小的回显服务器就能工作啦。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-d07297442a570b93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h2 id="使用-GET-回显"><a href="#使用-GET-回显" class="headerlink" title="使用 GET 回显"></a>使用 GET 回显</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use Bailador;</div><div class="line"></div><div class="line">get &apos;/&apos; =&gt; sub &#123;</div><div class="line">	&apos;&lt;form method=&quot;GET&quot;  action=&quot;/echo&quot;&gt;&lt;input name=&quot;text&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">get &apos;/echo&apos; =&gt; sub &#123;</div><div class="line">    return &apos;You said (in a GET request) &apos; ~ (request.params&lt;text&gt; // &apos;&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">baile;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-399effeb8572bf83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>在这个例子中，我省略了临时变量 <strong>$text</strong> 和 <strong>$html</strong>，在之前的例子中它们也不是必要的。当我们使用 <strong>GET</strong> 方法请求后，提交后回在浏览器的 URL 地址栏中拼接上我们的 text 字段和字段的值。</p>
<h1 id="Bailador-Application-in-a-module"><a href="#Bailador-Application-in-a-module" class="headerlink" title="Bailador Application in a module"></a>Bailador Application in a module</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>在下面这个模板中，它把数据接收到变量 <code>$h</code> 中，之后使用这个变量来展示版本号和当前时间 - 从纪元开始的秒数。<br><em>bailador/code_in_module/views/index.tt</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">% my ($h) = @_;</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;Bailador App&lt;/title&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=yes&quot;&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;h1&gt;Bailador App&lt;/h1&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">      Version &lt;%= $h&lt;version&gt; %&gt; Current time: &lt;%= $h&lt;date&gt; %&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>这个文件把所有代码包含在类中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unit class Demo;</div></pre></td></tr></table></figure>
<p>为了拥有特定领域语言(DSL)，它加载了 Bailador 以让我们定义路由更容易。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">use Bailador;</div></pre></td></tr></table></figure>
<p>最重要的是它包含了路由。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">unit class Demo;</div><div class="line">use Bailador;</div><div class="line"> </div><div class="line">my $version = &apos;0.01&apos;;</div><div class="line"></div><div class="line">get &apos;/&apos; =&gt; sub &#123;</div><div class="line">    template &apos;index.tt&apos;, &#123; version =&gt; $version, date =&gt; time &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="启动应用程序的脚本"><a href="#启动应用程序的脚本" class="headerlink" title="启动应用程序的脚本"></a>启动应用程序的脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use Bailador;</div><div class="line">Bailador::import();</div><div class="line">use lib callframe(0).file.IO.dirname ~ &apos;/lib&apos;;</div><div class="line">use Demo;</div><div class="line"></div><div class="line">baile;</div></pre></td></tr></table></figure>
<p>最有意思的应该是这段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">use lib callframe(0).file.IO.dirname ~ &apos;/lib&apos;;</div></pre></td></tr></table></figure>
<p>它计算这个工程的根目录 - 假设 <code>app.pl</code> 文件在根目录中 - 然后把 <code>/lib</code> 子目录添加到 perl 将要查找额外模块的地方。这会在 <code>lib</code> 子目录下加载 <code>Demo.pm</code> 文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-317746ed1c73c978.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用类来排序数组]]></title>
      <url>http://ohmycloud.github.io/2016/03/15/%E7%94%A8%E7%B1%BB%E6%9D%A5%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>有多列数据, 序号, 学校, 课程 … 年份这几列。要如果学校和课程相同就根据年份倒序排列。</p>
<p>先按学校排序, 再按课程排序, 然后按年份倒序排序。</p>
<p>我定义一个类来进行多列数据的排序, 很方便：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">class Course &#123;</div><div class="line">  has Int $.numb;</div><div class="line">  has Str $.univ;</div><div class="line">  has Str $.dis;</div><div class="line">  has Int $.paper;</div><div class="line">  has Int $.cited;</div><div class="line">  has Int $.year;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @headers = &lt;numb univ dis paper cited year&gt;;</div><div class="line">my @courses;</div><div class="line"></div><div class="line">for $=finish.lines -&gt; $line &#123;</div><div class="line">  next if $line ~~ /^num/;</div><div class="line">  my @words  = $line.words;</div><div class="line">  @words[0, 3,4,5] = @words[0,3,4,5]».Int;</div><div class="line">  my %h =  @headers Z=&gt; @words;</div><div class="line">  my $course = Course.new(|%h);</div><div class="line">  @courses.push($course);</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @sorted  = @courses.sort(*.univ).sort(*.dis).sort(-*.year);</div><div class="line">for @sorted  &#123;</div><div class="line">  say join &quot; &quot;, .numb, .univ, .dis, .paper, .cited, .year;</div><div class="line">&#125;</div><div class="line"></div><div class="line">=finish</div><div class="line">num	univ	dis	paper	cited	year</div><div class="line">1	Beijing	Physics	193	4555	2005</div><div class="line">2	Beijing	Physics	197	2799	2006</div><div class="line">3	Beijing	Physics	240	2664	2007</div><div class="line">4	Beijing	Physics	200	3191	2008</div><div class="line">5	Beijing	Physics	268	2668	2009</div><div class="line">6	Beijing	Physics	249	2300	2010</div><div class="line">7	Beijing	Physics	262	2080	2011</div><div class="line">8	Beijing	Physics	230	2371	2012</div><div class="line">9	Beijing	Physics	309	1367	2013</div><div class="line">10	Beijing	Physics	284	615	2014</div><div class="line">11	Beijing	Chemistry	143	1650	2005</div><div class="line">12	Beijing	Chemistry	149	2379	2006</div><div class="line">13	Beijing	Chemistry	190	2566	2007</div><div class="line">14	Beijing	Chemistry	147	1888	2008</div><div class="line">15	Beijing	Chemistry	184	2146	2009</div><div class="line">16	Beijing	Chemistry	214	2568	2010</div><div class="line">17	Beijing	Chemistry	238	2874	2011</div><div class="line">18	Beijing	Chemistry	265	2097	2012</div><div class="line">19	Beijing	Chemistry	251	1303	2013</div><div class="line">20	Beijing	Chemistry	241	656	2014</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Using-Perl-6(二)]]></title>
      <url>http://ohmycloud.github.io/2016/03/14/Using-Perl-6-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><hr>
<p>签名不仅仅是语法，它们是含有一列参数对象的 first-class 对象  。同样地，有一种含有参数集的数据结构,叫捕获。捕获有位置和命名两个部分，表现的就像列表和散列。像列表的那部分含有位置参数，而像散列的那部分含有命名参数。</p>
<h4 id="创建和使用捕获"><a href="#创建和使用捕获" class="headerlink" title="创建和使用捕获"></a>创建和使用捕获</h4><hr>
<p>无论你什么时间写下一个子例程调用，你就隐式地创建了一个捕获。然而，它随即被调用消耗了。有时，你想做一个捕获，存储它，然后将一个或多个子例程应用到它包含的一系列参数上。为了这，使用 n(…) 语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @tasks = n(39, 3, action =&gt; &#123; say $^a + $^b &#125;),</div><div class="line">n(6, 7, action =&gt; &#123; say $^a * $^b &#125;);</div></pre></td></tr></table></figure>
<p>这里，@tasks数组最后会包含两个捕获，每个捕获各含有两个位置参数和一个命名参数。捕获中的命名参数出现在哪并没有关系，因为他们是按名字传递，而非按位置。就像数组和散列，使用 | ，捕获也能被展平到参数列表中去:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sub act($left, $right, :$action) &#123;</div><div class="line">    $action($left, $right);</div><div class="line">&#125;</div><div class="line"></div><div class="line">for @tasks -&gt; $task-args &#123;</div><div class="line">    act(|$task-args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>However, in this case it is specifying the full set of arguments for the call, including both<br>named and positional arguments.<br>Unlike signatures, captures work like references. Any variable mentioned in a capture<br>exists in the capture as a reference to the variable. us rw parameters still work with<br>captures involved.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">my $value = 7;</div><div class="line">my $to-change = n($value);</div><div class="line"></div><div class="line">sub double($x is rw) &#123;</div><div class="line">    $x *= 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub triple($x is rw) &#123;</div><div class="line">    $x *= 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">triple(|$to-change);</div><div class="line">double(|$to-change);</div><div class="line"></div><div class="line">say $value; # 42</div></pre></td></tr></table></figure>
<p> Perl types with both positional and named parts also show up in various other situations. For example, regex matches have both positional and named matches–Match objects themselves are a type of capture. It’s also possible to conceive of an XML node type<br>that is a type of capture, with named attributes and positional children. Binding this node<br>to a function could use the appropriate parameter syntax to work with various children<br>and attributes.</p>
<h4 id="签名中的捕获"><a href="#签名中的捕获" class="headerlink" title="签名中的捕获"></a>签名中的捕获</h4><hr>
<p>All calls build a capture on the caller side and unpack it according to the signature on<br>the callee side</p>
<p>. It is also possible to write a signature that binds the capture itself into a<br>variable. is is especially useful for writing routines that delegate to other routines with<br>the same arguments.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub visit-czechoslovakia(|$plan) &#123;</div><div class="line">    warn &quot;Sorry, this country has been deprecated.&quot;;</div><div class="line">    visit-slovakia(|$plan);</div><div class="line">    visit-czech-republic(|$plan);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>e benefit of using this over a signature like :(<em>@pos, </em>%named) is that these both enforce<br>some context on the arguments, which may be premature. For example, if the caller<br>passes two arrays, they would Ęatten into @pos. is means that the two nested arrays<br>could not be recovered at the point of delegation. A capture preserves the two array<br>arguments, so that the final callee’s signature may determine how to bind them.</p>
<p>An optimizing Perl 6 compiler may, of course, be able to optimize away part or all of this process,<br>depending on what it knows at compilation time.</p>
<h3 id="Unpacking"><a href="#Unpacking" class="headerlink" title="Unpacking"></a>Unpacking</h3><hr>
<p>有时候，你只需要使用一个数组或散列的一部分。你可以使用常规的切片获取，或使用签名绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sub first-is-largest(@a) &#123;</div><div class="line">    my $first = @a.shift;</div><div class="line">    # TODO: either explain junctions, or find a concise way to write without them</div><div class="line">    return $first &gt;= all(@a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"># same thing:</div><div class="line">sub first-is-largest(@a) &#123;</div><div class="line">    my :($first, *@rest) := \(|@a)</div><div class="line">    return $first &gt;= all(@rest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>the signature binding approach might seem clumsy, but when you use it in the main<br>signature of a subroutine, you get tremendous power:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub first-is-largest([$first, *@rest]) &#123;</div><div class="line">    return $first &gt;= all(@rest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>the brackets in the signature tell the compiler to expect a list-like argument. Instead<br>of binding to an array parameter, it instead unpacks its arguments into several parameters–in this case, a scalar for the first element and an array for the rest. is subsignature<br>also acts as a constraint on the array parameter: the signature binding will fail unless the<br>list in the capture contains at least one item.<br>Likewise you can unpack a hash by using %(…) instead of square brackets, but you must<br>access named parameters instead of positional.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub create-world(%(:$temporary, *%characteristics)) &#123;</div><div class="line">    my $world = World.new(%characteristics);</div><div class="line">    return $world if $temporary;</div><div class="line"></div><div class="line">    save-world($world);</div><div class="line">&#125;</div><div class="line"></div><div class="line"># TODO: come up with a good example # maybe steal something from http://jnthn.net/papers/2010-yapc-eu-signatures.pdf</div><div class="line"># TODO: generic object unpacking</div></pre></td></tr></table></figure>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><hr>
<p>Consider a module that provided the example from the \Optional Parameters” section:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub order-burger( $type, $side? ) &#123; ... &#125;;</div></pre></td></tr></table></figure>
<p> If you used order-burger repeatedly, but oen with a side of french fries, you might wish<br>that the author had also provided a order-burger-and-fries sub. You could easily write<br>it yourself:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub order-burger-and-fries ( $type ) &#123;</div><div class="line">    order-burger( $type, side =&gt; &apos;french fries&apos; );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>If your personal order is always vegetarian, you might instead wish for a order-the-usual<br>sub. is is less concise to write, due to the optional second  parameter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sub order-the-usual ( $side? ) &#123;</div><div class="line">    if ( $side.defined ) &#123;</div><div class="line">        order-burger( &apos;veggie&apos;, $side );</div><div class="line">    &#125; else &#123;</div><div class="line">        order-burger( &apos;veggie&apos; );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Currying gives you a shortcut for these exact cases; it creates a new sub from an existing<br>sub, with parameters already filled in. In Perl 6, curry with the .assuming method:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&amp;order-the-usual := &amp;order-burger.assuming( &apos;veggie&apos; );</div><div class="line">&amp;order-burger-and-fries := &amp;order-burger.assuming( side =&gt;  &apos;french fries&apos; );</div></pre></td></tr></table></figure>
<p>e new sub is like any other sub, and works with all the various parameter-passing<br>schemes already described.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">order-the-usual( &apos;salsa&apos; );</div><div class="line">order-the-usual( side =&gt; &apos;broccoli&apos; );</div><div class="line"></div><div class="line">order-burger-and-fries( &apos;plain&apos; );</div><div class="line">order-burger-and-fries( :type&lt;&lt;double-beef&gt;&gt; );</div></pre></td></tr></table></figure>
<h3 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h3><hr>
<p>子例程和他们的签名都是对象。除了调用它们，你可以学习它们的东西，包括它们的参数的细节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> sub logarithm(Numeric $x, Numeric :$base = exp(1)) &#123;</div><div class="line">        log($x) / log($base);</div><div class="line">     &#125;</div><div class="line"></div><div class="line"> my @params = &amp;logarithm.signature.params;</div><div class="line"> say @params.elems, &apos; parameters&apos;;</div><div class="line"></div><div class="line"> for @params &#123;</div><div class="line">     say &quot;Name: &quot;,      .name;</div><div class="line">     say &quot; Type: &quot;,      .type;</div><div class="line">     say &quot; named? &quot;,     .named ?? &apos;yes&apos; !! &apos;no&apos;;</div><div class="line">     say &quot; slurpy? &quot;,    .slurpy ?? &apos;yes&apos; !! &apos;no&apos;;</div><div class="line">     say &quot; optional? &quot;,  .optional ?? &apos;yes&apos; !! &apos;no&apos;;</div><div class="line">  &#125;</div><div class="line">```  </div><div class="line">输出：</div><div class="line"></div><div class="line">```perl6</div><div class="line"> parameters</div><div class="line"></div><div class="line">Name: $x</div><div class="line">   Type: Numeric()</div><div class="line">   named? no</div><div class="line">   slurpy? no</div><div class="line">   optional? no</div><div class="line">Name: $base</div><div class="line">   Type: Numeric()</div><div class="line">   named? yes</div><div class="line">   slurpy? no</div><div class="line">   optional? yes</div></pre></td></tr></table></figure>
<p>&amp;logarithm.signature 返回这个子例程的签名，并对签名调用.params 方法，返回一个参数对象的列表。这些对象中的每个对象都详细描述一个参数。<br>Table 4.2: Methods in the Parameter class<br># stolen straight from S06, adapted a bit</p>
<p>签名的自省允许你创建一个能获取并传递正确数据到子例程的接口，例如，你可以 创建一个知道如何获取用户输入的web表单生成器，检测它，然后根据通过自省获得的信息you could build a web form generator that knew<br>how to get input from a user, validate it, and then call a routine with it based upon the<br>information obtained through introspection. A similar approach might generate a command line interface along with some basic usage instructions.<br>Beyond this, traits (traits) allow you to associate extra data with parameters. is metadata can go far beyond that which subroutines, signatures, and parameters normally provide.</p>
<h3 id="MAIN-子例程"><a href="#MAIN-子例程" class="headerlink" title="MAIN 子例程"></a>MAIN 子例程</h3><hr>
<p>Frequent users of the UNIX shells might have noticed a symmetry between postional<br>and named arguments to routines on the one hand, and argument and options on the<br>command line on the other hand.<br>is symmetry can be exploited by declaring a subroutine called MAIN. It is called every time the script is run, and its signature counts as a specification for command line<br>arguments.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># script roll-dice.pl</div><div class="line">sub MAIN($count = 1, Numeric :$sides = 6, Bool :$sum) &#123;</div><div class="line">    my @numbers = (1..$sides).roll($count);</div><div class="line">    say @numbers.join(&apos; &apos;);</div><div class="line">    say &quot;sum: &quot;, [+] @numbers if $sum;</div><div class="line">    &#125;</div><div class="line"># TODO: explain ranges, .pick and [+]</div></pre></td></tr></table></figure>
<p>执行该脚本时可以带参数也可以不带参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ perl6 roll-dice.pl</div><div class="line">$ perl6 roll-dice.pl 4</div><div class="line"> 4 2 4</div><div class="line">$ perl6 roll-dice.pl --sides=20 3</div><div class="line"> 1 2</div><div class="line">$ perl6 roll-dice.pl --sides=20 --sum 3</div><div class="line"> 14 12</div><div class="line">sum: 35</div><div class="line">$ perl6 roll-dice.pl --unknown-option</div><div class="line">Usage:</div><div class="line">roll-dice.pl [--sides=&lt;Numeric&gt;] [--sum] [&lt;count&gt;]</div></pre></td></tr></table></figure>
<p>命名参数可以跟很多GNU工具一样，使用 –name=value 语法提供，而位置参数使用它们的值就好了。</p>
<p>如果选项没有要求参数，MAIN 签名里的参数需要被标记为 Bool 类型。<br>使用未知选项或太多或太少的参数会触发一个自动生成的用法通知，它可以用一个普通的 USAGE 子例程重写：</p>
<p>  sub MAIN(:$really-do-it!) { … }<br>      sub USAGE() {<br>      say “This script is dangerous, please read the documentation first”;<br>    }</p>
<h2 id="第五章-类和对象"><a href="#第五章-类和对象" class="headerlink" title="第五章 类和对象"></a>第五章 类和对象</h2><hr>
<p>TODO: 以一个超简单露骨的例子开始!</p>
<p>下面的程序显示了 Perl 6 中的依赖处理是怎样的. 它展示了 cases custom constructors , 私有和公共属性, 方法和签名的各个方面. 它不太像代码, 结果却很有意思, 有时还是有用的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Task &#123;</div><div class="line">    has      &amp;!callback;</div><div class="line">    has Task @!dependencies;</div><div class="line">    has Bool $.done;</div><div class="line"></div><div class="line">method new(&amp;callback, Task *@dependencies) &#123;</div><div class="line">    return self.bless(*, :&amp;callback, :@dependencies);</div><div class="line">&#125;</div><div class="line"></div><div class="line">method add-dependency(Task $dependency) &#123;</div><div class="line">    push @!dependencies, $dependency;</div><div class="line">&#125;</div><div class="line">method perform() &#123;</div><div class="line">    unless $!done &#123;</div><div class="line">        .perform() for @!dependencies;</div><div class="line">        &amp;!callback();</div><div class="line">        $!done = True;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $eat =</div><div class="line">    Task.new(&#123; say &apos;eating dinner. NOM!&apos; &#125;,</div><div class="line">        Task.new(&#123; say &apos;making dinner&apos; &#125;,</div><div class="line">            Task.new(&#123; say &apos;buying food&apos; &#125;,</div><div class="line">                Task.new(&#123; say &apos;making some money&apos; &#125;),</div><div class="line">                Task.new(&#123; say &apos;going to the store&apos; &#125;)</div><div class="line">            ),</div><div class="line">            Task.new(&#123; say &apos;cleaning kitchen&apos; &#125;)</div><div class="line">        )</div><div class="line">    );</div><div class="line"></div><div class="line">$eat.perform();</div></pre></td></tr></table></figure>
<h3 id="从-class-开始"><a href="#从-class-开始" class="headerlink" title="从 class 开始"></a>从 class 开始</h3><hr>
<p>Perl 6 像很多其它语言一样, 使用 class 关键字来引入一个新类. 随后的 block 可能包含任意的代码, 就像任何其他块一样, 但是类通常包含状态和行为描述. 例子中的代码包含了通过 has 关键字引入的属性(状态), 和通过 method 关键字引入的行为.</p>
<p> 声明一个类就创建了 type object, 它默认被安装到当前包中.(就像使用 our 作用域声明一个变量一样). 这个 type object 是这个类的 “空实例”. 你在之前的章节中已经见到过了. 例如, 诸如 Int 和 Int 之类的 types 引用例如 Perl 6  内置类中的 type object. 上面的例子使用了类名 Task, 以至于其它代码能在之后引用这个类, 例如通过调用 new 方法来创建类的实例.</p>
<p> 类型对象是未定义的, 如果你在类型对象上调用 .defined 方法会返回 False.<br> 你可以使用这个方法找出一个给定的对象是类型对象还是不是:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> my $obj = Int;</div><div class="line"> if $obj.defined &#123;</div><div class="line">     say &quot;Ordinary, defined object&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    say &quot;Type object&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="我能拥有状态"><a href="#我能拥有状态" class="headerlink" title="我能拥有状态?"></a>我能拥有状态?</h3><hr>
<p>在这个 Task类的 block 里面, 前 3 行都声明了属性(在其它语言中叫做范畴或实例存储). 这些都是存储在本地的, 类的每个实例都能获得. 就像 my 声明的变量不能在它的声明范围之外访问到一样, 属性在类的外面也不可访问. 这种封装是面向对象设计的一个关键原则.</p>
<p>第一个声明为 callback 回调指定了实例存储 - 引用的一小块代码, 为了执行对象代表的任务.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">has &amp;!callback;</div></pre></td></tr></table></figure>
<p><code>&amp;</code>符号表明这个属性代表某些能调用的东西. <code>!</code> 符号是一个 twigil, 或者 第二符号. twigil 组成了变量名字的一部分. 这个例子里, <code>!</code> twigil 强调这个属性是类私有的.</p>
<p>第二个声明也使用了私有 twigil:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">has Task @!dependencies;</div></pre></td></tr></table></figure>
<p>然而, 这个属性代表一组项, 所以它要用 @ 符号. 这些项每个都指定了一个任务, 即在当前任务完成之前必须先被完成. 还有, 属性的类型声明表明数组能够存储 Task 类的实例(或者某些它的子类).</p>
<p>第三个属性代表了任务完成的状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">has Bool $.done;</div></pre></td></tr></table></figure>
<p>这个标量属性( 带有 $ 符号 )有一个 Bool 类型. 这里的 twigil 是 <code>.</code> 而非 <code>!</code>. 虽然 Perl 6 确实强制封装属性, 它也让你免于写 accessor 方法.<br>使用 . 代替 !  既声明了属性 $!done 又声明了名为 done 的访问方法. 它就像你这样写的一样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">has Bool $!done;</div><div class="line">method done() &#123; return $!done &#125;</div></pre></td></tr></table></figure>
<p>注意, 这不像是声明一个公共属性, 像其他语言允许的那样; 你真的既得到了私有存储位置,又得到一个方法, 不用非得手写方法了. 你可以自由的书写你自己的访问方法, 如果在未来的某些时候, 你需要做一些更复杂的事情而不仅仅是返回它的值.</p>
<p>注意, 使用 . twigil 已经创建了一个方法用于只读访问那个属性. 如果这个对象的使用者想重置任务的完成状态(也许重新执行这个任务), 你可以更改属性声明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">has Bool $.done is rw;</div></pre></td></tr></table></figure>
<p><code>is rw</code> 特征允许生成的访问方法返回某些外部代码, 能够修改以改变属性的值.</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><hr>
<p>属性给了对象状态, 方法则给了对象行为. 暂时无视 new 方法;它是一个特殊类型的方法. 看看第二个方法, add-dependency, 它给这个任务依赖列表添加了一个新任务:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">method add-dependency(Task $dependency) &#123;</div><div class="line">    push @!dependencies, $dependency;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从很多方面讲, 这看起开很像子例程声明. 然而, 有两个重要区别. 首先, 把该子例程声明为方法就把它添加到当前类的方法列表中了. 因此, 任何 Task 类的实例都能使用 .method 调用操作调用这个方法. 第二, 方法把它的调用放到特殊变量 <code>self</code> 中了.</p>
<h3 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h3><hr>
<h3 id="Consuming-our-class"><a href="#Consuming-our-class" class="headerlink" title="Consuming our class"></a>Consuming our class</h3><hr>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><hr>
<h4 id="Overriding-Inherited-Methods"><a href="#Overriding-Inherited-Methods" class="headerlink" title="Overriding Inherited Methods"></a>Overriding Inherited Methods</h4><hr>
<h4 id="Multiple-Inheritance"><a href="#Multiple-Inheritance" class="headerlink" title="Multiple Inheritance"></a>Multiple Inheritance</h4><hr>
<h3 id="Introspection"><a href="#Introspection" class="headerlink" title="Introspection"></a>Introspection</h3><hr>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><hr>
<h2 id="第六章-Multis"><a href="#第六章-Multis" class="headerlink" title="第六章 Multis"></a>第六章 Multis</h2><hr>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><hr>
<h3 id="Narrowness"><a href="#Narrowness" class="headerlink" title="Narrowness"></a>Narrowness</h3><hr>
<h3 id="Multiple-arguments"><a href="#Multiple-arguments" class="headerlink" title="Multiple arguments"></a>Multiple arguments</h3><hr>
<h3 id="Bindability-checks"><a href="#Bindability-checks" class="headerlink" title="Bindability checks"></a>Bindability checks</h3><hr>
<h3 id="Nested-Signatures-in-Multi-dispatch"><a href="#Nested-Signatures-in-Multi-dispatch" class="headerlink" title="Nested Signatures in Multi-dispatch"></a>Nested Signatures in Multi-dispatch</h3><hr>
<h3 id="Protos"><a href="#Protos" class="headerlink" title="Protos"></a>Protos</h3><hr>
<h3 id="Toying-with-the-candidate-list"><a href="#Toying-with-the-candidate-list" class="headerlink" title="Toying with the candidate list"></a>Toying with the candidate list</h3><hr>
<h3 id="Multiple-MAIN-subs"><a href="#Multiple-MAIN-subs" class="headerlink" title="Multiple MAIN subs"></a>Multiple MAIN subs</h3><hr>
<h2 id="第七章-Roles"><a href="#第七章-Roles" class="headerlink" title="第七章 Roles"></a>第七章 Roles</h2><hr>
<h3 id="What-is-a-role"><a href="#What-is-a-role" class="headerlink" title="What is a role?"></a>What is a role?</h3><hr>
<h3 id="Compile-Time-Composition"><a href="#Compile-Time-Composition" class="headerlink" title="Compile Time Composition"></a>Compile Time Composition</h3><hr>
<h4 id="Multi-methods-and-composition"><a href="#Multi-methods-and-composition" class="headerlink" title="Multi-methods and composition"></a>Multi-methods and composition</h4><hr>
<h4 id="Calling-all-candidates"><a href="#Calling-all-candidates" class="headerlink" title="Calling all candidates"></a>Calling all candidates</h4><hr>
<h4 id="Expressing-requirements"><a href="#Expressing-requirements" class="headerlink" title="Expressing requirements"></a>Expressing requirements</h4><hr>
<h3 id="Runtime-Application-of-Roles"><a href="#Runtime-Application-of-Roles" class="headerlink" title="Runtime Application of Roles"></a>Runtime Application of Roles</h3><hr>
<h4 id="Differences-from-compile-time-composition"><a href="#Differences-from-compile-time-composition" class="headerlink" title="Differences from compile time composition"></a>Differences from compile time composition</h4><hr>
<h4 id="The-but-operator"><a href="#The-but-operator" class="headerlink" title="The but operator"></a>The but operator</h4><hr>
<h3 id="Parametric-Roles"><a href="#Parametric-Roles" class="headerlink" title="Parametric Roles"></a>Parametric Roles</h3><hr>
<h3 id="Roles-and-Types"><a href="#Roles-and-Types" class="headerlink" title="Roles and Types"></a>Roles and Types</h3><hr>
<h2 id="第八章-子类"><a href="#第八章-子类" class="headerlink" title="第八章 子类"></a>第八章 子类</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">enum Suit &lt;spades hearts diamonds clubs&gt;;</div><div class="line">enum Rank (2, 3, 4, 5, 6, 7, 8, 9, 10,</div><div class="line">                    &apos;jack&apos;, &apos;queen&apos;, &apos;king&apos;, &apos;ace&apos;);</div><div class="line"></div><div class="line">class Card &#123;</div><div class="line">     has Suit $.suit;</div><div class="line">     has Rank $.rank;</div><div class="line"></div><div class="line">method Str &#123;</div><div class="line">      $.rank.name ~ &apos; of &apos; ~ $.suit.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">subset PokerHand of List where &#123; .elems == 5 &amp;&amp; all(|$_) ~~ Card &#125;</div><div class="line"></div><div class="line">sub n-of-a-kind($n, @cards) &#123;</div><div class="line">     for @cards&gt;&gt;.rank.uniq -&gt; $rank &#123;</div><div class="line">     return True if $n == grep $rank, @cards&gt;&gt;.rank;</div><div class="line">    &#125;</div><div class="line">return False;</div><div class="line">&#125;</div><div class="line"></div><div class="line">subset Quad of PokerHand where         &#123; n-of-a-kind(4, $_) &#125;</div><div class="line">subset ThreeOfAKind of PokerHand where &#123; n-of-a-kind(3, $_) &#125;</div><div class="line">subset OnePair of PokerHand where      &#123; n-of-a-kind(2, $_) &#125;</div><div class="line"></div><div class="line">subset FullHouse of PokerHand where OnePair &amp; ThreeOfAKind;</div><div class="line"></div><div class="line">subset Flush of PokerHand where -&gt; @cards &#123; [==] @cards&gt;&gt;.suit &#125;</div><div class="line"></div><div class="line">subset Straight of PokerHand where sub (@cards) &#123;</div><div class="line">          my @sorted-cards = @cards.sort(&#123; .rank &#125;);</div><div class="line">          my ($head, @tail) = @sorted-cards;</div><div class="line">          for @tail -&gt; $card &#123;</div><div class="line">               return False if $card.rank != $head.rank + 1;</div><div class="line">               $head = $card;</div><div class="line">            &#125;</div><div class="line"> return True;</div><div class="line">&#125;</div><div class="line"></div><div class="line">subset StraightFlush of Flush where Straight;</div><div class="line"></div><div class="line">subset TwoPair of PokerHand where sub (@cards) &#123;</div><div class="line">           my $pairs = 0;</div><div class="line">           for @cards&gt;&gt;.rank.uniq -&gt; $rank &#123;</div><div class="line">                ++$pairs if 2 == grep $rank, @cards&gt;&gt;.rank;</div><div class="line"> &#125;</div><div class="line">return $pairs == 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub classify(PokerHand $_) &#123;</div><div class="line">     when StraightFlush    &#123; &apos;straight flush&apos;,  8  &#125;</div><div class="line">     when Quad             &#123; &apos;four of a kind&apos;,  7  &#125;</div><div class="line">     when FullHouse        &#123; &apos;full house&apos;,      6  &#125;</div><div class="line">     when Flush            &#123; &apos;flush&apos;,           5  &#125;</div><div class="line">     when Straight         &#123; &apos;straight&apos;,        4  &#125;</div><div class="line">     when ThreeOfAKind     &#123; &apos;three of a kind&apos;, 3  &#125;</div><div class="line">     when TwoPair          &#123; &apos;two pair&apos;,        2  &#125;</div><div class="line">     when OnePair          &#123; &apos;one pair&apos;,        1  &#125;</div><div class="line">     when *                &#123; &apos;high cards&apos;,      0  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @deck = map -&gt; $suit, $rank &#123; Card.new(:$suit, :$rank) &#125;,</div><div class="line">                       (Suit.pick(*) X Rank.pick(*));</div><div class="line"></div><div class="line">@deck .= pick(*);</div><div class="line"></div><div class="line">my @hand1;</div><div class="line">@hand1.push(@deck.shift()) for ^5;</div><div class="line">my @hand2;</div><div class="line">@hand2.push(@deck.shift()) for ^5;</div><div class="line"></div><div class="line">say &apos;Hand 1: &apos;, map &#123; &quot;\n $_&quot; &#125;, @hand1&gt;&gt;.Str;</div><div class="line">say &apos;Hand 2: &apos;, map &#123; &quot;\n $_&quot; &#125;, @hand2&gt;&gt;.Str;</div><div class="line"></div><div class="line">my ($hand1-description, $hand1-value) = classify(@hand1);</div><div class="line">my ($hand2-description, $hand2-value) = classify(@hand2);</div><div class="line"></div><div class="line">say sprintf q[The first hand is a &apos;%s&apos; and the second one a &apos;%s&apos;, so %s.],</div><div class="line">$hand1-description, $hand2-description,</div><div class="line">$hand1-value &gt; $hand2-value</div><div class="line">        ?? &apos;the first hand wins&apos;</div><div class="line">        !! $hand2-value &gt; $hand1-value</div><div class="line">                   ?? &apos;the second hand wins&apos;</div><div class="line">                   !! &quot;the hands are of equal value&quot;; # XXX: this is wrong</div></pre></td></tr></table></figure>
<h2 id="第九章-模式匹配"><a href="#第九章-模式匹配" class="headerlink" title="第九章 模式匹配"></a>第九章 模式匹配</h2><hr>
<p>尽管 Perl 6 中描述的语法跟 PCRE 和 POSIX 已经不一样了，我们还是叫它们 regex.</p>
<p>eg：查找连续重复2次的单词</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $s = &apos;the quick brown fox jumped over the the lazy dog&apos;;</div><div class="line">if $s ~~ m/ &lt;&lt; (\w+) \W+ $0 &gt;&gt; / &#123;say &quot;Found &apos;$0&apos; twice in a  row&quot;;&#125;</div><div class="line">Found &apos;the&apos; twice in a row</div></pre></td></tr></table></figure>
<p>&lt;&lt; 和 &gt;&gt; 是单词边界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if &apos;properly&apos; ~~ m/ perl / &#123;</div><div class="line">    say &quot;&apos;properly&apos; contains &apos;perl&apos;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>m/ … / 结构创建了一个正则表达式。默认地，正则表达式中的空格是无关紧要的，你可以写成 m/perl/, m/ perl /,甚至 m/p e rl/。</p>
<p>只有单词字符，数字和下划线在正则表达式中代表字面值。其它所有的字符可能有特殊的意思。如果你想搜索逗号，星号或其它非单词字符，你必须引起或转义它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $str = &quot;I&apos;m *very* happy&quot;;</div><div class="line"></div><div class="line"># quoting</div><div class="line">if $str ~~ m/ &apos;*very*&apos; / &#123; say &apos;\o/&apos; &#125;</div><div class="line"></div><div class="line"># escaping</div><div class="line">if $str ~~ m/ \* very \* / &#123; say &apos;\o/&apos; &#125;</div></pre></td></tr></table></figure>
<p>正则表达式支持特殊字符，点( . ) 匹配任意一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my @words = &lt;spell superlative openly stuff&gt;;</div><div class="line"></div><div class="line">for @words -&gt; $w &#123;</div><div class="line">     if $w ~~ m/ pe.l / &#123;</div><div class="line">         say &quot;$w contains $/&quot;;</div><div class="line">     &#125; else &#123;</div><div class="line">         say &quot;no match for $w&quot;;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">spell contains pell</div><div class="line">superlative contains perl</div><div class="line">openly contains penl</div><div class="line">no match for stuff</div></pre></td></tr></table></figure>
<p>点匹配了l,r和n，但是在句子 the spectroscope lacks resolution 中正则表达式默认忽略单词边界。<br>特殊变量 $/ 存储匹配到的对象，这允许你检测匹配到的文本。</p>
<pre><code>Table 9.1: 反斜线序列和它们的意思
Symbol  Description                 Examples
\w        word character                l, ö, 3,
\d        digit                        0, 1
\s        whitespace                    (tab), (blank), (newline)
\t        tabulator                    (tab)
\n         newline                        (newline)
\h        horizontal whitespace        (space), (tab)
\v        vertical whitespace            (newline), (vertical tab)
</code></pre><p>\加上一个大写字母代表上面表格的相反意思：\W 匹配一个非单词字符，　\N 匹配一个不是换行符的单个字符。</p>
<p>这些匹配超越了ASCII表的范围—— \d 匹配拉丁数字、阿拉伯数字和梵文数字和其它数字， \s 匹配非中断空白，等等。这些字符类遵守Unicode关于什么是字母、数字等的定义。</p>
<p>你可以自定义你的字符类，将合适的字符列在嵌套的尖括号和方括号中： &lt;[ … ]&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if $str ~~ / &lt;[aeiou]&gt; / &#123;</div><div class="line">    say &quot;&apos;$str&apos; contains a vowel&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># negation with a -</div><div class="line">if $str ~~ / &lt;-[aeiou]&gt; / &#123;</div><div class="line">    say &quot;&apos;$str&apos; contains something that&apos;s not a vowel&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以在字符类中使用范围操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># match a, b, c, d, ..., y, z</div><div class="line">if $str ~~ / &lt;[a..z]&gt; / &#123;</div><div class="line">    say &quot;&apos;$str&apos; contains a lower case Latin letter&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以使用 + 和 - 操作符将字符添加到字符类 或 从字符类中减去字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if $str ~~ / &lt;[a..z]+[0..9]&gt; / &#123;</div><div class="line">    say &quot;&apos;$str&apos; contains a letter or number&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if $str ~~ / &lt;[a..z]-[aeiou]&gt; / &#123;</div><div class="line">    say &quot;&apos;$str&apos; contains a consonant（辅音）&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在字符类里面，非单词字符不需要被转义，一般使用它们的特殊意义。所以 /&lt;[+.*]&gt;/匹配一个加号，或一个点或一个星号。需要转义的就是反斜线 / 和破折号 -  。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $str = &apos;A character [b] inside brackets&apos;;</div><div class="line">if $str ~~ /&apos;[&apos; &lt;-[ \[ \] ]&gt; &apos;]&apos;/ ) &#123;  #  \[ \] 匹配一个 非[和非]字符</div><div class="line">    say &quot;Found a non-bracket character inside square brackets&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>量词 跟Perl5 中的用法相似：如 ? 表示重复前面的东西0次或一次； *表示重复前面的东西0次或多次，+ 号表示重复前面的东西 1次或多次。</p>
<p>最普遍的量词是 <strong> ，当它后面接一个数字number时，表示匹配前面的东西number 次。Perl 5 中用 {m,n}<br>当 </strong> 后面跟着 一个范围时，它能匹配范围中的任何数字次数的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># match a date of the form 2009-10-24:</div><div class="line">m/ \d**4 &apos;-&apos; \d\d &apos;-&apos; \d\d /</div><div class="line"></div><div class="line"># match at least three &apos;a&apos;s in a row:</div><div class="line">m/ a ** 3..* /</div><div class="line"></div><div class="line"># 可以使用 % 号在量词后面指定一个分隔符：</div><div class="line"> &apos;1,2,3&apos; ~~ / \d+ % &apos;,&apos; /</div></pre></td></tr></table></figure>
<p>  分隔符也可以是一个正则表达式。</p>
<p>贪婪匹配和非贪婪匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">my $html = &apos;&lt;p&gt;A paragraph&lt;/p&gt; &lt;p&gt;And a second one&lt;/p&gt;&apos;;</div><div class="line"></div><div class="line">if $html ~~ m/ &apos;&lt;p&gt;&apos; .* &apos;&lt;/p&gt;&apos; / &#123;</div><div class="line">    say &apos;Matches the complete string!&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if $html ~~ m/ &apos;&lt;p&gt;&apos; .*? &apos;&lt;/p&gt;&apos; / &#123;</div><div class="line">    say &apos;Matches only &lt;p&gt;A paragraph&lt;/p&gt;!&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $ingredients = &apos;milk, flour, eggs and sugar&apos;;</div><div class="line"># prints &quot;milk, flour, eggs&quot;</div><div class="line">$ingredients ~~ m/ [\w+]+ % [\,\s*] / &amp;&amp; say &quot;|$/|&quot;;</div><div class="line"># |milk, flour, eggs|</div></pre></td></tr></table></figure>
<p> 这里 \w 匹配一个单词，并且 [\w+]+ % [\,\s*]  匹配至少一个单词，并且单词之间用逗号和任意数量的空白分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> &gt; &apos;1,2,3&apos; ~~ / \d+ % &apos;,&apos; / &amp;&amp; say &quot;|$/|&quot;;</div><div class="line">|1,2,3|</div></pre></td></tr></table></figure>
<p>%必须要跟在量词后面，否则报错。</p>
<p>选择分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$string ~~ m/ \d**4 &apos;-&apos; \d\d &apos;-&apos; \d\d | &apos;today&apos; | &apos;yesterday&apos; /</div></pre></td></tr></table></figure>
<p> 一个竖直条意味着分支是并行匹配的，并且最长匹配的分支胜出。两个竖直条会让正则引擎按顺序尝试匹配每个分支，并且第一个匹配的分支胜出。</p>
<h3 id="锚定"><a href="#锚定" class="headerlink" title="锚定"></a>锚定</h3><hr>
<p> 到目前为止, 在一个字符串中, 所有的正则都是在任何地方匹配. 通常把匹配限制为字符串或单词边界的开始或结尾是很有用的. 单个的 ^ 符号匹配字符串的开始, 美元符 $ 匹配字符串的结尾. m/ ^a / 匹配以一个字母 a 开头的字符串, m/ ^ a $ / 匹配只含一个字符 a 的字符串.</p>
<pre><code>                       Table 9.2: Regex anchors
Anchor Meaning
^      字符串的开头
$      字符串的结尾
^^     行的开头
$$     行的结尾
&lt;&lt;     左单词边界
«      左单词边界
&gt;&gt;     右单词边界
»      右单词边界
</code></pre><h3 id="捕获-1"><a href="#捕获-1" class="headerlink" title="捕获"></a>捕获</h3><hr>
<p>圆括号里的匹配被捕获到特殊数组 $/ 中，第一个捕获分组存储在 $/[0]中，第二个存储在  $/[1]中，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;Germany was reunited on 1990-10-03, peacefully&apos;;</div><div class="line"></div><div class="line">if $str ~~ m/ (\d**4) \- (\d\d) \- (\d\d) / &#123;</div><div class="line">    say &apos;Year:  &apos;,  &quot;$/[0]&quot;;</div><div class="line">    say &apos;Month: &apos;,  &quot;$/[1]&quot;;</div><div class="line">    say &apos;Day:   &apos;,  &quot;$/[2]&quot;;</div><div class="line">    # usage as an array:</div><div class="line">    say $/.join(&apos;-&apos;); # prints 1990-10-03</div><div class="line">&#125;</div><div class="line"></div><div class="line">Year: 1990</div><div class="line">Month: 10</div><div class="line">Day: 03</div><div class="line">1990-10-03</div></pre></td></tr></table></figure>
<p>如果你在捕获后面加上量词，匹配对象中的对应的项是一列其它对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $ingredients = &apos;eggs, milk, sugar and flour&apos;;</div><div class="line"></div><div class="line">if $ingredients ~~ m/(\w+)+ % [\,\s*] \s* &apos;and&apos; \s* (\w+)/ &#123;</div><div class="line">    say &apos;list: &apos;, $/[0].join(&apos; | &apos;);</div><div class="line">    say &apos;end: &apos;, &quot;$/[1]&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这打印:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list: eggs | milk | sugar</div><div class="line">end: flour</div></pre></td></tr></table></figure>
<p>第一个捕获(\w+)被量词化了，所以$/[0]包含一列单词。代码调用 .join方法将它转换为字符串。 不管第一个捕获匹配了多少次（并且有$/[0]中有多少元素），第二个捕获$/[1]始终可以访问。</p>
<p>作为一种便捷的方式，$/[0] 可以写为 $0, $/[1] 可以写为 $1,等等。这些别名在正则表达式内部也可使用。这允许你写一个正则表达式检测普通的单词重复错误，就像本章开头的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $s = &apos;the quick brown fox jumped over the the lazy dog&apos;;</div><div class="line">if $s ~~ m/ &lt;&lt; (\w+) \W+ $0 &gt;&gt; / &#123;say &quot;Found &apos;$0&apos; twice in a  row&quot;;&#125;</div><div class="line">Found &apos;the&apos; twice in a row</div></pre></td></tr></table></figure>
<p>如果没有第一个单词边界锚点，它会匹配  strand and<br>beach or lathe the table leg. 没有最后的单词边界锚点，它会匹配the theory.</p>
<h3 id="命名正则"><a href="#命名正则" class="headerlink" title="命名正则"></a>命名正则</h3><hr>
<p>你可以像申明子例程一样申明正则表达式——甚至给它们起名字。假设你发现之前的例子很有用，你想让它更容易被访问。假设你想扩展这个正则让它处理诸如  doesn’t 或 isn’t 的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my regex word &#123; \w+ [ \&apos; \w+]? &#125;</div><div class="line">my regex dup &#123; « &lt;word=&amp;word&gt; \W+ $&lt;word&gt; » &#125;</div><div class="line">if $s ~~ m/ &lt;dup=&amp;dup&gt; / &#123;</div><div class="line">    say &quot;Found &apos;&#123;$&lt;dup&gt;&lt;word&gt;&#125;&apos; twice in a row&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码引入了一个名为 word 的正则表达式，它至少匹配一个单词字符，后面跟着一个可选的单引号和更多的单词字符。另外一个名为 dup （duplcate的缩写，副本的意思）的正则包含一个单词边界锚点。<br>在正则里面，语法 &lt;&amp;word&gt; 在当前词法作用域内查找名为word的正则并匹配这个正则表达式。 <code>&lt;name=&amp;regex&gt;</code> 语法创建了一个叫做 name的捕获，它记录了 &amp;regex 匹配的内容。</p>
<p>在这个例子中，dup 调用了名为 word 正则，随后匹配至少一个非单词字符，之后再匹配相同的字符串（ 前面word 正则匹配过的）一次，它以另外一个字符边界结束。这种向后引用的语法记为美元符号 $  后面跟着用尖括号包裹着捕获的名字。</p>
<p>在 if 代码块里， <code>$&lt;dup&gt;</code> 是  $/{‘dup’} 的快捷写法。它访问正则 dup 产生的匹配对象。dup 也有一个叫 word 的子规则。从那个调用产生的匹配对象用 <code>$&lt;dup&gt;&lt;word&gt;</code>来访问。</p>
<p>命名捕获让组织复杂正则更容易。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><hr>
<p>s修饰符是 :sigspace  的缩写，该修饰符允许可选的空白出现在文本中无论哪里有一个或更多空白字符出现在模式中。它甚至比那更聪明：在两个单词字符之间，空白字符是任意的。该 regex 不匹配字符串 eggs,milk, sugarandflour.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $ingredients = &apos;eggs, milk, sugar and flour&apos;;</div><div class="line"></div><div class="line">if $ingredients ~~ m/:s ( \w+ )+ % \,&apos;and&apos; (\w+)/ &#123;</div><div class="line">    say &apos;list: &apos;, $/[0].join(&apos; | &apos;);</div><div class="line">    say &apos;end: &apos;, &quot;$/[1]&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">list: eggs |  milk |  sugar</div><div class="line">end: flour</div></pre></td></tr></table></figure>
<h3 id="回溯控制"><a href="#回溯控制" class="headerlink" title="回溯控制"></a>回溯控制</h3><hr>
<p>当用 m/\w+ ‘en’/ 匹配字符串 oxen时，\w+ 首先匹配全部字符串oxen，因为 +是贪婪的，然后 ‘en’ 不能匹配任何东西。 \w+ 丢弃一个字符，匹配了 oxe，但是 ‘en’还是不能匹配，\w+ 继续丢弃一个字符，匹配 ox, 然后 ‘en’匹配成功。</p>
<p>一个冒号开关（ : ） 可以为之前的量词或分支关闭回溯。 所以 m / \w+: ‘en’/不会匹配任何字符串，因为 \w+ 总是吃光所有的单词字符，从不回退。</p>
<p> :ratchet（防止倒转的制轮装置） 修饰符让整个 正则的回溯功能失效，禁止回溯让 \w+ 总是匹配一个完整的单词:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># XXX: does actually match, because m/&lt;&amp;dup&gt;/</div><div class="line"># searches for a starting position where the</div><div class="line"># whole regex matches. Find an example that</div><div class="line"># doesn&apos;t match</div><div class="line"></div><div class="line">my regex word &#123; :ratchet \w+ [ \&apos; \w+]? &#125;</div><div class="line">my regex dup &#123; &lt;word=&amp;word&gt; \W+ $&lt;word&gt; &#125;</div><div class="line"></div><div class="line"># no match, doesn&apos;t match the &apos;and&apos;</div><div class="line"># in &apos;strand&apos; without backtracking</div><div class="line">&apos;strand and beach&apos; ~~ m/&lt;&amp;dup&gt;/</div></pre></td></tr></table></figure>
<p> :ratchet 只影响它出现的正则中。外围的正则依然会回溯，所以它能在不同的起始位置重新尝试匹配 正则 word 。正则 { :ratchet … } 模式太常用了，它有它自己的快捷方式：token { … } .惯用的重复单词搜索可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my token word &#123; \w+ [ \&apos; \w+]? &#125;</div><div class="line">my regex dup &#123; &lt;word&gt; \W+ $&lt;word&gt; &#125;</div></pre></td></tr></table></figure>
<p>带有 :sigspace 修饰符的令牌是一个 rule:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># TODO: check if it works</div><div class="line">my rule wordlist &#123; &lt;word&gt;+ % \, &apos;and&apos; &lt;word&gt; &#125;</div></pre></td></tr></table></figure>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><hr>
<p>正则表达式对于数据操作很好用。 subst 方法用一个正则跟一个字符串匹配。<br> 当subst 匹配的时候，它用它的第二个操作数替换掉匹配到的部分字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $spacey = &apos;with    many     superfluous      spaces&apos;;</div><div class="line"></div><div class="line">say $spacey.subst(rx/ \s+ /, &apos; &apos;, :g);</div><div class="line"># output: with many superfluous spaces</div></pre></td></tr></table></figure>
<p>默认地，subst执行一个单个替换然后停止。 :g 告诉替换是全局的，它替换每个可能的匹配。<br>注意  这里使用 rx/ … / 而不是 m/ … / 来构建这个正则。前者构建一个正则表达式对象。后者构建一个正则对象然后立即用它匹配主题变量 $_ 。调用subst时使用 m/ … / 会创建一个匹配对象并且将它作为第一个参数传递，而不是传递正则表达式本身。</p>
<h3 id="其它正则特性"><a href="#其它正则特性" class="headerlink" title="其它正则特性"></a>其它正则特性</h3><hr>
<p>有时候你需要调用其它正则，但是不想让它们捕获匹配的文本。当解析编程语言的时候，你可能想删除空白字符和注释。你可以调用 &lt;.otherrule&gt; 完成。如果你用 <code>:sigspace</code> 修饰符，每个连续的空白块调用内建的规则 <code>&lt;.ws&gt;</code> 。使用这个规则而不是使用字符类允许你定义你自己的空白字符版本。<br>有些时候你仅仅想前视一下以查看下面的字符是否满足某些属性而不消耗这些字符。这在替换中很有用。在一般的英文文本中，你总是在逗号后面添加一个空格。如果某些人忘记了添加空格，正则能够在慵懒的写完之后整理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $str = &apos;milk,flour,sugar and eggs&apos;;</div><div class="line">say $str.subst(/&apos;,&apos; &lt;?before \w&gt;/, &apos;, &apos;, :g);  #向前查看</div><div class="line"># output: milk, flour, sugar and eggs</div></pre></td></tr></table></figure>
<p>内建的 token <code>&lt;alpha&gt;</code> 匹配一个字母表字符，所以你可以重写这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $str.subst(/&apos;,&apos; &lt;?alpha&gt;/, &apos;, &apos;, :g);</div></pre></td></tr></table></figure>
<p>前置感叹号反转上面的意思，否定前视:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $str.subst(/&apos;,&apos; &lt;!space&gt;/, &apos;, &apos;, :g);</div></pre></td></tr></table></figure>
<p>向后环视<code>&lt;?after&gt;</code>.<br>Table 9.3: 用环视断言模拟锚点</p>
<h3 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">sub line-and-column(Match $m) &#123;</div><div class="line">       my $line = ($m.orig.substr(0, $m.from).split(&quot;\n&quot;)).elems;</div><div class="line">       # RAKUDO workaround for RT #70003, $m.orig.rindex(...) directly fails</div><div class="line">       my $column = $m.from - (&apos;&apos; ~ $m.orig).rindex(&quot;\n&quot;, $m.from);</div><div class="line">      $line, $column;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $s = &quot;the quick\nbrown fox jumped\nover the the lazy dog&quot;;</div><div class="line"></div><div class="line">my token word &#123; \w+ [ \&apos; nw+]? &#125;</div><div class="line">my regex dup &#123; &lt;word&gt; \W+ $&lt;word&gt; &#125;</div><div class="line"></div><div class="line">if $s ~~ m/ &lt;dup&gt; / &#123;</div><div class="line">   my ($line, $column) = line-and-column($/);</div><div class="line">   say &quot;Found &apos;&#123;$&lt;dup&gt;&lt;word&gt;&#125;&apos; twice in a row&quot;;</div><div class="line">   say &quot;at line $line, column $column&quot;;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"># 输出:</div><div class="line"># Found &apos;the&apos; twice in a row</div><div class="line"># at line 3, column 6</div></pre></td></tr></table></figure>
<p>每个正则匹配返回一个类型为 Match 的对象。在布尔上下文中，匹配对象在匹配成功时返回真，匹配失败时返回假。</p>
<p>orig 方法返回它匹配的字符串，from 和 to 方法返回匹配的开始位置和结束点。</p>
<p>在前面的例子中， line-and-column 函数探测在匹配中行号出现的位置， 通过提取字符串直到匹配位置($m.orig.substr(0,$m.from)), 用换行符分隔它， 并计算元素个数。它通过从匹配位置向后搜索并计算与匹配位置的不同来计算列数 。index方法在一个字符串中搜索一个字串并且返回在搜寻字符串中的位置。rindex方法与之相同，但是它从字符串末尾想后搜索，所以它查找字串最后出现的位置。</p>
<p>Using a match object as an array yields access to the positional captures. Using it as a hash<br>reveals the named captures. 在前面的例子中, <code>$&lt;dup&gt;</code> 是 <code>$/&lt;dup&gt;</code> 或 <code>$/{ &#39;dup&#39; }</code> 的快捷写法。这些捕获又是 Match 对象，所以匹配对象实际是匹配树。</p>
<p> caps 方法返回所有的捕获，命名的和位置的，按照它们匹配的文本在原始字符串中出现的顺序返回。返回的值是一个 Pair 对象列表。键值是捕获的名字或数量，键值是对应的 Match 对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if &apos;abc&apos; ~~ m/(.) &lt;alpha&gt; (.) / &#123;</div><div class="line">    for $/.caps &#123;</div><div class="line">        say .key, &apos; =&gt; &apos;, .value;</div><div class="line">       &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># Output:</div><div class="line"># 0 =&gt; a</div><div class="line"># alpha =&gt; b</div><div class="line"># 1 =&gt; c</div></pre></td></tr></table></figure></p>
<p>在这种情况下，捕获以它们在正则中的顺序出现，但是量词可以改变这种情况。即使如此， $/.caps 后面跟着有顺序的字符串，而不是一个正则。<br>字符串的某一部分匹配但是不是捕获的一部分不会出现在caps 方法返回的值中。</p>
<p>为了访问非捕获部分，用 $/. 代替。它返回匹配字符串的捕获和非捕获两部分，跟  caps 的格式相同但是带有一个 ~ 符号作为键。如果没有重叠的捕获（出现在环视断言中）,所有返回的 pair 值连接与匹配部分的字符串相同。</p>
<h2 id="第十章-Grammars"><a href="#第十章-Grammars" class="headerlink" title="第十章 Grammars"></a>第十章 Grammars</h2><hr>
<p>Grammars 组织正则表达式, 就像类组织方法一样.下面的例子演示了怎样解析JSON, 一种已经介绍过的数据交换格式.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"># file lib/JSON/Tiny/Grammar.pm</div><div class="line"></div><div class="line">grammar JSON::Tiny::Grammar &#123;</div><div class="line">    rule TOP      &#123; ^[ &lt;object&gt; | &lt;array&gt; ]$ &#125;</div><div class="line">    rule object   &#123; &apos;&#123;&apos; ~ &apos;&#125;&apos; &lt;pairlist&gt;     &#125;</div><div class="line">    rule pairlist &#123; &lt;pair&gt;* % [ \, ]         &#125;</div><div class="line">    rule pair     &#123; &lt;string&gt; &apos;:&apos; &lt;value&gt;     &#125;</div><div class="line">    rule array    &#123; &apos;[&apos; ~ &apos;]&apos; [ &lt;value&gt;* % [ \, ] ] &#125;</div><div class="line"></div><div class="line">proto token value &#123; &lt;...&gt; &#125;;</div><div class="line"></div><div class="line">token value:sym&lt;number&gt; &#123;</div><div class="line">    &apos;-&apos;?</div><div class="line">    [ 0 | &lt;[1..9]&gt; &lt;[0..9]&gt;* ]</div><div class="line">    [ \. &lt;[0..9]&gt;+ ]?</div><div class="line">    [ &lt;[eE]&gt; [\+|\-]? &lt;[0..9]&gt;+ ]?</div><div class="line">&#125;</div><div class="line"></div><div class="line">token value:sym&lt;true&gt;   &#123; &lt;sym&gt;    &#125;;</div><div class="line">token value:sym&lt;false&gt;  &#123; &lt;sym&gt;    &#125;;</div><div class="line">token value:sym&lt;null&gt;   &#123; &lt;sym&gt;    &#125;;</div><div class="line">token value:sym&lt;object&gt; &#123; &lt;object&gt; &#125;;</div><div class="line">token value:sym&lt;array&gt;  &#123; &lt;array&gt;  &#125;;</div><div class="line">token value:sym&lt;string&gt; &#123; &lt;string&gt; &#125;</div><div class="line"></div><div class="line">token string &#123;</div><div class="line">    \&quot; ~ \&quot; [ &lt;str&gt; | \\ &lt;str_escape&gt; ]*</div><div class="line">&#125;</div><div class="line"></div><div class="line">token str &#123;</div><div class="line">    [</div><div class="line">        &lt;!before \t&gt;</div><div class="line">        &lt;!before \n&gt;</div><div class="line">        &lt;!before \\&gt;</div><div class="line">        &lt;!before \&quot;&gt;</div><div class="line">        .</div><div class="line">    ]+</div><div class="line">    # &lt;-[&quot;\\\t\n]&gt;+</div><div class="line">&#125;</div><div class="line"></div><div class="line">token str_escape &#123;</div><div class="line">    &lt;[&quot;\\/bfnrt]&gt; | u &lt;xdigit&gt;**4</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"># test it:</div><div class="line">my $tester = &apos;&#123;</div><div class="line">    &quot;country&quot;: &quot;Austria&quot;,</div><div class="line">    &quot;cities&quot;: [ &quot;Wien&quot;, &quot;Salzburg&quot;, &quot;Innsbruck&quot; ],</div><div class="line">    &quot;population&quot;: 8353243</div><div class="line">&#125;&apos;;</div><div class="line"></div><div class="line">if JSON::Tiny::Grammar.parse($tester) &#123;</div><div class="line">    say &quot;It&apos;s valid JSON&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    # TODO: error reporting</div><div class="line">    say &quot;Not quite...&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>词法包含了各种命名正则. 正则的名字和子例程或方法的名字的构建方式一样. 然而正则的名字完全按照词法的写法,当在grammar上执行 .parse() 方法时, 默认会调用名为 TOP 的正则. 所以, 调用 JSON::Tiny::Grammar.parse($tester) 会让字符串 $tester 与叫做 TOP 的正则表达式进行匹配.</p>
<p>然而, 例子中的代码似乎并没有一个叫做 TOP 的正则; 它有一个叫做 TOP 的 rule. 看一下 grammar, 你还能看见 token 声明. 区别是什么? 每个 token 和 rule 声明就是有特殊默认行为的正则声明. token 声明了正则默认不会回溯, 所以当部分模式匹配失败时, 正则引擎不会返回并重试另外的选项( 这等价于使用 <code>:ratchet</code> 修饰符) .  rule 默认也不会回溯, 此外, 连续的空白也被认为是重要的, 并在字符串中使用内置的 <code>&lt;ws&gt;</code> rule 会匹配真正的空白(这等价于使用 <code>:sigspace</code> 修饰符).</p>
<p>查看 sec:regexes 获取更多关于修饰符的信息和使用方法,或查看 S05文档.</p>
<p>通常, 当谈论 rules 或 tokens 的正则时, 我们趋向于叫它们 rules 或 tokens 而非更普通的项 regex, 这是为了区分它们之间的不同行为.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rule TOP &#123; ^[ &lt;object&gt; | &lt;array&gt; ]$ &#125;</div></pre></td></tr></table></figure>
<p>在这个例子中, TOP rule 锚定了匹配的开始和末尾, 以至于整个字符串是合法的 JSON 格式,以让匹配成功. 在字符串的开头匹配了锚点之后, 正则表达式尝试匹配一个 <code>&lt;array&gt;</code> 或 <code>&lt;object&gt;</code>. 把正则的名字包裹在一对儿尖括号中让正则引擎尝试在同一个 <code>grammar</code> 里通过名字匹配一个正则. 随后的匹配很易懂了, 反映了 JSON 组件出现的可能结构.  </p>
<p> 正则可以是递归的. 数组可能包含着值. 反过来值也可以包含数组.这不会引发无限循环,只要正则表达式的每次递归调用消耗至少一个字符. 如果一系列正则相互递归调用彼此,但不在字符串中移动, 递归可能进入无限循环并且永远不会处理 <code>grammar</code> 的其余部分.</p>
<p> JSON grammar 的例子介绍了目标匹配语法,即能够被呈现为: A ~B C. 在 JSON::Tiny::Grammar中, A 是 ‘{‘, B 是 ‘}’, 而 C 是 <code>&lt;pairlist&gt;</code>. 在波浪线左侧的原子(A) 被正常匹配. 一旦最后的原子匹配, 正则引擎会尝试匹配目标(B). 这里的作用是改变了最后两个原子(B 和 C ) 的匹配顺序, 但是因为 Perl 知道正则引擎应该查找目标, 当目标不匹配时,能给出更好的错误信息. 这对括号结构很有帮助, 因为括号彼此靠的很近.</p>
<p> 另外一个新奇的小东西是 proto token 声明:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> proto token value &#123; &lt;...&gt; &#125;;</div><div class="line"></div><div class="line"> token value:sym&lt;number&gt; &#123;</div><div class="line">    &apos;-&apos;?</div><div class="line">    [ 0 | &lt;[1..9]&gt; &lt;[0..9]&gt;* ]</div><div class="line">    [ \. &lt;[0..9]&gt;+ ]?</div><div class="line">    [ &lt;[eE]&gt; [\+|\-]? &lt;[0..9]&gt;+ ]?</div><div class="line">&#125;</div><div class="line">token value:sym&lt;true&gt;  &#123; &lt;sym&gt; &#125;;</div><div class="line">token value:sym&lt;false&gt; &#123; &lt;sym&gt; &#125;;</div></pre></td></tr></table></figure></p>
<p>sym 是 symbol 的简写, 表示符号.<br>proto token 语法表明 value 是一系列分支而非单个 regex. 每个分支有一个形如 token value:sym<code>&lt;thing&gt;</code> 的名字, 参数 sym 设置为 thing 的 value 分支. 这种分支的主体是正常的 regex, 而 <code>&lt;sym&gt;</code> 匹配参数的值, 在这个例子中就是 thing.</p>
<p>当调用 rule<code>&lt;value&gt;</code>时, grammar 引擎尝试并行地匹配所有分支,并且最长的匹配胜出. 这真的像极了普通分支, 但是就像我们下一节看到的那样, 他还有可扩展性的优势.</p>
<h3 id="Grammar-继承"><a href="#Grammar-继承" class="headerlink" title="Grammar 继承"></a>Grammar 继承</h3><hr>
<p> grammars 和 类的相似性让把正则存储在名字空间走的更深入, 就像类存储方法那样. 你可以从 grammars 继承并扩展grammars, 将 roles 混合到 grammars, 并且利用多态. 事实上, grammar 就是一个类, 它默认继承于 Grammar 而非 Any. Grammar 基础词法中广泛包含了有用的预定义好的 rules. 例如, 有一个匹配字母字符(<code>&lt;alpha&gt;</code>)的 rule, 还有一个匹配数字(<code>&lt;digit&gt;</code>)的, 还有个匹配空白符的(<code>&lt;ws&gt;</code>), 等等.</p>
<p> 假设你想增强 JSON 词法以允许单行 C++ 或 JavaScript 注释, 它们以 // 开始, 直到行的末尾. 最简单的增强方法是允许这样的注释出现在允许空白符的任何地方.</p>
<p> 然而, JSON::Tiny::Grammar 在 rules 的使用过程中只<code>隐式地</code>匹配空白符. 隐式空白是使用继承的正则 <code>&lt;ws&gt;</code>, 所以开启单行注释最简单的方法就是覆盖那个 ws 命名正则:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">grammar JSON::Tiny::Grammar::WithComments</div><div class="line">    is JSON::Tiny::Grammar &#123;</div><div class="line"></div><div class="line">    token ws &#123;</div><div class="line">    \s* [ &apos;//&apos; \N* \n ]?</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $tester = &apos;&#123;</div><div class="line">    &quot;country&quot;: &quot;Austria&quot;,</div><div class="line">    &quot;cities&quot;: [ &quot;Wien&quot;, &quot;Salzburg&quot;, &quot;Innsbruck&quot; ],</div><div class="line">    &quot;population&quot;: 8353243 // data from 2009-01</div><div class="line">&#125;&apos;;</div><div class="line"></div><div class="line">if JSON::Tiny::Grammar::WithComments.parse($tester) &#123;</div><div class="line">    say &quot;It&apos;s valid (modified) JSON&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开头两行引入一个 grammar , 这个 grammar 继承于 JSON::Tiny::Grammar. 就像子类从父类中继承方法一样, 所以 grammars 从它的 base grammar 中继承了 rules. 在 grammar 中使用的任何 rule, 在使用时首先要它曾经用过的 grammar 中进行查找, 然后才在它的 parent(s) 中查找.</p>
<p>在这个微型的 JSON grammar 中, 空白符从来不是强制性的, 所以 ws 可以什么也不匹配. 在可选的空白后面, 两个反斜杠 ‘//‘ 引入一个注释, 注释之后必须跟着任意数量的<code>非新行符</code>, 然后是一个换行符. 在散文中, 注释以 ‘//‘ 开头, 并延伸到该行的剩余部分.</p>
<p>继承的 grammars 也能添加变体到 proto tokens中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">grammar JSON::ExtendedNumeric is JSON::Tiny::Grammar &#123;</div><div class="line">    token value:sym&lt;nan&gt; &#123; &lt;sym&gt; &#125;</div><div class="line">    token value:sym&lt;inf&gt; &#123; &lt;[+-]&gt;? &lt;sym&gt; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个grammar中, 调用 <code>&lt;value&gt;</code> 会匹配两个新添加的分支中的一个, 或匹配父词法 JSON::Tiny::Grammar 中任意的旧分支. 这样的扩展性对于普通的, 使用 | 分隔的分支是很难实现的.</p>
<h3 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h3><hr>
<p>grammar 的 .parse 方法返回一个 <code>Match</code> 对象, 通过它我们可以获取匹配所有的相关信息.与散列相似,  命名正则在 grammar 中的匹配可以通过 Match 对象获取, 而键是正则表达式的名字, 键值是 <code>Match</code> 对象中, 代表整个正则匹配中它匹配到的那部分. 类似地, 匹配的一部分被圆括号捕获, 并作为 Match 对象(它就像一个数组) 的位置元素访问.</p>
<p>一旦你有了 Match 对象, 你能用它来做什么? 你可以递归遍历这个对象, 并基于你查找的东西或可执行的代码块来创建数据结构. Perl 6 提供了另外一种选择: action 方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> # JSON::Tiny::Grammar as above</div><div class="line"> # ...</div><div class="line">class JSON::Tiny::Actions &#123;</div><div class="line">    method TOP($/)      &#123; make $/.values.[0].ast              &#125;</div><div class="line">    method object($/)   &#123; make $&lt;pairlist&gt;.ast.hash           &#125;</div><div class="line">    method pairlist($/) &#123; make $&lt;pair&gt;».ast                   &#125;</div><div class="line">    method pair($/)     &#123; make $&lt;string&gt;.ast =&gt; $&lt;value&gt;.ast  &#125;</div><div class="line">    method array($/)    &#123; make [$&lt;value&gt;».ast]                &#125;</div><div class="line">    method string($/)   &#123; make join &apos;&apos;, $/.caps&gt;&gt;.value&gt;&gt;.ast &#125;</div><div class="line"></div><div class="line"> # TODO: make that</div><div class="line"> # make +$/</div><div class="line"> # once prefix:&lt;+&gt; is sufficiently polymorphic</div><div class="line">method value:sym&lt;number&gt;($/) &#123; make eval $/       &#125;</div><div class="line">method value:sym&lt;string&gt;($/) &#123; make $&lt;string&gt;.ast &#125;</div><div class="line">method value:sym&lt;true&gt;  ($/) &#123; make Bool::True    &#125;</div><div class="line">method value:sym&lt;false&gt; ($/) &#123; make Bool::False   &#125;</div><div class="line">method value:sym&lt;null&gt;  ($/) &#123; make Any           &#125;</div><div class="line">method value:sym&lt;object&gt;($/) &#123; make $&lt;object&gt;.ast &#125;</div><div class="line">method value:sym&lt;array&gt; ($/) &#123; make $&lt;array&gt;.ast  &#125;</div><div class="line"></div><div class="line">method str($/)               &#123; make ~$/           &#125;</div><div class="line"></div><div class="line">method str_escape($/) &#123;</div><div class="line">    if $&lt;xdigit&gt; &#123;</div><div class="line">        make chr(:16($&lt;xdigit&gt;.join));</div><div class="line">    &#125; else &#123;</div><div class="line">        my %h = &apos;\\&apos; =&gt; &quot;\\&quot;,</div><div class="line">        &apos;n&apos; =&gt; &quot;\n&quot;,</div><div class="line">        &apos;t&apos; =&gt; &quot;\t&quot;,</div><div class="line">        &apos;f&apos; =&gt; &quot;\f&quot;,</div><div class="line">        &apos;r&apos; =&gt; &quot;\r&quot;;</div><div class="line">        make %h&#123;$/&#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $actions = JSON::Tiny::Actions.new();</div><div class="line">JSON::Tiny::Grammar.parse($str, :$actions);</div></pre></td></tr></table></figure>
<p>这个例子传递了一个 action 对象给 grammars的 parse 方法. 每当 grammar 引擎解析完一个正则 regex,  就在 action 对象上调用一个方法, 方法的名字和正则的名字一样.  如果该方法不存在, grammar 引擎会继续解析剩余的 grammar. 如果确实存在这样的一个方法, grammar 引擎会把<code>当前的匹配对象</code>作为位置参数传递.</p>
<p>对有效负载的对象,每个匹配对象有一个叫做 ast(抽象语法树的简写 abstract syntax tree)的槽口. 这个槽持有能从 action 方法中创建的一般数据结构. 在 action 方法中调用 make $thing 把当前匹配对象的 ast 属性设置为了 $thing.</p>
<blockquote>
<p> 抽象语法树, 或者叫 AST, 是一种表现文本解析版本的数据结构. 你的词法描述了 AST 的结构: 它的根元素是 TOP 节点, 包含了允许类型的孩子等等.</p>
</blockquote>
<p>在 JSON 解析这个例子中, 有效负载是 JSON 字符串代表的数据结构. 对每个 matching rule , 词法引擎调用一个 action 方法生成匹配对象的抽象语法树 ast. 这个处理把 match tree 转换为不同的 tree – 这样, 真正的 JSON tree.</p>
<p>尽管 rules 和 action 方法处于不同的名字空间(并且在现实世界中工程甚至可能在各自的文件中), 这里它们连在一块来说明他们的关系:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rule   TOP     &#123; ^ [ &lt;object&gt; | &lt;array&gt; ]$  &#125;</div><div class="line">method TOP($/) &#123; make $/.values.[0].ast     &#125;</div></pre></td></tr></table></figure>
<p> TOP rule 有一个含有两个分支的选项, object 分支和 array 分支. 这两个都有一个命名捕获. <code>$/.values</code> 返回所有捕获的一个列表, 这儿要么是 object 要么是 array 捕获.</p>
<p> action 方法使 AST 附加到子捕获的匹配对象上, 并通过调用 make 把它提升为自己的 AST.<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rule object       &#123; &apos;&#123;&apos; ~ &apos;&#125;&apos; &lt;pairlist&gt;      &#125;</div><div class="line">method object($/) &#123; make $&lt;pairlist&gt;.ast.hash &#125;</div></pre></td></tr></table></figure></p>
<p> object 的 reduction 方法提取了 子匹配 pairlist 的 AST 结构, 并通过调用它的 hash 方法将它转换为一个散列.<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rule pairlist       &#123; &lt;pair&gt;* % [ \, ]   &#125;</div><div class="line">method pairlist($/) &#123; make $&lt;pair&gt;».ast; &#125;</div></pre></td></tr></table></figure></p>
<p> pairlist rule 匹配多个用逗号分隔的 pairs. reduction 方法在每个匹配的 pair 上调用 .ast 方法, 并把结果列表组装到它自己的 AST 中.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rule pair       &#123; &lt;string&gt; &apos;:&apos; &lt;value&gt;               &#125;</div><div class="line">method pair($/) &#123; make $&lt;string&gt;.ast =&gt; $&lt;value&gt;.ast &#125;</div></pre></td></tr></table></figure>
<p> 一个 pair 由字符串形式的键和值组成, 所以 action 方法使用 <code>=&gt;</code> 操作符创建了一个 Perl 6 的 pair.</p>
<p> 其他的 action 方法原理与此相同. 它们将他们从匹配对象中提取出来的信息转换为<code>原生的</code> Perl 6 <code>数据结构</code>, 并调用 <code>make</code> 把那些<code>原生的数据结构</code>转换为他们自己的 <code>ASTs</code>.</p>
<p> proto tokens 的 action 方法包含了每个独立 rule 的全名, 包括 <code>sym</code> 部分:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">token value:sym&lt;null&gt;        &#123; &lt;sym&gt;              &#125;;</div><div class="line">method value:sym&lt;null&gt;($/)   &#123; make Any           &#125;</div><div class="line"></div><div class="line">token value:sym&lt;object&gt;      &#123; &lt;object&gt;           &#125;;</div><div class="line">method value:sym&lt;object&gt;($/) &#123; make $&lt;object&gt;.ast &#125;</div></pre></td></tr></table></figure></p>
<p> 当一个 <code>&lt;value&gt;</code> 调用匹配时, 带有相同符号的 action 方法作为匹配 subrule 执行.</p>
<h2 id="第11章-内建类型、操作符和方法"><a href="#第11章-内建类型、操作符和方法" class="headerlink" title="第11章 内建类型、操作符和方法"></a>第11章 内建类型、操作符和方法</h2><hr>
<p>很多操作符需要特别的数据类型才能工作。如果操作数的类型与要求的不同，Perl 会复制一份操作数，并加盖它们转换为需要的类型。例如， $a + $b 会将$a和 $b的副本转换为数字（除非它们已经是数字了）。这种隐式的转换叫做强制变换。除了操作符之外，其它句法元素也强制转换它们的元素： <code>if</code> 和 <code>while</code> 会强制值为真（布尔）， <code>for</code> 会把东西看作列表，等等。</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><hr>
<p>最重要的类型是整数型:<br>Int</p>
<p>Int 对象存储任意大小的整数。如果你写出一个只含有数字的字面量，例如 12 ，那它就是整形。</p>
<p>Num<br>Num 是浮点型，它存储固定宽度的符号、尾数和指数。包含 Num 数字的计算通通常很快， though subject to limited precision.<br>诸如 6.022e23 使用科学计数法标记的是 Ｎum 类型。</p>
<p>Rat 有理数<br>Rat, 有理数的简称, 存储分数，不损失精度。它将跟踪它的分子和分母作为整数，所以使用大量的针对对有理数的数学运算会相当慢。因为这，含有大分母的有理数会自动降级为 Num。</p>
<p>Complex</p>
<p>复数有两部分组成:实部和虚部。 If 任一部分是 NaN,则整个数字可能都是 NaN。<br>复数的形式是 a + bi,其中 bi 是虚数部分，其类型为复数。</p>
<p>很多数学函数都有方法和函数两种形式，例如 (-5).abs 和 abs(-5) 结果一样.</p>
<p>三角函数 sin, cos, tan, asin, acos, atan, sec, cosec, cotan, asec,<br>acosec, acotan, sinh, cosh, tanh, asinh, acosh, atanh, sech, cosech, cotanh, asech, acosech 和 acotanh 默认使用弧度作为单位。 你可以指定Degrees, Gradians or Circles参数作为单位。例如,180.sin(Degrees) 近似于 0 。</p>
<pre><code>表 11.1 二元数字操作符
</code></pre><p>Table 11.2: 一元数字操作符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">操作符      描述</div><div class="line">+           转换为数字</div><div class="line">-           负</div></pre></td></tr></table></figure>
<p>数学函数和方法</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><hr>
<p>根据字符编码，字符串存储为 Str，它是字符序列。 Buf 类型用作存储二进制数据，  encode 方法将 Str  转换为 Buf. decode 相反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">字符串操作：</div><div class="line">Table 11.4: 二元字符串操作符</div><div class="line">操作符    描述</div><div class="line">~         连接: &apos;a&apos; ~&apos;b&apos; 是 &apos;ab&apos;</div><div class="line">x         重复: &apos;a&apos; x 2 is &apos;aa&apos;</div><div class="line"></div><div class="line">Table 11.5: 一元字符串操作符</div><div class="line">操作符  描述</div><div class="line"> ~      转换为字符串: ~1 变成 &apos;1&apos;</div><div class="line"></div><div class="line">Table 11.6: 字符串方法/函数</div><div class="line">方法/函数                                  描述</div><div class="line">.chomp                                     移除末尾的新行符</div><div class="line">.substr($start,$length)                    提取字符串的一部分。默认的，$length是字符串的剩余部分</div><div class="line">.chars                                     字符串中的字符数</div><div class="line">.uc                                        大写</div><div class="line">.lc                                        小写</div><div class="line">.ucfirst                                   首字符转换为大写</div><div class="line">.lcfirst                                   首字符转换为小写</div><div class="line">.capitalize                                将每个单词的首字符转换为大写，其余字符转换为小写</div></pre></td></tr></table></figure>
<h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><hr>
<p>布尔值要么为真，要么为假。在布尔上下文中，任何值都可以转化为布尔值。决定一个值是真是假要根据值的类型：</p>
<p>字符串</p>
<p>空字符串和 字符串  “0” 的值为假。任何其它字符串的值为真。</p>
<p>数字<br>除了 0 之外的所有数字的值为真。</p>
<p>列表和散列</p>
<p>诸如列表和散列等容器类型的值为假，如果它们是空的话，如果至少包含一个值，则为真。</p>
<p>诸如 if 之类的结构会自动在布尔上下文中求值。你可以在表达式前面放一个问号 ? 来强制一个显式的布尔上下文。用前缀符号   ! 反转布尔值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my $num = 5;</div><div class="line"></div><div class="line"># 隐式的布尔上下文</div><div class="line">if $num &#123; say &quot;True&quot; &#125;</div><div class="line"></div><div class="line"># 显式的布尔上下文</div><div class="line">my $bool = ?$num;</div><div class="line"></div><div class="line"># negated boolean context</div><div class="line">my $not_num = !$num;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[匿名状态变量的工作原理]]></title>
      <url>http://ohmycloud.github.io/2016/03/12/%E5%8C%BF%E5%90%8D%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="Anonymous-State-Variables-And-How-They-Work"><a href="#Anonymous-State-Variables-And-How-They-Work" class="headerlink" title="Anonymous State Variables And How They Work"></a>Anonymous State Variables And How They Work</h2><hr>
<p>当调试代码的时候, 我经常添加一个计数变量以用于循环, 所以我能跟踪发生了什么, 或我能在代码片段中处理正迭代的部分数据集:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my $event-no = 0;</div><div class="line">for get_events() -&gt; $event &#123;</div><div class="line">    $event-no++;</div><div class="line">    process-event($event);</div><div class="line">    last if $event-no &gt;= 5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你正在调试, 或者你正尝试在单行中节省空间, Perl  6 实际上有一个匿名状态变量(<em>anonymous state variables</em>)标记, 用不含名字的 <code>$</code>符号来标示(你还可以在很多可迭代对象身上使用 kv 方法来完成类似的东西, 但是匿名的 <code>$</code> 更普遍。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for get_events() -&gt; $event &#123;</div><div class="line">    process-event($event);</div><div class="line">    last if ++$ &gt;= 5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而, 注意; 下面这样的用法是没有效果的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for get_events() -&gt; $event &#123;</div><div class="line">    process-event($event);</div><div class="line">    $++;</div><div class="line">    last if $ &gt;= 5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了, 为什么是那样的？</p>
<h2 id="Use-the-Source"><a href="#Use-the-Source" class="headerlink" title="Use the Source"></a>Use the Source</h2><hr>
<p>好吧, 让我们来看看 Rakudo 源代码, 可以吗?</p>
<p>如你所想, 在 Perl 6 Grammar 中查找 <code>$</code> 是怎样被解析的将会是一个很困难的任务。所以我们让编译器自己来帮助我们! 我们会使用一个小例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for ^10 &#123; $++ &#125;</div></pre></td></tr></table></figure>
<p>并让 Rakudo 吐出它生成的 <strong>AST</strong>, 专门用于查找变量:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$ perl6 --target=ast -e <span class="string">'for ^10 &#123; $++ &#125;'</span> | <span class="keyword">grep</span> Var</div><div class="line">    - QAST::Var(attribute $!<span class="keyword">do</span>)</div><div class="line">    - QAST::Var(attribute $!<span class="keyword">do</span>)</div><div class="line">  - QAST::Var(<span class="keyword">local</span> __args_<span class="number">_</span> :decl(param))</div><div class="line">        - QAST::Var(lexical $¢ :decl(contvar))</div><div class="line">        - QAST::Var(lexical $! :decl(contvar))</div><div class="line">        - QAST::Var(lexical $/ :decl(contvar))</div><div class="line">        - QAST::Var(lexical $_ :decl(contvar))</div><div class="line">        - QAST::Var(lexical GLOBALish :decl(static))</div><div class="line">        - QAST::Var(lexical EXPORT :decl(static))</div><div class="line">        - QAST::Var(lexical $?PACKAGE :decl(static))</div><div class="line">        - QAST::Var(lexical ::?PACKAGE :decl(static))</div><div class="line">        - QAST::Var(lexical $=finish :decl(static))</div><div class="line">              - QAST::Var(lexical $ANON_VAR__1 :decl(statevar))</div><div class="line">              - QAST::Var(lexical $_ :decl(param))</div><div class="line">                    - QAST::Var(lexical $ANON_VAR__1) :BY&lt;EXPR/POSTFIX W&gt; :nosink&lt;?&gt; :WANTED $</div><div class="line">                      - QAST::Var(lexical $ANON_VAR__1) :BY&lt;EXPR/POSTFIX W&gt; :nosink&lt;?&gt; :WANTED $</div><div class="line">        - QAST::Var(lexical $=pod :decl(static))</div><div class="line">        - QAST::Var(lexical !UNIT_MARKER :decl(static))</div><div class="line">          - QAST::Var(<span class="keyword">local</span> ctxsave :decl(var))</div><div class="line">          - QAST::Var(contextual $*CTXSAVE)</div><div class="line">            - QAST::Var(<span class="keyword">local</span> ctxsave)</div><div class="line">              - QAST::Var(<span class="keyword">local</span> ctxsave)</div><div class="line">              - QAST::Var(<span class="keyword">local</span> ctxsave)</div></pre></td></tr></table></figure>
<p>你可能不会立即看到它, 但是那儿有一个可疑的声明: <code>$ANON_VAR__1</code>。现在我们有了一个搜索字符串并想得到更多相关的结果, 用 <a href="http://beyondgrep.com/" target="_blank" rel="external">ack</a> 这样的工具搜索源代码, 我们会找到 <code>src/Perl6/Actions.nqp</code>这个文件。让我们深入进去!</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># taken from rakudo@85d20f3</span></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">declare_variable</span>($/, $<span class="title">past</span>, $<span class="title">sigil</span>, $<span class="title">twigil</span>, $<span class="title">desigilname</span>, $<span class="title">trait_list</span>, $<span class="title">shape</span>?, :@<span class="title">post</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">elsif</span> $desigilname eq <span class="string">''</span> &#123;</div><div class="line">        <span class="keyword">if</span> $twigil &#123;</div><div class="line">            $/.CURSOR.panic(<span class="string">"Cannot have an anonymous variable with a twigil"</span>);</div><div class="line">        &#125;</div><div class="line">        $name    := QAST::Node.unique($sigil ~ <span class="string">'ANON_VAR_'</span>);</div><div class="line">        $varname := $sigil;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以这部分代码(搜索 <code>ANON_VAR</code> 时唯一的结果)告诉我们当我们声明一个符号后面没有名字的变量时, 我们应该生成一个唯一的名字。</p>
<h2 id="How-Did-We-Get-Here"><a href="#How-Did-We-Get-Here" class="headerlink" title="How Did We Get Here?"></a>How Did We Get Here?</h2><hr>
<p>那很好, 但是我们怎么从 grammar 中到达那里? 这种情况下我使用的小技巧就是抛出一个异常并查看回溯发生在哪?</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">declare_variable</span>($/, $<span class="title">past</span>, $<span class="title">sigil</span>, $<span class="title">twigil</span>, $<span class="title">desigilname</span>, $<span class="title">trait_list</span>, $<span class="title">shape</span>?, :@<span class="title">post</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">elsif</span> $desigilname eq <span class="string">''</span> &#123;</div><div class="line">        <span class="keyword">if</span> $twigil &#123;</div><div class="line">            $/.CURSOR.panic(<span class="string">"Cannot have an anonymous variable with a twigil"</span>);</div><div class="line">        &#125;</div><div class="line">+       <span class="keyword">if</span> nqp::atkey(nqp::getenvhash(), <span class="string">'ROB_DEBUG'</span>) &#123;</div><div class="line">+           $/.CURSOR.panic(<span class="string">"here I am!"</span>);</div><div class="line">+       &#125;</div><div class="line">        $name    := QAST::Node.unique($sigil ~ <span class="string">'ANON_VAR_'</span>);</div><div class="line">        $varname := $sigil;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重新编译之后, 打开 <code>ROB_DEBUG</code> 环境变量并运行,  并使用 <code>--ll-exception</code>, 来确保内部构件被包含进了堆栈跟踪中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ROB_DEBUG=1 perl6 --ll-exception -e &apos;for ^10 &#123; $++ &#125;&apos;</div></pre></td></tr></table></figure>
<p>我不会临时包含这个堆栈跟踪, 但是你可以自己生成它如果你愿意追随的话。通过查看出现在提到 <code>Actions.nqp:3160</code>（我插入异常的地方） 后面提到 <code>Grammar.nqp</code> 的第一个堆栈跟踪项, 我们来到 <code>Grammar.nqp</code>中的 <code>token variable</code>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># also taken from rakudo@85d20f3</span></div><div class="line">token variable &#123;</div><div class="line">    :<span class="keyword">my</span> $*IN_META := <span class="string">''</span>;</div><div class="line">    [</div><div class="line">    | :dba(<span class="string">'infix noun'</span>) <span class="string">'&amp;['</span> ~ <span class="string">']'</span> &lt;infixish(<span class="string">'[]'</span>)&gt;</div><div class="line">    | &lt;sigil&gt; &lt;twigil&gt;? &lt;desigilname&gt;</div><div class="line">      [ &lt;?&#123; !$*IN_DECL &amp;&amp; $*VARIABLE &amp;&amp; $*VARIABLE eq $&lt;sigil&gt; ~ $&lt;twigil&gt; ~ $&lt;desigilname&gt; &#125;&gt;</div><div class="line">        &#123; self.typed_panic: <span class="string">'X::Syntax::Variable::Initializer'</span>, <span class="string">name =&gt;</span> $*VARIABLE &#125; ]?</div><div class="line">    | &lt;special_variable&gt;</div><div class="line">    | &lt;sigil&gt; $&lt;<span class="keyword">index</span>&gt;=[\d+]                              [&lt;?&#123; $*IN_DECL &#125;&gt; &lt;.typed_panic: <span class="string">"X::Syntax::Variable::Numeric"</span>&gt;]?</div><div class="line">    | &lt;sigil&gt; &lt;?[&lt;]&gt; &lt;postcircumfix&gt;                      [&lt;?&#123; $*IN_DECL &#125;&gt; &lt;.typed_panic(<span class="string">'X::Syntax::Variable::Match'</span>)&gt;]?</div><div class="line">    | &lt;?before &lt;sigil&gt; &lt;?[ ( [ &#123; ]&gt;&gt; &lt;!RESTRICTED&gt; &lt;?&#123; !$*IN_DECL &#125;&gt; &lt;contextualizer&gt;</div><div class="line">    | $&lt;sigil&gt;=[<span class="string">'$'</span>] $&lt;desigilname&gt;=[&lt;[<span class="regexp">/_!¢]&gt;]</span></div><div class="line">    | &#123;&#125; &lt;sigil&gt; &lt;!&#123; $*QSIGIL &#125;&gt; &lt;?MARKER('baresigil')&gt;   # try last, to allow sublanguages to redefine sigils (like &amp; in regex)</div><div class="line">    ]</div><div class="line">    [ &lt;?&#123; $&lt;twigil&gt; &amp;&amp; $&lt;twigil&gt; eq '.' &#125;&gt;</div><div class="line">        [ &lt;.unsp&gt; | '\\' | &lt;?&gt; ] &lt;?[(]&gt; &lt;!RESTRICTED&gt; &lt;arglist=.postcircumfix&gt;</div><div class="line">    ]?</div><div class="line">    &#123; $*LEFTSIGIL := nqp::substr(self.orig(), self.from, 1) unless $*LEFTSIGIL &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码对你没有什么意义如果你初学 Perl 6的话, 更不用说 Rakudo 源代码了。我认为这一句是最重要的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| &#123;&#125; &lt;sigil&gt; &lt;!&#123; $*QSIGIL &#125;&gt; &lt;?MARKER(&apos;baresigil&apos;)&gt; # try last, to allow sublanguages to redefine sigils (like &amp; in regex)</div></pre></td></tr></table></figure>
<p>这个分支接受由符号唯一组成的变量。所以 <code>token variable</code> 匹配源代码中的每个裸的 <code>$</code> 实例, 并且每次发生都会调用 <code>Actions::declare_variable</code>, 生成不同的变量, 我用这个片段来说没明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">for ^3 &#123;</div><div class="line">    say ++$;</div><div class="line">    say ++$;</div><div class="line">&#125;</div><div class="line">=output</div><div class="line">1</div><div class="line">1</div><div class="line">2</div><div class="line">2</div><div class="line">3</div><div class="line">3</div></pre></td></tr></table></figure>
<p>所以, 对于匿名状态变量你只能执行非常简单的操作。记住你也可以使用匿名数组或匿名散列变量来处理东西:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ^<span class="number">10</span> &#123;</div><div class="line">    <span class="keyword">say</span>((@).push($_));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是在正式代码中不建议这么用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[token和rule的区别]]></title>
      <url>http://ohmycloud.github.io/2016/03/11/token%E5%92%8Crule%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>在 grammar 中, 有两个 regex 的变体, <code>rule</code> 和 <code>token</code>。rule 默认不会回溯.  rule 与 token 的一个重要区别就是, <code>rule</code> 这样的正则采取了 <code>:sigspace</code> 修饰符。 <code>rule</code> 实际上是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">regex :ratchet :sigspace &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>的简写.  ratchet 这个单词的意思是: (防倒转的)棘齿, 意思它是不能回溯的!  而 <code>:sigspace</code> 表明正则中的空白是<code>有意义的</code>, 而 <code>token</code> 实际上是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">regex :ratchet &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>的简写。 所以在 token 中, 若不是显式的写上 <code>\s</code>、<code>\h</code>、<code>\n</code> 等空白符号, 其它情况下就好像空白隐身了一样, 虽然你写了, 但是编译器却视而不见。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="keyword">use</span> Grammar::Debugger;</div><div class="line">grammar Token::Rule::Difference &#123;</div><div class="line">    <span class="comment"># 下面三者等价</span></div><div class="line">    <span class="comment"># rule TOP &#123; [\w+]+ % ' ' | [\d+]+ % ' '   &#125;  等价于</span></div><div class="line">    <span class="comment"># rule TOP &#123; | [\w+]+ % ' ' | [\d+]+ % ' ' &#125;  等价于</span></div><div class="line">    rule TOP &#123; | [\w+]+ % <span class="string">' '</span></div><div class="line">               | [\d+]+ % <span class="string">' '</span></div><div class="line">             &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># $=finish.lines 中的每一行末尾都没有换行符</span></div><div class="line"><span class="keyword">for</span> $=finish.lines -&gt; $line &#123;</div><div class="line">    <span class="keyword">print</span>($line);</div><div class="line">    <span class="keyword">say</span> Token::Rule::Difference.parse($line)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">=finish</span></div><div class="line">token takes whitespace invisible unless with sigspace</div><div class="line">rule is a token without sigspace</div><div class="line">2015 12 25</div><div class="line">2016 01 07</div></pre></td></tr></table></figure>
<p>说明在 rule 中, <code>|</code> 左右两边的空格会被忽略, 这通常是为了使格式对齐, 看起来不乱。另外 rule 中, 开头和末尾的空白也会被忽略。</p>
<p>如果每一行都带有换行符呢？</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="keyword">use</span> Grammar::Debugger;</div><div class="line">grammar Token::Rule::Difference &#123;</div><div class="line"></div><div class="line">    <span class="comment"># token TOP &#123; ^ [&lt;line&gt;\n]+ $ &#125;</span></div><div class="line">    <span class="comment"># token line &#123;</span></div><div class="line">    <span class="comment">#     | [\w+]+ % ' '</span></div><div class="line">    <span class="comment">#     | [\d+]+ % ' '</span></div><div class="line">    <span class="comment"># &#125;</span></div><div class="line"></div><div class="line"><span class="comment"># 等价于</span></div><div class="line"></div><div class="line">    rule TOP &#123; ^ &lt;wrap&gt;+ $&#125;</div><div class="line">    token wrap &#123; &lt;line&gt; &#125;</div><div class="line">    rule line &#123;</div><div class="line">         [\w+]+ % <span class="string">' '</span> | [\d+]+ % &lt;[-\<span class="keyword">s</span>:]&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $str = <span class="keyword">q</span>:to/EOF/;</div><div class="line">token takes whitespace invisible <span class="keyword">unless</span> with sigspace</div><div class="line">rule is a token without sigspace</div><div class="line"><span class="number">2015</span>-<span class="number">12</span>-<span class="number">25</span> <span class="number">12</span>:<span class="number">23</span></div><div class="line"><span class="number">2016</span>-<span class="number">01</span>-<span class="number">07</span> <span class="number">13</span>:<span class="number">45</span></div><div class="line">EOF</div><div class="line"></div><div class="line"><span class="keyword">my</span> $parse = Token::Rule::Difference.parse($str);</div><div class="line"><span class="keyword">say</span> $parse;</div></pre></td></tr></table></figure>
<h2 id="token-vs-rule"><a href="#token-vs-rule" class="headerlink" title="token vs. rule"></a>token vs. rule</h2><hr>
<blockquote>
<p>When we use rule in place of token, any whitespace after anatom is turned into a non-capturing call to ws                                    </p>
</blockquote>
<p>这句话是说, 在 <code>rule</code> 中, 任何跟在原子(atom)后面的空白会变成非捕获的<code>ws</code>调用, 即 <code>&lt;.ws&gt;</code>, </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rule entry &#123; &lt;key&gt; <span class="string">'='</span> &lt;value&gt; &#125;</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">token entry &#123; &lt;key&gt; &lt;.ws&gt; <span class="string">'='</span> &lt;.ws&gt; &lt;value&gt; &lt;.ws&gt; &#125; <span class="comment"># .抑制了捕获</span></div></pre></td></tr></table></figure>
<p>在 grammar 中, 我们继承了默认的 <code>ws</code>, 但是我们也可以提供自己的 ws:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">token ws &#123; \h* &#125; <span class="comment"># 匹配水平空白, 不包括换行</span></div></pre></td></tr></table></figure>
<p>rule 中空白的使用:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $str = <span class="string">"Swift          is hard    to  learn"</span>;</div><div class="line"><span class="keyword">my</span> token word &#123; \w+ &#125;</div><div class="line"><span class="keyword">my</span> rule  line &#123; &lt;word&gt;+ % [<span class="string">','</span> ] &#125;</div><div class="line">$str ~~ <span class="keyword">m</span>:g/ &lt;line&gt; <span class="regexp">/;</span></div></pre></td></tr></table></figure>
<p>逗号附近的方括号保证了 <code>&lt;.ws&gt;</code> 调用产生的空白作为分割符的一部分。这利用了 <code>&lt;.ws&gt;</code> 的一个特点：</p>
<p>在两个 <code>\w</code> 之间解释为 <code>\s+</code>, 其它地方解释为 <code>\s*</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-圣诞月历-(2009)]]></title>
      <url>http://ohmycloud.github.io/2016/03/11/Perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2009/</url>
      <content type="html"><![CDATA[<h1 id="2009"><a href="#2009" class="headerlink" title="2009"></a>2009</h1><hr>
<h2 id="有用的和有意思的循环"><a href="#有用的和有意思的循环" class="headerlink" title="有用的和有意思的循环"></a>有用的和有意思的循环</h2><hr>
<p>让我们来看一个基本的例子.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for 1, 2, 3, 4 &#123; .say &#125;</div></pre></td></tr></table></figure>
<p>  这是一个最简单清晰的语法的例子.在这并没有使用<code>括号</code>来包起整个列表的语句,象这种写法可以贯穿整个 Perl 6. 通常比起 Perl 5 来你没有必要写那么多的括号了.</p>
<p>很象 Perl 5 , 这个循环中的值会默认存到 <code>$_</code> .在这个方法调用的 say 其实就是 <code>$_.say</code>.注意在 Perl 6 中,你不能直接只打一个 say  而不加参数,它会默认使用 $<em> 来传参.你需要使用 <code>.say</code> 。要么明确的指定是 `$</em>`.</p>
<p>下面这个语法块并不是一个普通的块.它能通过一个尖的指向,来告诉你的 循环变量传进去的参数的名字 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for 1, 2, 3, 4 -&gt; $i &#123; $i .say &#125;</div></pre></td></tr></table></figure>
<pre><code>如果你调用的 return 内部有这个,将返回闭合的子函数.
这个尖尖也能取 多个 参数.象下面这样.
</code></pre><p>1<br>2<br>3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for 1, 2, 3, 4 -&gt; $i , $j &#123; &quot;$i, $j&quot; .say &#125;</div><div class="line"># 1 2</div><div class="line"># 3 4</div></pre></td></tr></table></figure>
<p>实际做了些什么啦？就是你在列表进行迭代时一次取了<code>两个</code>元素 . 如果你不明确指明参数的话,就退化到 Perl 5 一样使用 <code>$_</code>.</p>
<p>我们可以意识到这个我们能做什么,比如迭代一个列表。当然,也可以是一个数组的值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for @array &#123; .say &#125;</div></pre></td></tr></table></figure>
<p>  这是一个非常简单的例子,我们可能更加喜欢使用 <code>map:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@array.map : *.say;</div></pre></td></tr></table></figure>
<p>如果对你来讲 顺序 和连续的并不重要,你可以使用 <code>hyperoperator（超运算符）</code>,上一个文章中也讲过这个,今天的主题也不详细讲这个了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@array».say;</div></pre></td></tr></table></figure>
<p>我们也能使用 范围构造器中缀操作符 <code>..</code> 来生成一个数字的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for 1..4 &#123; .say &#125;</div></pre></td></tr></table></figure>
<p>有一个最通用的功能,就是我们想些生成一个从 <code>0</code> 开始到 <code>$n</code> 的数字的列表,比如常用的数组下标.我们可以写成 <code>0 .. $n-1</code>或者另一个不同的范围构造器 <code>0..^$n</code>.但在 Perl 6 中提供了一个短的快捷的方法就是使用前缀的 <code>^</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for ^4 &#123; .say &#125;</div></pre></td></tr></table></figure>
<p>0<br>1<br>2<br>3</p>
<p>一个常用的理由是,人们在 Perl 5 中常常退回到 C 风格的循环的原因是必须知道 for 的成员数组中索引的位置,或者因为必须并行的迭代二个和更多的数组.Perl 6 提供了一个短的快捷方法,就是中缀的 Z 这个 zip 操作符.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for @array1 Z @array2 -&gt; $one , $two &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>假设二个数组是相同的长度<code>$one</code> 会是第一个 <code>@array1</code> 的成员元素,<code>$two</code> 会是相应的位置 <code>@array2</code> 的成员元素.如果是不同的长度的话.迭代会停止到短的那个数组结束的长度.<br>        我们可以很容易地在迭代数组包含进索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for ^Inf Z @array -&gt; $index , $item &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>如果一个无限长的列表,会让你害怕使用上面用法的话,可以象下面这样,使用前缀操作符 <code>^</code> 来取出数组元素的长度.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for ^@array.elems Z @array -&gt; $index , $item &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>上面这个可以得到相同的结果,但是更加优雅.因为中缀操作符 <code>Z</code> 操作时,第一个元素的长度决定了什么整个长度.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for @array.kv -&gt; $index , $item &#123; ... &#125;</div></pre></td></tr></table></figure>
<p><code>@array.kv</code> 会返回 <code>keys</code> 和 <code>values</code> 的交错,这个 <code>$key</code> 是数组元素的下标.所以同时迭代这二个可能是你比较想要的效果.<br>希望这篇文章让你了解 Perl 6 灵活的循环相关的一些概念,它们可以灵活的使用在各种常见任务上.在这之前,我要回答最后一个问题,我知道有人一直在想这个问题.怎么样一次性迭代四个数组.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for @one Z @two Z @three Z @four -&gt; $one , $two , $three , $four &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>这是一个关联列表中缀操作符,这样使用,是不是一种享受？</p>
<h2 id="超运算符"><a href="#超运算符" class="headerlink" title="超运算符"></a>超运算符</h2><hr>
<p>pmichaud 在昨天介绍了 Perl 6 的 hyper 运算符,我这要进一步来探索 Perl6 中强大的元操作的特性.<br>首先,为简单起见,我将编写一个 lsay 的函数,可以轻松地得到好看的列表值的输出.这个 sub 是用我们用 Perl 来创建的</p>
<p>  our sub lsay( @a ) { @a.perl.say }</p>
<p>接下来我们看 hyperoperator 的例子.在这个中,我们使用 <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> 来替换 <code>»</code> 和 <code>«</code>, 主要因为这样更加容易看(我怕我会需要眼镜). <code>»</code>和<code>«</code> 是语言中真实的形式,但较长的 ASCII 字符版本也是可以正常工作的.</p>
<p>首先.来个基本的:<br>添加两个相同长度的列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; (1, 2, 3, 4) &lt;&lt;+&gt;&gt; (3, 1, 3, 1)</div><div class="line">4, 3, 6, 5</div><div class="line">&gt; (1, 2, 3, 4) &gt;&gt;+&lt;&lt; (3, 1, 3, 1)</div><div class="line">4, 3, 6, 5</div></pre></td></tr></table></figure>
<p>如果数组的长度是相同的,上面这两种形式之间没有区别.但是,如果长度是不同的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; (1, 2, 3, 4) &lt;&lt;+&gt;&gt; (3, 1)</div><div class="line">4, 3, 6, 5</div><div class="line">&gt; (1, 2, 3, 4) &gt;&gt;+&lt;&lt; (3, 1)</div></pre></td></tr></table></figure>
<pre><code>Sorry, lists on both sides of non-dwimmy hyperop are not of same length : left: 4 elements, right: 2 elements
</code></pre><p>  这规则是, 象诸如此类的尖尖是用来表明 hyperoperator 使用时,当一端比另一端短,可以延长短的那一端来进行扩展延伸.</p>
<p>象如果是尖尖指向内部,是指不能进行扩展延伸.当然,还可以有各种组合都是可以的.所以你也能指出只有<code>左边</code>能扩展延伸 (<code>&lt;&lt;+&lt;&lt;</code>),也可以只指出只有<code>右边</code>能(<code>&gt;&gt;+&gt;&gt;</code>).当然也能二边都是可以扩展延伸 (<code>&lt;&lt;+&gt;&gt;</code>),或者二边都不能扩展延伸 (<code>&gt;&gt;+&lt;&lt;</code>).  R 语言中也有向量的循环法则。<br>单标量扩展延伸如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; (1, 2, 3, 4) &gt;&gt;+&gt;&gt; 2</div><div class="line">3, 4, 5, 6</div><div class="line">&gt; 3 &lt;&lt;+&lt;&lt; (1, 2, 3, 4)</div><div class="line">4, 5, 6, 7</div></pre></td></tr></table></figure>
<p>因此,这就是基本的使用中缀操作符 hyperoperator 的方法.您还可以使用前缀和后缀运算符：<br>单边运算时，元素要能漏到操作符的左边(  如<code>@a&gt;&gt;++</code>  )或右边（ 如 <code>~&lt;&lt;</code>  ）。想象一下漏斗，总是从大的口向小的口漏。<br>所以操作符前面或后面接什么样的超运算符要取决于操作数是在操作符的前面（用<code>&gt;&gt;</code>）或后面(用<code>&lt;&lt;</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; ~&lt;&lt;(1, 2, 3, 4)    # ~(1,2,3,4)</div></pre></td></tr></table></figure>
<p>超运算符就是在普通运算符的后面，加强普通运算符的功能。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; ~&lt;&lt; &quot;1&quot; , &quot;2&quot; , &quot;3&quot; , &quot;4&quot;</div><div class="line">&gt; -&lt;&lt;(1, 2, 3, 4)</div><div class="line">-1 -2 -3 -4</div><div class="line">&gt; my @a = (1, 2, 3, 4);</div><div class="line">@a&gt;&gt;++;</div><div class="line">@a ;    # 单边运算时，@a与&gt;&gt;之间不能有空格，如不能写成@a &gt;&gt;+</div><div class="line">2, 3, 4, 5</div></pre></td></tr></table></figure>
<p>你也能这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; (0, pi/4, pi/2, pi, 2*pi)&gt;&gt;.sin  # R 中向量化的运算</div><div class="line">0, 0.707106781186547, 1, 1.22464679914735e-16, -2.44929359829471e-16</div><div class="line">&gt; (-1, 0, 3, 42)&gt;&gt;.Str</div><div class="line">&quot;-1&quot; , &quot;0&quot; , &quot;3&quot; , &quot;42&quot;</div></pre></td></tr></table></figure>
<p>这其实就是只是想说 <code>&gt;&gt;.</code> 是调用列表中的每一个成员的一种方法。点 (.)也是一个操作符</p>
<p>其他说明：hyperoperators 并不只是只能和内置操作符一起工作.他们也将能跟你定义以及任何新的运算符工作的很好（即大多数的的都能正常在现在的 Rakudo 上工作）.</p>
<p>只要给放在适当的地方.如<code>@a &gt;&gt;/=&gt;&gt;2</code> 整个数组成员都除以 2. 他们将来能和更多的结构一起工作,如多维列表,树与哈希;我们可 S03 Hyper operators .(据我所知,有些功能还尚未在 Rakudo 正常实现)</p>
<p>我并不知道是否有很多代码示例中广泛使用 hyperoperators. 但 LastOfTheCarelessMen’s Vector 是一个非常好的实现.它使用单循环直接的实现了一个 N 维向量类.</p>
<p><a href="https://github.com/LastOfTheCarelessMen/Vector/blob/master/lib/Vector.pm" target="_blank" rel="external">N维向量</a></p>
<h2 id="reduce-和-hyper-元操作符"><a href="#reduce-和-hyper-元操作符" class="headerlink" title="reduce 和 hyper 元操作符"></a>reduce 和 hyper 元操作符</h2><hr>
<p>Hyper  亢奋的；精力旺盛的 Hyper[ˈhaɪpə(r)]</p>
<p>今天是第四天,在这个小盒子中,你会见到一些有意思的实现阶乘的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub fac( Int $n ) &#123;</div><div class="line">        [*] 1.. $n</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Okay, 它是怎么工作的？ 今天的 Advent 的盒子就是为了给你提供答案.<br>Perl 6 有一些不同的”元操作符”是用来修改现有的运算符完成更加强大的功能.<br>这个方括号中是一个有关“reduce metaoperator”的元操作符的例子,它是中缀运算符,会变成列表操作,操作是在后面各个元素的中间来, 例如,表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[+] 1, $a , 5, $b</div></pre></td></tr></table></figure>
<p>  它相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 + $a + 5 + $b</div></pre></td></tr></table></figure>
<p>这为我们提供了非常便利的机制“计算整个列表中的所有元素之和”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sum = [+] @a ; # @a 中所有元素之和</div></pre></td></tr></table></figure>
<p>更多的中缀运算符(包含用户自己定义的),都能放到这个方括号来减少操作符;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$prod   = [*] @a ;         # 相乘 @a 中所有的元素</div><div class="line">$mean   = ([+] @a ) / @a ; # 计算 @a 的平均值</div><div class="line">$sorted = [&lt;=] @a ;        # 如果 @a 元素是数字排序就为 true</div><div class="line">$min    = [min] @a , @b ;  # find the smallest element of @a and @b combined</div></pre></td></tr></table></figure>
<p>在那个阶乘的子函数中,表达示 <code>[*] 1..$n</code> 返回全部 <code>1</code> 到 <code>$n</code> 之间所有乘数的乘积.</p>
<p>另一个非常有用的元操作符是 “hyper” 操作符,放置 <code>&gt;&gt;</code>（与<code>|</code>或）<code>&lt;&lt;</code> 在操作符的二边(一边),使得那个操作 “hyper”（更亢奋）.这个是用来操作列表中所有的成员,来进行这个包起来的运算符的操作.象下面的例子,我们来打算从 @a 和 @b 中成对的取出数据来进行运算后存入 @c.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@c = @a &gt;&gt;+&lt;&lt; @b ;</div></pre></td></tr></table></figure>
<p>如果是在 Perl 5 中,我们需要写成象才面这样才能完成.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ( $i = 0; $i &lt; @a ; $i ++) &#123;</div><div class="line">        $c [ $i ] = $a [ $i ] + $b [ $i ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这只是有点长.</p>
<p>正如上面的方括号中,我们可以使用Hyper作用在各种运算符上,包括用户定义操作符：<br>  注：可以这样记忆 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符，它们就像是<code>漏斗</code>，<code>&lt;&lt;</code>  让元素从<code>右边</code>漏入，<code>&gt;&gt;</code> 让元素从<code>左边</code>漏入，然后进行运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 对 @xyz 中所有的元素进行 ++ 的操作</div><div class="line">@xyz &gt;&gt;++</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 从@a 和 @b 中找出最小的元素放到 @x 中</div><div class="line">@x = @a   &gt;&gt;min&lt;&lt; @b ;</div></pre></td></tr></table></figure>
<p>我们还可以<code>翻转&lt;&lt;的角度</code>,使标量的行为像一个<code>数组</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># @a 中每个成员都乘 3.5  </div><div class="line">my @a=2,4,6;</div><div class="line">@b = @a   &gt;&gt;*&gt;&gt; 3.5;</div></pre></td></tr></table></figure>
<p>这其实相当于 <code>@b = @a   &gt;&gt;*&lt;&lt; (3.5,3.5,3.5）</code> 较短的向量会被自动循环使用！模仿 R 语言的短向量自动循环。<br>如果右边的向量没有左边的长，箭头就指向那个单个向量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># @x 中每个成员都乘以 $m 然后在加 $b</div><div class="line">@y = @x   &gt;&gt;*&gt;&gt; $m &gt;&gt;+&gt;&gt; $b ;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 颠倒 @x 中所有的成员</div><div class="line">@inv = 1  &lt;&lt;/&lt;&lt; @x ;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># concatenate @last, @first to produce @full</div><div class="line">@full = ( @last   &gt;&gt;~&gt;&gt; &apos;, &apos; )  &gt;&gt;~&lt;&lt; @first ;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; my @string=&lt;I LOVE YOU&gt;</div><div class="line">I LOVE YOU</div><div class="line">&gt; @string &gt;&gt;~&gt;&gt;&apos;-&apos; &gt;&gt;~&gt;&gt; &quot;szx&quot;</div><div class="line">I-szx LOVE-szx YOU-szx</div></pre></td></tr></table></figure>
<p><code>&gt;&gt;~&lt;&lt;</code> 两侧的元素个数必须相同！<br>当然,reductions 和 hyper 操作符也能联合表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 计算 @x 的平方和</div><div class="line">$sumsq = [+] ( @x   &gt;&gt;**&gt;&gt; 2);</div></pre></td></tr></table></figure>
<p>还有很多其他元操作符,包括X（cross交叉）,R（reverse反向）,S（顺序sequential）.事实上,这只是在恰当的位置放个运算符,如<code>+=,*=,?=</code>,只是元形式的后缀等号运算,它相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$a += 5;     # same as $a = $a + 5;</div><div class="line">$b = 7;      # same as $b = $b 7;</div><div class="line">$c min= $d ; # same as $c = $c min $d;</div></pre></td></tr></table></figure>
<h2 id="static-types-和-multi-subs"><a href="#static-types-和-multi-subs" class="headerlink" title="static types 和 multi subs."></a>static types 和 multi subs.</h2><hr>
<p>打开Advent 这第三个盒子,这次我们要读到什么啦？啊….真好.这次没想到有二个礼物.这个盒子中放着 <code>static types</code> 和 <code>multi subs</code>.<br>在 Perl 5 中,<code>$scalar</code> 的标量只能包含二种东西引用或值,这值可以是任何东西,能是整数,字符,数字,日期和你的名字.这通常是非常方便的,但并不明确.<br>在 Perl6 中给你机会修改标量的类型 .如果你这个值比较特别,你可以直接放个类型名在 <code>my</code> 和 <code>$variable</code> 的中间.象下面的例子,是在设置値一定要是一个 Int 型的数据,来节约 cpu 判断类型的时间,和让你更少的程序上出错.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my Int $days = 24;</div></pre></td></tr></table></figure>
<p>其它的标量类型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my Str $phrase   = &quot;Hello World&quot; ;</div><div class="line">my Num $pi       = 3.141e0;</div><div class="line">my Rat $other_pi = 22/7;</div></pre></td></tr></table></figure>
<p>如果你还是想用老的设置值的方法,你可以不声明类型或使用 Any 的类型代替.</p>
<p>今天盒子中的第二个礼物 <code>multi subs</code> 也很容易,因为我们会手把手教你.到底什么是 <code>multi subs</code> ? 简单的来讲 <code>multi subs</code> 可以让我们 重载 <code>sub</code> 的名字 .当然 <code>Multi subs</code> 可以做更多其它的事情,所以下次其它作者的礼物中也会有这个,但现在我们会先介绍几个非常有用的一些 sub .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">multi sub identify(Int $x) &#123;</div><div class="line">    return &quot;$x is an integer.&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub identify(Str $x) &#123;</div><div class="line">    return qq&lt;&quot;$x&quot; is a string.&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub identify(Int $x, Str $y) &#123;</div><div class="line">    return &quot;You have an integer $x, and a string \&quot;$y\&quot;.&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub identify(Str $x, Int $y) &#123;</div><div class="line">    return &quot;You have a string \&quot;$x\&quot;, and an integer $y.&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub identify(Int $x, Int $y) &#123;</div><div class="line">    return &quot;You have two integers $x and $y.&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi sub identify(Str $x, Str $y) &#123;</div><div class="line">    return &quot;You have two strings \&quot;$x\&quot; and \&quot;$y\&quot;.&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say identify(42);</div><div class="line">say identify(&quot;This rules!&quot;);</div><div class="line">say identify(42, &quot;This rules!&quot;);</div><div class="line">say identify(&quot;This rules!&quot;, 42);</div><div class="line">say identify(&quot;This rules!&quot;, &quot;I agree!&quot;);</div><div class="line">say identify(42, 24);</div></pre></td></tr></table></figure>
<p>还有两个礼物很有优势吧.你可以尝试多使用他们,我们会不断的丰富这个 Advent 的树,并不断放更多的礼物,希望你能多来看看.</p>
<h2 id="comb-your-constraints"><a href="#comb-your-constraints" class="headerlink" title=".comb your constraints"></a>.comb your constraints</h2><hr>
<p>我们以前 advent 了解过的内容,对于今天所要介绍的礼物非常有用,今天要讲两个东西： comb 方法和 constraints 的概念。</p>
<p>constraints 和原来那章节中提到的<code>静态变量</code>定义的相同,constraints 可以让我们在写程序的时候就更方便的在子函数和方法上进行控制.</p>
<p>在很多其它的程序中,你可以通过参数调用子函数并可以在参数进入的时候就通过 <code>constraints</code> 来验证输入的内容.这样我们就能在程序声明的时候就验证输入的内容,不在需要等到程序运行的时候.</p>
<p>下面是一个基本的例子,如果是一个整数和偶数,在子函数中它会不能处理下去.在 Perl 5 中的实际基本就象下面这样子了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub very_odd</div><div class="line">&#123;</div><div class="line">   my $odd = shift;</div><div class="line">   unless ($odd % 2)</div><div class="line">   &#123;</div><div class="line">       return undef;</div><div class="line">   &#125;</div><div class="line">   # 在这接着处理奇数.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Perl 6 中,我们可以只需要简单的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub very_odd(Int $odd where &#123;$odd % 2&#125;)</div><div class="line">&#123;</div><div class="line">      # 在这接着处理奇数.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你试图来传入一个偶数来调用 very_odd.你会直接得到一个 error.不要担心：你可以使用 multi sub 的功能来给偶数一个机会:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">multi sub very_odd(Int $odd where &#123;$odd % 2&#125;)</div><div class="line"> &#123;</div><div class="line">     # Process the odd number here</div><div class="line">&#125;</div><div class="line">multi sub very_odd(Int $odd) &#123; return Bool::False; &#125;</div></pre></td></tr></table></figure>
<p>我们在使用成对的 <code>.comb</code> 方法时,这个 <code>constraints</code> 是非常有用.</p>
<p>为什么正好是 <code>.comb</code> ? 当我们早上梳整我们的头发时,我们先通常使用梳子来梳成你想要的样子(线条),然后在你的头上固定梳成的样子.前面讲的内容在这非常象.split.在这也一样,你<code>不是真想</code>要切开字符串,而是你想达到一个什么样目的.这一段简单的代码,来说明这两种目标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;say &quot;Perl 6 Advent&quot;.comb(/&lt;alpha&gt;/).join(&apos;|&apos;);</div><div class="line">P|e|r|l|A|d|v|e|n|t</div><div class="line">&gt;say &quot;Perl 6 Advent&quot;.comb(/&lt;alpha&gt;+/).join(&apos;|&apos;);</div><div class="line">Perl|Advent</div></pre></td></tr></table></figure>
<p>正则表达式有可能另一天会拿出来讲,但是我们先快速了解一下是没有坏处的.这个第一行,会输出 <code>P|e|r|l|A|d|v|e|n|t</code>. 它会取得每个字母然后放到一个暂时的数组中,然后使用 <code>join</code> 管道连接起来这是目的.第二行也有点象,但它捕获了更多的字母,会输出 <code>Perl|Advent</code> 这是第二个的目标单词.<br>这个 <code>.comb</code> 是非常非常强大,然而,你得到你梳出来的输出,你就能操作这个串了如果你有一个基本的ASCII十六进制字符的字符串,可以使用的 hyperoperators 超的操作符转变各自的块成为等效的 ASCII 字符！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;5065726C36&quot;.comb(/&lt;xdigit&gt;**2/)».fmt(&quot;0x%s&quot;)».chr</div></pre></td></tr></table></figure>
<pre><code># Outputs &quot;Perl6&quot;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;5065726C36&quot;.comb(/&lt;xdigit&gt;**2/)</div></pre></td></tr></table></figure>
<pre><code>50 65 72 6C 36
</code></pre><p><code>**</code>在正则里是量词，表示重复前面的十六进制数两次，合起来就是每两个字符分一下。</p>
<p>如果你提心这个,你可以使用 <code>.map</code> 的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;5065726C36&quot;.comb(/&lt;xdigit&gt;**2/).map: &#123; chr &apos;0x&apos; ~ $_ &#125; ;</div></pre></td></tr></table></figure>
<pre><code>#Outputs &quot;Perl6&quot;
</code></pre><p>记的,这是 Perl.做任何事情都不只一种方法.<br>今天给完了所有礼物,我现在向你挑战.有 KyleHasselbacher 的协助,我们能使用约束<code>.comb</code> 和 <code>.map</code> 做出一个像样的版本的古老的凯撒加密法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">sub rotate_one( Str $c where &#123; $c.chars == 1 &#125;, Int $n ) &#123;</div><div class="line">   return $c if $c !~~ /&lt;alpha&gt;/;</div><div class="line">   my $out = $c.ord + $n;</div><div class="line">   $out -= 26 if $out &gt; ($c eq $c.uc ?? &apos;Z&apos;.ord !! &apos;z&apos;.ord);</div><div class="line">   return $out.chr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub rotate(Str $s where &#123;$s.chars&#125;, Int $n = 3)</div><div class="line">&#123;</div><div class="line">   return ($s.comb.map: &#123; rotate_one( $_, $n % 26 ) &#125;).join( &apos;&apos; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">die &quot;Usage:\n$*PROGRAM_NAME string number_for_rotations&quot; unless @*ARGS == 2;</div><div class="line"></div><div class="line">my Str $mess   = @*ARGS[0];</div><div class="line">my Int $rotate = @*ARGS[1].Int;</div><div class="line"></div><div class="line">say qq|&quot;$mess&quot; rotated $rotate characters gives &quot;&#123;rotate($mess,$rotate)&#125;&quot;.|;</div></pre></td></tr></table></figure>
<p>我希望你在休息的时候,可以使用目前为止在 Perl 6 中和今天的礼物中的学到的内容来编写编码算法.毕竟,编程语言本身只有更多的使用,才能让它变的更优秀.</p>
<h2 id="一个正则表达式的故事"><a href="#一个正则表达式的故事" class="headerlink" title="一个正则表达式的故事"></a>一个正则表达式的故事</h2><hr>
<p>By perlpilot</p>
<p>在 advent 的第十天,我们有一个故事做为礼物……</p>
<p>曾几何时,在比你想象的更近的时候,一个叫 Tim 的学 Perl 6 程序的学生,工作中出现了一个简单的解析相关的问题.他的老板（我们叫他 C 先生）曾问过他,解析日志文件中包含着库存信息,确保在文件内是唯一有效的行.文件中每行内是这样的：<br>    <part number=""> <quantity> <color> <description></description></color></quantity></part></p>
<p>所以这个 Perl 6 的学生,他用熟悉正则表达式写了一个可爱的小正则表达式,可以用来找出有效的行.代码检查每行内容是这样写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">next unless $line ~~ / ^^ \d+ \s+ \d+ \s+ \S+ \s+ \N* $$ /</div></pre></td></tr></table></figure>
<p>使用 <code>~~</code> 操作符的原因是因为,右侧的正则表达式会匹配左侧标量.在正则内部,<code>^^</code> 是匹配行的开头,<code>\d+</code> 是用来匹配一个或者多个数字(由零件编号 part number 和数量 quantity 组成的),<code>\S+</code> 是用来匹配一个或者多个非空白字符,<br> <code>\N*</code> 来匹配零个或者多个非换行符,<code>\s+</code> 匹配空白之间的这些东西和 <code>$$</code> 用来匹配行结束.<br>在 Perl 6 中,正则表达式的每个单独的部分可以使用空格来让它更具可读性,所以更加好,这个空格不会是正则的一部分只用来分隔.</p>
<p>但 C 先生决定最好信息的每个部分都可以从提取来验证. Tim 想了一下,“没问题,我只要使用括号来捕获”.下面就是全部需要做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">next unless $line ~~ / ^^ (\d+) \s+ (\d+) \s+ (\S+) \s+ (\N*) $$ /</div></pre></td></tr></table></figure>
<p>在成功的模式匹配以后,每个括号内都存着匹配到的对象本身(<code>$/</code>),可以通过 <code>$/[0]</code>,<code>$/[1]</code>,<code>$/[2]</code> 或 <code>$/[3]</code>.它可以通过特殊的变量 <code>$0</code>,<code>$1</code>,<code>$2</code>,<code>$3</code>访问.Tim 和他老板 C 先生都很高兴.</p>
<p>但随后发现了一些行中,没有从描述信息中给颜色信息分开,这些行其实也是有效的.在行中颜色信息和描述信息有个特殊的组合方式.他们总是象下面这样：</p>
<pre><code>&lt;part number&gt; &lt;quantity&gt; &lt;description&gt; (&lt;color&gt;)
</code></pre><p>在这像以前一样,可以加入包括任意数量的空格在字符中. Tim 认为,“现在这个本来简单的解析程序似乎突然更加复杂了”.幸运的是,Tim 可以找一个地方寻求帮助.他迅速登录到 <code>irc.freenode.org</code>,加入 <code>#perl6</code> 通道 并请求大家协助.有人建议他使用名字来命名他的正则表达式的各个部分,来使事情变得更容易.然后使用交替的方法来匹配这个正则表达式的最后一部分的多种可能.</p>
<p>首先,Tim 尝试给正则能捕获到的每个部分都加上一个名字,详细信息可以见 Perl 6 正则的纲要,下面是他所做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">next unless $line ~~</div><div class="line">    / ^^ $&lt;product&gt;=(\d+) \s+ $&lt;quantity&gt;=(\d+) \s+ $&lt;color&gt;=(\S+) \s+ $&lt;description&gt;=(\N*) $$ /</div></pre></td></tr></table></figure>
<p>现在,成功的匹配后,每各部分都可以匹配到对象中不同的东西,通过特殊的变量 <code>$&lt;Product&gt;</code>,<code>$&lt;quantity&gt;</code>,<code>$&lt;color&gt;</code> 和 <code>$&lt;description&gt;</code>.<br>这比预期的更容易,让 Tim 感到非常有信心.接着,他需要补充：交替区分两种不同的有效行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">next unless $line ~~ / ^^</div><div class="line">    $&lt;product&gt;=(\d+) \s+ $&lt;quantity&gt;=(\d+) \s+</div><div class="line">    [</div><div class="line">    | $&lt;description&gt;=(\N*) \s+ &apos;(&apos; $&lt;color&gt;=(\S+) &apos;)&apos;</div><div class="line">    | $&lt;color&gt;=(\S+) \s+ $&lt;description&gt;=(\N*)</div><div class="line">    ]</div><div class="line">  $$</div><div class="line">/</div></pre></td></tr></table></figure>
<p>为了从正则表达式中的交替和其余部分隔离开,Tim 使用了分组括号（<code>[ and ]</code>）在要交替检查的部分.<br>这个分组是正则的一部分,其中像圆括号是唯一没有捕捉到 <code>$0</code> 的, 由于必须匹配到精确的圆括号, Tim 使用了另一个有用的 Perl6 正则表达式的优势：带引号的字符串字面匹配.因为分配给正则表达式的中 <code>$&lt;color&gt;</code> 和 <code>$&lt;description&gt;</code> 总是会在适当部分包含字符串.</p>
<p>Tim 非常的扬眉吐气！他展示了他的代码给 Mr.C,并表扬到 “干得好 Tim！”;</p>
<p>然而,经过成功过后,Tim 开始以更挑剔的眼光来看他的工作.对于一些行中描述之后颜色,它有可能是 <code>( color)</code> or <code>(color )</code> or<code>( color )</code>.他目前正则表达式是正常的,但如果描述中包括的颜色的部分象前面一样时,并不是所有匹配颜色的会设置 <code>$&lt;color&gt;</code>. Tim 初步修复,通过加入更多的 <code>\s*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">next unless $line ~~ / ^^</div><div class="line">    $&lt;product&gt;=(\d+) \s+ $&lt;quantity&gt;=(\d+) \s+</div><div class="line">    [</div><div class="line">    | $&lt;description&gt;=(\N*) \s+ &apos;(&apos; \s* $&lt;color&gt;=(\S+) \s* &apos;)&apos;</div><div class="line">    | $&lt;color&gt;=(\S+) \s+ $&lt;description&gt;=(\N*)</div><div class="line">    ]</div><div class="line">  $$</div><div class="line">/</div></pre></td></tr></table></figure>
<p>这运行的非常良好,但正则表达式的开始显得有点凌乱.Tim 再次使用 #perl6 来让人帮助.</p>
<p>这时候有个名叫 PerlJam 告诉他,“你为什么不把你的正则表达式放到 <code>grammar</code> 中？这可以让你分配给每片到变量来匹配对象”“ Wha?? Tim 不知道 PerlJam 讲的是什么.通过简短的交流后,Tim 了解后,并知道在哪里查看必须的相关信息后.然后感谢 PerlJam,并在次回到了程序上.这一次的正则表达式几乎消失,因为它使用了 grammar.什么是 grammar ？,看下面匹配的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">grammar Inventory &#123;</div><div class="line">    regex product     &#123; \d+ &#125;</div><div class="line">    regex quantity    &#123; \d+ &#125;</div><div class="line">    regex color       &#123; \S+ &#125;</div><div class="line">    regex description &#123; \N* &#125;</div><div class="line">    regex TOP &#123; ^^ &lt;product&gt; \s+ &lt;quantity&gt;  \s+</div><div class="line">                [</div><div class="line">                | &lt;description&gt; \s+ &apos;(&apos; \s* &lt;color&gt; \s*  &apos;)&apos;</div><div class="line">                | &lt;color&gt; \s+ &lt;description&gt;</div><div class="line">                ]</div><div class="line">                $$</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"># ...在来到代码开始的地方</div><div class="line">next unless Inventory.parse($line);</div></pre></td></tr></table></figure>
<p>以前的正则表达式中各自的变量变成了 grammar 中的命名正则表达式.在 Perl 6 的正则表达式中的命名正则是由括在尖括号内的名称来匹配（<code>&lt; and &gt;</code>）.当 <code>Grammar.parse</code> 调用来匹配一个标量时（会操作这特定的命名正则 <code>TOP</code>）行为是完全和以前一样,因为命名的正则表达相当于其它正则表达式的一部分,匹配的文本保存到匹配对象中,并引用该名称.</p>
<p>虽然仍然有改进的余地,Tim 和 Mr.C 对这个结果感到非常高兴.</p>
<p>完<br>注：默认情况下,允许启用空格注解； 所以,虽然在 Perl 5 中您可以用“hello there”本身来匹配“hello there”,但在 Perl 6 中,您必须将其改为 /hello <code>&lt;sp&gt;</code> there/.这样就可以在正则表达中将条件清晰地分离开来.</p>
<p>Perl 6 正则表达式可以被复用.在匹配单一的词时,复用正则表达式是很荒谬的；但在解析配置文件时,几乎必须要复用正则表达式（这取决于配置文法的复杂度、发生修改的频率等）.这样性能也会高很多.</p>
<p>在 Perl 5 中, Regexp::Common 模块,已经在尝试复用正则表达式,但是,因为 Perl 5 不允许复用正则表达式,所以不得不将它们封装在一个模块接口中. Perl 6 完全支持这种复用.<br><a href="http://www.ibm.com/developerworks/cn/linux/l-cpregex.html" target="_blank" rel="external">其它参数资料：</a></p>
<h2 id="类-属性-方法和其它"><a href="#类-属性-方法和其它" class="headerlink" title="类, 属性, 方法和其它"></a>类, 属性, 方法和其它</h2><hr>
<p>By jnthnwrthngtn</p>
<p>我非常兴奋地撕下今天的礼物上闪亮的包装纸,里面是无可争议的 Perl 6 的对象模型,它内置了其类声明,角色组成,自豪的元模型(meta-model).除了有先进的功能外,让我们看看在 Perl 6 中是多么容易写一个类.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Dog &#123;</div><div class="line">    has $.name;</div><div class="line">    method bark($times) &#123;</div><div class="line">        say &quot;w00f! &quot; x $times;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们开始使用一个 class 的关键字.如果你有学过 Perl5 的话,你能想到的类有点像包(package)的变种,这个关键字为您提供一个优雅的语义.</p>
<p>接下来,我们使用 has 的关键字来声明属性访问器方法.这个”.”的东西名叫 twigil. Twigil 是用来告诉你指定变量的作用域.它是”属性 + 存取方法”的组合.它的选项是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">has $!name;       # 私有; 只能在内部可见</div><div class="line">has $.name is rw; # Generates an l-value accessor</div></pre></td></tr></table></figure>
<p>接下来是方法的使用,并介绍使用 method 的关键字.在对象中的方法象包中的子函数,不同之处在于方法是放在类的方法列表的条目中.<br>它还能自动取得调用者(invocant),所以你如果没有在参数列表中加入参数.它是会给自我传递过去.在 Perl 5 中需要我们显示的写 <code>$self = shift</code>.</p>
<p>所有的类都继承一个叫 new 的默认的构造器,会自动的映射命名参数到属性,所有传进的参数会存到属性中.我们可以调用 Dog 的构造器(这个 Dog 的类的对象,并取得一个新的实例).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my  $fido = Dog.new(name =&gt; &apos;Fido&apos;);</div><div class="line">say $fido.name;  # Fido</div><div class="line">$fido.bark(3);   # w00f! w00f! w00f!</div></pre></td></tr></table></figure>
<p>请注意,Perl 6 中的方法调用操作符是”.”而不是 Perl 5 中使用的”-&gt;”.它缩短了 50％ 并更加合适从其他语言转过来的开发人员.</p>
<p>当然,很容易实现继承,下面我们建一个叫 puppy 子类 ,直接使用 is 加父类的名字就行了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Puppy is Dog &#123;</div><div class="line">    method bark($times) &#123;</div><div class="line">        say &quot;yap! &quot; x $times;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这也支持委托,详细作用见下面的 FQA.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class DogWalker &#123;</div><div class="line">    has $.name;</div><div class="line">    has Dog $.dog handles (dog_name =&gt; &apos;name&apos;);</div><div class="line">&#125;</div><div class="line">my $bob = DogWalker.new(name =&gt; &apos;Bob&apos;, dog =&gt; $fido);</div><div class="line">say $bob.name;      # Bob</div><div class="line">say $bob.dog_name;  # Fido</div></pre></td></tr></table></figure>
<p>在这里,我们声明指出我们想调用 DogWalker 类的名为 dog_name 的方法,并设置这个方法转到 Dog 类中包含名为 name 的方法.重命名只是其中的一个可选方式;委托常常有很多其它的实现方法.</p>
<p>内心深层之美比外在更加重要.所以,在整洁的语法之下是使用 meta-model(元模型)想法来实现对象.类,属性和方法都是 Perl 6 中最重要和 Meta-object 的.我们可以在运行时使用这些内省对象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for Dog.^methods(:local) -&gt; $meth &#123;</div><div class="line">    say &quot;Dog has a method &quot; ~ $meth.name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 <code>.^</code> 的操作是 <code>.</code> 操作的变种,用来替换元类(metaclass-描述类的这个对象)的调用.在这里,我们提供该类所定义的方法(Method)的列表,我们使用  <code>:local</code> 来排除那些从父类的继承. 这不只是给我们一个名字列表,而是方法对象的列表.其实我们直接使用这个对象来调用方法,但在这种情况下,我们只要它的名字就行.</p>
<p>让你了解 Meta-programming 并附送一个扩展 Perl6 的对象的功能：只要你知道声明一个方位,使用 method 的关键字让它在编译时在调用元类中的  add_method 来变成实际的方法.所以在 Perl 6 中,不仅为您提供了强大的对象模型,但也提供了机会,用来实现其它的特性,以满足未来我们还没有想到的需求.</p>
<p>这些都只是 Perl 6 的对象模型所提供的伟大的事情中的一些,也许我们会发现更多的东西在其他礼品中. :-)</p>
<p>注：<br>面向对象的概念</p>
<p>首先,我们定义几个预备性的术语.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">构造器 (constructor):   创建一个对象的函数.</div><div class="line">实例 (instance)：  一个对象的实例化实现.</div><div class="line">标识 (identity)：  每个对象的实例都需要一个可以唯一标识这个实例的标记.</div><div class="line">实例属性 (instance attribute)：  一个对象就是一组属性的集合.</div><div class="line">实例方法 (instance method)：  所有存取或者更新对象某个实例一条或者多条属性的函数的集合.</div><div class="line">类属性(class attribute)：  属于一个类中所有对象的属性,不会只在某个实例上发生变化.</div><div class="line">类方法(class method)：  那些无须特定的对性实例就能够工作的从属于类的函数.</div><div class="line">委托 (Delegation)： 　在对象需要执行某个工作时并不直接处理，而是要求另一个对外象代为处理(有时只处理部分工作),所以这时第二个对象代表第一个对象来执行该操作。</div><div class="line">调用者(invocant):   对类来讲,调用者是包的名字,对实例方法来讲,调用者是指定对象的引用.换句话讲,调用者就是调用方法的那种东西,有的文章叫他为代理(agent)施动者(actor).</div><div class="line">抽象类(abstract class):抽象类实现类的占位符，主要用来定义行为，而子类用来实现这个行为。</div></pre></td></tr></table></figure>
<h2 id="arguments-and-parameters"><a href="#arguments-and-parameters" class="headerlink" title="arguments and parameters"></a>arguments and parameters</h2><hr>
<p>By carl</p>
<p>在第９天的 advent 中…我打开了　…这是有关 parameters 和 arguments<br>你也许了解或者不了解 Perl5 的 是怎么处理函数参数的.先让你看看,它通常象下面的这个例子这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub sum &#123;</div><div class="line">   [+] @_</div><div class="line">&#125;</div><div class="line">say sum 100, 20, 3; # 123</div></pre></td></tr></table></figure>
<p>这个 [+] 是在 Perl 6 中的,但我们也可以写成 Perl 5 风格的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $i = 0;</div><div class="line">$i _= $_ for @_;</div><div class="line">$i;</div></pre></td></tr></table></figure>
<p>我们要想到上面这些区别,这些在 Perl 6 中非常重要,也就是为什么我们讲 Perl 6 比 Perl 5 好.当你调用函数时.你可以从 @_ 找到你的参数.你然后取出它们来做一些操作.<br>这是非常灵活的.因为它不会对参数做任何默认的处理,程序会全部传给你来进行处理.当然这也同样是令人厌烦因为样样都要自己处理,但很方便我们来进行扩展进行参数的检查,看下面这个虚构的例子.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub grade_essay &#123;</div><div class="line">  my ($essay, $grade) = @_;</div><div class="line">  die &apos;The first argument must be of type Essay&apos;</div><div class="line">    unless $essay ~~ Essay;</div><div class="line">  die &apos;The second argument must be an integer between 0 and 5&apos;</div><div class="line">    unless $grade ~~ Int &amp;&amp; $grade ~~ 0..5;</div><div class="line"></div><div class="line">  %grades&#123;$essay&#125; = $grade;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(如果在 Perl 5 中,你需要使用 isa 来替换　~~　和使用 %grades 来替换成 $grades 才能正常工作.除了这些,都在 Perl6 中工作)</p>
<p>现在,这一刻,看看上面的内容,看到手册中的参数验证的实现,你是不是开始有点绝望吗？你感觉到了吧？好.<br>在 Perl 5 中的解决方法是使用优秀的 CPAN 模块,象 <code>Sub::Signatures</code> 和 <code>MooseX::Declare</code>,然后在你的程序中使用这些模块,并按照模块设置就行了.</p>
<p>在 Perl 6 的中的解决方法是,给你参数设置默认范围. 我在想看了下面这些时, “请确保键盘前的你不会流口水”.在 Perl 6 中,我会写这样来写子函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub grade_essay(Essay $essay, Int $grade where 0..5) &#123;</div><div class="line">  %grades&#123;$essay&#125; = $grade;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们见到,在这程序运行会对这个长版本的参数进行检查,没有必要在导入其它的 CPAN 的模块了.</p>
<p>有时,我们可以提供一些默认的值给参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub entreat($message = &apos;Pretty please, with sugar on top!&apos;, $times = 1) &#123;</div><div class="line">    say $message for ^$times;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这些参数的默认的值是不固定的,可以使用老的方式来传参数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub xml_tag ($tag, $endtag = matching_tag($tag) ) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>如果您的参数是不确定的,对这种可选的参数可以加一个 ? 的标记.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub deactivate(PowerPlant $plant, Str $comment?) &#123;</div><div class="line">  $plant.initiate_shutdown_sequence();</div><div class="line">  say $comment if $comment;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有一个特性,我特别喜欢,我们可以在调用时通过参数名字来引用参数,这样你可以以喜欢的任何顺序传递命名参数.这样会永远记得在这个函数中参数本来的顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub draw_line($x1, $y1, $x2, $y2) &#123; ... &#125;</div><div class="line"></div><div class="line">draw_line($x1, $y1, $x2, $y2); # phew. got it right this time.</div><div class="line">draw_line($x1, $x2, $y1, $y2); # dang! :-/</div></pre></td></tr></table></figure>
<p>这的方法是引用参数的名字,来使得这个问题被解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">draw_line(:x1($x1), :y1($y1), :x2($x2), :y2($y2)); # works</div><div class="line">draw_line(:x1($x1), :x2($x2), :y1($y1), :y2($y2)); # also works!</div></pre></td></tr></table></figure>
<p>冒号的意思是 “这来自命名参数”, 整个结构读作:name_of_parameter($variable_passed_in).这可以使用的参数和变量具有相同的名称,但有一个简短形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">draw_line(:$x1, :$y1, :$x2, :$y2); # works</div><div class="line">draw_line(:$x1, :$x2, :$y1, :$y2); # also works!</div></pre></td></tr></table></figure>
<p>我喜欢短形式.我觉得它使我的代码更具可读性.</p>
<p>如果作为 API 的作者,要强迫别人使用命名参数 – 例如还是在 draw_line 的情况下 – 你只需要提供在子程序参数前的冒号.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub draw_line(:$x1, :$y1, :$x2, :$y2 ) &#123; ... &#125; # optional nameds</div></pre></td></tr></table></figure>
<p>但要小心注意,命名参数默认是可选的.换句话说,上述内容相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub draw_line(:$x1?, :$y1?, :$x2?, :$y2?) &#123; ... &#125; # optional nameds</div></pre></td></tr></table></figure>
<p>如果你想明确地指出必需的参数,可以追加！对下面的这些参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub draw_line(:$x1!, :$y1!, :$x2!, :$y2!) &#123; ... &#125; # required nameds</div></pre></td></tr></table></figure>
<p>现在调用这个,就像他们是普通的顺序位置参数传递进来.</p>
<p>关于可变参数呢？假如你想传递的参数是不确认多少个数量,比如参数是数组,可以在它前面带有“*”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub sum(*@terms) &#123;</div><div class="line">  [+] @terms</div><div class="line">&#125;</div><div class="line">say sum 100, 20, 3;  # 123</div></pre></td></tr></table></figure>
<p>我使用同样的例子来提出一个观点：当你不提供任何符号到您的子程序时,你最终是得到的符号其实是是 <code>*@_</code> .这是模拟 Perl 5 中的行为.</p>
<p>但数组前面的 * 号是仅用来捕获的位置参数(positional arguments).如果你想捕捉命名参数(named arguments),你要使用 “slurpy hash”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub detect_nonfoos(:$foo!, *%nonfoos) &#123;</div><div class="line">  say &quot;Besides &apos;foo&apos;, you passed in &quot;, %nonfoos.keys.fmt(&quot;&apos;%s&apos;&quot;, &apos;, &apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">detect_nonfoos(:foo(1), :bar(2), :baz(3));</div><div class="line"># Besides &apos;foo&apos;, you passed in &apos;bar&apos;, &apos;baz&apos;</div></pre></td></tr></table></figure>
<p>哦,这可能是一个很好的通过以命名的参数传递哈希的方法,像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">detect_nonfoos(foo =&gt; 1, bar =&gt; 2, baz =&gt; 3);</div><div class="line"># Besides &apos;foo&apos;, you passed in &apos;bar&apos;, &apos;baz&apos;</div></pre></td></tr></table></figure>
<p>这里的 Perl 5 中的一个重要区别：默认参数是只读的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub increase_by_one($n) &#123;</div><div class="line">  ++$n</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $value = 5;</div><div class="line">increase_by_one($value); # boom</div></pre></td></tr></table></figure>
<p>在这让参数只读,主要有两个原因,其一为了效率.当变量只读时可以使其最佳化,其二要鼓励程序员写程序时有个正确的习惯,只会有一点点不习惯.<br>所以这个功能不仅是为优化好,更是为了让你有个更好的灵魂.</p>
<p>下面是你需要做的工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub increase_by_one($n is rw) &#123;</div><div class="line">   ++$n</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $value = 5;</div><div class="line">say increase_by_one($value); # 6</div></pre></td></tr></table></figure>
<p>有时可能你想让你的这个参数可以读写(RW),但是有时你可能更想修改传进来的参数复本.当你想使用这个 copy 时:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub format_name($first, $middle is copy, $last) &#123;</div><div class="line">    $middle .= substr(0, 1);</div><div class="line">    &quot;$first $middle. $last&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原内容将保持不变.</p>
<p>在 Perl 6 中,当传递一个数组或哈希时,默认情况下它并不会给数组和哈希拉平成几个参数.相反,当你想让参数扁平化时可以使用”|”.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sub list_names($x, $y, $z) &#123;</div><div class="line">    &quot;$x, $y and $z&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @ducklings = &lt;huey dewey louie&gt;;</div><div class="line">try &#123;</div><div class="line">    list_names(@ducklings);</div><div class="line">&#125;</div><div class="line">say $!; # &apos;Not enough positional parameters passed;</div><div class="line"># got 1 but expected 3&apos;</div><div class="line">say list_names(|@ducklings); # &apos;huey, dewey and louie&apos;</div></pre></td></tr></table></figure>
<p>同样,如果扁平化一个哈希,其参数内容将作为命名的参数(named arguments)发送到函数.</p>
<p>正如您传送数组和哈希一样,你也可以传送代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub traverse_inorder(TreeNode $n, &amp;action) &#123;</div><div class="line">    traverse_inorder($n.left, &amp;action) if $n.left;</div><div class="line">    action($n);</div><div class="line">    traverse_inorder($n.right, &amp;action) if $n.right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面前三个印记符号(@ % &amp; )其实是类型约束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@ Array (actually, Positional)</div><div class="line">% Hash (actually, Associative)</div><div class="line">&amp; Code (actually, Callable)</div><div class="line"></div><div class="line">$ 的印记是工作在不受约束的版本.</div></pre></td></tr></table></figure>
<p>当心！常出的简单的小陷阱是人们常常落入指定类型约束两次,还都是同一个类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub f(Array @a) &#123; ... &#125; # WRONG, unless you mean Array of Array</div><div class="line">sub f( @a)      &#123; ... &#125; # probably what you meant</div><div class="line">sub f(Int @a)   &#123; ... &#125; # Array of Int</div></pre></td></tr></table></figure>
<p>你学到这,你应得的另一个 Perl6 单行…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;.fmt(&quot;%b&quot;).trans(&quot;01&quot; =&gt; &quot; #&quot;).say for &lt;734043054508967647390469416144647854399310&gt;.comb(/.**7/)&apos;</div></pre></td></tr></table></figure>
<h2 id="Going-to-the-Rats"><a href="#Going-to-the-Rats" class="headerlink" title="Going to the Rats"></a>Going to the Rats</h2><hr>
<p>As I hinted at back in the in the Day 1 post, Perl 6 has rational numbers. They are created in the most straightforward fashion, by dividing an integer with another integer. But it can be a bit hard to see that there is anything unusual about the result:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; say (3/7).WHAT</div><div class="line">Rat()</div><div class="line">&gt; say 3/7</div><div class="line">0.428571428571429</div></pre></td></tr></table></figure>
<p>When you convert a Rat to a Str (for example, to “say” it), it converts to a decimal representation. This is based on the principle of least surprise: people generally expect 1/4 to equal 0.25. But the precision of the Rat is exact, rather than the approximation you’d get from a floating point number like a Num:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; say (3/7).Num + (2/7).Num + (2/7).Num - 1;</div><div class="line">-1.11022302462516e-16</div><div class="line">&gt; say 3/7 + 2/7 + 2/7 - 1</div><div class="line">0</div></pre></td></tr></table></figure>
<p>The most straightforward way to see what is going on inside the Rat is to use the .perl method. .perl is a standard Perl 6 method which returns a human-readable string which, when eval’d, recreates the original object as closely as is possible:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; say (3/7).perl</div><div class="line">3/7</div><div class="line">You can also pick at the components of the Rat:</div><div class="line">&gt; say (3/7).numerator</div><div class="line">3</div><div class="line">&gt; say (3/7).denominator</div><div class="line">7</div><div class="line">&gt; say (3/7).nude.perl</div><div class="line">[3, 7]</div></pre></td></tr></table></figure>
<p>All the standard numeric operators and operations work on Rats. The basic arithmetic operators will generate a result which is also a Rat if that is possible; the rest will generate Nums:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; my $a = 1/60000 + 1/60000; say $a.WHAT; say $a; say $a.perl</div><div class="line">Rat()</div><div class="line">3.33333333333333e-05</div><div class="line">1/30000</div><div class="line">&gt; my $a = 1/60000 + 1/60001; say $a.WHAT; say $a; say $a.perl</div><div class="line">Num()</div><div class="line">3.33330555601851e-05</div><div class="line">3.33330555601851e-05</div><div class="line">&gt; my $a = cos(1/60000); say $a.WHAT; say $a; say $a.perl</div><div class="line">Num()</div><div class="line">0.999999999861111</div><div class="line">0.999999999861111</div></pre></td></tr></table></figure>
<p>(Note that the 1/60000 + 1/60000 didn’t work in the last official release of Rakudo, but is fixed in the Rakudo github repository.)<br>There also is a nifty method on Num which creates a Rat within a given tolerance of the Num (default is 1e-6):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; say 3.14.Rat.perl</div><div class="line">157/50</div><div class="line">&gt; say pi.Rat.perl</div><div class="line">355/113</div><div class="line">&gt; say pi.Rat(1e-10).perl</div><div class="line">312689/99532</div></pre></td></tr></table></figure>
<p>One interesting development which has not made it into the main Rakudo build yet is decimal numbers in the source are now spec’d to be Rats. Luckily this is implemented in the ng branch, so it is possible to demo how it will work once it is in mainstream Rakudo:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; say 1.75.WHAT</div><div class="line">Rat()</div><div class="line">&gt; say 1.75.perl</div><div class="line">7/4</div><div class="line">&gt; say 1.752.perl</div><div class="line">219/125</div></pre></td></tr></table></figure>
<p>One last thing: in Rakudo, the Rat class is entirely implemented in Perl 6. The source code is thus a pretty good example of how to implement a numeric class in Perl 6.</p>
<h2 id="pick-your-game"><a href="#pick-your-game" class="headerlink" title=".pick your game"></a>.pick your game</h2><hr>
<p>December 15, 2009<br>又一个大学学期结束了，或者快要结束了，对于身在美国的大多数来说。这个礼物会有些乐趣，他可以 .pick 东西。<br>.pick 允许从一个列表中选择随机的元素，先来看看Perl5 的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @dice = (1, 2, 3, 4, 5, 6);</div><div class="line">my $index = int (rand() * scalar @dice);</div><div class="line">print $dice[$index] . &quot;\n&quot;;</div></pre></td></tr></table></figure>
<blockquote>
<p>5</p>
</blockquote>
<p>Perl 6 可以简化这，同时能选择多个元素.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @dice = 1..6;</div><div class="line">say @dice.pick(2).join(&quot; &quot;);</div></pre></td></tr></table></figure>
<pre><code>&gt; 3 4
</code></pre><p>仅仅使用一套骰子，你就可以和你的朋友们进行角色扮演的会话了。现在让我们看看使用 10 次6面的骰子会有多少攻击：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @dice = 1..6;</div><div class="line">say @dice.pick(10).join(&quot; &quot;);</div></pre></td></tr></table></figure>
<pre><code>&gt; 5 3 1 4 2 6
</code></pre><p>对那些怀疑者，上面的结果并非拼写错误。 <code>.pick</code> 的行为实际上和它的名字是一致的。当你把某个东西选出来，你通常不会把它放回去了。如果你想把它们再放回去，允许同一个项目被再次选中，请在第二个参数中使用副词 :repalce。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @dice = 1..6;</div><div class="line">say @dice.pick(10, :replace).join(&quot; &quot;);</div></pre></td></tr></table></figure>
<pre><code>&gt; 4 1 5 6 4 3 3 5 1 1
</code></pre><p>Note to game masters: don’t invite me to your D&amp;D games unless you need someone with terrible dice luck. ;)<br>There is no specific order the list items have to be in for .pick to work its magic. Take the values of monopoly money, for instance:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @dice = &lt;1 5 10 20 50 100 500&gt;;</div><div class="line">say @dice.pick(10, :replace).join(&quot; &quot;);</div></pre></td></tr></table></figure>
<pre><code>&gt; 20 50 100 500 500 10 20 5 50 20
</code></pre><p>When dice aren’t available, a deck of cards is usually on hand. This version is very basic, but is meant to get ideas going.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">class Card</div><div class="line">&#123;</div><div class="line">  has $.rank;</div><div class="line">  has $.suit;</div><div class="line"></div><div class="line">  multi method Str()</div><div class="line">  &#123;</div><div class="line">    return $.rank ~ $.suit;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @deck;</div><div class="line">for &lt;A 2 3 4 5 6 7 8 9 T J Q K&gt; -&gt; $rank</div><div class="line">&#123;</div><div class="line">  for &lt;♥ ♣ ♦ ♠&gt; -&gt; $suit</div><div class="line">  &#123;</div><div class="line">    @deck.push(Card.new(:$rank, :$suit));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"># Shuffle the cards.</div><div class="line">@deck .= pick(*);</div><div class="line">say @deck.Str;</div></pre></td></tr></table></figure>
<pre><code>&gt; Not outputting the results here.
</code></pre><p>What does the pick(*) do? Call that a sneak peak for another gift. For now, see if you can improve on the card code and make a deck class.<br>With that, I hope I have proven that Perl 6 is fun. It certainly gets a high mark from me. ✓</p>
<h2 id="Whatever"><a href="#Whatever" class="headerlink" title="Whatever"></a>Whatever</h2><hr>
<p>by Moritz</p>
<p>Whatever 在 Perl 6 中是一种类型，在它出现的上下文中，Whatever 代表着它知道的任何东西。<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">1..*                 # infinite range</div><div class="line">my @x = &lt;a b c d e&gt;;</div><div class="line">say @x[*-2]          # indexing from the back of the array</div><div class="line">                     # returns &apos;d&apos;</div><div class="line">say @x.map: * ~ &apos;A&apos;; # concatenate A to whatever the</div><div class="line">                     # thing is we pass to it</div><div class="line">say @x.pick(*)       # randomly pick elements of @x</div><div class="line">                     # until all are used up</div><div class="line"></div><div class="line">say @array[*-5] 等价于：</div><div class="line">say @array[-&gt; $x &#123; $x-5 &#125;]; # $x 是数组元素的个数</div><div class="line"></div><div class="line">my $make-index = -&gt; $x &#123; $x-5 &#125;;</div><div class="line">say @array[$make-index];</div></pre></td></tr></table></figure>
<p>所以这是怎么回事？<br>有些用法看起来很明显： <code>*</code> 在 <code>term</code> 位置上会产生一个 <code>Whatever</code> 对象， 并且有些内置函数(例如 List.pick) 知道怎么处理这个 <code>Whatever</code> 对象。<br>编辑器读取代码后， 知道怎么解析项和操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">say  2 + 4</div><div class="line">|    | | |</div><div class="line">|    | | + term (literal number)</div><div class="line">|    | + operator (binary +)</div><div class="line">|    +  term (literal number)</div><div class="line">+ term (listop), which expects another term</div></pre></td></tr></table></figure>
<p>所以，当你写下：<br><code>* * 2</code><br>编译器会把 第一个 <code>*</code> 解释为 <code>项</code>， 把第二个 <code>*</code> 解释为 <code>操作符</code><br>上面那行代码生成了一个代码块： <code>* * 2</code> 等价于 <code>-&gt; $x { $x * 2 }</code>， 你可以想任何其它子例程或 <code>block</code> 一样调用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $x = * * 2;</div><div class="line">say $x(4);     # says 8</div></pre></td></tr></table></figure>
<p>同样地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say @x.map: * ~ &apos;A&apos;;</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say @x.map: -&gt; $x &#123; $x ~ &apos;A&apos; &#125;;</div></pre></td></tr></table></figure>
<p>而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say @x.map: *.succ;</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say @x.map: -&gt; $x &#123; $x.succ &#125;;</div></pre></td></tr></table></figure>
<p>Whatever 在排序时很有用 — 例如， 根据数字大小排序( 前缀 ‘+’ 意味着获取某个东西的数字值)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@list.sort: +*</div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $desc = -&gt; $a, $b &#123; $a &lt;=&gt; $b &#125;</div><div class="line">@list.sort: $desc</div></pre></td></tr></table></figure>
<p>而把列表元素作为字符串排序  (前缀 ‘~’ 意思是获取某个东西的字符串值)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@list.sort: ~*</div></pre></td></tr></table></figure>
<h2 id="Junctions"><a href="#Junctions" class="headerlink" title="Junctions"></a>Junctions</h2><hr>
<p>December 13, 2009<br>Among the many exciting things in Perl 6, junctions are one of my favourites. While I know I don’t really comprehend everything you can do with them, there are a few useful tricks which I think most people will appreciate, and it is those which I’m going to cover as today’s gift.<br>Junctions are values which have (potentially) more than one value at once. That sounds odd, so let’s get thinking about some code which uses them. First, let’s take an example. Suppose you want to check a variable for a match against a set of numbers:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if $var == 3 || $var == 5 || $var == 7 &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>I’ve never liked that kind of testing, seeing as how it requires much repetition. With an any junction we can rewrite this test:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if $var == any(3, 5, 7) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>How does this work? Right near the core of Perl 6 is a concept called junctive autothreading. What this means is that, most of the time, you can pass a junction to anything expecting a single value. The code will run for each member of the junction, and the result will be all those results combined in the same kind of junction which was originally passed.<br>In the sample above, the infix:&lt;==&gt; operator is run for each element of the junction to compare them with $var. The results of each test are combined into a new any junction, which is then evaluated in Boolean context by the if statement. An any junction in Boolean context is true if any of its values are true, so if $var matches any value in the junction, the test will pass.<br>This can save a lot of duplicated code, and looks quite elegant. There’s another way to write it, as any junctions can also be constructed using the infix:&lt;|&gt; operator:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if $var == 3|5|7 &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>What if you want to invert this kind of test? There’s another kind of junction that’s very helpful, and it’s called none:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if $var == none(3, 5, 7) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>As you may have guessed, a none junction in Boolean context is true only if none of its elements are true.<br>Junctive autothreading also applies in other circumstances, such as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $j = any(1, 2, 3);</div><div class="line">my $k = $j + 2;</div></pre></td></tr></table></figure>
<p>What will this do? By analogy to the first example, you can probably guess that $k will end up being any(3, 4, 5).<br>There is an important point to note in these examples. We’re talking about junctive autothreading, which should give you a hint. By the Perl 6 spec, the compiler is free to run these multiple operations on junctions in different threads so that they can execute in parallel. Much as with hyperoperators, you need to be aware that this could happen and avoid anything which would make a mess if run simultaneously.<br>The last thing I want to talk about is how junctions work with smartmatching. This is really just another instance of autothreading, but there are some other junction types which become particularly useful with smartmatching.<br>Say you have a text string, and you want to see if it matches all of a set of regexes:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$string ~~ /&lt;first&gt;/ &amp; /&lt;second&gt;/ &amp; /&lt;third&gt;/</div></pre></td></tr></table></figure>
<p>Assuming, of course, you have defined regexes called first, secondand third. Rather like |, &amp; is an infix operator which creates junctions, this time all junctions which are only true if all their members are true.<br>The great thing about junctions is that they have this behaviour without the routine you’re passing them to having to know about it, so you can pass junctions to almost any library or core function and expect this kind of behaviour (it is possible for a routine to deliberately notice junctions and treat them how it prefers rather than using the normal autothreading mechanism). So if you have a routine which takes a value to smartmatch something against, you can pass it a junction and get that flexibility in the smartmatch for free. We use this in the Perl 6 test suite, with functions like Test::Util::is_run, which runs some code in another interpreter and smartmatches against its output.<br>To finish off, here are some other useful things you can do with junctions. First, checking if $value is present in @list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">any(@list) == $value</div></pre></td></tr></table></figure>
<p>Junction constructors can work quite happily with the elements of arrays, so this opens up many possibilities. Others include:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">all(@list) &gt; 0; # All members greater than zero?</div><div class="line">all(@a) == any(@b); # All elements of @a present in @b?</div></pre></td></tr></table></figure>
<p>Go experiment, and have fun!</p>
<h2 id="Modules-and-Exporting"><a href="#Modules-and-Exporting" class="headerlink" title="Modules and Exporting"></a>Modules and Exporting</h2><hr>
<p>December 12, 2009<br>Today I’d like to talk about a fairly fundamental subject: libraries.<br>To write a library in Perl 6, we use the “module” keyword:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module Fancy::Utilities &#123;</div><div class="line">    sub lolgreet($who) &#123;</div><div class="line">        say &quot;O HAI &quot; ~ uc $who;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Put that in Fancy/Utilities.pm somewhere in $PERL6LIB and we can use it like the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use Fancy::Utilities;</div><div class="line">Fancy::Utilities::lolgreet(&apos;Tene&apos;);</div></pre></td></tr></table></figure>
<p>That’s hardly ideal.  Just like in Perl 5, we can indicate that some symbols from the module should be made available in the lexical scope of the code loading the module.  We’ve got a rather different syntax for it, though:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Utilities.pm</div><div class="line">module Fancy::Utilities &#123;</div><div class="line">  sub lolgreet($who) is export &#123;</div><div class="line">    say &quot;O HAI &quot; ~ uc $who;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># foo.pl</div><div class="line">use Fancy::Utilities;</div><div class="line">lolgreet(&apos;Jnthn&apos;);</div><div class="line">If you don’t specify further, symbols marked “is export” are exported by default.  We can also choose to label symbols as being exported as part of a different named group:</div><div class="line">module Fancy::Utilities &#123;</div><div class="line">sub lolgreet($who) is export(:lolcat, :greet) &#123;</div><div class="line">  say &quot;O HAI &quot; ~ uc $who;</div><div class="line">&#125;</div><div class="line">sub nicegreet($who) is export(:greet, :DEFAULT) &#123;</div><div class="line">  say &quot;Good morning, $who!&quot;; # Always morning?</div><div class="line">&#125;</div><div class="line">sub shortgreet is export(:greet) &#123;</div><div class="line">  say &quot;Hi!&quot;;</div><div class="line">&#125;</div><div class="line">sub lolrequest($item) is export(:lolcat) &#123;</div><div class="line">  say &quot;I CAN HAZ A &#123;uc $item&#125;?&quot;;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Those tags can be referenced in the code loading this module to choose which symbols to import:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">use Fancy::Utilities; # Just get the DEFAULTs</div><div class="line">use Fancy::Utilities :greet, :lolcat;</div><div class="line">use Fancy::Utilities :ALL; # Everything marked is export</div><div class="line">Multi subs are export by default, so you only need to label them if you want to change that.</div><div class="line">multi sub greet(Str $who) &#123; say &quot;Good morning, $who!&quot; &#125;</div><div class="line">multi sub greet() &#123; say &quot;Hi!&quot; &#125;</div><div class="line">multi sub greet(Lolcat $who) &#123; say &quot;O HAI &quot; ~ $who.name &#125;</div><div class="line">Classes are just a specialization of modules, so you can export things from them as well.  In addition, you can export a method to make it available as a multi sub.  For example, the setting exports the “close” method from the IO class so you can call “close($fh);”</div><div class="line">class IO &#123;</div><div class="line">    ...</div><div class="line">    method close() is export &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Perl 6 does support importing symbols by name from a library, but Rakudo does not yet implement it.</p>
<h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h2><hr>
<p>by jnthnwrthngtn<br>As the snow falls outside, we grab a glass of mulled wine – or maybe a cup of eggnog – to enjoy as we explore today’s exciting gift – roles!<br>Traditionally in object oriented programming, classes have taken on two tasks: instance management and re-use. Unfortunately, this can end up pulling classes in two directions: re-use wants them to be small and minimal, but if they’re representing a complex entity then they need to support all of the bits it needs. In Perl 6, classes retain the task of instance management. Re-use falls to roles.<br>So what does a role look like? Imagine that we are building up a bunch of classes that represent different types of product. Some of them will have various bits of data and functionality in common. For example, we may have a BatteryPower role.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">role BatteryPower &#123;</div><div class="line">    has $.battery-type;</div><div class="line">    has $.batteries-included;</div><div class="line">    method find-power-accessories() &#123;</div><div class="line">        return ProductSearch::find($.battery-type);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>At first glance, this looks a lot like a class: it has attributes and methods. However, we can not use a role on its own. Instead, we must compose it into a class, using the does keyword.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class ElectricCar does BatteryPower &#123;</div><div class="line">    has $.manufacturer;</div><div class="line">    has $.model;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Composition takes the attributes and methods – including generated accessors – from the role and copies them into the class. From that point on, it is as if the attributes and methods had been declared in the class itself. Unlike with inheritance, where the parents are looked at during method dispatch, with roles there is no runtime link beyond the class knowing to say “yes” if asked if it does a particular role.<br>Where things get really interesting is when we start to compose multiple roles into the class. Suppose that we have another role, SocketPower.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">role SocketPower &#123;</div><div class="line">    has $.adapter-type;</div><div class="line">    has $.min-voltage;</div><div class="line">    has $.max-voltage;</div><div class="line">    method find-power-accessories() &#123;</div><div class="line">        return ProductSearch::find($.adapter-type);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Our laptop computer can be plugged in to the socket or battery powered, so we decide to compose in both roles.<br>class Laptop does BatteryPower does SocketPower {<br>}<br>We try to run this and…BOOM! Compile time fail! Unlike with inheritance and mix-ins, role composition puts all of the roles on a level playing field. If both provide a method of the same name – in this case, find-power-accessories – then the conflict will be detected as the class is being formed and you will be asked to resolve it. This can be done by supplying a method in our class that says what should be done.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Laptop does BatteryPower does SocketPower &#123;</div><div class="line">    method find-power-accessories() &#123;</div><div class="line">        my $ss = $.adapter-type ~ &apos; OR &apos; ~ $.battery-type;</div><div class="line">        return ProductSearch::find($ss);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This is perhaps the most typical use of roles, but not the only one. Roles can also be taken and mixed in to an object (on a per-object basis, not a per-class basis) using the does and but operators, and if filled only with stub methods will act like interfaces in Java and C#. I won’t talk any more about those in this post, though: instead, I want to show you how roles are also Perl 6’s way of achieving generic programming, or parametric polymorphism.<br>Roles can also take parameters, which may be types or just values. For example, we may have a role that we apply to products that need to having a delivery cost calculated. However, we want to be able to provide alternative shipping calculation models, so we take a class that can handle the delivery calculation as a parameter to the role.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">role DeliveryCalculation[::Calculator] &#123;</div><div class="line">    has $.mass;</div><div class="line">    has $.dimensions;</div><div class="line">    method calculate($destination) &#123;</div><div class="line">        my $calc = Calculator.new(</div><div class="line">            :$!mass,</div><div class="line">            :$!dimensions</div><div class="line">        );</div><div class="line">        return $calc.delivery-to($destination);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Here, the ::Calculator in the square brackets after the role name indicates that we want to capture a type object and associate it with the name Calculator within the body of the role. We can then use that type object to call .new on it. Supposing we had written classes that did shipping calculations, such as ByDimension and ByMass, we could then write:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Furniture does DeliveryCalculation[ByDimension] &#123;</div><div class="line">&#125;</div><div class="line">class HeavyWater does DeliveryCalculation[ByMass] &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In fact, when you declare a role with parameters, what goes in the square brackets is just a signature, and when you use a role what goes in the square brackets is just an argument list. Therefore you have the full power of Perl 6 signatures at your disposal. On top of that, roles are “multi” by default, so you can declare multiple roles with the same short name, but taking different types or numbers of parameters.<br>As well as being able to parametrize roles using the square bracket syntax, it is also possible to use the of keyword if each role takes just one parameter. Therefore, with these declarations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">role Cup[::Contents] &#123; &#125;</div><div class="line">role Glass[::Contents] &#123; &#125;</div><div class="line">class EggNog &#123; &#125;</div><div class="line">class MulledWine &#123; &#125;</div></pre></td></tr></table></figure>
<p>We may now write the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my Cup of EggNog $mug = get_eggnog();</div><div class="line">my Glass of MulledWine $glass = get_wine();</div></pre></td></tr></table></figure>
<p>You can even stack these up.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">role Tray[::ItemType] &#123; &#125;</div><div class="line">my Tray of Glass of MulledWine $valuable;</div></pre></td></tr></table></figure>
<p>The last of these is just a more readable way of saying Tray[Glass[MulledWine]]. Cheers!<br>About these ads<br>Like this:</p>
<p>Like Loading…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的模式匹配]]></title>
      <url>http://ohmycloud.github.io/2016/03/09/Perl6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $name = &quot;twostraws&quot;;</div><div class="line"></div><div class="line">given $name &#123;</div><div class="line">  when &quot;bilbo&quot;      &#123; say &quot;Hello, Bilbo Baggins!&quot;&#125;</div><div class="line">  when &quot;twostraws&quot;  &#123; say &quot;Hello, Paul Hudson!&quot;  &#125;</div><div class="line">  default           &#123; say &quot;身份验证失败&quot;           &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="同时检查名字和密码"><a href="#同时检查名字和密码" class="headerlink" title="同时检查名字和密码"></a>同时检查名字和密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my $name     = &quot;twostraws&quot;;</div><div class="line">my $password = &quot;fr0st1es&quot;;</div><div class="line"></div><div class="line">given ($name, $password) &#123;</div><div class="line">  when (&quot;bilbo&quot;, &quot;bagg1n5&quot;)      &#123; say &quot;Hello, Bilbo Baggins!&quot; &#125;</div><div class="line">  when (&quot;twostraws&quot;, &quot;fr0st1es&quot;) &#123; say &quot;Hello, Paul Hudson!&quot;   &#125;</div><div class="line">  default                        &#123; say &quot;你是谁?&quot;                &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用单个元组"><a href="#使用单个元组" class="headerlink" title="使用单个元组"></a>使用单个元组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $authentication = (&quot;twostraws&quot;, &quot;fr0st1es&quot;);</div><div class="line"></div><div class="line">given $authentication &#123;</div><div class="line">  when (&quot;bilbo&quot;, &quot;bagg1n5&quot;)      &#123; say &quot;Hello, Bilbo Baggins!&quot; &#125;</div><div class="line">  when (&quot;twostraws&quot;, &quot;fr0st1es&quot;) &#123; say &quot;Hello, Paul Hudson!&quot;   &#125;</div><div class="line">  default                        &#123; say &quot;你是谁?&quot;                &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 你只关心某些感兴趣的值，不关心其它值，使用 `*` 号或 `$` 来代表 &quot;any value is fine&quot;</div><div class="line">my $authentication = (&quot;twostraws&quot;, &quot;fr0st1es&quot;, &quot;127.0.0.1&quot;);</div><div class="line">given $authentication &#123;</div><div class="line">  when (&quot;bilbo&quot;, &quot;bagg1n5&quot;, *)      &#123; say &quot;Hello, Bilbo Baggins!&quot;&#125;</div><div class="line">  when (&quot;twostraws&quot;, &quot;fr0st1es&quot;, $) &#123; say &quot;Hello, Paul Hudson!&quot;  &#125;</div><div class="line">  default                           &#123; say &quot;Who are you?&quot;         &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="只匹配元组的一部分"><a href="#只匹配元组的一部分" class="headerlink" title="只匹配元组的一部分"></a>只匹配元组的一部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 但仍然想知道其它部分是什么</div><div class="line">my $authentication = (&quot;twostraws&quot;, &quot;fr0st1es&quot;);</div><div class="line">given $authentication &#123;</div><div class="line">  when (&quot;bilbo&quot;, *)     &#123; say &quot;Hello, Bilbo Baggins!&quot; &#125;</div><div class="line">  when (&quot;twostraws&quot;, *) &#123; say &quot;Hello, Paul Hudson: your password was $_!&quot; &#125;</div><div class="line">  default               &#123; say &quot;Who are you?&quot;         &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="匹配计算型元组"><a href="#匹配计算型元组" class="headerlink" title="匹配计算型元组"></a>匹配计算型元组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sub fizzbuzz(Int $number) returns Str &#123;</div><div class="line">    given ($number % 3 == 0, $number % 5 == 0) &#123;</div><div class="line">      when (True, False)  &#123; return &quot;Fizz&quot;     &#125;</div><div class="line">      when (False, True)  &#123; return &quot;Buzz&quot;     &#125;</div><div class="line">      when (True, True)   &#123; return &quot;FizzBuzz&quot; &#125;</div><div class="line">      when (False, False) &#123; return $number.Str&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say fizzbuzz(15);</div></pre></td></tr></table></figure>
<h3 id="遍历元组"><a href="#遍历元组" class="headerlink" title="遍历元组"></a>遍历元组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my $twostraws = (&quot;twostraws&quot;, &quot;fr0st1es&quot;);</div><div class="line">my $bilbo = (&quot;bilbo&quot;, &quot;bagg1n5&quot;);</div><div class="line">my $taylor = (&quot;taylor&quot;, &quot;fr0st1es&quot;);</div><div class="line">my @users = $twostraws, $bilbo, $taylor;</div><div class="line"></div><div class="line">for @users -&gt; $user &#123;</div><div class="line">    say $user[0];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用-when-匹配元组中的指定值"><a href="#使用-when-匹配元组中的指定值" class="headerlink" title="使用 when 匹配元组中的指定值"></a>使用 when 匹配元组中的指定值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my $twostraws = (&quot;twostraws&quot;, &quot;fr0st1es&quot;);</div><div class="line">my $bilbo = (&quot;bilbo&quot;, &quot;bagg1n5&quot;);</div><div class="line">my $taylor = (&quot;taylor&quot;, &quot;fr0st1es&quot;);</div><div class="line">my @users = $twostraws, $bilbo, $taylor;</div><div class="line"></div><div class="line">say &quot;User twostraws has the password fr0st1es&quot; when (&quot;twostraws&quot;, &quot;fr0st1es&quot;) for @users;</div><div class="line"></div><div class="line"># 打印秘密为指定值的用户</div><div class="line">say &quot;User $_[0] has password \&quot;fr0st1es\&quot;&quot; when (*, &quot;fr0st1es&quot;) for @users;</div></pre></td></tr></table></figure>
<h3 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a>匹配范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $age = 36;</div><div class="line"></div><div class="line">given $age &#123;</div><div class="line">  when 0 ..^ 18   &#123; say &quot;你有活力有时间，但是没钱&quot;  &#125;</div><div class="line">  when 18 ..^ 70  &#123; say &quot;你有活力有钱，但是没时间&quot;  &#125;</div><div class="line">  default         &#123; say &quot;你有时间和金钱，但是没活力&quot;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="when-可以配合智能匹配操作符-单独使用"><a href="#when-可以配合智能匹配操作符-单独使用" class="headerlink" title="when 可以配合智能匹配操作符 ~~ 单独使用"></a>when 可以配合智能匹配操作符 ~~ 单独使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $age = 36;</div><div class="line">when $age ~~ 0 ..^ 18  &#123; say &quot;你有活力有时间，但是没钱&quot;  &#125; </div><div class="line">when $age ~~ 18 ..^ 70 &#123; say &quot;你有活力有钱，但是没时间&quot;  &#125;</div><div class="line">default                &#123; say &quot;你有时间和金钱，但是没活力&quot;&#125;</div></pre></td></tr></table></figure>
<h3 id="使用-contains-方法"><a href="#使用-contains-方法" class="headerlink" title="使用 contains 方法"></a>使用 contains 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $age = 36;</div><div class="line">when (0 ..^ 18).contains($age)  &#123; say &quot;你有活力有时间，但是没钱&quot;  &#125; </div><div class="line">when (18 ..^ 70).contains($age) &#123; say &quot;你有活力有钱，但是没时间&quot;  &#125;</div><div class="line">default                         &#123; say &quot;你有时间和金钱，但是没活力&quot;&#125;</div></pre></td></tr></table></figure>
<h3 id="匹配元组中的范围"><a href="#匹配元组中的范围" class="headerlink" title="匹配元组中的范围"></a>匹配元组中的范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $user = (&quot;twostraws&quot;, &quot;fr0st1es&quot;, 36);</div><div class="line">given $user &#123;</div><div class="line">  my $name = $user[0];</div><div class="line">  when ($name, *, 0 ..^ 18)  &#123; say &quot;$name 有活力有时间，但是没钱&quot;  &#125; </div><div class="line">  when ($name, *, 18 ..^ 70) &#123; say &quot;$name 有活力有钱，但是没时间&quot;  &#125;</div><div class="line">  when ($name, *, *)         &#123; say &quot;$name 有时间和金钱,但是没活力&quot; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum WeatherType &lt;Cloudy Sunny Windy&gt;;</div><div class="line">my $today = WeatherType::Cloudy;</div><div class="line">given $today &#123;</div><div class="line">  when WeatherType::Cloudy &#123; say &quot;多云&quot; &#125;</div><div class="line">  when WeatherType::Sunny  &#123; say &quot;晴天&quot; &#125;</div><div class="line">  when WeatherType::Windy  &#123; say &quot;有风&quot; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 使用 if 语句</div><div class="line">if $today ~~ WeatherType::Cloudy &#123; say &quot;多云&quot; &#125;</div></pre></td></tr></table></figure>
<h3 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">enum WeatherType  (</div><div class="line">    Cloudy =&gt; 100,</div><div class="line">    Sunny  =&gt; 50,</div><div class="line">    Windy  =&gt; 30</div><div class="line">);</div><div class="line"></div><div class="line">my $today = WeatherType::Windy;</div><div class="line">given $today &#123;</div><div class="line">  when WeatherType::Cloudy &#123; say 20*Cloudy &#125;</div><div class="line">  when WeatherType::Sunny  &#123; say 10*Sunny  &#125; </div><div class="line">  when WeatherType::Windy  &#123; say 12*Windy  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="when-从句"><a href="#when-从句" class="headerlink" title="when 从句"></a>when 从句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my @numbers = 1..10;</div><div class="line">.say when $_ % 2 == 1 for @numbers;</div><div class="line"></div><div class="line">my @celebrities = &quot;Michael Jackson&quot;, &quot;Taylor Swift&quot;, &quot;MichaelCaine&quot;, &quot;Adele Adkins&quot;, &quot;Michael Jordan&quot;;</div><div class="line">.say when /^Michael/ for @celebrities;     # 使用正则表达式</div><div class="line">.say when $_.chars &gt; 12 for @celebrities;  # 调用方法</div><div class="line">.say when /^Michael/ and $_.chars &gt;12 for @celebrities; # 复合条件</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的正则表达式(一)]]></title>
      <url>http://ohmycloud.github.io/2016/03/08/Perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%80/</url>
      <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>Synopsis 5: Regexes and Rules</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">创建于: 2002/06/24</div><div class="line"></div><div class="line">上次修改: 2015/05/12</div><div class="line">版本: 180</div></pre></td></tr></table></figure>
<p>不论何时, 在 <code>grammar</code> 中引用递归模式时, 通常更偏好使用 <code>token</code> 和 <code>rule</code>, 而不是 <code>regex</code>.</p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>作为常规表达式记法的扩展, Perl 6 原生地实现了 <code>Parsing Expression Grammars</code>(PEGs). PEGs 要求你为有歧义的那部分提供一个 <code>主从秩序</code>.  Perl 6 的 <code>主从秩序</code> 由一个多级的平局择优法测试决定:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1) Most-derived only/proto hides less-derived of the same name</div><div class="line">2) 最长 token 匹配: food\s+ beats foo by 2 or more positions</div><div class="line">3) 最长字面值前缀: food\w* beats foo\w* by 1 position</div><div class="line">4) 对于一个给定的 proto, multis from a more-derived grammar win</div><div class="line">5) 在一个给定的编译单元中, 出现较早的备选分支或 multi 胜出.</div></pre></td></tr></table></figure>
<p><code>#3</code> 会把任何初始的字面序列当作最长字面值前缀. 如果在最长 token 匹配中有一个嵌入的备选分支, 那些备选分支会扩展字面值前缀,   把备选分支也作为字面值的一部分. 如果所有的备选分支都是字面值的, 那么字面值也能延伸到备选分支的末尾, 当它们重新聚合时.  否则,  备选分支的末尾会终止所有的最长字面值前缀, 即使分支全部是字面值的.  例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/ a [ 1 | 2 ] b /   # 最长字面值是 &apos;a1b&apos; 和 &apos;a2b&apos;</div><div class="line">/ a [ 1 | 2\w ] b / # 最长文字是&apos;a1 和 &apos;a2&apos;, \w 不是字面值</div><div class="line">/ a &lt;[ 1 2 ]&gt; b /   # 最长字面值是 &apos;a&apos;</div></pre></td></tr></table></figure>
<p>注意, 这种情况下, 字符类和备选分支被不同地对待. 在字符类中包含一个最长的字面字符串太普遍了.</p>
<p>就像最长 <em>token</em> 匹配一样, 最长字面值前缀贯穿于 <em>subrules</em> 中. 如果 <em>subrule</em> 是一个 <em>protoregex</em>, 它会被看作带有 <code>|</code> 的备选分支, 后面跟着扩展或终止最长字面值前缀的同一个 <em>rules</em>.</p>
<p>除了这个主从秩序以外, 如果任何 <em>rule</em> 选择于主从秩序回溯之下, 那么选择下一个最好的 <em>rule</em>.  即, 主从秩序决定了候选者列表; 正是因为选择一个候选者并不意味着放弃其它候选者. 然而,  能通过一个恰当的回溯控制显式地放弃其它候选者(有时叫它 <code>cut</code> 操作符, 但是  Perl 6 有多个 <em>cut</em> , 取决于你想切掉多少)</p>
<p>还有, 任何在 <code>#1</code> 下被选中执行的 <em>rule</em>  可以选择委托给它的祖先来执行; PEG 不对此回溯.</p>
<h1 id="新的匹配结果和捕获变量"><a href="#新的匹配结果和捕获变量" class="headerlink" title="新的匹配结果和捕获变量"></a>新的匹配结果和捕获变量</h1><p>附属的匹配对象现在可通过 <code>$/</code> 变量获取, 它隐式是词法作用域的. 通过这个变量来访问最近一次的匹配.  单独的捕获变量(例如 <code>$0</code>, <code>$1</code>等) 正是 <code>$/</code> 中的元素.<br>顺便说一下, 不像 Perl 5, Perl 6 中的捕获变量现在从 <code>$0</code> 开始编号而不是 <code>$1</code>. 查看下面.<br>为了检测 Perl 5的不相关的 <code>$/</code> 变量的意外使用, Perl 6 的 <code>$/</code> 变量不能被直接赋值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$/ = $x;   # 不支持使用  $/ 变量作为输入记录分隔符 (input record separator)</div><div class="line">$/ := $x;  # OK, 绑定</div><div class="line">$/ RR= $x; # OK, 元操作符</div><div class="line">($/) = $x; # OK, 列表赋值</div></pre></td></tr></table></figure>
<h1 id="没变的语法特性"><a href="#没变的语法特性" class="headerlink" title="没变的语法特性"></a>没变的语法特性</h1><p>下面的正则特性语法和 Perl 5 是一样的:</p>
<p><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L100-L247" target="_blank" rel="external"><code>S05-mass/rx.t lines 100–247</code></a></p>
<ul>
<li>捕获: <code>(…)</code></li>
<li>重复量词: <code>*</code>, <code>+</code>, 和  <code>?</code></li>
<li>备选分支: <code>|</code></li>
<li>反斜线转义: <code>\</code></li>
<li>最少匹配后缀: <code>??</code>, <code>*?</code>, <code>+?</code></li>
</ul>
<p>虽然 <code>|</code> 的语法没有变, 但是默认的语义稍微改变了一点.  我们试图混合一个令人满意的描述性的和程序上的匹配, 以至于我们能拥有其中两者. 简言之, 你不用给 <em>grammar</em> 写你自己的 <code>tokener</code>了, 因为 Perl 会帮你写好. 查看下面的 <code>Longest-token</code> 匹配.</p>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/longest-alternative.t#L6-L52" target="_blank" rel="external"><code>S05-metasyntax/longest-alternative.t lines 6–52</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use Test;</div><div class="line"></div><div class="line">plan 53;</div><div class="line"></div><div class="line">#L&lt;S05/Unchanged syntactic features/&quot;While the syntax of | does not change&quot;&gt;</div><div class="line"></div><div class="line">my $str = &apos;a&apos; x 7;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    ok $str ~~ m:c(0)/a|aa|aaaa/, &apos;basic sanity with |&apos;;</div><div class="line">    is ~$/, &apos;aaaa&apos;, &apos;Longest alternative wins 1&apos;;</div><div class="line"></div><div class="line">    ok $str ~~ m:c(4)/a|aa|aaaa/, &apos;Second match still works&apos;;</div><div class="line">    is ~$/, &apos;aa&apos;,   &apos;Longest alternative wins 2&apos;;</div><div class="line"></div><div class="line">    ok $str ~~ m:c(6)/a|aa|aaaa/, &apos;Third match still works&apos;;</div><div class="line">    is ~$/, &apos;a&apos;,    &apos;Only one alternative left&apos;;</div><div class="line"></div><div class="line">    ok $str !~~ m:c(7)/a|aa|aaaa/, &apos;No fourth match&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># now test with different order in the regex - it shouldn&apos;t matter at all</div><div class="line"></div><div class="line">#?niecza skip &apos;Regex modifier g not yet implemented&apos;</div><div class="line">&#123;</div><div class="line">    ok $str ~~ m:c/aa|a|aaaa/, &apos;basic sanity with |, different order&apos;;</div><div class="line">    is ~$/, &apos;aaaa&apos;, &apos;Longest alternative wins 1, different order&apos;;</div><div class="line"></div><div class="line">    ok $str ~~ m:c/aa|a|aaaa/, &apos;Second match still works, different order&apos;; # c -&gt; 从上次匹配结束的位置匹配继续匹配</div><div class="line">    is ~$/, &apos;aa&apos;,   &apos;Longest alternative wins 2, different order&apos;;</div><div class="line"></div><div class="line">    ok $str ~~ m:c/aa|a|aaaa/, &apos;Third match still works, different order&apos;;</div><div class="line">    is ~$/, &apos;a&apos;,    &apos;Only one alternative left, different order&apos;;</div><div class="line"></div><div class="line">    ok $str !~~ m:c/aa|a|aaaa/, &apos;No fourth match, different order&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    my @list = &lt;a aa aaaa&gt;;</div><div class="line">    ok $str ~~ m/ @list /, &apos;basic sanity with interpolated arrays&apos;;</div><div class="line">    is ~$/, &apos;aaaa&apos;, &apos;Longest alternative wins 1&apos;;</div><div class="line"></div><div class="line">    ok $str ~~ m:c(4)/ @list /, &apos;Second match still works&apos;;</div><div class="line">    is ~$/, &apos;aa&apos;,   &apos;Longest alternative wins 2&apos;;</div><div class="line"></div><div class="line">    ok $str ~~ m:c(6)/ @list /, &apos;Third match still works&apos;;</div><div class="line">    is ~$/, &apos;a&apos;,    &apos;Only one alternative left&apos;;</div><div class="line"></div><div class="line">    ok $str !~~ m:c(7)/ @list /, &apos;No fourth match&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="简化的模式词法解析"><a href="#简化的模式词法解析" class="headerlink" title="简化的模式词法解析"></a>简化的模式词法解析</h1><p>不像传统的正则表达式那样, Perl 6 不要求你记住数量众多的元字符.  相反, Perl 6 通过一个简单的 <code>rule</code> 将字符进行了分类. 在正则表达式中, 所有根字符为下划线(<code>_</code>)或拥有一个以 <code>L</code>(例如, 字母) 或 <code>N</code>(例如, 数字)开头的 Unicode 类别的字形(字素) 总是字面的.(例如, 自己和自己匹配的).  它们必须使用 <code>\</code> 转义以使它们变成元语法的(这时单个字母数字字符本身是元语法的, 但是任何在字母数字后面紧紧跟随的字符不是).</p>
<p>所有其它的字形 — 包括空白符 — 正好与此相反:它们总是被认为是元语法的.(例如, 自身和自身不匹配),  必须被转义或引用以使它们变为字面值. 按照传统, 它们可以使用 <code>\</code> 单独转义, 但是在 Perl 6中,  它们也能像下面这样被括起来.</p>
<p>把一个或多个任意类型的字形序列放在单引号中能使它们变为字面值.(如果使用和当前语言相同的插值语义, 双引号也是允许的 )  引号创建了一个能量化的原子,  所以,</p>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/single-quotes.t#L16-L27" target="_blank" rel="external"><code>S05-metasyntax/single-quotes.t lines 16–27</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">moose*</div></pre></td></tr></table></figure>
<p>量词只作用在字母 <code>e</code> 上, 并匹配 <code>mooseee</code>, 而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;moose&apos;*</div></pre></td></tr></table></figure>
<p>量词作用在整个字符串上并匹配  <code>moosemoose</code>.</p>
<p>下面有个表格总结了这些区别:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                字母数字的           非字母数字的                 混合的</div><div class="line"></div><div class="line">Literal glyphs   a    1    _        \*  \$  \.   \\   \&apos;       K\-9\!</div><div class="line">Metasyntax      \a   \1   \_         *   $   .    \    &apos;      \K-\9!</div><div class="line">Quoted glyphs   &apos;a&apos;  &apos;1&apos;  &apos;_&apos;       &apos;*&apos; &apos;$&apos; &apos;.&apos; &apos;\\&apos; &apos;\&apos;&apos;     &apos;K-9!&apos;</div></pre></td></tr></table></figure>
<p>换句话说, 标识符字形是字面值的(或者在被转义时是元语法的), 非标识符字形是元语法的(或者在被转义时是字面值的), 而且单引号包围起来的东西是字面值的。</p>
<p>注意, 目前在 Perl 6 中不是所有的非标识符字形作为元语法都是有意义的(例如 <code>\1</code>、<code>\_</code>、<code>-</code>、<code>!</code>)。更准确地说, 所有非转义的非标识符字形都有可能是元语法的, 而且留作将来之用。如果你使用了这样一个序列, 那么编译器会抛出一个有用的编译时错误以标示你要么需要引起这个序列, 要么定义一个新的操作符以识别它。</p>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/unknown.t#L6-L48" target="_blank" rel="external"><code>S05-metasyntax/unknown.t lines 6–48</code></a></p>
<p>分号字符被特别地保留作非意义(non-meaningful)元字符;  如果看到了未被引起的分号, 那么编译器就会抱怨那个正则表达式没有终止符。</p>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/regex.t#L73-L129" target="_blank" rel="external"><code>S05-metasyntax/regex.t lines 73–129</code></a></p>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><ul>
<li><code>/x</code> 语法扩展不在需要了.. 在 Perl 6 中 <code>/x</code> 是默认的了.(事实上, 这是强制的 – 唯一能用回旧语法的方式是使用 <code>:Perl5/:P5</code> 修饰符)</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_4.t#L7-L119" target="_blank" rel="external"><code>S05-modifier/perl5_4.t lines 7–119</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_2.t#L7-L119" target="_blank" rel="external"><code>S05-modifier/perl5_2.t lines 7–119</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_9.t#L7-L112" target="_blank" rel="external"><code>S05-modifier/perl5_9.t lines 7–112</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_1.t#L7-L119" target="_blank" rel="external"><code>S05-modifier/perl5_1.t lines 7–119</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_8.t#L7-L128" target="_blank" rel="external"><code>S05-modifier/perl5_8.t lines 7–128</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_5.t#L7-L126" target="_blank" rel="external"><code>S05-modifier/perl5_5.t lines 7–126</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_7.t#L7-L119" target="_blank" rel="external"><code>S05-modifier/perl5_7.t lines 7–119</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_6.t#L7-L130" target="_blank" rel="external"><code>S05-modifier/perl5_6.t lines 7–130</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_3.t#L7-L119" target="_blank" rel="external"><code>S05-modifier/perl5_3.t lines 7–119</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_0.t#L9-L113" target="_blank" rel="external"><code>S05-modifier/perl5_0.t lines 9–113</code></a></p>
<ul>
<li>没有 <code>/s</code> 或 <code>/m</code> 修饰符了(变成了元字符来替代它们-看下面.)</li>
<li>没有 <code>/e</code>求值修饰符用于替换了, 相反, 使用:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/pattern/&#123; doit() &#125;/</div></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s[pattern] = doit()</div></pre></td></tr></table></figure>
<p>代替 <code>/ee</code> 的是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/pattern/&#123; EVAL doit() &#125;/</div></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s[pattern] = doit().EVAL</div></pre></td></tr></table></figure>
<ul>
<li>修饰符现在作为副词放在匹配或替换的开头:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:g:i/\s* (\w*) \s* ,?/;</div></pre></td></tr></table></figure>
<p>每个修饰符必须以自己的冒号开始. 必须使用空格把模式分隔符和最后一个修饰符隔开, 如果它会被看作为前面那个修饰符的参数.(只有当下一个字符是左圆括号时才为真).</p>
<ul>
<li>单字符修饰符也有更长的版本:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">:i        :ignorecase   忽略大小写</div><div class="line">:m        :ignoremark   忽略记号</div><div class="line">:g        :global       全局</div><div class="line">:r        :ratchet      回溯</div></pre></td></tr></table></figure>
<ul>
<li><code>:i</code> (或 <code>:ignorecase</code>) 修饰符在词法作用域但不是它的动态作用域中忽略大小写. 即, <em>subrules</em> 总是使用它们自己的大小写设置. 大小写转换的次数取决于当前上下文. 在字节和代码点模式中, 要求级别为1 的大小写转换. 在字形模式下, 需要级别为 2 的大小写转换.</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ignorecase.t#L24-L87" target="_blank" rel="external"><code>S05-modifier/ignorecase.t lines 24–87</code></a></p>
<ul>
<li><code>:ii</code> (或 <code>:samecase</code>) 变体可能被用在替换上以把被替换掉的字符串的大小写模式修改成和匹配字符串的大小写模式一样。它暗示着该修饰符和上面的 <code>:i</code> 修饰符的语义拥有相同的模式。所以把 <code>:i</code> 和 <code>:ii</code> 放在一块没有必要。</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ii.t#L8-L30" target="_blank" rel="external"><code>S05-modifier/ii.t lines 8–30</code></a></p>
<ul>
<li><p>如果模式匹配的时候没有使用 <code>:sigspace</code> 修饰符, 那么 case info is carried across on a character by character basis. 如果右侧字符串比左侧字符串长, 那么最后一个字符的大小写被重复。 如果可能的话, 不管结果字母是不在单词的开头, 都会执行单词首字母大写; 如果没有可用的单词首字母大写字符, 就会使用对应的大写字符。(该策略可以在本地作用域中通过依赖于语言的 Unicode 声明来根据特定语言的正交规则替换 titlecase。)不携带大小写信息的字符保持它们对应的替换字符串不变。</p>
</li>
<li><p>如果模式匹配使用了 <code>:sigspace</code> 修饰符, 那么then a slightly smarter algorithm is used which attempts to determine if there is a uniform capitalization policy over each matched word, and applies the same policy to each replacement word. If there doesn’t seem to be a uniform policy on the left, the policy for each word is carried over word by word, with the last pattern word replicated if necessary. If a word does not appear to have a recognizable policy, the replacement word is translated character for character as in the non-sigspace case. Recognized policies include:</p>
</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ii.t#L31-L75" target="_blank" rel="external"><code>S05-modifier/ii.t lines 31–75</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lc()</div><div class="line">uc()</div><div class="line">tc()</div><div class="line">tclc()</div><div class="line">tcuc()</div></pre></td></tr></table></figure>
<p>任何情况下，只有模式匹配的正式匹配到的字符串部分才被计数，所以任何形式的向前匹配或语境匹配没有包含在分析之内。</p>
<ul>
<li><code>:m</code> (或 <code>:ignoremark</code>) 修饰符的作用域非常像 <code>:ignorecase</code>, 除了它忽略记号(重音和诸如此类) 而非大小写之外。它等价于接收每个字素(in both target and pattern), 把两者都转换为 NFD (最大限度地分解)并比较那两个根字符(Unicode 无记号字符)而忽略任何末尾记号字符。记号字符只在判断断言真假的时候忽略记号字符; 实际匹配的的文本包含了所有的忽略字符, 包含任何跟在最后的根字符后面的东西。<br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ignoremark.t#L14-L39" target="_blank" rel="external">S05-modifier/ignoremark.t lines 14–39</a></li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ignorecase-and-ignoremark.t#L15-L35" target="_blank" rel="external">S05-modifier/ignorecase-and-ignoremark.t lines 15–35</a></p>
<ul>
<li><p><code>:mm</code> (或 <code>:samemark</code>) 变体能用于替换以把替换字符串更改为和匹配字符串相同的记号/重音。这暗示着它和上面的 <code>:m</code> 的模式语义相同, 所以, 把 <code>:m</code> 和 <code>:mm</code> 放在一块是没有必要的。<br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/samemark.t#L9-L39" target="_blank" rel="external">S05-modifier/samemark.t lines 9–39</a></p>
</li>
<li><p>通过字根对字符执行记号信息。如果右侧字符串比左侧字符串长, 那么剩余的字符在被替换时不使用任何修改。 (注意 <em>NFD</em>/<em>NFC</em> 的区别通常不太重要, 因为 Perl 把它封装在了字素模式中。) 在 <code>:sigspace</code> 修饰符下, 会逐字应用之前的规则。</p>
</li>
<li><p><code>:c</code> (或 <code>:continue</code>) 修饰符让 <code>pattern</code> 从字符串中指定的位置继续扫描 (默认为 <code>$/ ?? $/.to !! 0</code>):<br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/continue.t#L6-L50" target="_blank" rel="external"><code>S05-modifier/continue.t lines 6–50</code></a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:c($p)/ pattern /     # 从位置 $p 开始扫描, $p 是字符串中的位置,而非模式中的位置</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"></div><div class="line">#L&lt;S05/Modifiers/&quot;The :c&quot;&gt;</div><div class="line"></div><div class="line">my regex simple &#123; . a &#125;;</div><div class="line">my $string = &quot;1a2a3a&quot;;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    $string ~~ m:c/&lt;&amp;simple&gt;/;               # 1a</div><div class="line">    $string ~~ m:c/&lt;&amp;simple&gt;/;               # 2a</div><div class="line">    $string ~~ m:c/&lt;&amp;simple&gt;/;               # 3a</div><div class="line">    $string ~~ m:c/&lt;&amp;simple&gt;/;               # no more &apos;a&apos;s to match</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    my $m = $string.match(/.a/);             # 1a</div><div class="line">    $m = $string.match(/.a/, :c(2));         # 2a</div><div class="line">    $m = $string.match(/.a/, :c(4));         # 3a</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"># this batch not starting on the exact point, and out of order</div><div class="line">&#123;</div><div class="line">    my $m = $string.match(/.a/, :c(0));      # 1a</div><div class="line">    $m = $string.match(/.a/, :c(3));         # 3a</div><div class="line">    $m = $string.match(/.a/, :c(1));         # 2a</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    my $m = $string.match(/.a/);             # 1a</div><div class="line">    $m = $string.match(/.a/, :continue(2));  # 2a</div><div class="line">    $m = $string.match(/.a/, :continue(4));  # 3a</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意, 这不会自动把 <code>pattern</code> 锚定到开始位置. (使用 <em>:p</em> 可以). 提供给 <code>split</code> 的 <em>pattern</em> 默认有一个隐式的 <code>:c</code> 修饰符.</p>
<ul>
<li><code>:p</code> (或 <code>:pos</code>) 修饰符让 <code>pattern</code> 只在字符串中指定的位置尝试匹配:<br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/pos.t#L13-L111" target="_blank" rel="external"><code>S05-modifier/pos.t lines 13–111</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:pos($p)/ pattern /  # match at position $p</div></pre></td></tr></table></figure>
<p>如果参数被省略，它就默认为 <code>($/ ?? $/.to !! 0)</code>. (Unlike in Perl 5, the string itself has no clue where its last match ended.) All subrule matches are implicitly passed their starting position. Likewise, the pattern you supply to a Perl macro’s <code>is parsed</code> trait has an implicit <code>:p</code> modifier.</p>
<p>注意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:c($p)/pattern/</div></pre></td></tr></table></figure>
<p>正等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:p($p)/.*? &lt;( pattern )&gt; /</div></pre></td></tr></table></figure>
<p>所有的 <code>:g</code>, <code>:ov</code>, <code>:nth</code>, <code>:x</code> 跟 <code>:p</code> 都是不兼容的, 并且会失败， 推荐使用 <code>:c</code> 代替. 允许使用 <code>:ex</code> 修饰符， 但是只会在那个位置产生匹配.</p>
<ul>
<li>新的 <code>:s</code> (<code>:sigspace</code>) 修饰符让空白序列起作用，这些空白被匹配规则 <code>&lt;.ws&gt;</code> 代替. 只有紧跟在匹配结构(原子, 量词化原子)之后的空白序列是合适的。因此, 出现在任何 regex 开头的空白都会被忽略, 为了让能够参与最长 token 匹配的备选分支更容易书写。即： </li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-grammar/ws.t#L5-L34" target="_blank" rel="external"><code>S05-grammar/ws.t lines 5–34</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:s/ next cmd &apos;=&apos;   &lt;condition&gt;/</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m/ next &lt;.ws&gt; cmd &lt;.ws&gt; &apos;=&apos; &lt;.ws&gt; &lt;condition&gt;/</div></pre></td></tr></table></figure>
<p>同样等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m/ next \s+ cmd \s* &apos;=&apos; \s* &lt;condition&gt;/</div></pre></td></tr></table></figure>
<p>但是在这种情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:s&#123;(a|\*) (b|\+)&#125;</div></pre></td></tr></table></figure>
<p>或等价的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m &#123; (a|\*) &lt;.ws&gt; (b|\+) &#125;</div></pre></td></tr></table></figure>
<p><code>&lt;.ws&gt;</code> 直到看见数据才能决定要做什么. 它仍旧能做对事情. 不过不能, 定义你自己的 <code>ws</code>, 而 <code>:sigspace</code> 会使用它.`<br>仅仅当 rule 可能参与最长 token 匹配时,  rule 前面的空白才会被忽略, 但是在任何显式备选分支的前面这同样适用, 因为同样的原因。如果你想在一组备选分支前面匹配有意义的空格(sigspace), 把你的空白格放在含有备选分支的括号外面。<br>  ​  ​<br>当你这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rule TOP &#123; ^ &lt;stuff&gt; $ &#125;</div></pre></td></tr></table></figure>
<p>这等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">token TOP &#123; ^ &lt;.ws&gt; &lt;stuff&gt; &lt;.ws&gt; $ &lt;.ws&gt; &#125;</div></pre></td></tr></table></figure>
<p>但是注意最后一个 <code>&lt;.ws&gt;</code>  总是匹配空字符串，因为  <code>$</code> 锚定字符串的末尾. 如果你的 <code>TOP</code> rule 没有使用 <code>^</code> 锚定, 它不会匹配开头的空白. </p>
<p>特别地， 下面的构造会把后面跟着的空白转换为 <code>sigspace</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">任何原子或量词化的原子</div><div class="line">$foo @bar</div><div class="line">&apos;a&apos; &quot;$b&quot;</div><div class="line">^ $ ^^ $$</div><div class="line">(...) [...] &lt;...&gt; 作为整个原子</div><div class="line">(...)* [...]* &lt;...&gt;* 作为量词化的原子</div><div class="line">&lt;( 和 )&gt;</div><div class="line">« 和 » (但是不要那样使用 « )</div></pre></td></tr></table></figure>
<p>然而这些并不会:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">开口的 ( 或 [</div><div class="line">| 或 ||</div><div class="line">&amp; 或 &amp;&amp;</div><div class="line">** % 或 %%</div><div class="line">:foo 声明, 包括 :my 和 :sigspace 自身</div><div class="line">&#123;...&#125;</div></pre></td></tr></table></figure>
<p>当我们说 <em>sigspace</em> 能跟在原子或量词化的原子后面时, 我们是说 <em>sigspace</em> 能出现在原子和它的量词之间:<br>  ​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ms/ &lt;atom&gt; * /      # 意味着 / [&lt;atom&gt;&lt;.ws&gt;]* /</div></pre></td></tr></table></figure></p>
<p>(如果每个原子匹配空白, 那么就没有必要匹配后面的量词了)。If each atom matches whitespace, then it doesn’t need to match after the quantifier.)</p>
<p>一般地, 你不需要在 grammars 中使用 <code>:sigspace</code>, 因为解析规则会为你自动处理空白策略。在该上下文中, 空白常会包含注释, 根据 grammar 如何去定义它的空白规则。尽管默认的 <code>&lt;.ws&gt;</code> subrule 识别不了注释结构, 任何 grammar 能随意重写 <code>&lt;.ws&gt;</code> 规则。<code>&lt;.ws&gt;</code> <em>rule</em> 并不意味着在哪儿都是一样。</p>
<p><a href="https://github.com/perl6/roast/blob/master/S05-grammar/ws.t#L6-L34" target="_blank" rel="external"><code>S05-grammar/ws.t lines 6–34</code></a></p>
<p>给 <code>:sigspace</code> 传递一个参数也是可能的, 指定一个完全不同的 <em>subrule</em> 以应用。 这可以是任何 <em>rule</em>, 它不需要必须匹配空白。当谈论这个修饰符的时候, 把模式中的有意义的空白和正被匹配的”空白”区分开很重要, 所以我们会把模式中的空白叫做 <em>sigspace</em>, 而通常保留  <em>whitespace</em> 来标示当前 <em>grammar</em> 中 <code>&lt;.ws&gt;</code> 所匹配到的任何东西。  <em>sigspace</em> 和 <em>whitespace</em> 之间的一致性是隐喻性的, 这就是为什么一致性既有用又令人迷惑。</p>
<p>除了智能空白匹配, <em>:ss</em> (或 <em>:samespace</em>) 变体还可以用在替换上做智能空白映射。(即, <em>:ss</em> 暗示了 <em>:s</em> )。 对于左侧每个包含 <em>sigspace</em> 的 <code>&lt;ws&gt;</code> 调用,  所匹配到的空白被复制到右侧对应的坑(slot)里, 在想要空白替换的替换字符中由单个空白符表示。如果右侧比左侧的空白坑多, 则那些右手边的字符保持自身不变。如果右侧没有足够的空白坑映射所有从匹配中得到的空白坑, 那么算法会尝试通过从空白列表中随机地拼接”普通”空白符来使信息丢失最小化。 从最不贵重(valuable)到最贵重, 排列顺序为:<br>  ​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">spaces</div><div class="line">tabs</div><div class="line">所有其他水平空白, 包括 Unicode</div><div class="line">换行符 (包括作为一个单元的 crlf)</div><div class="line">所有其他垂直空白, 包括 Unicode</div></pre></td></tr></table></figure></p>
<p>这些规则的主要意图是发生在行边界这样的替换时最小化格式分裂。也就是说, 当然, 不保证结果正是人们想要的。<br>  ​<br><code>:s</code> 修饰符很重要, 以至于为它们定义了匹配变体:<br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/sigspace.t#L27-L48" target="_blank" rel="external"><code>S05-modifier/sigspace.t lines 27–48</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-substitution/subst.t#L212-L222" target="_blank" rel="external"><code>S05-substitution/subst.t lines 212–222</code></a><br>  ​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ms/match some words/                        # 和 m:sigspace  相同</div><div class="line">ss/match some words/replace those words/    # 和 s:samespace 相同</div></pre></td></tr></table></figure></p>
<p>注意 <code>ss///</code> 是就 <code>:ss</code> 而言所定义的, 所以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$_ = &quot;a b\nc\td&quot;;</div><div class="line">ss/b c d/x y z/;</div></pre></td></tr></table></figure>
<p>结果就是  <code>a x\ny\tz</code>.</p>
<ul>
<li>新修饰符可指定 Unicode 级别:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">m:bytes  / .**2 /       # 匹配两个字节</div><div class="line">m:codes  / .**2 /       # match two codepoints</div><div class="line">m:graphs / .**2 /       # match two language-independent graphemes</div><div class="line">m:chars  / .**2 /       # match two characters at current max level</div></pre></td></tr></table></figure>
<ul>
<li>新的 <code>:Perl5</code>/<code>:P5</code> 修饰符允许使用 Perl 5 正则语法 (现在不允许你把修饰符放在后面). 例如,</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:P5/(?mi)^(?:[a-z]|\d)&#123;1,2&#125;(?=\s)/</div></pre></td></tr></table></figure>
<p>等价于 Perl 6 语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m/ :i ^^ [ &lt;[a..z]&gt; || \d ] ** 1..2 &lt;?before \s&gt; /</div></pre></td></tr></table></figure>
<ul>
<li>任何一个整数修饰符指定一个计数. 数字后面的字符决定了计数的种类:</li>
<li>如果后面跟着一个 <code>x</code>, 则意味着重复. 一般使用 <code>:x(4)</code> 这种形式:</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-modifier/repetition-exhaustive.t#L16-L30" target="_blank" rel="external"><code>S05-modifier/repetition-exhaustive.t lines 16–30</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/repetition.t#L6-L29" target="_blank" rel="external"><code>S05-modifier/repetition.t lines 6–29</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s:4x [ (&lt;.ident&gt;) &apos;=&apos; (\N+) $$] = &quot;$0 =&gt; $1&quot;;</div></pre></td></tr></table></figure>
<p>等同于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s:x(4) [ (&lt;.ident&gt;) &apos;=&apos; (\N+) $$] = &quot;$0 =&gt; $1&quot;;</div></pre></td></tr></table></figure>
<p>这几乎等同于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s:c[ (&lt;.ident&gt;) &apos;=&apos; (\N+) $$] = &quot;$0 =&gt; $1&quot; for 1..4;</div></pre></td></tr></table></figure>
<p>except that the string is unchanged unless all four matches are found. However, ranges are allowed, so you can say <code>:x(1..4)</code> to change anywhere from one to four matches.</p>
<ul>
<li>如果数字后面跟着 <code>st</code>, <code>nd</code>, <code>rd</code>, 或 <code>th</code>, 它意味着查找第<code>*N*th</code> 次出现.  一般使用 <code>:nth(3)</code> 这种形式, 所以<br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/counted.t#L13-L252" target="_blank" rel="external"><code>S05-modifier/counted.t lines 13–252</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s:3rd/(\d+)/@data[$0]/;</div></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s:nth(3)/(\d+)/@data[$0]/;</div></pre></td></tr></table></figure>
<p>它等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m/(\d+)/ &amp;&amp; m:c/(\d+)/ &amp;&amp; s:c/(\d+)/@data[$0]/;</div></pre></td></tr></table></figure>
<p>​例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$_ =  &quot;123abc456def789hij&quot;</div><div class="line">s:3rd/(\d+)/&quot;PERL&quot;/;  # $_ =&gt; 123abc456def&quot;PERL&quot;hij</div><div class="line">s:2rd/(\d+)/PHP/;     # $_ =&gt; 123abcPHPdef&quot;PERL&quot;hij</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$_ = &quot;0abc1DEF2cfg3OOP&quot;;</div><div class="line">my @data =(&apos;-&apos;, &apos;_&apos;, &apos;:&apos;);</div><div class="line">s:3rd/(\d+)/@data[$0]/;    # $_ =&gt; 0abc1DEF:cfg3OOP</div></pre></td></tr></table></figure>
<p><code>:nth</code> 的参数允许是一个整数列表, 但是这样的列表应该是单调递增的.(任何小于等于前一个值的值都会被忽略.) 所以:<br>  ​</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:nth(2,4,6...*)    # return only even matches</div><div class="line">:nth(1,1,*+*...*)  # match only at 1,2,3,5,8,13...</div></pre></td></tr></table></figure>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$_ = &quot;1 2 3 4 5 6 7 8 9&quot;;</div><div class="line">my @a = m:nth(2,4,6,8)/(\d+)/; # 返回 2 4 6 8</div></pre></td></tr></table></figure>
<p>该选项不再要求支持智能匹配。你可以 grep 一个整数列表如果你真的需要那个能力:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:nth(grep *.oracle, 1..*)</div></pre></td></tr></table></figure>
<p>如果 <code>:nth</code> 和 <code>:x</code> 都出现了, 那么相匹配的子例程查找使用 <code>:nth</code> 匹配的子匹配。如果第后 nth 个匹配的数量与 <code>:x</code> 中的约束相容, 那么整个匹配成功, 并且子匹配的可能的数量最高。如果 <code>:nth</code> 不是单个标量, 则 <code>:nth</code> 和 <code>:x</code> 通常才有意义。</p>
<ul>
<li>使用新的 <code>:ov</code> (<code>:overlap</code>) 修饰符, 当前的 regex 会在所有可能的字符位置上(包括重叠)匹配, 并在列表上下文中返回所有的匹配, 或在 item 上下文中返回间断的匹配。任一位子的第一个匹配会被返回。匹配保证了相对于开始位置, 会以从左到右的顺序返回。</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-modifier/overlapping.t#L16-L67" target="_blank" rel="external"><code>S05-modifier/overlapping.t lines 16–67</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$str = &quot;abracadabra&quot;;</div><div class="line">if $str ~~ m:overlap/ a (.*) a / &#123;</div><div class="line">     @substrings = slice @();    # bracadabr cadabr dabr br</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用新的 <code>:ex</code> (<code>:exhaustive</code>) 修饰符, 当前正则会匹配所有可能的路径(包括重叠)并返回所有 <code>matches</code>的一个列表.<br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/exhaustive.t#L10-L147" target="_blank" rel="external"><code>S05-modifier/exhaustive.t lines 10–147</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/repetition-exhaustive.t#L17-L30" target="_blank" rel="external"><code>S05-modifier/repetition-exhaustive.t lines 17–30</code></a></li>
</ul>
<p>匹配确保会相对于起始位置以从左到右的顺序返回。每个起始位置之内的顺序不能收到保证, 并且可能依赖于模式和匹配引擎两者。(推测: 或者我们能强制回溯引擎语义。或者我们可以保证一点也没有顺序, 除非模式以 <code>::</code> 开始或者某种这样的东西抑制了 DFAish 方法。)<br>  ​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$str = &quot;abracadabra&quot;;</div><div class="line">if $str ~~ m:exhaustive/ a (.*?) a / &#123;</div><div class="line">   say &quot;@()&quot;;    # br brac bracad bracadabr c cad cadabr d dabr br</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意一旦发现第一个匹配, 上面的 <code>~~</code> 就返回, 而匹配的剩余部分可能通过 <code>@()</code> 来懒惰地执行。<br>  ​</p>
<ul>
<li>新的 <code>:rw</code> 修饰符让该 regex 要求当前的字符串可以修改而非假设写时复制语义。 <code>$/</code> 中所有的捕获变成了左值字符串, 这样如果你修改, 例如, <code>$1</code>, 那么原来的字符串在那个位置被修改, 并且所有其它字段的的位置也相应地修改(不管它是什么意思)。如果没有该修饰符, (特别是如果它尚未实现或永远不会被实现), 那么 <code>$/</code> 的所有片段都被当作是写时复制的, 如果不是只读的话。</li>
</ul>
<p>[猜测: 这应该真正把模式和字符串变量联合在一起, 而不是一个字符串值(可能是不可变的)]</p>
<ul>
<li>新的 <code>:r</code> 或 <code>:ratchet</code> 修饰符让这个 regex 默认不回溯。 (通常你不直接使用这个修饰符, 因为在 <code>token</code> 和 <code>rule</code> 声明符中已经隐式地包含了这个修饰符, 也就是说 <strong>token</strong> 和 <strong>rule</strong> 默认也是不回溯的。) 这个修饰符的作用是在每个原子(atom)后面暗指一个 <code>:</code>, 包括但不限于  <code>*</code>, <code>+</code>, 和 <code>?</code> 量词, 还有备选分支。量词化原子上的显式回溯修饰符, 例如 <code>**</code>, 会重写这个修饰符。 </li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ratchet.t#L5-L27" target="_blank" rel="external"><code>S05-modifier/ratchet.t lines 5–27</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L92-L99" target="_blank" rel="external"><code>S05-mass/rx.t lines 92–99</code></a></p>
<ul>
<li><code>:i</code>, <code>:m</code>, <code>:r</code>, <code>:s</code>, <code>:dba</code>, <code>:Perl5</code>, 和  Unicode 级别的修饰符能被放在 regex 里面  (并且是词法作用域的):<br><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ignorecase.t#L18-L23" target="_blank" rel="external"><code>S05-modifier/ignorecase.t lines 18–23</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m/:s alignment &apos;=&apos; [:i left|right|cent[er|re]] /</div></pre></td></tr></table></figure>
<p>就像外面的修饰符一样,  只有圆括号能够作为副词的参数被识别为合法的括号. 特别地:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">m/:foo[xxx]/        Parses as :foo [xxx]</div><div class="line">m/:foo&#123;xxx&#125;/        Parses as :foo &#123;xxx&#125;</div><div class="line">m/:foo&lt;xxx&gt;/        Parses as :foo &lt;xxx&gt;</div></pre></td></tr></table></figure>
<ul>
<li>用户自定义修饰符成为可能:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:fuzzy/pattern/;</div></pre></td></tr></table></figure>
<ul>
<li>用户自定义修饰符也能接收参数, 但是只能在圆括号中:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:fuzzy(&apos;bare&apos;)/pattern/;</div></pre></td></tr></table></figure>
<ul>
<li>要使用括号作为你的分隔符你必须隔开:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:fuzzy (pattern);</div></pre></td></tr></table></figure>
<p>或者把 pattern 放在最后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m:fuzzy(fuzzyargs); pattern ;</div></pre></td></tr></table></figure>
<ul>
<li>任何 grammar regex 实际上是一种<code>方法</code>, 并且你可以在这样一个子例程中使用一个冒号跟着任何作用域声明符来声明一个变量, 这些声明符包括 <code>my</code>, <code>our</code>, <code>state</code> 和 <code>constant</code> (作为类似的声明符, temp 和 let 也能被识别). 单个语句(直到结尾的分号或行末尾的闭括号为止) 被解析为普通的 Perl 6 代码:</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-modifier/my.t#L5-L87" target="_blank" rel="external"><code>S05-modifier/my.t lines 5–87</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">token prove-nondeterministic-parsing &#123;</div><div class="line">    :my $threshold = rand;</div><div class="line">    &apos;maybe&apos; \s+ &lt;it($threshold)&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种作用域声明符不会终止最长 token 匹配, 所以无效的声明符可以作为作为一个挂钩来挂起副作用而不改变随后的模式匹配:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rule breaker &#123;</div><div class="line">    :state $ = say &quot;got here at least once&quot;;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的动态变量]]></title>
      <url>http://ohmycloud.github.io/2016/02/29/Perl6%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<p>Perl 6 中的<a href="http://qiita.com/B73W56H84/items/18053bf37de8bb2bb808#err" target="_blank" rel="external">动态变量</a></p>
<h2 id="ARGFILES"><a href="#ARGFILES" class="headerlink" title="$*ARGFILES"></a>$*ARGFILES</h2><hr>
<blockquote>
<p>$*ARGFILES Magic command-line input handle.</p>
</blockquote>
<p><strong><code>argfiles.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">$*ARGFILES.perl.say; #=&gt; IO::Handle.new(:path(Any),:chomp)</div><div class="line"></div><div class="line"># 按行读取</div><div class="line">for $*ARGFILES.lines -&gt; $line &#123;</div><div class="line">    say &quot;$line&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 一次性读取</div><div class="line"># say $*ARGFILES.slurp;</div></pre></td></tr></table></figure>
<p><strong><code>USAGE</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ perl6 argfiles.pl6 file1 file2 file3 ...</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://doc.perl6.org/type/IO::Handle" target="_blank" rel="external">class IO::Handle - Perl 6 Documentation</a></li>
<li><a href="http://doc.perl6.org/language/io" target="_blank" rel="external">Input/Output - Perl 6 Documentation</a></li>
<li><a href="http://qiita.com/syohex/items/0a7782920968ab105ba0" target="_blank" rel="external">Perl6文件操作 - Qiita</a></li>
</ul>
<h2 id="ARGS"><a href="#ARGS" class="headerlink" title="@*ARGS"></a>@*ARGS</h2><hr>
<blockquote>
<p>@*ARGS - Arguments from the command line. 命令行中的参数。</p>
</blockquote>
<p><strong><code>agrs.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say @*ARGS.WAHT;    #=&gt; (Array)</div><div class="line">say @*ARGS;         #=&gt; [a b c d e]</div><div class="line"></div><div class="line">say @*ARGS.perl;    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</div></pre></td></tr></table></figure>
<p><strong><code>USAGE</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ perl6 args.pl6 a b c d e</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://doc.perl6.org/type/Array" target="_blank" rel="external">class Array - Perl 6 Documentation</a></li>
</ul>
<h2 id="IN"><a href="#IN" class="headerlink" title="$*IN"></a>$*IN</h2><hr>
<blockquote>
<p>$*IN - 标准输入文件句柄, 等同于 stdin</p>
</blockquote>
<p><strong><code>in.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*IN.perl;   #=&gt; IO::Handle.new(:path(IO::Special.new(what =&gt; &quot;&lt;STDIN&gt;&quot;)),:chomp)</div><div class="line">say $*IN.path;   #=&gt; IO::Special.new(what =&gt; &quot;&lt;STDIN&gt;&quot;)</div><div class="line">say $*IN.chomp;  #=&gt; True</div><div class="line"></div><div class="line">for $*IN.lines -&gt; $line &#123;</div><div class="line"> say &quot;$line&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>USAGE</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ perl6 in.pl6</div><div class="line">人力</div><div class="line">...</div><div class="line"></div><div class="line">$ cat somefile.txt | perl6 in.pl6</div></pre></td></tr></table></figure>
<h2 id="OUT"><a href="#OUT" class="headerlink" title="$*OUT"></a>$*OUT</h2><hr>
<blockquote>
<p>$*OUT - 标准输出文件句柄, 等同于 stdout</p>
</blockquote>
<p><strong><code>out.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*OUT.perl;   #=&gt; IO::Handle.new(:path(IO::Special.new(what =&gt; &quot;&lt;STDOUT&gt;&quot;)),:chomp)</div><div class="line">say $*OUT.path;   #=&gt; IO::Special.new(what =&gt; &quot;&lt;STDOUT&gt;&quot;)</div><div class="line">say $*OUT.chomp;  #=&gt; True</div><div class="line"></div><div class="line">$*OUT.say( q:to/新年快乐/ );</div><div class="line">    祝你新年快乐</div><div class="line">    2016.01.23</div><div class="line">    让我再说一次</div><div class="line">新年快乐</div><div class="line"></div><div class="line"># 通常我们会在打印时省略 $*OUT</div><div class="line"># say &quot;哈利路亚&quot;;</div></pre></td></tr></table></figure>
<p>最后一段代码中 <code>//</code> 中间的字符是分割符。这打印出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">祝你新年快乐</div><div class="line">2016.01.23</div><div class="line">让我再说一次</div></pre></td></tr></table></figure>
<p><strong><code>USAGE</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 out.pl6</div><div class="line">$ perl6 out.pl6 &gt; result.txt</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://doc.perl6.org/type/IO" target="_blank" rel="external">role IO - Perl 6 Documentation</a></li>
</ul>
<h2 id="ERR"><a href="#ERR" class="headerlink" title="$*ERR"></a>$*ERR</h2><hr>
<blockquote>
<p>$*ERR - 标准错误文件句柄, 等同于 stderr</p>
</blockquote>
<p><strong><code>err.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*ERR.perl;   #=&gt; IO::Handle.new(:path(IO::Special.new(what =&gt; &quot;&lt;STDERR&gt;&quot;)),:chomp)</div><div class="line">say $*ERR.path;   #=&gt; IO::Special.new(what =&gt; &quot;&lt;STDERR&gt;&quot;)</div><div class="line">say $*ERR.chomp;  #=&gt; True</div><div class="line"></div><div class="line">$*ERR.say(&quot;我错了&quot;);</div><div class="line"></div><div class="line"># 平时可以使用 note</div><div class="line"># note &quot;前方高能预警&quot;;</div></pre></td></tr></table></figure>
<p><strong><code>USAGE</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 err.pl6 &gt; /dev/null</div><div class="line">我错了</div></pre></td></tr></table></figure>
<h2 id="REPO"><a href="#REPO" class="headerlink" title="$*REPO"></a>$*REPO</h2><hr>
<blockquote>
<p>$*REPO A variable holding information about modules installed/loaded</p>
</blockquote>
<p><strong><code>repo.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*REPO;</div><div class="line">say $*REPO.perl;</div><div class="line">say $*REPO.id;</div><div class="line">say $*REPO.path-spec;</div><div class="line">say $*REPO.loaded;</div><div class="line">say $*REPO.repo-chain;</div></pre></td></tr></table></figure>
<h2 id="TZ"><a href="#TZ" class="headerlink" title="$*TZ"></a>$*TZ</h2><hr>
<blockquote>
<p>$*TZ The system’s local timezone.</p>
</blockquote>
<p><strong><code>tz.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*TZ;      #=&gt; 32400</div><div class="line">say $*TZ.perl; #=&gt; 32400</div><div class="line"></div><div class="line">say $*TZ.WHAT; #=&gt; (Int)</div></pre></td></tr></table></figure>
<h2 id="CWD"><a href="#CWD" class="headerlink" title="$*CWD"></a>$*CWD</h2><hr>
<blockquote>
<p>$*CWD The Current Working Directory.</p>
</blockquote>
<p><strong><code>cwd.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*CWD;       #=&gt; &quot;/Users/kujira&quot;.IO</div><div class="line">say $*CWD.path;  #=&gt; /Users/kujira</div><div class="line">say $*CWD.perl;  #=&gt; &quot;/Users/kujira&quot;.IO(:SPEC(IO::Spec::Unix),:CWD(&quot;/Users/kujira&quot;))</div></pre></td></tr></table></figure>
<h2 id="KERNEL"><a href="#KERNEL" class="headerlink" title="$*KERNEL"></a>$*KERNEL</h2><hr>
<blockquote>
<p>$*KERNEL Which kernel am I compiled for?</p>
</blockquote>
<p><strong><code>kernel.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*KERNEL;            #=&gt; darwin (15.2.0)</div><div class="line">say $*KERNEL.release;    #=&gt; Darwin Kernel Version 15.2.0: Fri Nov 13 19:56:56 PST 2015; root:xnu-3248.20.55~2/RELEASE_X86_64</div><div class="line">say $*KERNEL.name;       #=&gt; darwin</div><div class="line">say $*KERNEL.auth;       #=&gt; unknown</div><div class="line">say $*KERNEL.version;    #=&gt; v15.2.0</div><div class="line">say $*KERNEL.signature;  #=&gt; (Blob)</div><div class="line">say $*KERNEL.desc;       #=&gt; (Str)</div><div class="line"></div><div class="line">say $*KERNEL.perl;        #=&gt; Kernel.new(release =&gt; Str, name =&gt; &quot;darwin&quot;, auth =&gt; &quot;unknown&quot;, version =&gt; Version.new(&apos;15.2.0&apos;), signature =&gt; Blob, desc =&gt; Str)</div><div class="line">say $*KERNEL.WHAT;        #=&gt; (Kernel)</div></pre></td></tr></table></figure>
<h2 id="DISTRO"><a href="#DISTRO" class="headerlink" title="$*DISTRO"></a>$*DISTRO</h2><hr>
<blockquote>
<p>$*DISTRO Which OS distribution am I compiling under?</p>
</blockquote>
<p><strong><code>distro.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*DISTRO;           #=&gt; macosx (10.11.2)</div><div class="line"></div><div class="line">say $*DISTRO.name;      #=&gt; macosx</div><div class="line">say $*DISTRO.is-win;    #=&gt; False</div><div class="line">say $*DISTRO.version;   #=&gt; v10.11.2</div><div class="line"></div><div class="line">say $*DISTRO.path-sep;  #=&gt; :</div><div class="line">say $*DISTRO.auth;      #=&gt; Apple Computer, Inc.</div><div class="line">say $*DISTRO.desc;      #=&gt; 2016-01-17T01:48:03.261407+09:00</div><div class="line">say $*DISTRO.release;   #=&gt; 15C50</div><div class="line">say $*DISTRO.signature; #=&gt; (Blob)</div><div class="line"></div><div class="line">say $*DISTRO.gist;      #=&gt; macosx (10.11.2)</div><div class="line">say $*DISTRO.Str;       #=&gt; macosx</div><div class="line">say $*DISTRO.perl;      #=&gt; Distro.new(release =&gt; &quot;15C50&quot;, is-win =&gt; Bool::False, path-sep =&gt; &quot;:&quot;, name =&gt; &quot;macosx&quot;, auth =&gt; &quot;Apple Computer, Inc.&quot;, version =&gt; Version.new(&apos;10.11.2&apos;), signature =&gt; Blob, desc =&gt; &quot;2016-01-17T01:48:47.273804+09:00&quot;)</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://blog.64p.org/entry/2015/09/05/225701" target="_blank" rel="external">Perl6 で windows かどうか判定したい - tokuhirom’s blog</a></li>
<li><a href="https://github.com/perl6/roast/blob/master/S02-magicals/DISTRO.t" target="_blank" rel="external">DISTRO.t</a></li>
</ul>
<h2 id="VM"><a href="#VM" class="headerlink" title="$*VM"></a>$*VM</h2><hr>
<blockquote>
<p>$*VM Which virtual machine am I compiling under?</p>
</blockquote>
<p><strong><code>vm.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*VM;         #=&gt; moar (2015.12)</div><div class="line"></div><div class="line">say $*VM.config;</div><div class="line">say $*VM.perl;</div></pre></td></tr></table></figure>
<h2 id="PERL"><a href="#PERL" class="headerlink" title="$*PERL"></a>$*PERL</h2><hr>
<blockquote>
<p>$*PERL Which Perl am I compiled for?</p>
</blockquote>
<p><strong><code>perl.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*PERL;          #=&gt; Perl 6 (6.c)</div><div class="line">say $*PERL.compiler; #=&gt; rakudo (2015.12)</div><div class="line"></div><div class="line">say $*PERL.perl;     #=&gt; Perl.new(compiler =&gt; Compiler.new(id =&gt; &quot;AEB5E66886F036F5AF7448E587F49EB233F6F7F5.1451295526.86961&quot;, release =&gt; &quot;&quot;, codename =&gt; &quot;&quot;, name =&gt; &quot;rakudo&quot;, auth =&gt; &quot;The Perl Foundation&quot;, version =&gt; Version.new(&apos;2015.12&apos;), signature =&gt; Blob, desc =&gt; Str), name =&gt; &quot;Perl 6&quot;, auth =&gt; &quot;The Perl Foundation&quot;, version =&gt; Version.new(&apos;6.c&apos;), signature =&gt; Blob, desc =&gt; Str)</div></pre></td></tr></table></figure>
<h2 id="PID"><a href="#PID" class="headerlink" title="$*PID"></a>$*PID</h2><hr>
<blockquote>
<p>$*PID Process ID of the current process.</p>
</blockquote>
<p><strong><code>pid.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*PID;      #=&gt; 35480</div><div class="line">say $*PID.perl; #=&gt; 35480</div><div class="line">say $*PID.WHAT; #=&gt; (Int)</div></pre></td></tr></table></figure>
<h2 id="PROGRAM-NAME"><a href="#PROGRAM-NAME" class="headerlink" title="$*PROGRAM-NAME"></a>$*PROGRAM-NAME</h2><hr>
<blockquote>
<p>$*PROGRAM-NAME Path to the current executable as it was entered on the command line, or C&lt;-e&gt; if perl was invoked with the -e flag.</p>
</blockquote>
<p><strong><code>program-name.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*PROGRAM-NAME;</div><div class="line">say $*PROGRAM-NAME.perl;</div><div class="line">say $*PROGRAM-NAME.IO.basename;</div></pre></td></tr></table></figure>
<h2 id="PROGRAM"><a href="#PROGRAM" class="headerlink" title="$*PROGRAM"></a>$*PROGRAM</h2><hr>
<blockquote>
<p>$*PROGRAM Location (in the form of an C<a href="undefined">IO::Path</a> object) of the Perl program being executed.</p>
</blockquote>
<p><strong><code>program.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*PROGRAM;        #=&gt; &quot;/Users/kujira/program.pl6&quot;.IO</div><div class="line">say $*PROGRAM.Str;    #=&gt; program.pl6</div><div class="line"></div><div class="line">say $*PROGRAM.perl;   #=&gt; &quot;program.pl6&quot;.IO(:SPEC(IO::Spec::Unix),:CWD(&quot;/Users/kujira&quot;))</div><div class="line"></div><div class="line">say $*PROGRAM.SPEC;   #=&gt; (Unix)</div><div class="line">say $*PROGRAM.CWD;    #=&gt; /Users/kujira</div><div class="line"></div><div class="line">say $*PROGRAM.WHAT;   #=&gt; (Path)</div></pre></td></tr></table></figure>
<h2 id="EXECUTABLE"><a href="#EXECUTABLE" class="headerlink" title="$*EXECUTABLE"></a>$*EXECUTABLE</h2><hr>
<blockquote>
<p>$*EXECUTABLE Absolute path of the perl executable that is currently running.</p>
</blockquote>
<p><strong><code>executable.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*EXECUTABLE;           #=&gt; &quot;/usr/local/bin/perl6&quot;.IO</div><div class="line">say $*EXECUTABLE.Str;       #=&gt; /usr/local/bin/perl6</div><div class="line">say $*EXECUTABLE.basename;  #=&gt; perl6</div><div class="line"></div><div class="line">say $*EXECUTABLE.WHAT;      #=&gt; (Path)</div><div class="line"></div><div class="line">say $*EXECUTABLE.perl;      #=&gt; &quot;/usr/local/bin/perl6&quot;.IO(:SPEC(IO::Spec::Unix))</div><div class="line">say $*EXECUTABLE.SPEC;      #=&gt; (Unix)</div></pre></td></tr></table></figure>
<h2 id="EXECUTABLE-NAME"><a href="#EXECUTABLE-NAME" class="headerlink" title="$*EXECUTABLE-NAME"></a>$*EXECUTABLE-NAME</h2><hr>
<blockquote>
<p>$<em>EXECUTABLE-NAME The name of the perl executable that is currently running. (e.g. perl6-p, perl6-m, Niecza.exe) Favor $</em>EXECUTABLE because it is not guaranteed that the perl executable is in PATH.</p>
</blockquote>
<p><strong><code>executable-name.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*EXECUTABLE-NAME;       #=&gt; perl6</div><div class="line">say $*EXECUTABLE-NAME.WHAT;  #=&gt; (Str)</div></pre></td></tr></table></figure>
<h2 id="USER"><a href="#USER" class="headerlink" title="$*USER"></a>$*USER</h2><hr>
<blockquote>
<p>$*USER The user that is running the program. It is an object that evaluates to “username (uid)”. It will evaluate to the username only if treated as a string and the numeric user id if treated as a number.</p>
</blockquote>
<p><strong><code>user.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*USER;      #=&gt; kujira (801)</div><div class="line"></div><div class="line">say +$*USER;     #=&gt; 801</div><div class="line">say ~$*USER;     #=&gt; kujira</div><div class="line"></div><div class="line">say $*USER.perl; #=&gt; IdName.new</div></pre></td></tr></table></figure>
<h2 id="GROUP"><a href="#GROUP" class="headerlink" title="$*GROUP"></a>$*GROUP</h2><hr>
<blockquote>
<p>$*GROUP The primary group of the user who is running the program. It is an object that evaluates to “groupname (gid)”. It will evaluate to the groupname only if treated as a string and the numeric group id if treated as a number.</p>
</blockquote>
<p><strong><code>group.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*GROUP;       #=&gt; whale (0)</div><div class="line"></div><div class="line">say ~$*GROUP;      #=&gt; whale</div><div class="line">say +$*GROUP;      #=&gt; 0</div><div class="line"></div><div class="line">say $*GROUP.perl;  #=&gt; IdName.new</div></pre></td></tr></table></figure>
<h2 id="HOME"><a href="#HOME" class="headerlink" title="$*HOME"></a>$*HOME</h2><hr>
<blockquote>
<p>$*HOME An L<a href="undefined">IO::Path</a> object representing the “home directory” of the user that is running the program. If the “home directory” cannot be determined it will be L</p>
</blockquote>
<p><strong><code>home.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*HOME;       #=&gt; &quot;/Users/kujira&quot;.IO</div><div class="line"></div><div class="line">say $*HOME.CWD;   #=&gt; /Users/kujira</div><div class="line">say $*HOME.SPEC;  #=&gt; (Unix)</div><div class="line">say $*HOME.WHAT;  #=&gt; (Path)</div><div class="line"></div><div class="line">say $*HOME.perl;  #=&gt; &quot;/Users/kujira&quot;.IO(:SPEC(IO::Spec::Unix),:CWD(&quot;/Users/kujira&quot;))</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://doc.perl6.org/type/IO::Path" target="_blank" rel="external">class IO::Path - Perl 6 Documentation</a></li>
</ul>
<h2 id="SPEC"><a href="#SPEC" class="headerlink" title="$*SPEC"></a>$*SPEC</h2><hr>
<blockquote>
<p>$*SPEC The appropriate L<a href="undefined">IO::Spec</a> sub-class for the platform that the program is running on.</p>
</blockquote>
<p><strong><code>spec.pl6</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say $*SPEC;          #=&gt; (Unix)</div><div class="line">say $*SPEC.perl;     #=&gt; IO::Spec::Unix</div><div class="line">say $*SPEC.path;     #=&gt; (/usr/local/Cellar/rakudo-star/2015.12/share/perl6/site/bin /usr/local/sbin /usr/local/bin /usr/bin /bin /usr/sbin /sbin)</div><div class="line">say $*SPEC.tmpdir;   #=&gt; &quot;/var/folders/9v/wr31l2zj78x1nw58jgljq_9w0000gn/T&quot;.IO</div><div class="line">say $*SPEC.dir-sep;  #=&gt; /</div><div class="line">say $*SPEC.curdir;   #=&gt; .</div><div class="line">say $*SPEC.updir;    #=&gt; ..</div><div class="line">say $*SPEC.curupdir; #=&gt; none(., ..)</div><div class="line">say $*SPEC.rootdir;  #=&gt; /</div><div class="line">say $*SPEC.devnull;  #=&gt; /dev/null</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://doc.perl6.org/type/IO::Spec" target="_blank" rel="external">class IO::Spec - Perl 6 Documentation</a></li>
<li><a href="http://doc.perl6.org/type/IO::Spec::QNX" target="_blank" rel="external">class IO::Spec::QNX - Perl 6 Documentation</a></li>
<li><a href="http://doc.perl6.org/type/IO::Spec::Unix" target="_blank" rel="external">class IO::Spec::Unix - Perl 6 Documentation</a></li>
<li><a href="http://doc.perl6.org/type/IO::Spec::Win32" target="_blank" rel="external">class IO::Spec::Win32 - Perl 6 Documentation</a></li>
<li><a href="http://doc.perl6.org/type/IO::Spec::Cygwin" target="_blank" rel="external">class IO::Spec::Cygwin - Perl 6 Documentation</a></li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><a href="http://qiita.com/B73W56H84/items/18053bf37de8bb2bb808#%E5%8F%82%E8%80%83%E3%81%A8%E6%B3%A8%E9%87%88" target="_blank" rel="external"></a></h2><hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bless]]></title>
      <url>http://ohmycloud.github.io/2016/02/26/bless/</url>
      <content type="html"><![CDATA[<h2 id="bless-方法"><a href="#bless-方法" class="headerlink" title="bless 方法"></a>bless 方法</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method bless(*%attrinit) returns Mu:D</div></pre></td></tr></table></figure>
<p>相比 <code>new</code>方法来说更低层级别的对象构造方法。</p>
<p>创建一个和调用者同类型的新对象, 使用具名参数来初始化属性, 并返回创建后的<strong>对象</strong>。</p>
<p>在自定义构造函数时可以使用该方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line"></div><div class="line">    # multi 是可选的</div><div class="line">    multi method new($x, $y) &#123;</div><div class="line">        self.bless(:$x, :$y);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 重写构造函数后, 不需要传具名参数了</div><div class="line">my $p = Point.new(-1, 1);</div><div class="line">say $p.x; # -1</div></pre></td></tr></table></figure>
<blockquote>
<p>虽然你可以自定义构造函数, 记得它会让子类继承变得更困难。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line"># bless 的原理</div><div class="line">class Dog &#123;</div><div class="line">    has $.name;</div><div class="line">    my $.counter; # 类方法</div><div class="line">    # 重写 new 方法, 使用位置参数创建实例</div><div class="line">    method new ($newName) &#123;</div><div class="line">        $.counter++;</div><div class="line">        self.bless(name =&gt; $newName);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $dog = Dog.new(&quot;yayaya&quot;);</div><div class="line">say $dog.name;   # yayaya</div><div class="line">say Dog.counter; # 1</div></pre></td></tr></table></figure>
<h2 id="让我们创建一个对象"><a href="#让我们创建一个对象" class="headerlink" title="让我们创建一个对象"></a>让我们创建一个对象</h2><hr>
<p>在 Perl 6 中创建一个对象相当容易。 作为类的作者你真的不必关心(至少在最简单的情况下), 你从 <code>Mu</code> 类继承了一个默认的构造函数。作为类的使用者, 你仅仅写出 <code>MyClass.new(attrib1 =&gt; $value1)</code> 就能创建一个 <code>MyClass</code>类的对象, 同时初始化了一个公开的属性 <strong>attrib1</strong>。</p>
<h2 id="运行初始化代码"><a href="#运行初始化代码" class="headerlink" title="运行初始化代码"></a>运行初始化代码</h2><hr>
<p>如果你想在对象创建中运行某些初始化代码, 那么你一点儿也没有必要动用 <code>new</code>方法。使用 <strong>BUILD</strong> 子方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    submethod BUILD &#123;</div><div class="line">        say &quot;创建一个 C 的实例&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">C.new();  # 创建一个 C 的实例</div></pre></td></tr></table></figure>
<p><strong>BUILD</strong> submethod 由构造函数自动调用, 并且可以处理任何必要的初始化。<strong>BUILD</strong> submethod 也能接收用户传递给 <code>new()</code> 方法的具名参数。</p>
<p>(以防你疑惑,  <strong>submethod</strong> 是<strong>不能</strong>被子类继承的方法。)</p>
<p>因为 <strong>BUILD</strong> 运行在尚未完全构建好的对象上,  属性只有在被声明为具名参数的时候才可以被访问:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">submethod BUILD(:$!attr1, :$!attr2) &#123;</div><div class="line">    # 这儿可以使用 $!attr1 和 $!attr2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该语法也自动的使用和 <code>new</code>方法同名的具名参数的值初始化属性 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">class Cat &#123;</div><div class="line">    has $.fullname;</div><div class="line">    has $.nickname;</div><div class="line"></div><div class="line">    submethod BUILD(:$!fullname, :$!nickname) &#123;</div><div class="line">        say &quot;造了一只猫, 它的全名是 $!fullname, 它的昵称是 $!nickname&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 造了一只猫, 它的全名是 Camelia, 它的昵称是 Rakudo Star</div><div class="line">Cat.new(fullname =&gt; &apos;Camelia&apos;, nickname =&gt; &apos;Rakudo Star&apos;);</div></pre></td></tr></table></figure>
<p>所以下面的两个类声明, 表现一样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class D &#123;</div><div class="line">    has $.x;</div><div class="line">&#125;</div><div class="line"># and</div><div class="line">class D &#123;</div><div class="line">    has $!x;                   # 私有属性</div><div class="line">    submethod BUILD(:$!x) &#123;&#125;   # 允许 D.new( x =&gt; $x )</div><div class="line">    method x() &#123;$!x&#125;           # accessor</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这也解释了 <code>has $.x</code> 等价于 <code>has $!x</code> 加上 accessor 的原理。</p>
<h2 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h2><hr>
<p>假如你对具名参数不感冒, 而你想自定义一个接收<strong>一个</strong>强制位置参数的构造函数。那样你就需要自定义 <code>new</code>方法。要创建一个对象, 被重写的 new 方法中<strong>必须</strong>调用 <code>self.bless</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    has $.size;</div><div class="line">    method new($x) &#123;</div><div class="line">        self.bless(*, size =&gt; 2 * $x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say C.new(3).size; # 接收一个位置参数, 打印出 6</div></pre></td></tr></table></figure>
<p><code>bless</code>的第一个参数 <strong>*</strong>号告诉它创建一个空对象自身。</p>
<p>如果你想开启额外的具名参数, 那很容易:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    has $.size;</div><div class="line">    method new($x, *%remaining) &#123;</div><div class="line">        self.bless(*, size =&gt; 2 * $x, |%remaining);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意, 这两个概念(自定义 new() 和 BUILD() (sub)methods) 是正交的; 你一次可以使用它俩, 它俩能和谐共处。</p>
<h2 id="属性的默认值"><a href="#属性的默认值" class="headerlink" title="属性的默认值"></a>属性的默认值</h2><hr>
<p>为属性提供默认值的最方便的方式是在声明属性的时候为属性提供默认值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Window &#123;</div><div class="line">    has $.height = 600;</div><div class="line">    has $.width  = $.height * 1.618;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认值只会用在底层属性没有被 <code>new</code> 或 <code>BUILD</code>接触的时候使用。</p>
<h2 id="理解对象初始化"><a href="#理解对象初始化" class="headerlink" title="理解对象初始化"></a>理解对象初始化</h2><hr>
<p>假如你有一个类 C 继承自类 B, 那么创建一个类 C 的对象的处理看起来是这样:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-b43db2865db0c528.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>用户调用 <code>C.new</code>, 这反过来调用 <code>self.bless(*, |args)</code>。<strong>bless</strong> 方法创建了一个新的存储新创建对象的 <strong>P6Opaque</strong> 对象。这就是调用上图中的 <strong>CREATE</strong>。</p>
<p>分配完存储空间和属性初始化之后,  <code>new</code>把控制权传给<strong>BUILDALL</strong>(顺带传递所有的具名参数), 这反过来会从层级树的顶端开始, 调用继承层级树上所有类的 <strong>BUILD</strong> 方法,  最后调用类 C 的 <strong>BUILD</strong> 方法。</p>
<p>这样的设计允许你花费最少的力气来替换初始化的一部分, 尤其是自定义 <strong>new</strong> 和 <strong>BUILD</strong> 方法会很容易写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">class B &#123;</div><div class="line">    has $.name;</div><div class="line"></div><div class="line">    submethod BUILD(:$!name) &#123;</div><div class="line">        say &quot;调用了 B 的 BUILD, 我叫 $!name&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C is B &#123;</div><div class="line">    has $.nickname;</div><div class="line"></div><div class="line">    submethod BUILD(:$!nickname, :$name) &#123;</div><div class="line">        say &quot;调用了 C 的 BUILD, 我叫 $!nickname, 我爸爸是 $name&quot;</div><div class="line">    &#125;</div><div class="line">    method new(:$nickname) &#123;</div><div class="line">        self.bless(nickname =&gt; &apos;Camelia&apos;, name =&gt; &apos;Lucy&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $c = C.new(nickname =&gt; &apos;HANMEIMEI&apos;);</div></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">调用了 B 的 BUILD, 我叫 Lucy</div><div class="line">调用了 C 的 BUILD, 我叫 Camelia, 我爸爸是 Lucy</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[reddit-Array-language]]></title>
      <url>http://ohmycloud.github.io/2016/02/23/reddit-Array-language/</url>
      <content type="html"><![CDATA[<p><a href="https://www.reddit.com/r/dailyprogrammer/comments/3wdm0w/20151209_challenge_244_easyer_array_language_part/" target="_blank" rel="external">[2015-12-09] Challenge #244 [Easy]er - Array language (part 3) - J Forks</a></p>
<h3 id="Forks"><a href="#Forks" class="headerlink" title="Forks"></a>Forks</h3><hr>
<p><em>*fork</em> 是一个接收三个函数作为参数的函数</p>
<p>给三个函数 <code>f(y, x = defalut):</code>, <code>g(y, x = default):</code>, <code>h(y, x = default):</code>, 其中函数 <strong>g</strong> 是含有两个参数的真实的函数。</p>
<p>然后调用 <code>Fork(f, g, h)</code>执行函数合成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g(f(y, x), h(y, x)) (data1, data2)</div></pre></td></tr></table></figure>
<h4 id="1-从字符串输入执行函数调用来产生字符串"><a href="#1-从字符串输入执行函数调用来产生字符串" class="headerlink" title="1. 从字符串输入执行函数调用来产生字符串"></a>1. 从字符串输入执行函数调用来产生字符串</h4><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum divide count</div></pre></td></tr></table></figure>
<p>(上面的输入是 Fork 函数的三个函数名)</p>
<h4 id="2-根据你喜欢的原生语言-从上面的字符串输入中创建一个执行函数"><a href="#2-根据你喜欢的原生语言-从上面的字符串输入中创建一个执行函数" class="headerlink" title="2. 根据你喜欢的原生语言, 从上面的字符串输入中创建一个执行函数"></a>2. 根据你喜欢的原生语言, 从上面的字符串输入中创建一个执行函数</h4><hr>
<h4 id="3-或创建一个接收三个函数作为输入的函数并返回一个函数"><a href="#3-或创建一个接收三个函数作为输入的函数并返回一个函数" class="headerlink" title="3. 或创建一个接收三个函数作为输入的函数并返回一个函数"></a>3. 或创建一个接收三个函数作为输入的函数并返回一个函数</h4><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Fork(sum, divide, count) (array data)</div></pre></td></tr></table></figure>
<p>应该返回数组的平均数。</p>
<h4 id="4-扩展上面的函数使函数参数接收基数"><a href="#4-扩展上面的函数使函数参数接收基数" class="headerlink" title="4. 扩展上面的函数使函数参数接收基数"></a>4. 扩展上面的函数使函数参数接收基数</h4><hr>
<p>对于 5 个参数, Fork(a, b, c, d, e) 是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b(a, Fork(c,d,e))   NB. should expand this if producing strings.</div></pre></td></tr></table></figure>
<p>smls 给出的答案:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">sub sum    ($y, $x = 0) &#123; $y.sum + $x   &#125;</div><div class="line">sub count  ($y, $x = 0) &#123; $y.elems + $x &#125;</div><div class="line">sub divide ($y, $x = 1) &#123; $y / $x       &#125;</div><div class="line"></div><div class="line">multi Fork (&amp;f, &amp;g, &amp;h) &#123;</div><div class="line">    sub (|args) &#123; g f(|args), h(|args) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi Fork (&amp;f, &amp;g, *@rest where * !%% 2) &#123;</div><div class="line">    sub (|args) &#123; g f(|args), Fork(|@rest)(|args) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say Fork(&amp;sum, &amp;divide, &amp;count)([1, 2, 3, 4, 5]); # 3</div><div class="line">say Fork(&amp;sum, &amp;divide, &amp;sum, &amp;divide, &amp;count)([1, 2, 3, 4, 5]); # 5</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的智能匹配]]></title>
      <url>http://ohmycloud.github.io/2016/02/19/Perl6%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<h3 id="智能匹配"><a href="#智能匹配" class="headerlink" title="智能匹配"></a><a href="https://desgin.perl6.org/S03.html#Smart_matching" target="_blank" rel="external">智能匹配</a></h3><p>这儿有一个标准 Perl 6（即在你的编译单元开始的时候所生效的 Perl 方言） 的智能匹配表格。智能匹配通常作用在当前「主题」(topic)上, 即作用在 <code>$_</code> 变量上. 在下面的表格中, <code>$_</code> 代表 <em>~~</em> 操作符的左侧, 或者代表 <em>given</em> 的参数, 或者代表其它主题化的参数。 <strong>X</strong> 代表 ~~ 操作符右侧要与之(<code>$_</code>)相匹配的模式, 或者在 <em>when</em> 后面的模式。(并且, 实际上, ~~ 操作符充当着一个小型的主题(topicalizer); 即, 为了右侧的计算, 它把 <code>$_</code> 绑定到左侧的值上。 使用底层的 .ACCEPTS 形式来避免这种主题化.)</p>
<p>第一节包含了特殊的(privileged)语法; 如果匹配能通过那些条目之一完成, 那它就会那样做。 这些特别的语法是通过它们的外形(form)而非它们的类型(type)进行分派的。 否则就使用表格中的剩余部分,并且匹配会根据正常的方法分派规则进行分派。 优化器(optimizer)被允许假定在编译时之后没有定义额外的匹配操作符, 所以, 如果在编译时模式类型就是显而易见的话, 那么跳转表(jump table)就可以被优化。 然而, 只要 <em>~~</em> 操作符是 Perl 中少有的几个不使用多重分派的操作符之一, 那么这部分表格的语法仍然有些特殊。 相反, 基于类型的智能匹配被直截了当地分派给了属于 <strong>X</strong> 模式对象的底层方法.</p>
<p>换句话说, 智能匹配首先根据模式(pattern)的外形/形式(form)或类型(下面的X)进行分派(dispatch), 然后那个模式自身决定是否关注和怎样关注主题(<code>$_</code>)的类型。 所以, 下表中的第二列实际上是初始(primary)列。 第一列中的 Any 条目标示了模式要么不关心主题的类型, 要么挑选那个条目作为默认项, 因为上面列出的类型越具体，它越不匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$_        X         所隐含的匹配类型           Match if (given $_)</div><div class="line">======    =====     =====================   ===================</div><div class="line">Any       True      ~~ True                 (parsewarn on literal token)</div><div class="line">Any       False     ~~ False match          (parsewarn on literal token)</div><div class="line">Any       Match     ~~ Successful match     (parsewarn on literal token)</div><div class="line">Any       Nil       ~~ Benign failure       (parsewarn on literal token)</div><div class="line">Any       Failure   Failure type check      (okay, 与类型相匹配)</div><div class="line">Any       *         block 签名匹配            block 成功绑定到 |$_</div><div class="line"></div><div class="line">Any       Callable:($)  item sub truth          X($_)</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-callable.t#L5-L14" target="_blank" rel="external">S03-smartmatch/any-callable.t lines 5–14</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub is_even($x) &#123; $x % 2 == 0 &#125;</div><div class="line">sub is_odd ($x) &#123; $x % 2 == 1 &#125;</div><div class="line"></div><div class="line"># 这里 Any 代表了数字 4, X 代表了调用子例程所返回的布尔值</div><div class="line">say &apos;scalar sub truth (unary)&apos;                      if 4 ~~  &amp;is_even;</div><div class="line">say &apos;scalar sub truth (unary, negated smart-match)&apos; if 4 !~~ &amp;is_odd;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Any       Callable:()   simple closure truth    X() (ignoring $_)</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-callable.t#L15-L24" target="_blank" rel="external">S03-smartmatch/any-callable.t lines 15–24</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Any       Bool      simple truth            X (treats Bool value as success/failure)</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-bool.t#L5-L23" target="_blank" rel="external">S03-smartmatch/any-bool.t lines 5–23</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Positional  List      lists are comparable    $_ »~~« X (but dwims ** wildcards!)</div><div class="line">Any         Match     match success           X (treats Match value as success)</div><div class="line">Any         Nil       benign failure          X (treats Nil value as failure)</div><div class="line">Any         Failure   malign failure          X (passes Failure object through)</div><div class="line">Any         Numeric   数值相等                 +$_ == X</div><div class="line">Any         Stringy   字符串相等               ~$_ eq X</div><div class="line"></div><div class="line"></div><div class="line">Associative Pair      test hash mapping       $_&#123;X.key&#125; ~~ X.value</div><div class="line">Any         Pair      测试对象属性              ?.&quot;&#123;X.key&#125;&quot; === ?X.value (例如. 文件测试)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub is-true() &#123; True &#125;;</div><div class="line">sub is-false() &#123; False &#125;;</div><div class="line">say &apos;~~ non-syntactic True&apos; if  0  ~~ is-true();   </div><div class="line">say &apos;~~ non-syntactic True&apos; if &apos;a&apos; ~~ is-true();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;a&apos; ~~ .so; # True</div><div class="line">0 ~~ .so;   # False</div><div class="line">0 ~~ .not;  # True</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 列表可比较</div><div class="line">my @a = &quot;iPad&quot;, &quot;iTouch&quot;, &quot;iWatch&quot;;</div><div class="line">say so @a ~~ (&quot;iPad&quot;, &quot;iTouch&quot;, &quot;iWatch&quot;); # True, 必须是位置和元素都相同才相等</div><div class="line">say so @a ~~ (&quot;iPad&quot;, &quot;iWatch&quot;, &quot;iTouch&quot;); # False</div><div class="line"></div><div class="line"></div><div class="line"># 判断数值相等</div><div class="line">my  $a = 3;</div><div class="line">say so $a ~~ 30; # False</div><div class="line">say so $a ~~ 3;  # True</div><div class="line"></div><div class="line"># 判断字符串相等</div><div class="line"># my $lan = &quot;Perl 6&quot;;</div><div class="line">say so $lan ~~ &quot;Perl&quot;;   # False</div><div class="line">say so $lan ~~ &quot;Perl 6&quot;; # True</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-pair.t#L5-L35" target="_blank" rel="external">S03-smartmatch/any-pair.t lines 5–35</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Set         Set       identical sets          $_ === X</div><div class="line">Any         Setty     force set comparison    $_.Set === X.Set</div><div class="line"></div><div class="line">Bag         Bag       identical bags          $_ === X</div><div class="line">Any         Baggy     force bag comparison    $_.Bag === X.Bag</div><div class="line"></div><div class="line">Mix         Mix       identical bags          $_ === X</div><div class="line">Any         Mixy      force mix comparison    $_.Mix === X.Mix</div><div class="line"></div><div class="line">Associative Array     keys/list are comparable +X == +$_ and $_&#123;X.all&#125;:exists</div><div class="line">Callable    Positional list vs predicate      so $_(X)</div><div class="line">Any         Positional lists are comparable   $_[] «===» X[]</div><div class="line"></div><div class="line">Hash        Hash      hash mapping equivalent $_ eqv X</div><div class="line">Associative Hash      force hash comparison   $_.Hash eqv X</div><div class="line">Callable    Hash      hash vs predicate       so $_(X)</div><div class="line">Positional  Hash      attempted any/all       FAIL, point user to [].any and [].all for LHS</div><div class="line">Pair        Hash      hash does mapping       X&#123;.key&#125; ~~ .value</div><div class="line">Any         Hash      hash contains object    X&#123;$_&#125;:exists</div><div class="line"></div><div class="line">Str         Regex     string pattern match    .match(X)</div><div class="line">Associative Regex     attempted reverse dwim  FAIL, point user to any/all vs keys/values/pairs</div><div class="line">Positional  Regex     attempted any/all/cat   FAIL, point user to any/all/cat/join for LHS</div><div class="line">Any         Regex     pattern match           .match(X)</div><div class="line"></div><div class="line">Range       Range     subset range            !$_ or .bounds.all ~~ X (mod ^&apos;s)</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/range-range.t#L5-L29" target="_blank" rel="external">S03-smartmatch/range-range.t lines 5–29</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Any         Range     in real range           X.min &lt;= $_ &lt;= X.max (mod ^&apos;s)</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/disorganized.t#L30-L145" target="_blank" rel="external">S03-smartmatch/disorganized.t lines 30–145</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Any         Range     in stringy range        X.min le $_ le X.max (mod ^&apos;s)</div><div class="line">Any         Range     in generic range        [!after] X.min,$_,X.max (etc.)</div><div class="line"></div><div class="line">Any         Type      type membership         $_.does(X)</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-type.t#L5-L40" target="_blank" rel="external">S03-smartmatch/any-type.t lines 5–40</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Signature Signature sig compatibility       $_ is a subset of X      ???</div><div class="line">Callable  Signature sig compatibility       $_.sig is a subset of X  ???</div><div class="line">Capture   Signature parameters bindable     $_ could bind to X (doesn&apos;t!)</div><div class="line">Any       Signature parameters bindable     |$_ could bind to X (doesn&apos;t!)</div><div class="line"></div><div class="line">Signature Capture   parameters bindable     X could bind to $_</div><div class="line"></div><div class="line">Any       Any       scalars are identical   $_ === X</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S03-smartmatch/any-any.t#L5-L29" target="_blank" rel="external">S03-smartmatch/any-any.t lines 5–29</a>  </p>
<p>如果没有其它模式要求 X, 最后那个 rule 才会被应用.</p>
<p>所有的智能匹配类型都是itemized; ~~ 和 given/when 都为它们的参数提供了 item 上下文, 并自动线程化(autothread)任何 junctive 匹配, 以使最终对 .ACCEPTS 的分派看不到任何「复数」（plural）. 所以,上面的 $_ 和 X 都是被当作标量的潜在容器对象。 (不过，你可以显式地使 ~~ 亢奋。 在这种情况下, 所有的智能匹配都是使用 .ACCEPTS 的基于类型的分派来完成的, 不是前面表格中的基于形式的分派)</p>
<p>基于类型的底层方法分派的真正形式是 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X.ACCEPTS($_)</div></pre></td></tr></table></figure>
<p>作为单个分派调用, 这仅仅只关注最初的 X 的类型。 ACCEPT 方法接口是通过 Pattern role 来定义的。 任何组成 Pattern role 的类都可以选择提供单个 ACCEPTS 方法来处理一切, 这对应于上面那些左侧只有一个 Any 条目的模式类型。或者在类中,类也能选择提供多个 ACCEPTS multi-methods, 然后这些会在类中根据 <code>$_</code> 的类型进行重新分派.</p>
<p>智能匹配表格主要用于反应编译时识别的形式和类型. 为了避免条目的激增, 表格假设下面的类型会有相似的表现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">实际类型                     Use entries for</div><div class="line">===========                 ===============</div><div class="line">Iterator Seq                Array</div><div class="line">SetHash BagHash MixHash     Hash</div><div class="line">named values created with</div><div class="line">  Class, Enum, or Role,</div><div class="line">  or generic type binding   Type</div><div class="line">Char Cat                    Str</div><div class="line">Int UInt etc.               Num</div><div class="line">Byte                        Str or Int</div><div class="line">Buf                         Str or Array of Int</div></pre></td></tr></table></figure>
<p>(注意, 然而, 这些映射可以显式地通过定义合适的 ACCEPTS 方法进行重写。 如果在编译时, 重定义出现的比智能匹配的分析早, 那么优化器也可以可访问到信息)。</p>
<p>如果并且只有在它跟 Unicode 的关系被清楚地声明或类型化时, 一个包含任何ASCII 范围之外的字节或整数的 Buf 类型才可能被静静地提升为 Str 类型用于模式匹配。 这种类型信息可能来自输入文件句柄, 或者 Buf role 可能是一个允许你使用各种已知的编码来实例化 buffers 的参数类型。 在没有这种类型信息的情况下, 你仍然可以跟 buffer 进行模式匹配, 但是任何把 buffer 当作不是整数序列的尝试都是错误的, 这通常会发生警告.</p>
<p>与 Grammar 相匹配会把 grammar 当作类型名, 而不是一个 grammar。 你需要使用 .parse 和 .parsefile 方法来调用一个 grammar.</p>
<p>与 Signature 相匹配不会真的绑定任何变量, 而只是测试那个签名是否能绑定。 要真的绑定到一个签名上, 使用模式 <code>*</code> 把绑定代理到 when 语句块里。 在 when 里面与 <code>*</code> 相匹配很特殊。它从随后的 block 是否与主题变量相绑定中接收真假, 所以你可以做有序的签名匹配:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">given $capture &#123;</div><div class="line">    when * -&gt; Int $a, Str $b &#123; ... &#125;</div><div class="line">    when * -&gt; Str $a, Int $b &#123; ... &#125;</div><div class="line">    when * -&gt; $a, $b         &#123; ... &#125;</div><div class="line">    when *                   &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当多重分派无序的语义不足以定义代码的”主从秩序”(“pecking order”)时, 这会很有用。 注意, 你要么绑定给一个裸的 block 要么绑定给一个箭头 block(pointy  block)。 绑定给裸的 block 很方便的把主题放在 <code>$_</code> 中,所以上面最后那种形式等价于一个 default.(占位符参数也能用于裸 block 形式, 尽管它们的类型不能被那样指定.)</p>
<p>没有为 Any 模式定义的模式匹配, 所以,如果你想要一个右侧是 Any 的反转的智能匹配测试, 那么你总是通过显式地调用使用了 <code>$_</code> 作为模式的底层 ACCEPTS 方法来获取它. 例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$_       X    想要的匹配类型           右侧所使用的东西</div><div class="line">======   ===  ====================   ========================</div><div class="line">Callable Any  item sub truth         .ACCEPTS(X) or .(X)</div><div class="line">Range    Any  in range               .ACCEPTS(X)</div><div class="line">Type     Any  type membership        .ACCEPTS(X) or .does(X)</div><div class="line">Regex    Any  pattern match          .ACCEPTS(X)</div><div class="line">etc.</div></pre></td></tr></table></figure>
<p>同样的技巧会允许你倾向于给混合对象以默认匹配规则, 只要你在 <code>$_</code> 身上以点方法开头:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">given $somethingordered &#123;</div><div class="line">    when .values.&apos;[&lt;=]&apos;     &#123; say &quot;increasing&quot; &#125;</div><div class="line">    when .values.&apos;[&gt;=]&apos;     &#123; say &quot;decreasing&quot; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>必要时, 你可以定义一个宏来得到”反转的 when”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my macro statement_control:&lt;ACCEPTS&gt; () &#123; &quot;when .ACCEPTS: &quot; &#125;</div><div class="line">given $pattern &#123;</div><div class="line">    ACCEPTS $a      &#123; ... &#125;</div><div class="line">    ACCEPTS $b      &#123; ... &#125;</div><div class="line">    ACCEPTS $c      &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>各种提议但弃用了的智能匹配行为可以很容易地(并且我们希望更易读)被模仿成下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">$_      X      Type of Match Wanted   What to use on the right</div><div class="line">======  ===    ====================   ========================</div><div class="line">Array   Num    array element truth    .[X]</div><div class="line">Array   Num    array contains number  *,X,*</div><div class="line">Array   Str    array contains string  *,X,*</div><div class="line">Array   Seq    array begins with seq  X,*</div><div class="line">Array   Seq    array contains seq     *,X,*</div><div class="line">Array   Seq    array ends with seq    *,X</div><div class="line">Hash    Str    hash element truth     .&#123;X&#125;</div><div class="line">Hash    Str    hash key existence     .&#123;X&#125;:exists</div><div class="line">Hash    Num    hash element truth     .&#123;X&#125;</div><div class="line">Hash    Num    hash key existence     .&#123;X&#125;:exists</div><div class="line">Buf     Int    buffer contains int    .match(X)</div><div class="line">Str     Char   string contains char   .match(X)</div><div class="line">Str     Str    string contains string .match(X)</div><div class="line">Array   Scalar array contains item    .any === X</div><div class="line">Str     Array  array contains string  X.any</div><div class="line">Num     Array  array contains number  X.any</div><div class="line">Scalar  Array  array contains object  X.any</div><div class="line">Hash    Array  hash slice exists      .&#123;X.all&#125;:exists .&#123;X.any&#125;:exists</div><div class="line">Set     Set    subset relation        .&#123;X.all&#125;:exists</div><div class="line">Set     Hash   subset relation        .&#123;X.all&#125;:exists</div><div class="line">Any     Set    subset relation        .Set.&#123;X.all&#125;:exists</div><div class="line">Any     Hash   subset relation        .Set.&#123;X.all&#125;:exists</div><div class="line">Any     Set    superset relation      X.&#123;.all&#125;:exists</div><div class="line">Any     Hash   superset relation      X.&#123;.all&#125;:exists</div><div class="line">Any     Set    sets intersect         .&#123;X.any&#125;:exists</div><div class="line">Set     Array  subset relation        X,*          # (conjectured)</div><div class="line">Array   Regex  match array as string  .Cat.match(X)  cat(@$_).match(X)</div></pre></td></tr></table></figure>
<p>(注意, .cat 方法和 Cat 类型强转都接收单个对象, 不像 cat 函数, 它作为一个列表操作符, 接收一个句法的列表(或 multilist ) 并展开它. 然而,所有的这些都返回一个 Cat 对象.)</p>
<p>布尔表达式能返回布尔值, 例如比较操作符或一元 ? 操作符.它们可能显式或隐式地引用 <code>$_</code>. 如果它们一点也没有引用 <code>$_</code>, 那也是 okay 的 — 那种情况下你就使用 switch 结构作为比一串 elsifs 可读性更好的备选分支. 然而, 注意,那意味着你不能这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">given $boolean &#123;</div><div class="line">    when True  &#123;...&#125;</div><div class="line">    when False &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为它总是会选择 True 这种情况. 相反, 使用某些在内部使用的像条件上下文的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">given $boolean &#123;</div><div class="line">    when .Bool == 1 &#123;...&#125;</div><div class="line">    when .Bool == 0 &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最好，就使用 if 语句。在任何情况下, 如果你想使用 ~~ 或 when 进行智能匹配, 它会依照句法识别 True 或 False, 并提醒你它不会按你期望的那样做. 编译器也允许在它能检测的范围之内提醒任何其它不测试 $_ 的布尔结构,.</p>
<p>同样地, 任何接收一个 Matcher的函数(诸如 grep) 不会接收一个 Bool 类型的参数, 因为那总是标示着编程错误.(可以使用 * 来匹配任何东西, 如果那就是你想要的. 或者使用一个返回常量布尔值的闭包)</p>
<p>也要注意 regex 匹配不返回 Bool, 而是返回一个能用作布尔值的 Match 对象(或 Nil). 如果想要, 使用显式的 ? 或 so 来强制转为布尔值. Match 对象代表一个成功的匹配, 并被智能匹配当作与 True 的值相同, 类似地, Nil 代表着失败, 并且不能直接用于智能匹配的右侧. 测试 definedness 来代替或使用 * === Nil.</p>
<blockquote>
<p>(这一段可能有误)操作符的主要用途是在布尔上下文中返回一个 boolean-ish 的值。然而，对于某些诸如正则表达式的操作数，在 item 或列表上下文中操作符的使用把上下文转换为那个操作数，以至于，例如。，正则表达式可以返回一个所匹配的子字符串的列表，就像 Perl 5中一样。这可以通过返回一个能在列表上下文中返回一个列表或者在布尔上下文中返回一个布尔值的对象来完成。正则表达式匹配 Match 对象的情况是一种捕获(Capture), 它拥有这些能力。</p>
</blockquote>
<p>带有诸如 :g那样的修饰符的正则匹配想返回多个匹配, 使用 List来做 so.就像任何列表一样, 如果有一个或多项, 值就是被计算为真. 如果没有匹配, 返回空列表, 它在布尔上下文中计算为 false.</p>
<p>为了智能匹配, 所有的 Set, Bag, 和 Mix 值和对应的散列类型, SetHash, BagHash, 和 MixHash 是等价的. 即, Hash 容器中键代表唯一对象, 键值代表那些唯一键的重复次数.(当然, Set 能有 0 或 1次重复, 因为保证唯一性). 所以,所有这些 Mixy 类型只比较键, 不比较键值. 使用 eqv 来测试键和键值的相等性.</p>
<p>尽管为了执行智能匹配需要一个检测范围边界的实现, 对于任何按顺序的类型，例如数字，字符串，或版本号，两个 Range 对象智能匹配的结果实际上没有按照边界定义,而是作为在通过设定的间隔所包围的两个值的集合之间的子集关系。如果并且只有所有能被左侧的范围所匹配的潜在元素也能被右侧的范围所匹配结果才被定义为真。因此一个空范围被”过度指定”到什么长度是无关紧要的。如果左侧的范围为空，那么它总是匹配，因为不存在伪造它的值。如果右侧的范围为空，那么只有左侧的范围为空时它才能匹配。</p>
<p>Cat 类型允许你拥有一个无限可扩展的字符串。你可以通过把数组或迭代器「喂」(feeding)给一个 Cat 来匹配数组或迭代器, 它本质上是某种形式的迭代器上的一个 Str 接口。然后一个 Regex 可以与之相匹配就像它是一个普通的字符串一样。正则引擎可以询问那个字符串是否拥有更多字符，并且如果可能的话字符串会从它底层的迭代器中扩展自己。（注意这样的字符串拥有不确定数量的字符， 所以如果你在模式中使用了 <code>.*</code>， 或者你询问那个字符串里面有多少个字符，或者甚至你打印整个字符串，它可能感到有必要吞噬完剩余的字符串，这可能也可能不够敏捷。)</p>
<p>「cat」 操作符接收一个(潜在惰性的)列表并返回一个 「Cat」 对象。在字符串上下文中, 这惰性地把列表中的每一个元素强转为字符串, 表现为不确定长度的字符串。 你可以像这样搜索一个 gather:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $lazystr := cat gather for @foo &#123; take .bar &#125;</div><div class="line">$lazystr ~~ /pattern/;</div></pre></td></tr></table></figure>
<p>Cat 接口允许 regex 使用 <code>&lt;,&gt;</code> 断言来匹配元素的边界, 并且那个匹配所返回的 StrPos 对象可以被分解为在列表元素中的元素索引和位置。 如果底层的数据结构是一个可变数组, 那么对数组所做的更改(例如通过 shift 或 pop)由 Cat 追踪, 以使元素编号仍然正确。 字符串, 数组, 列表, 序列, 捕获还有树节点都可以通过正则表达式或者或多或少的通过可交换的签名来进行模式匹配。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6圣诞月历-(2013)]]></title>
      <url>http://ohmycloud.github.io/2016/02/15/Perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2013/</url>
      <content type="html"><![CDATA[<h1 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h1><hr>
<h2 id="Heredocs-Theredocs-Everywheredocs-docs"><a href="#Heredocs-Theredocs-Everywheredocs-docs" class="headerlink" title="Heredocs, Theredocs, Everywheredocs docs"></a>Heredocs, Theredocs, Everywheredocs docs</h2><hr>
<p>So let’s say you’ve got a bit of documentation to print out, a help statement perhaps. You could use an ordinary string, but it always looks like something you really shouldn’t be doing.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub USAGE &#123;</div><div class="line">    say &quot;foobar Usage:</div><div class="line">./foobar &lt;args&gt; &lt;file&gt;</div><div class="line"></div><div class="line">Options:</div><div class="line"></div><div class="line">...</div><div class="line">&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Perl 6 has a much better idea for you, fortunately: heredocs! They work a bit differently from Perl 5, and are now invoked using the adverb :heredoc on quoting constructs:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say q:heredoc/END/;</div><div class="line">Hello world!</div><div class="line">END</div></pre></td></tr></table></figure>
<p>When you use :heredoc, the contents of the string are no longer the final contents; they become the string that signifies the end of a heredoc. q”END” results in the string “END”, q:heredoc”END”results in everything before the next END to appear on its own line.<br>You will have also noticed that heredocs only start on the next possible line for them to start, not immediately after the construct closes. That semicolon after the construct never gets picked up as part of a heredoc, don’t worry :) .<br>The :heredoc adverb is nice, but it seems a bit long, doesn’t it? Luckily it has a short form, :to, which is much more commonly used. So that’s what we’ll be using through the rest of the post.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say q:to&quot;FIN&quot;;</div><div class="line">Hello again.</div><div class="line">FIN</div></pre></td></tr></table></figure>
<p>You can use any sort of string for the delimiter, so long as there’s no leading whitespace in it. A null delimiter (q:to//) is fine too, it just means you end the heredoc with two newlines, effectively a blank line.<br>And yes, delimiters need to be on their own line. This heredoc never ends:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say q:to&quot;noend&quot;;</div><div class="line">HELLO WORLD noend</div></pre></td></tr></table></figure>
<p>A note about indentation: look at this heredoc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say q:to[finished];</div><div class="line">  Hello there</div><div class="line">    everybody</div><div class="line">finished</div></pre></td></tr></table></figure>
<p>Which of those three heredoc lines decides how much whitespace is removed from the beginning of each line (and thus sets the base level of indentation)? It’s the line with the end delimiter, “finished” in the last example. Lines with more indentation than the delimiter will appear indented by however much extra space they use, and lines with less indentation will be as indented as the delimiter, with a warning about the issue.<br>(Tabs are considered to be 8 spaces long, unless you change $?TABSTOP. This usually doesn’t matter unless you mix spaces and tabs for indentation anyway though.)<br>It doesn’t matter how much the delimiter indentation is, all that matters is indentation relative to the delimiter. So these are all the same:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say q:to/END/;</div><div class="line">HELLO</div><div class="line">  WORLD</div><div class="line">END</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say q:to/END/;</div><div class="line">    HELLO</div><div class="line">      WORLD</div><div class="line">    END</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say q:to/END/;</div><div class="line">               HELLO</div><div class="line">                 WORLD</div><div class="line">               END</div></pre></td></tr></table></figure>
<p>One other thing to note is that what quoting construct you use will affect how the heredoc contents are parsed, so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say q:to/EOF/;</div><div class="line">$dlrs dollars and &#123;$cnts&#125; cents.</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p>Interpolates nothing,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say q:to:c/EOF/;</div><div class="line">$dlrs dollars and &#123;$cnts&#125; cents.</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p>Interpolates just <code>{$cnts}</code> (the :c adverb allows for interpolation of just closures), and</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say qq:to/EOF/;</div><div class="line">$dlrs dollars and &#123;$cnts&#125; cents.</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p>Interpolates both <code>$dlrs</code> and <code>{$cnts}</code>.<br>Here’s the coolest part of heredocs: using more than one at once! It’s easy too, just use more than one heredoc quoting construct on the line!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">say q:to/end1/, qq:to/end2/, Q:to/end3/;</div><div class="line">This is q.\\Only some backslashes work though\t.</div><div class="line">$sigils don&apos;t interpolate either.</div><div class="line">end1</div><div class="line">This is qq. I can $interpolate-sigils as well as \\ and \t.</div><div class="line">Neat, yes?</div><div class="line">end2</div><div class="line">This is Q. I can do \\ no \t such $things.</div><div class="line">end3</div></pre></td></tr></table></figure>
<p>Which, assuming you’ve defined $interpolate-sigils to hold the string “INTERPOLATE SIGILS”, prints out</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">This is q.\Only some backslashes work though\t.</div><div class="line">$sigils don&apos;t interpolate either.</div><div class="line">This is qq. I can INTERPOLATE SIGILS as well as \ and   .</div><div class="line">Neat, yes?</div><div class="line">This is Q. I can do \\ no \t such $things.</div></pre></td></tr></table></figure>
<p>After every end delimiter, the next heredoc to look for its contents starts.<br>Of course, indentation of different heredocs will help whenever you have to stack a bunch of them like this.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">say qq:to/ONE/, qq:to/TWO/, qq:to/THREE/, qq:to/ONE/;</div><div class="line">The first one.</div><div class="line">ONE</div><div class="line">    The second one.</div><div class="line">    TWO</div><div class="line">The third one.</div><div class="line">THREE</div><div class="line">    The fourth one.</div><div class="line">    ONE</div></pre></td></tr></table></figure>
<p>Which outputs:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The first one.</div><div class="line">The second one.</div><div class="line">The third one.</div><div class="line">The fourth one.</div></pre></td></tr></table></figure>
<p>(And yes, you don’t have to come up with a unique end delimiter every time. That could have been four <code>q:to/EOF/</code> statements and it’d still work.)<br>One final note you should be aware of when it comes to heredocs. Like the rest of Perl 6 (barring a couple of small exceptions), heredocs are read using one-pass parsing (this means your Perl 6 interpreter won’t re-read or skip ahead to better understand the code you wrote). For heredocs this means Perl 6 will just wait for a newline to start reading heredoc data, instead of looking ahead to try and find the heredoc.<br>As long as the heredoc contents and the statement that introduces the heredoc are part of the same compilation unit, everything’s fine. In addition to what you’ve seen so far, you can even do stuff like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub all-info &#123; return q:to/END/ &#125;</div><div class="line"></div><div class="line">This is a lot of important information,</div><div class="line">and it is carefully formatted.</div><div class="line">END</div></pre></td></tr></table></figure>
<p>(If you didn’t put the brace on the same line, it would be part of the heredoc, and then you’d need another brace on a line afterEND.)<br>However, things like BEGIN blocks start compiling before normal code, so trying that last one with BEGIN block fails:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; say q:to/END/ &#125;</div><div class="line">This is only the BEGINning.</div><div class="line">END</div></pre></td></tr></table></figure>
<p>You have to put the heredoc inside the BEGIN block, with the quoting construct, in order to place them in the same compilation unit.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">    say q:to/END/;</div><div class="line">    This is only the BEGINning.</div><div class="line">    END</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>That’s it for heredocs! When should you use them? I would say whenever you need to type a literal newline (by hitting Enter) into the string. Help output from the USAGE sub is probably the most common case. The one at the beginning could easily (and more readably) be written as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sub USAGE &#123;</div><div class="line">    say q:to&quot;EOHELP&quot;;</div><div class="line">        foobar Usage:</div><div class="line">        ./foobar &lt;args&gt; &lt;file&gt;</div><div class="line"></div><div class="line">        Options:</div><div class="line"></div><div class="line">        ...</div><div class="line">        EOHELP</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Parsing-and-generating-recurring-dates"><a href="#Parsing-and-generating-recurring-dates" class="headerlink" title="Parsing and generating recurring dates"></a>Parsing and generating recurring dates</h2><hr>
<p>By Moritz<br>There are a lot of events that are scheduled on particular days of the week each month, for example the regular Windows Patch Day on the second Tuesday of each month, or in Perl 6 land that Rakudo Perl 6 compiler release, which is scheduled for two days after the Parrot release day, which again is scheduled for the third Tuesday of the month.<br>So let’s write something that calculates those dates.<br>The specification format I have chosen looks like 3rd tue + 2 for the Rakudo release date, that is, two days after the 3rd Tuesday of each month (note that this isn’t always the same as the 3rd Thursday).<br>Parsing it isn’t hard with a simple grammar:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">grammar DateSpec::Grammar &#123;</div><div class="line">    rule TOP &#123;</div><div class="line">        [&lt;count&gt;&lt;.quant&gt;?]?</div><div class="line">        &lt;day-of-week&gt;</div><div class="line">        [&lt;sign&gt;? &lt;offset=count&gt;]?</div><div class="line">    &#125;</div><div class="line">    token count &#123; \d+ &#125;</div><div class="line">    token quant &#123; st | nd | rd | th &#125;</div><div class="line">    token day-of-week &#123; :i</div><div class="line">        [ mon | tue | wed | thu | fri | sat | sun ]</div><div class="line">    &#125;</div><div class="line">    token sign &#123; &apos;+&apos; | &apos;-&apos; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>As you can see, everything except the day of the week is optional, so sun would simply be the first Sunday of the month, and 2 sun - 1 the Saturday before the second Sunday of the month.<br>Now it’s time to actually turn this specification into a data structure that does something useful. And for that, a class wouldn’t be a bad choice:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">my %dow = (mon =&gt; 1, tue =&gt; 2, wed =&gt; 3, thu =&gt; 4,</div><div class="line">        fri =&gt; 5, sat =&gt; 6, sun =&gt; 7);</div><div class="line"></div><div class="line">class DateSpec &#123;</div><div class="line">    has $.day-of-week;</div><div class="line">    has $.count;</div><div class="line">    has $.offset;</div><div class="line"></div><div class="line">    multi method new(Str $s) &#123;</div><div class="line">        my $m = DateSpec::Grammar.parse($s);</div><div class="line">        die &quot;Invalid date specification &apos;$s&apos;\n&quot; unless $m;</div><div class="line">        self.bless(</div><div class="line">            :day-of-week(%dow&#123;lc $m&lt;day-of-week&gt;&#125;),</div><div class="line">            :count($m&lt;count&gt; ?? +$m&lt;count&gt;[0] !! 1),</div><div class="line">            :offset( ($m&lt;sign&gt; eq &apos;-&apos; ?? -1 !! 1)</div><div class="line">                    * ($m&lt;offset&gt; ?? +$m&lt;offset&gt; !! 0)),</div><div class="line">        );</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>We only need three pieces of data from those date specification strings: the day of the week, whether the 1st, 2nd, 3rd. etc is wanted (here named $.count), and the offset. Extracting them is a wee bit fiddly, mostly because so many pieces of the grammar are optional, and because the grammar allows a space between the sign and the offset, which means we can’t use the Perl 6 string-to-number conversion directly.<br>There is a cleaner but longer method of extracting the relevant data using an actions class.<br>The closing } is missing, because the class doesn’t do anything useful yet, and that should be added. The most basic operation is to find the specified date in a given month. Since Perl 6 has no built-in type for months, we use a Date object where the .day is one, that is, a Date object for the first day of the month.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">method based-on(Date $d is copy where &#123; .day == 1&#125;) &#123;</div><div class="line">     ++$d until $d.day-of-week == $.day-of-week;</div><div class="line">     $d += 7 * ($.count - 1) + $.offset;</div><div class="line">     return $d;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>The algorithm is quite simple: Proceed to the next date (++$d) until the day of week matches, then advance as many weeks as needed, plus as many days as needed for the offset. Date objects support addition and subtraction of integers, and the integers are interpreted as number of days to add or subtract. Handy, and exactly what we need here. (The API is blatantly copied from theDate::Simple Perl 5 module).<br>Another handy convenience method to implement is next, which returns the next date matching the specification, on or after a reference date.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    method next(Date $d = Date.today) &#123;</div><div class="line">        my $month-start = $d.truncated-to(month);</div><div class="line">        my $candidate   = $.based-on($month-start);</div><div class="line">        if $candidate ge $d &#123;</div><div class="line">            return $candidate;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            return $.based-on($month-start + $month-start.days-in-month);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Again there’s no rocket science involved: try the date based on the month of $d, and if that’s before $d, try again, but with the next month as base.<br>Time to close the class :-).<br>So, when is the next Rakudo release? And the next Rakudo release after Christmas?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $spec = DateSpec.new(&apos;3rd Tue + 2&apos;);</div><div class="line">say $spec.next;</div><div class="line">say $spec.next(Date.new(2013, 12, 25));</div></pre></td></tr></table></figure>
<p>Output:<br>2013-12-19<br>2014-01-23</p>
<p>The code works fine on Rakudo with both the Parrot and the JVM backend.<br>Happy recurring hollidates!</p>
<h2 id="Hashes-and-pairs"><a href="#Hashes-and-pairs" class="headerlink" title="Hashes and pairs"></a>Hashes and pairs</h2><hr>
<p>Hashes are nice. They can work as a kind of “poor man’s objects” when creating a class seems like just too much ceremony for the occasion.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $employee = &#123;</div><div class="line">    name =&gt; &apos;Fred&apos;,</div><div class="line">    age =&gt; 51,</div><div class="line">    skills =&gt; &lt;sweeping accounting barking&gt;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>花括号可以省略:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %employee =</div><div class="line">    name =&gt; &apos;Fred&apos;,</div><div class="line">    age =&gt; 51,</div><div class="line">    skills =&gt; &lt;sweeping accounting barking&gt;,</div><div class="line">;</div></pre></td></tr></table></figure>
<p>散列的最后一项的末尾可以添加一个逗号。<br>Hashes make great “configuration objects”, too. You want to pass some options into a routine somewhere, but the options (for reasons of future compatibility, perhaps) need to be an open set.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %options =</div><div class="line">    rpm =&gt; 440,</div><div class="line">    duration =&gt; 60,</div><div class="line">;</div><div class="line">$centrifuge.start(%options);</div></pre></td></tr></table></figure>
<p>Actually, we have two options with that last line. Either we pass in the whole hash like that, and the method in the centrifuge class will need to look like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">method start(%options) &#123;</div><div class="line">    # probably need to start by unpacking options here</div><div class="line">    # ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Or we decide to “gut” the hash as we pass it in, effectively turning it into a bunch of named arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$centrifuge.start( |%options );  # means :rpm(440), :duration(60)</div></pre></td></tr></table></figure>
<p>强制参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">method start(:$rpm!, :$duration!) &#123;</div><div class="line">    # ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(In this case, we probably want to put in those exclamation marks, to make those named parameters obligatory. Unless we’re fine with providing some of them with a default, such as <code>:$duration = 120</code>.)</p>
<p>前缀操作符 <code>prefix:&lt;|&gt;</code> 其实叫做“展开” 或 “插值”。 在 Perl 6 中， 数组被展开为位置参数，散列被展开为命名参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my @args = &quot;Would you like fries with that?&quot;, 15, 5;</div><div class="line">say substr(|@args);    # fries</div><div class="line"></div><div class="line">my %details = :year(1969), :month(7), :day(16),</div><div class="line">              :hour(20),     :minute(17);</div><div class="line">my $moonlanding = DateTime.new( |%details );</div></pre></td></tr></table></figure>
<p>Perl 6 散列的项真的很像命名参数。当然它们不是， 它们只是散列中的键和值。但确实太像了。我们有 2 种语法来写一个散列的项。 一个是 胖箭头 语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my %opts = blackberries =&gt; 42;</div></pre></td></tr></table></figure>
<p>一个是命名参数语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my %opts = :blackberries(42);</div></pre></td></tr></table></figure>
<p>他们俩各有千秋。 后者比较 nice 的是它能够混合变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $blackberries = 42;</div><div class="line">my %opts = :$blackberries;   # 等价于  :blackberries($blackberries)</div></pre></td></tr></table></figure>
<p>如果不重复单词 blackberries，使用 胖箭头语法就做不到了。</p>
<p>所以散列的项（一个键+一个键值）在 Perl 6 中变的更像一个东西。<br>在 Perl 6 中， 通过使用  <code>:blackberries(42)</code> 语法 或  <code>:$blackberries</code> 语法，让散列的项更突出。不仅如此， 把散列传递到子例程中时也是一项一项传递烦人，这让项更加突出。<br>最后，我们妥协了，意识到这样一串散列的项可以作为一个单位， 所以我们给它一个名字叫 Pair。散列是由一串串 Pair 对象（无序的）组成的。<br>所以，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say %employee.elems;</div></pre></td></tr></table></figure>
<p>打印出 “3″… 这就是散列 <code>%employee</code> 中 Pair 对象的数量。</p>
<p>But in the end, Pair objects even turn out to have a sort of independent existence, graduating from their role as hash constituents. For, example, you can treat them as cons pairs and simulate Lisp lists with them:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $lisp-list = 1 =&gt; 2 =&gt; 3 =&gt; Nil;  # it&apos;s nice that infix:&lt;&lt; =&gt; &gt;&gt; is right-associative</div></pre></td></tr></table></figure>
<p>And then, as a final trick, let’s dynamically extend the Pair class to recognize arbitrary cadr-like method calls. (Note that.^add_fallback is not in the spec and currently Rakudo-only.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Pair.^add_fallback(</div><div class="line">    -&gt; $, $name &#123; $name ~~ /^c&lt;[ad]&gt;+r$/ &#125;,  # should we handle this? yes, if /^c&lt;[ad]&gt;+r$/</div><div class="line">    -&gt; $, $name &#123;                            # if it turned out to be our job, this is what we do</div><div class="line">        -&gt; $p &#123;</div><div class="line">            $name ~~ /^c(&lt;[ad]&gt;*)(&lt;[ad]&gt;)r$/;        # split out last &apos;a&apos; or &apos;d&apos;</div><div class="line">            my $r = $1 eq &apos;a&apos; ?? $p.key !! $p.value;    # choose key or value</div><div class="line">            $0 ?? $r.&quot;c&#123;$0&#125;r&quot;() !! $r;                            # maybe recurse</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">);</div><div class="line"></div><div class="line">$lisp-list.caddr.say;    # 3</div></pre></td></tr></table></figure>
<p>Whee!</p>
<h2 id="Adverbly-Adverby-Adverbs"><a href="#Adverbly-Adverby-Adverbs" class="headerlink" title="Adverbly Adverby Adverbs"></a>Adverbly Adverby Adverbs</h2><hr>
<p>By Lueinc<br>两种创建Pair对象的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my %h = debug =&gt; True;</div></pre></td></tr></table></figure>
<p>还有一种是冒号记法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my %h = :debug(True);</div></pre></td></tr></table></figure>
<p>今天，我会向你展示冒号记法是如何有用，Perl 6将它们用作主要的语言特性<br>什么是副词？<br>在自然语言中，副词没有动词与形容词的意思变化的明显。例如<br>The dog fetched the stick.                               # 狗叼回了棒子<br>仅仅是狗所做的表现。通过加上副词，例如:<br>The dog quickly fetched the stick.          # 狗很快地叼回了棒子<br>声明狗能在很短的时间完成这件事。副词能让变化很激烈，就像看到的：<br>This batch of cookies was chewy.                # 饼干很难嚼<br>This batch of cookies was oddly chewy.  # 饼干极其难嚼<br>第二个句子，使用副词 “oddly”，让你知道那饼干不是面包师的目标。Perl6中的副词表现的跟上面的任务很像，告诉函数和其它语言特性做它们想做的<br>副词基础<br>副词是使用冒号+副词的语法来表达的。通常，你将它们用作开关。<br>开启副词的方式就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:adverb</div></pre></td></tr></table></figure>
<p>它和这一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:adverb(True)</div></pre></td></tr></table></figure>
<p>关闭副词长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:!adverb</div></pre></td></tr></table></figure>
<p>它就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:adverb(False)</div></pre></td></tr></table></figure>
<p>如果你传递的是字符串直接量，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:greet(&apos;Hello&apos;)</div><div class="line">:person(&quot;$user&quot;)</div></pre></td></tr></table></figure>
<p>你可以用下面的代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:greet&lt;Hello&gt;</div><div class="line">:person«$user» or :person&lt;&lt;$user&gt;&gt;</div></pre></td></tr></table></figure>
<p>只要字符串中没有空格（尖括号形式实际上创建一列项，用空格分隔）<br>你也可以缩写变量如果变量的名字和键的名字相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:foo($foo)</div><div class="line">:$foo</div></pre></td></tr></table></figure>
<p>如果你提供一个十进制数，有两种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:th(4)</div><div class="line">:4th</div></pre></td></tr></table></figure>
<p>(The :4th form only works on quoting construct adverbs, like <code>m//</code>and <code>q[]</code>, in Rakudo at the moment.)<br>注意，副词的反义形式 (<code>:!adv</code>) 和 符号形式 (<code>:$foo</code>, <code>:@baz</code>) 不能给予值， 因为你已经给了它一个值了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; my $foo = &apos;Fooo&apos;; my $bar = &apos;Barrr&apos;;</div><div class="line">Fooo</div><div class="line">Barrr</div><div class="line">&gt; my %h = :$foo, :$bar;</div><div class="line">bar =&gt; Barrr, foo =&gt; Fooo</div><div class="line">&gt; say %h&lt;foo&gt;;</div><div class="line">Fooo</div></pre></td></tr></table></figure>
<p>函数调用中的副词<br>函数调用中的副词用法更像具名参数，但仍计为副词。<br>下面是例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo($z, :adverbly);</div><div class="line">foo($z, :bar, :baz);</div><div class="line">foo($z, :bar :baz);</div></pre></td></tr></table></figure>
<p>每个副词都是一个具名参数，所以使用多个逗号分隔每个副词，就像分隔其它参数一样。注意你也可以像最后一个例子中一样，允许你叠加副词。<br>作用在操作符上的副词</p>
<p>副词能作用于操作符上，就像它们在函数中做的那样。它们优先级比项的赋值高，比条件的优先级低。<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo($z) :bar :baz  # 等价于 foo($z, :bar, :baz)</div><div class="line">1 / 3 :round       # applies to /</div><div class="line">$z &amp; $y :adverb    # applies to &amp;</div></pre></td></tr></table></figure>
<p>When it comes to more complex cases, it’s helpful to remember that adverbs work similar to how an infix operator at that precedence level would (if it helps, think of the colon as a double bond in chemistry, binding both “sides” of the infix to the left-hand side). It operates on the loosest precedence operator no looser than adverbs.当情况复杂的时候， 记住副词与中缀操作符在那个优先级上的效果相似（如果有用，把冒号看作化学里面的双键（如H2C=CH2(乙烯)。碳原子与碳原子C=C以双键结合。）把中缀操作符的两侧绑定到左边）它作用于优先级最低（比副词优先级高）的操作符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1 || 2 &amp;&amp; 3 :adv   # applies to ||</div><div class="line">1 || (2 &amp;&amp; 3 :adv) # applies to &amp;&amp;</div><div class="line">!$foo.bar() :adv   # applies to !</div><div class="line">!($foo.bar() :adv) # applies to .bar()</div><div class="line">@a[0..2] :kv       # applies to []</div><div class="line">1 + 2 - 3 :adv     # applies to -</div><div class="line">1 ** 2 ** 3 :adv   # applies to the leftmost **</div></pre></td></tr></table></figure>
<p>Notice that the behavior of adverbs on operators looser than adverbs is currently undefined.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 || 2 and 3 :adv  # error (&apos;and&apos; too loose, applies to 3)</div><div class="line">1 and 2 || 3 :adv  # applies to ||</div></pre></td></tr></table></figure>
<p>作用在引号结构上的副词</p>
<p>各种引号那样的结构也通过副词改变行为。<br>(注意：这儿没有提供副词的详尽信息。 S02 和 S05 里面有更详细的介绍)<br>例如，让一个引号结构表现为单引号并插值闭包， 则你需要写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">q:c &apos;Hello, $name. You have &#123; +@msgs &#125; messages.&apos;</div><div class="line">#  是的，字符 c 和 字符 &apos; 之间需要空格</div></pre></td></tr></table></figure>
<p>这会输出：Hello, <code>$name</code>. You have 12 messages.<br>(这表明@msgs 数组有12个元素)<br>如果你想让双引号结构不插值标量，你会使用副词 :s 的反义形式 :!s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">qq:!s &apos; ... etc ...&apos;</div></pre></td></tr></table></figure>
<p>正则 Regexes 允许你在 regex 外部使用副词之外， 还允许你在 regex 内部使用副词。在某些不能使用副词的情况下，内部副词允许你使用那些副词带来的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$a ~~ m:i/HELLO/; # matches HELLO, hello, Hello ...</div><div class="line">$a ~~ /:i HELLO/; # same</div><div class="line">regex Greeting &#123;</div><div class="line">    :i HELLO</div><div class="line">&#125;                 # same</div></pre></td></tr></table></figure>
<p>要记住的是作用在引号结构上的副词必须使用圆括号来传递值。这是因为，通常出现在副词后面的括号会被作为值传递给副词，这与你可以选择自己的引号括号的权利冲突了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">m:nth(5)// # OK</div><div class="line">m:nth[5]// # Not OK</div><div class="line">q:to(EOF)  # passing a value to :to, no delimiters found</div><div class="line">q:to (EOF) # string delimited by ()</div></pre></td></tr></table></figure>
<p>使用你自己的副词<br>所以你决定给你的函数添加你自己定义的副词。如果你记得的话，副词和具名参数基本上是一样的东西。所以，为了给你的函数创建副词，你仅仅只需要声明具名参数就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub root3($number, :$adverb1, :$adverb2) &#123;</div><div class="line">    # ... snip ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给副词一个默认值就和位置参数一样，并且让某个副词必须出现，只需在副词名后面添加一个感叹号就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub root4($num, :$adv1 = 42, :$adv2, :$adv3!) &#123;</div><div class="line">    # default value of $adv1 is 42,</div><div class="line">    # $adv2 is undefined (boolifies to False)</div><div class="line">    # $adv3 must be supplied by the user</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想捕捉别人扔给你的所有副词，你可以使用 slurpy 散列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub root3($num, *%advs) &#123;</div><div class="line">    # %advs 包含所有传递给该函数的副词 :adverbs</div><div class="line">    # that were passed to the function.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你在MAIN子例程定义了具名参数，它们会变成命令行选项！<br>操作符也是一样，因为操作符就是特殊语法的函数！<br>既然你已经学会了怎样把简陋的 Pair 应用到更多不止 Hashes 上面， 我希望你能在你的代码中快速使用它们， 并愉快地阅读剩下的 advent！</p>
<h2 id="Slicing-with-adverbs-the-only-way"><a href="#Slicing-with-adverbs-the-only-way" class="headerlink" title="Slicing with adverbs, the only way!"></a>Slicing with adverbs, the only way!</h2><hr>
<p>By Liztormato<br>在散列切片和数组切片中你能使用哪些副词呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">名称	            描述</div><div class="line">:exists	元素是否存在</div><div class="line">:delete	移除元素，返回真，如果有元素被移除的话</div><div class="line">:kv	            将键和值作为Parcel返回</div><div class="line">:p	            return key(s) and value(s) as Parcel of Pairs</div><div class="line">:k	          只返回键</div><div class="line">:v	          只返回值</div></pre></td></tr></table></figure>
<p><code>:exists</code><br>这个副词代替 <code>.exists</code>方法。 副词为散列和数组提供了统一的接口，可以一次检查多个元素。 .exists方法只允许一次检查单个键。<br>例子更有说服力。检查单个键是否存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;a&gt;:exists’</div><div class="line">True</div></pre></td></tr></table></figure>
<p>如果我们将这扩展到切片上，我们会得到一堆布尔值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:exists&apos;</div><div class="line">True True False</div></pre></td></tr></table></figure>
<p>返回结果是 （Parcel）<br>注意，如果我们仅仅请求一个键，我们取回的是一个布尔值，不是一个只含一个布尔值的Parcel.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say (%h&lt;a&gt;:exists).WHAT’</div><div class="line">(Bool)</div></pre></td></tr></table></figure>
<p>如果很清楚地知道我们是在处理多个键，或者在编译时不清楚我们仅仅处理单个键，我们得到 一个 Parcel：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say (%h&lt;a b c&gt;:exists).WHAT’</div><div class="line">(Parcel)</div><div class="line">$ perl6 -e &apos;my @a=&quot;a&quot;; my %h = a=&gt;1, b=&gt;2; say (%h&#123;@a&#125;:exists).WHAT&apos;</div><div class="line">(Parcel)</div></pre></td></tr></table></figure>
<p>有时，知道某些东西不存在更方便。你可以很方便的在副词前面前置一个 叹号 ! 来反转副词 ，无论如何，它们其实真的很像具名参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;c&gt;:!exists&apos;</div><div class="line">True</div></pre></td></tr></table></figure>
<p><code>:delete</code><br>只有这个副词能改变散列或数组，它代替的是 .delete方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;a&gt;:delete; say %h.perl&apos;</div><div class="line">(&quot;b&quot; =&gt; 2).hash</div></pre></td></tr></table></figure>
<p>当然，你也可以删除切片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:delete; say %h.perl&apos;</div><div class="line">1 2 (Any)</div><div class="line">().hash</div></pre></td></tr></table></figure>
<p>注意对于一个不存在的值会返回 (Any)，如果你碰巧给定散列一个默认的值，它会长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h is default(42) = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:delete; say %h.perl&apos;</div><div class="line">1 2 42</div><div class="line">().hash</div></pre></td></tr></table></figure>
<p>像 <code>:exists</code> 一样，你可以反转 <code>:delete</code> 副词，但是没有太多意义。因为副词本质上是具名参数，你可以让:delete属性带条件参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my $really = True; my %h = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:delete($really); say %h.perl&apos;</div><div class="line">1 2 (Any)</div><div class="line">().hash</div></pre></td></tr></table></figure>
<p>因为传递给副词的值是真的，删除才真正发生。然而，如果你传递一个假值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e ‘my $really; my %h = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:delete($really); say %h.perl&apos;</div><div class="line">1 2 (Any)</div><div class="line">(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2).hash</div></pre></td></tr></table></figure>
<p>它没有删除。注意返回值没有变化。删除操作就没有执行。如果你使用子例程或方法处理一些常规的切片，这会很方便，并且，你想用一个可选参数表明切片是否也被删除：仅仅将参数传递为副词的参数！</p>
<p>:kv, :p, :k, :v<br>kv 属性返回键值对，  :p属性返回一对Parcel， :k 和 :v属性只返回键和值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ perl6</div><div class="line">&gt; my %h = a =&gt; 1, b =&gt; 2;</div><div class="line">(&quot;a” =&gt; 1, &quot;b” =&gt; 2).hash</div><div class="line">&gt; %h&lt;a&gt;:kv</div><div class="line">a 1</div><div class="line">&gt; %h&lt;a&gt;:p  # 注意:p 返回的是 Parcel</div><div class="line">&quot;a&quot; =&gt; 1</div><div class="line">&gt; %h&lt;a&gt;:k</div><div class="line">a</div><div class="line">&gt; %h&lt;a&gt;:v</div><div class="line">1</div></pre></td></tr></table></figure>
<p>注意下面返回值的不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; %h&lt;a b c&gt;</div><div class="line">1 2 (Any)</div><div class="line">&gt; %h&lt;a b c&gt;:v</div><div class="line">1 2</div></pre></td></tr></table></figure>
<p>因为 :v 属性起着过滤的作用，过滤掉 Any. 但是，有时候你不需要这种行为。反转那个属性就可以达到目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; %h&lt;a b c&gt;:k</div><div class="line">a b</div><div class="line">&gt; %h&lt;a b c&gt;:!k</div><div class="line">a b c</div></pre></td></tr></table></figure>
<p>将副词组合在一块<br>你也可以将几个副词结合在一块作用到 散列或切片上。最有用的组合是用 :exist 和:delete中的一个或两个，结合 :kv, :p, :k, :v中的其中之一。一些例子，例如将散列中的切片放到另外一个散列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; my %i = (%h&lt;a c&gt;:delete:p).list; say %h.perl; say %i.perl&apos;  # delete返回删除的东西</div><div class="line">(&quot;b” =&gt; 2).hash</div><div class="line">(&quot;a” =&gt; 1).hash</div></pre></td></tr></table></figure>
<p>下面返回的是删除掉的键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:delete:k’</div><div class="line">a b</div></pre></td></tr></table></figure>
<p>数组不是散列<br>在数组中，元素的键是数组的索引，所以，显示数组中定义有值的元素的索引，我们可以使用 :k属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my @a; @a[3] = 1; say @a[]:k&apos;</div><div class="line">3</div></pre></td></tr></table></figure>
<p>或使用数组中的所有元素创建一个 Parcel：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my @a; @a[3] = 1; say @a[]:!k’</div><div class="line">0 1 2 3</div></pre></td></tr></table></figure>
<p>然而，从数组中删除一个元素，和把 Nil 赋值给它类似，所以它会返回它默认的值（通常是 (Any))</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; my @a=^10;</div><div class="line">0 1 2 3 4 5 6 7 8 9</div><div class="line">$ perl6 -e &apos;my @a = ^10; @a[3]:delete; say @a[2,3,4]; say @a[2,3,4]:exists&apos;</div><div class="line">2 (Any) 4</div><div class="line">True False True</div></pre></td></tr></table></figure>
<p>如果我们给数组指定了默认值，结果会稍有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my @a is default(42) = ^10; @a[3]:delete; say @a[2,3,4]; say @a[2,3,4]:exists&apos;</div><div class="line">2 42 4</div><div class="line">True False True</div></pre></td></tr></table></figure>
<p>所以，即使元素不存在了，它也能返回一个定义好的值</p>
<h2 id="A-Grammar-with-duplicate-checking"><a href="#A-Grammar-with-duplicate-checking" class="headerlink" title="A Grammar with duplicate checking"></a>A Grammar with duplicate checking</h2><hr>
<p>By Dwarring<br>今天的例子构建了一个 grammar 用于追踪打牌。一个或多个玩家， 每个玩家手上只有 5 张牌。每次发牌不允许有重复纸牌：</p>
<p>A simple Card Game Grammar<br>To start with, here’s the basic grammar (no duplicate checks yet):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">grammar CardGame &#123;</div><div class="line"></div><div class="line">    rule TOP &#123; ^ &lt;deal&gt; $ &#125;</div><div class="line"></div><div class="line">    rule deal &#123;</div><div class="line">        &lt;hand&gt;+ % &apos;;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    rule hand  &#123; [ &lt;card&gt; ]**5 &#125;</div><div class="line">    token card &#123; &lt;face&gt;&lt;suit&gt;  &#125;</div><div class="line"></div><div class="line">    proto token suit &#123;*&#125;</div><div class="line">    token suit:sym&lt;♥&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♦&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♣&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♠&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line"></div><div class="line">    token face &#123;:i &lt;[2..9]&gt; | 10 | j | q | k | a &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say CardGame.parse(&quot;2♥ 5♥ 7♦ 8♣ 9♠&quot;);</div><div class="line">say CardGame.parse(&quot;2♥ a♥ 7♦ 8♣ j♥&quot;);</div></pre></td></tr></table></figure>
<p>最高阶层的 rule 包含一个 deal （发牌）。 deal 由一个或多个使用 ; 隔开的 hands（一手牌）组成。每手牌 hand 有 5 张纸牌。<br>每张纸牌由一个 face 和一个 suite 代表。face 有 A、J、Q、K 或 2-10. 后面跟着花色 suite：♥ (红心) ♦ (方块) ♣ (梅花) or ♠ (黑桃)。<br>[我们可以使用纸牌字符， Unicode 6.0新引入的，但是还未被广泛支持]<br>不出所料，第一茬 grammar 能就解析任意手牌：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say CardGame.parse(&quot;a♥ a♥ 7♦ 8♣ j♥&quot;);</div><div class="line"># 一手, duplicate a♥</div><div class="line">say CardGame.parse(&quot;a♥ 7♥ 7♦ 8♣ j♥; 10♥ j♥ q♥ k♥ a♥&quot;);</div><div class="line"># 两手, duplicate j♥</div></pre></td></tr></table></figure>
<p>检测重复</p>
<p>我们开始给这个 grammar 添加一个 Perl 6变量申明。这将用于追踪纸牌：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rule deal &#123;</div><div class="line">    :my %*PLAYED = ();</div><div class="line">    &lt;hand&gt;+ % &apos;;&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这申明了 <code>%*PLAYED</code>。 ‘%<em>‘ twigil  表明那是一个散列， ‘</em>‘ 表明它是动态作用域的。<br>动态作用域不仅仅用于子例程和方法调用。它也能无缝地和 grammar rules、tokens和 actions 用在一起。<br>因为是动态作用域， <code>%*PLAYED</code>  对于 deal rule 的调用者是可见的； hand token 和它的调用者， card token。<br>%*PLAYED 对于任何随后被调用的 actions 也是可见的。所以通过为 card token 创建一个 action 我们能够追踪和报告重复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class CardGame::Actions &#123;</div><div class="line">    method card($/) &#123;</div><div class="line">       my $card = $/.lc;</div><div class="line">       say &quot;Hey, there&apos;s an extra $card&quot;</div><div class="line">           if %*PLAYED&#123;$card&#125;++;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $a = CardGame::Actions.new;</div><div class="line">say CardGame.parse(&quot;a♥ a♥ 7♦ 8♣ j♥&quot;, :actions($a));</div><div class="line"># &quot;Hey there&apos;s an extra a♥&quot;</div><div class="line">say CardGame.parse(&quot;a♥ 7♥ 7♦ 8♣ j♥; 10♥ j♥ q♥ k♥ a♦&quot;,</div><div class="line">                   :actions($a));</div><div class="line"># &quot;Hey there&apos;s an extra j♥&quot;</div></pre></td></tr></table></figure>
<p>这可能就是所有用于追踪和报告重复的代码了。grammar 申明和 action 是分开的， 还有一个动态作用域的散列。</p>
<p>不接收重复<br>我们要求当出现重复时，让解析失败。把重复检查的 grammar 语法移动到里面就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">token card &#123;&lt;face&gt;&lt;suit&gt;</div><div class="line">    &lt;?&#123;</div><div class="line">        # only allow each card to appear once</div><div class="line">        my $card = $/.lc;</div><div class="line">        say &quot;Hey, there&apos;s an extra $card&quot;</div><div class="line">            if %*PLAYED&#123;$card&#125;;</div><div class="line"></div><div class="line">        ! %*PLAYED&#123;$card&#125;++;</div><div class="line">     &#125;&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这在&lt;?{ 和 }&gt;  之间引入了一个断言. 当这段代码值为 True 时， rule 就成功， 当单次发牌同一张纸牌出现多于一次时card token 失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">say CardGame.parse(&quot;2♥ 7♥ 2♦ 3♣ 3♦&quot;);</div><div class="line"># legitimate, parses</div><div class="line"></div><div class="line">say CardGame.parse(&quot;a♥ a♥ 7♦ 8♣ j♥&quot;);</div><div class="line"># fails with message: Hey, there&apos;s an extra a♥</div><div class="line"></div><div class="line">say CardGame.parse(&quot;a♥ 7♥ 7♦ 8♣ j♥; 10♥ j♥ q♥ k♥ a♦&quot;);</div><div class="line"># fails with message: Hey, there&apos;s an extra j♥</div></pre></td></tr></table></figure>
<h2 id="Unary-Sort"><a href="#Unary-Sort" class="headerlink" title="Unary Sort"></a>Unary Sort</h2><hr>
<p>By Moritz<br>在Perl5中按数值大小排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use v5;</div><div class="line">my @sorted = sort &#123; $a &lt;=&gt; $b &#125; @values;</div></pre></td></tr></table></figure>
<p>Perl6 提供类似的选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my @sorted = sort &#123; $^a &lt;=&gt; $^b &#125;, @values;</div></pre></td></tr></table></figure>
<p>主要区别在于，参数不是通过全局变量 <code>$a</code> 和 <code>$b</code> 来传递，而是作为 comparator的参数传递。 comparator 可以是任何能掉调用的东西,即具名或匿名的子例程或代码块。{ $^a &lt;=&gt; $^b}语法对于sort也不特殊，我仅仅用了占位变量来展示和Perl5 的相似之处。 下面的写法一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @sorted = sort -&gt; $a, $b &#123; $a &lt;=&gt; $b &#125;, @values;</div><div class="line">my @sorted = sort * &lt;=&gt; *, @values;</div><div class="line">my @sorted = sort &amp;infix:«&lt;=&gt;», @values;</div></pre></td></tr></table></figure>
<p>The first one is just another syntax for writing blocks, <code>* &lt;=&gt; *</code> use* to automatically curry an argument, and the final one directly refers to the routine that implements the &lt;=&gt; “space ship” operator (which does numeric comparison).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 按照散列中定义的顺序排序单词:</div><div class="line">my %rank = a =&gt; 5, b =&gt; 2, c =&gt; 10, d =&gt; 3;</div><div class="line">say sort &#123; %rank&#123;$^a&#125; &lt;=&gt; %rank&#123;$^b&#125; &#125;, &apos;a&apos;..&apos;d&apos;;  # b d a c ,升序排列</div><div class="line"> #          ^^^^^^^^^^     ^^^^^^^^^^  code duplication</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 不区分大小写排序</div><div class="line">say sort &#123; $^a.lc cmp $^b.lc &#125;, @words;</div><div class="line"> #          ^^^^^^     ^^^^^^  代码重复</div></pre></td></tr></table></figure>
<p>因为我们酷爱便捷憎恨重复，Perl 6 提供了更短的方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># sort words by a sort order defined in a hash:</div><div class="line">say sort &#123; %rank&#123;$_&#125; &#125;, &apos;a&apos;..&apos;d&apos;;</div><div class="line"></div><div class="line"># sort case-insensitively</div><div class="line">say sort &#123; .lc &#125;, @words;</div></pre></td></tr></table></figure>
<p>sort足够聪明地知道代码块现在只有一个参数，并使用它将输入列表中的每个元素映射为新值。这与Schwartzian Transform很相似，但是很方便，因为它是内置的。所以，现在代码块起着转换者的角色，而非比较器。<br>如果你想按数字顺序比较，你可以强制元素在数字上下文中进行比较，使用 + 号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @sorted-numerically = sort +*, @list;</div></pre></td></tr></table></figure>
<p>如果你想按相反的顺序比较数字，就使用 <code>-*</code> 代替好了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-Examples]]></title>
      <url>http://ohmycloud.github.io/2016/02/14/Perl-6-Examples/</url>
      <content type="html"><![CDATA[<h2 id="斐波拉契数列（Fibonacci-Sequence）"><a href="#斐波拉契数列（Fibonacci-Sequence）" class="headerlink" title="斐波拉契数列（Fibonacci Sequence）"></a>斐波拉契数列（Fibonacci Sequence）</h2><hr>
<ul>
<li>analytic</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">fibonacci</span> (<span class="title">Int</span> $<span class="title">n</span> <span class="title">where</span> 0..*  --&gt; <span class="title">Int</span>) </span>&#123;</div><div class="line">    constant phi = (<span class="number">1</span> + <span class="keyword">sqrt</span> <span class="number">5</span>) / <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> round( phi**($n+<span class="number">1</span>) / <span class="keyword">sqrt</span> <span class="number">5</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法计算前1000个斐波拉契数大约为0.746s（2015.7.Rakudo, 以下都是）。</p>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">fibonacci</span> (<span class="title">Int</span> $<span class="title">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">state</span> @sequence = <span class="number">1</span>,<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> @sequence.elems &lt;= $n &#123;</div><div class="line">        @sequence.push( @sequence[*-<span class="number">2</span>] + @sequence[*-<span class="number">1</span>] );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> @sequence[$n];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种遍历法大概需要 1 秒多。</p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">fibonacci</span> (<span class="title">Int</span> $<span class="title">n</span> <span class="title">where</span> 0..*) </span>&#123;</div><div class="line">    <span class="keyword">if</span> $n == <span class="number">0</span> | <span class="number">1</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> fibonacci($n-<span class="number">1</span>) + fibonacci($n-<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比较慢。第 20 个之后越来越慢。</p>
<ul>
<li>递归 - 超运算符</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">fibonacci</span> (<span class="title">Int</span> $<span class="title">n</span> <span class="title">where</span> 0..*) </span>&#123;</div><div class="line">    <span class="keyword">if</span> $n == <span class="number">0</span> | <span class="number">1</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> [+] ($n-<span class="number">1</span>, $n-<span class="number">2</span>)».&amp;fibonacci;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和上面差不多。</p>
<ul>
<li>递归 - map</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">fibonacci</span> (<span class="title">Int</span> $<span class="title">n</span> <span class="title">where</span> 0..*) </span>&#123;</div><div class="line">    <span class="keyword">if</span> $n == <span class="number">0</span> | <span class="number">1</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> [+] <span class="keyword">map</span> &amp;fibonacci, ($n-<span class="number">1</span>, $n-<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同上。</p>
<ul>
<li>递归 - multi</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">multi fibonacci (<span class="number">0</span>)  &#123; <span class="number">1</span> &#125;</div><div class="line"></div><div class="line">multi fibonacci (<span class="number">1</span>)  &#123; <span class="number">1</span> &#125;</div><div class="line"></div><div class="line">multi fibonacci (Int $n --&gt; Int) &#123;</div><div class="line">    <span class="keyword">return</span> fibonacci($n-<span class="number">1</span>) + fibonacci($n-<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比上一个稍快。</p>
<ul>
<li>递归 - multi_cached</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">multi fibonacci (<span class="number">0</span>)  &#123; <span class="number">1</span> &#125;</div><div class="line"></div><div class="line">multi fibonacci (<span class="number">1</span>)  &#123; <span class="number">1</span> &#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> %cached;</div><div class="line">multi fibonacci (Int $n --&gt; Int) &#123;</div><div class="line">    <span class="keyword">return</span> %cached&#123;$n&#125; //= fibonacci($n-<span class="number">1</span>) + fibonacci($n-<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.849s 执行完毕。</p>
<ul>
<li>递归 - multi_cached_state</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">multi fibonacci (<span class="number">0</span>)  &#123; <span class="number">1</span> &#125;</div><div class="line"></div><div class="line">multi fibonacci (<span class="number">1</span>)  &#123; <span class="number">1</span> &#125;</div><div class="line"></div><div class="line">multi fibonacci (Int $n --&gt; Int) &#123;</div><div class="line">    <span class="keyword">state</span> %cached;</div><div class="line">    <span class="keyword">return</span> %cached&#123;$n&#125; //= fibonacci($n-<span class="number">1</span>) + fibonacci($n-<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0.885s</p>
<ul>
<li>递归 - multi_cached_trait</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">multi fibonacci (<span class="number">0</span>)  &#123; <span class="number">1</span> &#125;</div><div class="line"></div><div class="line">multi fibonacci (<span class="number">1</span>)  &#123; <span class="number">1</span> &#125;</div><div class="line"></div><div class="line">multi fibonacci (Int $n --&gt; Int) is cached &#123;</div><div class="line">    fibonacci($n-<span class="number">1</span>) + fibonacci($n-<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前报错。</p>
<ul>
<li>序列</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">fibonacci</span> (<span class="title">Int</span> $<span class="title">n</span>) </span>&#123;</div><div class="line">    constant @sequence :=  <span class="number">1</span>, <span class="number">1</span>, *+* ... *;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> @sequence[$n];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.6s多。 其中 <code>:=</code> 是惰性赋值。按需求值。</p>
<ul>
<li>序列 - inline</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">fibonacci</span> (<span class="title">Int</span> $<span class="title">n</span>) </span>&#123;</div><div class="line">    (<span class="number">1</span>, <span class="number">1</span>, *+* ... *)[$n];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">0</span>..<span class="number">1000</span> -&gt; $i &#123;</div><div class="line">    <span class="keyword">say</span> $i.fmt(<span class="string">'%3d'</span>), <span class="string">': '</span>, fibonacci($i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Finished in 133.808s.</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><hr>
<ul>
<li>bogosort</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">bogosort</span> ( *@<span class="title">list</span> ) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">until</span> [!after] @list &#123;</div><div class="line">        @list .= pick(*);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> @list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#my @data = 6, 7, 2, 1, 8, 9, 2;</span></div><div class="line"><span class="keyword">my</span> @data =  &lt; p e r l <span class="keyword">s</span> i <span class="keyword">x</span> &gt;;</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'input  = '</span> ~          @data;</div><div class="line"><span class="keyword">say</span> <span class="string">'output = '</span> ~ bogosort @data;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input  = p e r l s i x</div><div class="line">output = e i l p r s x</div><div class="line">[Finished in 1.326s]</div></pre></td></tr></table></figure>
<ul>
<li>mergesort</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">merge</span> (@<span class="title">a</span>, @<span class="title">b</span>) </span>&#123;</div><div class="line">    gather <span class="keyword">while</span> @a &amp;&amp; @b &#123;</div><div class="line">        <span class="keyword">if</span> @a[<span class="number">0</span>] before @b[<span class="number">0</span>] &#123; take @a.shift &#125;</div><div class="line">        <span class="keyword">else</span>                  &#123; take @b.shift &#125;</div><div class="line">    &#125;,</div><div class="line">    @a,</div><div class="line">    @b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mergesort</span> ( *@<span class="title">list</span> ) </span>&#123;</div><div class="line">    <span class="keyword">return</span> @list <span class="keyword">if</span> @list.elems &lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">my</span> $middle = @list.elems div <span class="number">2</span>;</div><div class="line">    <span class="keyword">my</span> @left   = mergesort @list[ <span class="number">0</span> ..^ $middle ];</div><div class="line">    <span class="keyword">my</span> @right  = mergesort @list[ $middle .. *  ];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> merge(@left, @right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;</span></div><div class="line"><span class="keyword">my</span> @data = &lt; p e r l <span class="keyword">s</span> i <span class="keyword">x</span> &gt;;</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">"input  = &#123;           @data  &#125;"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"output = &#123; mergesort(@data) &#125;"</span>;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input  = p e r l s i x</div><div class="line">output = e i l p r s x</div><div class="line">[Finished in 0.337s]</div></pre></td></tr></table></figure>
<ul>
<li>mergesort_functional</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">multi merge ([], @ys) &#123; @ys &#125;</div><div class="line"></div><div class="line">multi merge (@xs, []) &#123; @xs &#125;</div><div class="line"></div><div class="line">multi merge ([$x, *@xs], [$y, *@ys]) &#123;</div><div class="line">    $x before $y ?? ($x, merge @xs, [$y, @ys])</div><div class="line">                 !! ($y, merge [$x, @xs], @ys)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">multi mergesort ( [] ) &#123;  []  &#125;</div><div class="line"></div><div class="line">multi mergesort ([$x]) &#123; [$x] &#125;</div><div class="line"></div><div class="line">multi mergesort (@xs)  &#123;</div><div class="line">    merge</div><div class="line">        mergesort( @xs[<span class="number">0</span> ..^ @xs.elems div <span class="number">2</span>] ),</div><div class="line">        mergesort( @xs[@xs.elems div <span class="number">2</span> .. * ] )</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="keyword">my</span> @data = <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>;</div><div class="line"><span class="comment">#my @data = &lt; p e r l s i x &gt;;</span></div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">"input  = &#123;           @data  &#125;"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"output = &#123; mergesort(@data) &#125;"</span>;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input  = 6 7 2 1 8 9 5 3 4</div><div class="line">output = 1 2 3 4 5 6 7 8 9</div><div class="line">[Finished in 0.373s]</div></pre></td></tr></table></figure>
<ul>
<li>mergesort_functional_given</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">multi merge ([], @ys) &#123; @ys &#125;</div><div class="line"></div><div class="line">multi merge (@xs, []) &#123; @xs &#125;</div><div class="line"></div><div class="line">multi merge ([$x, *@xs], [$y, *@ys]) &#123;</div><div class="line">    $x before $y ?? ($x, merge @xs, [$y, @ys])</div><div class="line">                 !! ($y, merge [$x, @xs], @ys)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">multi mergesort ( [] ) &#123;  []  &#125;</div><div class="line"></div><div class="line">multi mergesort ([$x]) &#123; [$x] &#125;</div><div class="line"></div><div class="line">multi mergesort (@xs)  &#123;</div><div class="line">    <span class="keyword">given</span> @xs.elems div <span class="number">2</span> -&gt; $middle &#123;</div><div class="line">        merge</div><div class="line">            mergesort( @xs[ <span class="number">0</span> ..^ $middle ] ),</div><div class="line">            mergesort( @xs[ $middle .. *  ] )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">my</span> @data = <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>;</div><div class="line"><span class="comment">#my @data = &lt; p e r l s i x &gt;;</span></div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">"input  = &#123;           @data  &#125;"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"output = &#123; mergesort(@data) &#125;"</span>;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input  = 6 7 2 1 8 9 5 3 4</div><div class="line">output = 1 2 3 4 5 6 7 8 9</div><div class="line">[Finished in 0.375s]</div></pre></td></tr></table></figure>
<ul>
<li>mergesort_functional_interleaved</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">multi merge ([], @ys) &#123; @ys &#125;</div><div class="line"></div><div class="line">multi merge (@xs, []) &#123; @xs &#125;</div><div class="line"></div><div class="line">multi merge ([$x, *@xs], [$y, *@ys]) &#123;</div><div class="line">    $x before $y ?? ($x, merge @xs, [$y, @ys])</div><div class="line">                 !! ($y, merge [$x, @xs], @ys)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">multi mergesort ( [] ) &#123;  []  &#125;</div><div class="line"></div><div class="line">multi mergesort ([$x]) &#123; [$x] &#125;</div><div class="line"></div><div class="line">multi mergesort (@xs)  &#123;</div><div class="line">    merge</div><div class="line">        mergesort( @xs[<span class="number">0</span>,<span class="number">2</span>...*] ),</div><div class="line">        mergesort( @xs[<span class="number">1</span>,<span class="number">3</span>...*] )</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="keyword">my</span> @data = <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>;</div><div class="line"><span class="comment">#my @data = &lt; p e r l s i x &gt;;</span></div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">"input  = &#123;           @data  &#125;"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"output = &#123; mergesort(@data) &#125;"</span>;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input  = 6 7 2 1 8 9 5 3 4</div><div class="line">output = 1 2 3 4 5 6 7 8 9</div><div class="line">[Finished in 0.34s]</div></pre></td></tr></table></figure>
<ul>
<li>quicksort</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">quicksort</span>( *@<span class="title">list</span> ) </span>&#123;</div><div class="line">    <span class="keyword">return</span> @list <span class="keyword">if</span> @list.elems &lt; <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">my</span> $pivot = @list.shift;</div><div class="line"><span class="comment">#     my $pivot = @list.=pick(*).shift;</span></div><div class="line"></div><div class="line">    <span class="keyword">my</span> (@before, @after);</div><div class="line">    <span class="keyword">for</span> @list -&gt; $elem &#123;</div><div class="line">        <span class="keyword">if</span> $elem before $pivot &#123; @before.push($elem); &#125;</div><div class="line">        <span class="keyword">else</span>                   &#123; @after.push($elem);  &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> quicksort(@before),</div><div class="line">           $pivot,</div><div class="line">           quicksort(@after);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;</span></div><div class="line"><span class="keyword">my</span> @data = &lt; p e r l <span class="keyword">s</span> i <span class="keyword">x</span> &gt;;</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">"input  = &#123;           @data  &#125;"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"output = &#123; quicksort(@data) &#125;"</span>;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input  = p e r l s i x</div><div class="line">output = e i l p r s x</div><div class="line">[Finished in 0.246s]</div></pre></td></tr></table></figure>
<ul>
<li>quicksort_classify</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">multi quicksort(  []  ) &#123;    &#125;;</div><div class="line">multi quicksort(  Mu  ) &#123;    &#125;;</div><div class="line"></div><div class="line">multi quicksort( [$x] ) &#123; $x &#125;;</div><div class="line"></div><div class="line">multi quicksort( [$pivot, *@xs] ) &#123;</div><div class="line">    <span class="keyword">given</span> @xs.classify:&#123; $^elem before $pivot ?? <span class="string">'pre'</span> !! <span class="string">'post'</span>&#125; &#123;</div><div class="line">        quicksort( .&lt;pre&gt;  ),</div><div class="line">        $pivot,</div><div class="line">        quicksort( .&lt;post&gt; );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;</span></div><div class="line"><span class="keyword">my</span> @data = &lt; p e r l <span class="keyword">s</span> i <span class="keyword">x</span> &gt;;</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">"input  = &#123;           @data  &#125;"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"output = &#123; quicksort(@data) &#125;"</span>;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input  = p e r l s i x</div><div class="line">output =  e i  l p  r  s x</div><div class="line">[Finished in 0.303s]</div></pre></td></tr></table></figure>
<ul>
<li>quicksort_functional</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">multi quicksort(  []  ) &#123;    &#125;;</div><div class="line"></div><div class="line">multi quicksort( [$x] ) &#123; $x &#125;;</div><div class="line"></div><div class="line">multi quicksort( [$pivot, *@xs] ) &#123;</div><div class="line">    quicksort(@xs.<span class="keyword">grep</span>: * before $pivot),</div><div class="line">    $pivot,</div><div class="line">    quicksort(@xs.<span class="keyword">grep</span>: * !before $pivot);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;</span></div><div class="line"><span class="keyword">my</span> @data = &lt; p e r l <span class="keyword">s</span> i <span class="keyword">x</span> &gt;;</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">"input  = &#123;           @data  &#125;"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"output = &#123; quicksort(@data) &#125;"</span>;</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input  = p e r l s i x</div><div class="line">output =  e i l  p  r  s x</div><div class="line">[Finished in 0.27s]</div></pre></td></tr></table></figure>
<h2 id="pm-模块"><a href="#pm-模块" class="headerlink" title="pm 模块"></a>pm 模块</h2><hr>
<p>首先把自定义的 Bank.pm 模块复制到 Perl 6 的 lib 目录下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp Bank.pm /Users/chenyf/.rakudobrew/moar-nom/install/share/perl6/site/lib</div></pre></td></tr></table></figure>
<p>Bank.pm</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">class Ident &#123;</div><div class="line">    subset Pattern of Str where / \d**<span class="number">3</span> <span class="string">'-'</span> \d**<span class="number">3</span> <span class="string">'-'</span> \d**<span class="number">3</span> /;</div><div class="line"></div><div class="line">    has Str $.name              = <span class="string">'????'</span>;</div><div class="line">    has Str $.ID  where Pattern = <span class="string">'000-000-000'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">role Taxable [:$THRESHOLD = <span class="number">100_000</span>] &#123;</div><div class="line">    constant GENERAL_TAX_RATE = <span class="number">0</span>.<span class="number">01</span>;</div><div class="line"></div><div class="line">    has %.tax_record;</div><div class="line"></div><div class="line">    method tax_credits &#123;...&#125;</div><div class="line"></div><div class="line">    method calculate_tax () &#123;</div><div class="line">        <span class="keyword">my</span> $tax_payable = ($.balance min $THRESHOLD) * GENERAL_TAX_RATE </div><div class="line">                          - $.tax_credits;</div><div class="line"></div><div class="line">        %!tax_record<span class="string">&#123;now&#125;</span> = $tax_payable;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> $tax_payable;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Account</div><div class="line">    does Taxable</div><div class="line">&#123;</div><div class="line">    subset ID of Str where / &lt;alpha&gt;**<span class="number">4</span> &lt;digit&gt;**<span class="number">5</span> /;</div><div class="line"></div><div class="line">    <span class="keyword">state</span> ID $next_account_ID = <span class="string">'AAAA00001'</span>;</div><div class="line"></div><div class="line">    has Str     $.name        = <span class="keyword">die</span> <span class="string">'Must provide account name'</span>;</div><div class="line">    has Numeric $.balance     = <span class="number">0</span>;</div><div class="line">    has ID      $.ID          = $next_account_ID++;</div><div class="line"></div><div class="line">    method deposit(Numeric $amount where *&gt;<span class="number">0</span>) &#123;</div><div class="line">        $!balance += $amount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method withdraw(Numeric $amount where *&gt;<span class="number">0</span>) &#123;</div><div class="line">        fail <span class="string">"Insufficient funds to withdraw $amount"</span></div><div class="line">            <span class="keyword">if</span> $.balance &lt; $amount;</div><div class="line">        $!balance -= $amount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method description () &#123;</div><div class="line">        <span class="string">"$.ID ($.name): balance=$.balance"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method tax_credits &#123; <span class="number">0</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bank &#123;</div><div class="line">    has Ident   $!ident     handles&lt; name ID &gt;;</div><div class="line">    has Account %!accounts;</div><div class="line"></div><div class="line">    submethod BUILD (|args) &#123;</div><div class="line">        $!ident .= new(|args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method add_account(Account $account) &#123;</div><div class="line">        %!accounts&#123;$account.ID&#125; = $account;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method close_account(Str $ID) &#123;</div><div class="line">        <span class="keyword">return</span> %!accounts&#123;$ID&#125; :<span class="keyword">delete</span></div><div class="line">            // fail <span class="string">"No such account"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    multi method get_account(Account::ID $ID) &#123;</div><div class="line">        <span class="keyword">return</span> %!accounts&#123;$ID&#125; // fail <span class="string">"No such account"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    multi method get_account(Any $name) &#123;</div><div class="line"><span class="comment">#        return %!accounts.values.grep(&#123;.name ~~ $name&#125;);</span></div><div class="line">        self.for_each_account(&#123;.take <span class="keyword">if</span> .name ~~ $name&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method for_each_account (&amp;action_on) &#123;</div><div class="line">        gather <span class="keyword">for</span> %!accounts.values -&gt; $account is rw &#123;</div><div class="line">            action_on($account);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method collect_taxes () &#123;</div><div class="line">        self.for_each_account: &#123;</div><div class="line">            <span class="keyword">my</span> $tax = .calculate_tax();</div><div class="line">            .withdraw($tax);</div><div class="line">            take .<span class="string">ID =&gt;</span> $tax;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method report () &#123;</div><div class="line">        <span class="keyword">say</span> <span class="string">"[ &#123;self.ID&#125; [&#123;self.name&#125;] ]"</span>;         <span class="comment"># Or: say "[ $.ID [$.name] ]";</span></div><div class="line">        self.for_each_account(*.description.say);</div><div class="line">        <span class="keyword">say</span> <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class Account::Corporate</div><div class="line">    is Account</div><div class="line">    does Taxable[<span class="string">THRESHOLD =&gt;</span> <span class="number">1_000_000</span>]</div><div class="line">&#123;</div><div class="line">    has Str $.company_ID;</div><div class="line"></div><div class="line">    method tax_credits &#123; <span class="number">5_000</span> &#125;</div><div class="line"></div><div class="line">    method description () &#123;</div><div class="line">        callsame() ~ <span class="string">"  [$.company_ID]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该模块的功能是计算银行存款汇率等。下面使用这个模块：</p>
<ul>
<li>demo</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">use</span> Bank;</div><div class="line"></div><div class="line"><span class="keyword">my</span> Bank $bank .= new(:ID(<span class="string">'123-456-789'</span>));</div><div class="line"></div><div class="line">$bank.add_account: Account.new(:name(<span class="string">'Leslie Grace'</span>)                  );</div><div class="line">$bank.add_account: Account.new(:name(<span class="string">'Dana McKenna'</span>), :balance(<span class="number">10_000</span>));</div><div class="line">$bank.add_account: Account.new(:name(<span class="string">'AstroDynamic'</span>), :balance(   <span class="number">2</span>e7));</div><div class="line">$bank.add_account: Account.new(:name(<span class="string">'Jan van Quod'</span>), :balance( <span class="number">9_999</span>));</div><div class="line">$bank.add_account: Account.new(:name(<span class="string">'OmniCorp LLC'</span>), :balance(   <span class="number">1</span>e6));</div><div class="line">$bank.report;</div><div class="line"></div><div class="line">$bank.get_account(<span class="string">'AAAA00003'</span>).deposit(<span class="number">100</span>);</div><div class="line">$bank.get_account(<span class="string">'Jan van Quod'</span>)».deposit(<span class="number">2</span>);</div><div class="line">$bank.get_account(<span class="regexp">/D.na/</span>)».deposit(<span class="number">2</span>);</div><div class="line"><span class="comment">#$bank.get_account(*)».deposit(99);</span></div><div class="line">$bank.report;</div><div class="line"></div><div class="line"><span class="keyword">given</span> $bank.close_account(<span class="string">'AAAA00005'</span>) &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Closed $^account.perl()\n"</span>;</div><div class="line">    $bank.report;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$bank.close_account(<span class="string">'ZZZZ99999'</span>);</div><div class="line"></div><div class="line">$bank.get_account(<span class="string">'AAAA00001'</span>).withdraw(<span class="number">1001</span>);</div><div class="line">$bank.report;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">[ <span class="number">123</span>-<span class="number">456</span>-<span class="number">789</span> [????] ]</div><div class="line">AAAA00004 (Jan van Quod): balance=<span class="number">9999</span></div><div class="line">AAAA00001 (Leslie Grace): balance=<span class="number">0</span></div><div class="line">AAAA00005 (OmniCorp LLC): balance=<span class="number">1000000</span></div><div class="line">AAAA00002 (Dana McKenna): balance=<span class="number">10000</span></div><div class="line">AAAA00003 (AstroDynamic): balance=<span class="number">20000000</span></div><div class="line"></div><div class="line">[ <span class="number">123</span>-<span class="number">456</span>-<span class="number">789</span> [????] ]</div><div class="line">AAAA00004 (Jan van Quod): balance=<span class="number">10001</span></div><div class="line">AAAA00001 (Leslie Grace): balance=<span class="number">0</span></div><div class="line">AAAA00005 (OmniCorp LLC): balance=<span class="number">1000000</span></div><div class="line">AAAA00002 (Dana McKenna): balance=<span class="number">10002</span></div><div class="line">AAAA00003 (AstroDynamic): balance=<span class="number">20000102</span></div><div class="line"></div><div class="line">Closed Account.new(<span class="string">name =&gt;</span> <span class="string">"OmniCorp LLC"</span>, <span class="string">balance =&gt;</span> <span class="number">1000000</span>e<span class="number">0</span>, <span class="string">ID =&gt;</span> <span class="string">"AAAA00005"</span>, <span class="string">tax_record =&gt;</span> &#123;&#125;&lt;&gt;)</div><div class="line"></div><div class="line">[ <span class="number">123</span>-<span class="number">456</span>-<span class="number">789</span> [????] ]</div><div class="line">AAAA00004 (Jan van Quod): balance=<span class="number">10001</span></div><div class="line">AAAA00001 (Leslie Grace): balance=<span class="number">0</span></div><div class="line">AAAA00002 (Dana McKenna): balance=<span class="number">10002</span></div><div class="line">AAAA00003 (AstroDynamic): balance=<span class="number">20000102</span></div><div class="line"></div><div class="line">No such account</div><div class="line">  in method close_account at /Users/chenyf/.rakudobrew/moar-nom/install/share/perl6/site/lib/Bank.pm:<span class="number">67</span></div><div class="line">  in block &lt;unit&gt; at /Users/chenyf/Downloads/Perl6_Transparadigm_examples/<span class="number">04</span>.bank_demo.pl:<span class="number">26</span></div><div class="line"></div><div class="line">Actually thrown at:</div><div class="line">  in block &lt;unit&gt; at /Users/chenyf/Downloads/Perl6_Transparadigm_examples/<span class="number">04</span>.bank_demo.pl:<span class="number">26</span></div><div class="line"></div><div class="line">[Finished in <span class="number">0</span>.<span class="number">768</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<ul>
<li>demo_inheritance</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">show</span> ($<span class="title">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">''</span>;</div><div class="line">    <span class="keyword">say</span> (<span class="string">'____/ '</span> ~ $text ~ <span class="string">' \_________________________________________________'</span>).substr(<span class="number">0</span>,<span class="number">50</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">use</span> Bank;</div><div class="line"></div><div class="line"><span class="keyword">my</span> Bank $bank .= new(:ID(<span class="string">'123-456-789'</span>), :name(<span class="string">'Bank of Evil'</span>));</div><div class="line"></div><div class="line">$bank.add_account: Account.new(:name(<span class="string">'Leslie Grace'</span>), :balance( <span class="number">1_000</span>));</div><div class="line">$bank.add_account: Account.new(:name(<span class="string">'Dana McKenna'</span>), :balance(<span class="number">10_000</span>));</div><div class="line">$bank.add_account: Account.new(:name(<span class="string">'Jan van Quod'</span>), :balance( <span class="number">9_999</span>));</div><div class="line"></div><div class="line">$bank.add_account: Account::Corporate.new(:name(<span class="string">'AstroDynamic'</span>), :balance(<span class="number">2</span>e7) :company_ID(<span class="string">'ASDY'</span>));</div><div class="line">$bank.add_account: Account::Corporate.new(:name(<span class="string">'OmniCorp LLC'</span>), :balance(<span class="number">1</span>e6) :company_ID(<span class="string">'OMNI'</span>));</div><div class="line"></div><div class="line">show <span class="string">'Status'</span>;</div><div class="line">$bank.report;</div><div class="line"></div><div class="line">show <span class="string">'Taxes collected'</span>;</div><div class="line">.say <span class="keyword">for</span> $bank.collect_taxes();</div><div class="line"></div><div class="line">show <span class="string">'Status'</span>;</div><div class="line">$bank.report;</div><div class="line"></div><div class="line">$bank.collect_taxes();</div><div class="line"></div><div class="line">show <span class="string">'Tax records'</span>;</div><div class="line">$bank.for_each_account(&#123; <span class="keyword">say</span> .name, <span class="string">': '</span>, .tax_record &#125;);</div><div class="line"></div><div class="line">show <span class="string">'Culling acounts'</span>;</div><div class="line"><span class="keyword">given</span> $bank &#123;</div><div class="line">    .for_each_account: &#123;</div><div class="line">        .close_account($^account.ID).say</div><div class="line">            <span class="keyword">if</span> $^account.balance &lt; <span class="number">10_000</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">show <span class="string">'Status'</span>;</div><div class="line">$bank.report;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">___<span class="number">_</span>/ Status \___________________________________<span class="number">_</span></div><div class="line">[ <span class="number">123</span>-<span class="number">456</span>-<span class="number">789</span> [Bank of Evil] ]</div><div class="line">AAAA00004 (AstroDynamic): balance=<span class="number">20000000</span>  [ASDY]</div><div class="line">AAAA00001 (Leslie Grace): balance=<span class="number">1000</span></div><div class="line">AAAA00005 (OmniCorp LLC): balance=<span class="number">1000000</span>  [OMNI]</div><div class="line">AAAA00002 (Dana McKenna): balance=<span class="number">10000</span></div><div class="line">AAAA00003 (Jan van Quod): balance=<span class="number">9999</span></div><div class="line"></div><div class="line"></div><div class="line">___<span class="number">_</span>/ Taxes collected \__________________________<span class="number">_</span></div><div class="line"><span class="string">AAAA00004 =&gt;</span> <span class="number">5000</span></div><div class="line"><span class="string">AAAA00001 =&gt;</span> <span class="number">10</span></div><div class="line"><span class="string">AAAA00005 =&gt;</span> <span class="number">5000</span></div><div class="line"><span class="string">AAAA00002 =&gt;</span> <span class="number">100</span></div><div class="line"><span class="string">AAAA00003 =&gt;</span> <span class="number">99.99</span></div><div class="line"></div><div class="line">___<span class="number">_</span>/ Status \___________________________________<span class="number">_</span></div><div class="line">[ <span class="number">123</span>-<span class="number">456</span>-<span class="number">789</span> [Bank of Evil] ]</div><div class="line">AAAA00004 (AstroDynamic): balance=<span class="number">19995000</span>  [ASDY]</div><div class="line">AAAA00001 (Leslie Grace): balance=<span class="number">990</span></div><div class="line">AAAA00005 (OmniCorp LLC): balance=<span class="number">995000</span>  [OMNI]</div><div class="line">AAAA00002 (Dana McKenna): balance=<span class="number">9900</span></div><div class="line">AAAA00003 (Jan van Quod): balance=<span class="number">9899.01</span></div><div class="line"></div><div class="line">___<span class="number">_</span>/ Tax records \______________________________<span class="number">_</span></div><div class="line">AstroDynamic: Instant:<span class="number">1440413601.447466</span> =&gt; <span class="number">5000</span>, Instant:<span class="number">1440413601.463112</span> =&gt; <span class="number">5000</span></div><div class="line">Leslie Grace: Instant:<span class="number">1440413601.450753</span> =&gt; <span class="number">10</span>, Instant:<span class="number">1440413601.465823</span> =&gt; <span class="number">9.9</span></div><div class="line">OmniCorp LLC: Instant:<span class="number">1440413601.452933</span> =&gt; <span class="number">5000</span>, Instant:<span class="number">1440413601.468346</span> =&gt; <span class="number">4950</span></div><div class="line">Dana McKenna: Instant:<span class="number">1440413601.454860</span> =&gt; <span class="number">100</span>, Instant:<span class="number">1440413601.470238</span> =&gt; <span class="number">99</span></div><div class="line">Jan van Quod: Instant:<span class="number">1440413601.457399</span> =&gt; <span class="number">99.99</span>, Instant:<span class="number">1440413601.471551</span> =&gt; <span class="number">98.9901</span></div><div class="line">___<span class="number">_</span>/ Culling acounts \__________________________<span class="number">_</span></div><div class="line">Account.new(<span class="string">name =&gt;</span> <span class="string">"Leslie Grace"</span>, <span class="string">balance =&gt;</span> <span class="number">980.1</span>, <span class="string">ID =&gt;</span> <span class="string">"AAAA00001"</span>, <span class="string">tax_record =&gt;</span> &#123;<span class="string">"Instant:1440413601.450753"</span> =&gt; <span class="number">10.0</span>, <span class="string">"Instant:1440413601.465823"</span> =&gt; <span class="number">9.9</span>&#125;&lt;&gt;)</div><div class="line">Account.new(<span class="string">name =&gt;</span> <span class="string">"Dana McKenna"</span>, <span class="string">balance =&gt;</span> <span class="number">9801.0</span>, <span class="string">ID =&gt;</span> <span class="string">"AAAA00002"</span>, <span class="string">tax_record =&gt;</span> &#123;<span class="string">"Instant:1440413601.454860"</span> =&gt; <span class="number">100.0</span>, <span class="string">"Instant:1440413601.470238"</span> =&gt; <span class="number">99.0</span>&#125;&lt;&gt;)</div><div class="line">Account.new(<span class="string">name =&gt;</span> <span class="string">"Jan van Quod"</span>, <span class="string">balance =&gt;</span> <span class="number">9800.0199</span>, <span class="string">ID =&gt;</span> <span class="string">"AAAA00003"</span>, <span class="string">tax_record =&gt;</span> &#123;<span class="string">"Instant:1440413601.457399"</span> =&gt; <span class="number">99.99</span>, <span class="string">"Instant:1440413601.471551"</span> =&gt; <span class="number">98.9901</span>&#125;&lt;&gt;)</div><div class="line"></div><div class="line">___<span class="number">_</span>/ Status \___________________________________<span class="number">_</span></div><div class="line">[ <span class="number">123</span>-<span class="number">456</span>-<span class="number">789</span> [Bank of Evil] ]</div><div class="line">AAAA00004 (AstroDynamic): balance=<span class="number">19990000</span>  [ASDY]</div><div class="line">AAAA00005 (OmniCorp LLC): balance=<span class="number">990050</span>  [OMNI]</div><div class="line"></div><div class="line">[Finished in <span class="number">0</span>.<span class="number">817</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<ul>
<li>demo_unary_dot</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">use</span> Bank;</div><div class="line"></div><div class="line"><span class="keyword">my</span> Bank $bank .= new(:ID(<span class="string">'123-456-789'</span>));</div><div class="line"></div><div class="line"><span class="keyword">given</span> $bank &#123;</div><div class="line">    .add_account: Account.new(:name(<span class="string">'Leslie Grace'</span>), :balance( <span class="number">1_000</span>));</div><div class="line">    .add_account: Account.new(:name(<span class="string">'Dana McKenna'</span>), :balance(<span class="number">10_000</span>));</div><div class="line">    .add_account: Account.new(:name(<span class="string">'AstroDynamic'</span>), :balance(   <span class="number">2</span>e7));</div><div class="line">    .add_account: Account.new(:name(<span class="string">'Jan van Quod'</span>), :balance( <span class="number">9_999</span>));</div><div class="line">    .add_account: Account.new(:name(<span class="string">'OmniCorp LLC'</span>), :balance(   <span class="number">1</span>e6));</div><div class="line">    .report;</div><div class="line"></div><div class="line">    .get_account(<span class="string">'AAAA00003'</span>).deposit(<span class="number">100</span>);</div><div class="line">    .report;</div><div class="line"></div><div class="line">    <span class="keyword">say</span> .close_account(<span class="string">'AAAA00005'</span>);</div><div class="line">    .report;</div><div class="line"></div><div class="line">    .get_account(<span class="string">'AAAA00001'</span>).withdraw(<span class="number">1001</span>);</div><div class="line">    .report;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[ <span class="number">123</span>-<span class="number">456</span>-<span class="number">789</span> [????] ]</div><div class="line">AAAA00004 (Jan van Quod): balance=<span class="number">9999</span></div><div class="line">AAAA00001 (Leslie Grace): balance=<span class="number">1000</span></div><div class="line">AAAA00005 (OmniCorp LLC): balance=<span class="number">1000000</span></div><div class="line">AAAA00002 (Dana McKenna): balance=<span class="number">10000</span></div><div class="line">AAAA00003 (AstroDynamic): balance=<span class="number">20000000</span></div><div class="line"></div><div class="line">[ <span class="number">123</span>-<span class="number">456</span>-<span class="number">789</span> [????] ]</div><div class="line">AAAA00004 (Jan van Quod): balance=<span class="number">9999</span></div><div class="line">AAAA00001 (Leslie Grace): balance=<span class="number">1000</span></div><div class="line">AAAA00005 (OmniCorp LLC): balance=<span class="number">1000000</span></div><div class="line">AAAA00002 (Dana McKenna): balance=<span class="number">10000</span></div><div class="line">AAAA00003 (AstroDynamic): balance=<span class="number">20000100</span></div><div class="line"></div><div class="line">Account.new(<span class="string">name =&gt;</span> <span class="string">"OmniCorp LLC"</span>, <span class="string">balance =&gt;</span> <span class="number">1000000</span>e<span class="number">0</span>, <span class="string">ID =&gt;</span> <span class="string">"AAAA00005"</span>, <span class="string">tax_record =&gt;</span> &#123;&#125;&lt;&gt;)</div><div class="line">[ <span class="number">123</span>-<span class="number">456</span>-<span class="number">789</span> [????] ]</div><div class="line">AAAA00004 (Jan van Quod): balance=<span class="number">9999</span></div><div class="line">AAAA00001 (Leslie Grace): balance=<span class="number">1000</span></div><div class="line">AAAA00002 (Dana McKenna): balance=<span class="number">10000</span></div><div class="line">AAAA00003 (AstroDynamic): balance=<span class="number">20000100</span></div><div class="line"></div><div class="line">Insufficient funds to withdraw <span class="number">1001</span></div><div class="line">  in method withdraw at /Users/chenyf/.rakudobrew/moar-nom/install/share/perl6/site/lib/Bank.pm:<span class="number">43</span></div><div class="line">  in block &lt;unit&gt; at /Users/chenyf/Downloads/Perl6_Transparadigm_examples/<span class="number">04</span>.bank_demo_unary_dot.pl:<span class="number">22</span></div><div class="line"></div><div class="line">Actually thrown at:</div><div class="line">  in block &lt;unit&gt; at /Users/chenyf/Downloads/Perl6_Transparadigm_examples/<span class="number">04</span>.bank_demo_unary_dot.pl:<span class="number">22</span></div><div class="line"></div><div class="line">[Finished in <span class="number">0</span>.<span class="number">738</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<h2 id="LZW"><a href="#LZW" class="headerlink" title="LZW"></a>LZW</h2><hr>
<p><a href="http://baike.baidu.com/view/401141.htm" target="_blank" rel="external">LZW算法</a></p>
<ul>
<li>demo</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">compress</span>(<span class="title">Str</span> $<span class="title">uncompressed</span> --&gt; <span class="title">List</span>)  </span>&#123;</div><div class="line">    <span class="comment"># Build a look-up table of encoded representations</span></div><div class="line">    <span class="comment"># (each ASCII char represented by its equivalent codepoint)</span></div><div class="line">    <span class="keyword">my</span> %code_for = <span class="keyword">map</span> &#123; $^ASCII.<span class="string">chr =&gt;</span> $^ASCII &#125;, ^<span class="number">256</span>;</div><div class="line"></div><div class="line">    <span class="comment"># Loop and collect each encoding...</span></div><div class="line">    gather &#123;</div><div class="line">        <span class="comment"># Track which characters we've seen but not yet encoded</span></div><div class="line">        <span class="keyword">my</span> $already_seen = <span class="string">""</span>;</div><div class="line"></div><div class="line">        <span class="comment"># Walk through each single character...</span></div><div class="line">        <span class="keyword">for</span> $uncompressed.comb -&gt; $next_char &#123;</div><div class="line">            <span class="comment"># Now we've seen that next character as well</span></div><div class="line">            <span class="keyword">my</span> $now_seen = $already_seen ~ $next_char;</div><div class="line"></div><div class="line">            <span class="comment"># If new char sequence is known, keep looking</span></div><div class="line">            <span class="keyword">if</span> %code_for&#123;$now_seen&#125;:<span class="keyword">exists</span> &#123;</div><div class="line">                $already_seen = $now_seen;</div><div class="line">            &#125;</div><div class="line">            <span class="comment"># Otherwise, we have an unknown sequence of chars</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment"># Emit encoding for what we've previously seen</span></div><div class="line">                take %code_for&#123;$already_seen&#125;;</div><div class="line">                <span class="comment"># Add encoding for new unknown sequence to table</span></div><div class="line">                %code_for&#123;$now_seen&#125; = %code_for.elems;</div><div class="line">                <span class="comment"># Restart the current sequence from this char</span></div><div class="line">                $already_seen = $next_char;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment"># Emit the encoding for the final sequence (if any)</span></div><div class="line">        take %code_for&#123;$already_seen&#125; <span class="keyword">if</span> $already_seen <span class="keyword">ne</span> <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Convert to codepoints...</span></div><div class="line"><span class="keyword">my</span> @codes = compress(<span class="string">'To be or not to be. That be the question, matey!'</span>);</div><div class="line"><span class="keyword">say</span> @codes;</div><div class="line">separator;</div><div class="line"></div><div class="line"><span class="comment"># Emit as characters...</span></div><div class="line"><span class="keyword">say</span> @codes&gt;&gt;.chr;</div><div class="line">separator;</div><div class="line"></div><div class="line"><span class="comment"># Convert to a binary sequence...</span></div><div class="line"><span class="keyword">my</span> $bits_per_code = @codes.max.log(<span class="number">2</span>).ceiling();</div><div class="line"><span class="keyword">my</span> $format = <span class="string">'%0'</span> ~ $bits_per_code ~ <span class="string">'b'</span>;</div><div class="line"><span class="keyword">my</span> $bits = @codes&gt;&gt;.fmt($format).join;</div><div class="line"><span class="keyword">say</span> $bits;</div><div class="line">separator;</div><div class="line"></div><div class="line"><span class="keyword">say</span> $bits.comb(<span class="regexp">/.**1..7/</span>).map(&#123;:<span class="number">2</span>($^bitpattern).chr&#125;).join;</div><div class="line">separator;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">separator</span> </span>&#123; <span class="keyword">say</span> <span class="string">'_'</span> <span class="keyword">x</span> <span class="number">50</span> &#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">84</span> <span class="number">111</span> <span class="number">32</span> <span class="number">98</span> <span class="number">101</span> <span class="number">32</span> <span class="number">111</span> <span class="number">114</span> <span class="number">32</span> <span class="number">110</span> <span class="number">111</span> <span class="number">116</span> <span class="number">32</span> <span class="number">116</span> <span class="number">257</span> <span class="number">259</span> <span class="number">46</span> <span class="number">32</span> <span class="number">84</span> <span class="number">104</span> <span class="number">97</span> <span class="number">267</span> <span class="number">259</span> <span class="number">268</span> <span class="number">104</span> <span class="number">260</span> <span class="number">113</span> <span class="number">117</span> <span class="number">101</span> <span class="number">115</span> <span class="number">116</span> <span class="number">105</span> <span class="number">111</span> <span class="number">110</span> <span class="number">44</span> <span class="number">32</span> <span class="number">109</span> <span class="number">276</span> <span class="number">101</span> <span class="number">121</span> <span class="number">33</span></div><div class="line">_________________________________________________<span class="number">_</span></div><div class="line">T o   b e   o r   n o t   t ā ă .   T h a ċ ă Č h Ą <span class="keyword">q</span> u e <span class="keyword">s</span> t i o n ,   <span class="keyword">m</span> Ĕ e <span class="keyword">y</span> !</div><div class="line">_________________________________________________<span class="number">_</span></div><div class="line"><span class="number">001010100001101111000100000001100010001100101000100000001101111001110010000100000001101110001101111001110100000100000001110100100000001100000011000101110000100000001010100001101000001100001100001011100000011100001100001101000100000100001110001001110101001100101001110011001110100001101001001101111001101110000101100000100000001101101100010100001100101001111001000100001</span></div><div class="line">_________________________________________________<span class="number">_</span></div><div class="line"><span class="keyword">x</span>@1QoB\<span class="number">7</span>NAt@0\</div><div class="line">C aBp<span class="number">4</span> CDu<span class="string">'h4Ms8,l(2O</span></div><div class="line">__________________________________________________</div><div class="line">[Finished in 0.429s]</div></pre></td></tr></table></figure>
<ul>
<li>LZW_functional</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="comment"># To compress a string...</span></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">compress</span>(<span class="title">Str</span> $<span class="title">uncompressed</span>) </span>&#123;</div><div class="line">    <span class="comment"># Encode the character list via a dictionary, from the start</span></div><div class="line">    encode( $uncompressed.comb, <span class="string">code =&gt;</span> hash(<span class="keyword">map</span> &#123;$^ASCII.<span class="string">chr =&gt;</span> $^ASCII&#125;, ^<span class="number">256</span>), <span class="string">seen =&gt;</span> <span class="string">""</span> )</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Encode an empty list where nothing already seen as nothing</span></div><div class="line">multi encode([], :%code, :$seen where <span class="string">""</span>) &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment"># Encode an empty list where something already seen by look-up</span></div><div class="line">multi encode([], :%code, :$seen)          &#123; %code&#123;$seen&#125; &#125;</div><div class="line"></div><div class="line"><span class="comment"># Encode an list of one or more uncompressed characters...</span></div><div class="line">multi encode([$next, *@uncompressed], :%code, :$seen)  &#123;</div><div class="line">    <span class="comment"># If [already-seen plus next char] is a known sequence...</span></div><div class="line">    %code&#123; $seen~$next &#125;:<span class="keyword">exists</span></div><div class="line">         <span class="comment"># Then encode all of that together</span></div><div class="line">        ?? encode(@uncompressed, :%code, <span class="string">seen =&gt;</span> $seen~$next)</div><div class="line"></div><div class="line">         <span class="comment"># Else emit encoding for the already-seen sequence</span></div><div class="line">        !! ( %code&#123;$seen&#125;,</div><div class="line">             <span class="comment"># Plus the encoding for the rest of the string...</span></div><div class="line">             encode( @uncompressed,</div><div class="line">                     <span class="comment"># Add encoding for new sequence to table</span></div><div class="line">                     <span class="string">code =&gt;</span> %( %code, $seen~$next =&gt; %code.elems ),</div><div class="line">                     <span class="comment"># Continue encoding from next character</span></div><div class="line">                     <span class="string">seen =&gt;</span> $next</div><div class="line">             )</div><div class="line">           )</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Convert to codepoints...</span></div><div class="line"><span class="keyword">my</span> @codes = compress(<span class="string">'To be or not to be. That be the question, matey!'</span>);</div><div class="line"><span class="keyword">say</span> @codes;</div><div class="line">separator;</div><div class="line"></div><div class="line"><span class="comment"># Emit as characters...</span></div><div class="line"><span class="keyword">say</span> @codes&gt;&gt;.chr;</div><div class="line">separator;</div><div class="line"></div><div class="line"><span class="comment"># Convert to a binary sequence...</span></div><div class="line"><span class="keyword">my</span> $bits_per_code = @codes.max.log(<span class="number">2</span>).ceiling();</div><div class="line"><span class="keyword">my</span> $format = <span class="string">'%0'</span> ~ $bits_per_code ~ <span class="string">'b'</span>;</div><div class="line"><span class="keyword">my</span> $bits = @codes&gt;&gt;.fmt($format).join;</div><div class="line"><span class="keyword">say</span> $bits;</div><div class="line">separator;</div><div class="line"></div><div class="line"><span class="keyword">say</span> $bits.comb(<span class="regexp">/.**1..7/</span>).map(&#123;:<span class="number">2</span>($^bitpattern).chr&#125;).join;</div><div class="line">separator;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">separator</span> </span>&#123; <span class="keyword">say</span> <span class="string">'_'</span> <span class="keyword">x</span> <span class="number">50</span> &#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">84</span> <span class="number">111</span> <span class="number">32</span> <span class="number">98</span> <span class="number">101</span> <span class="number">32</span> <span class="number">111</span> <span class="number">114</span> <span class="number">32</span> <span class="number">110</span> <span class="number">111</span> <span class="number">116</span> <span class="number">32</span> <span class="number">116</span> <span class="number">257</span> <span class="number">259</span> <span class="number">46</span> <span class="number">32</span> <span class="number">84</span> <span class="number">104</span> <span class="number">97</span> <span class="number">267</span> <span class="number">259</span> <span class="number">268</span> <span class="number">104</span> <span class="number">260</span> <span class="number">113</span> <span class="number">117</span> <span class="number">101</span> <span class="number">115</span> <span class="number">116</span> <span class="number">105</span> <span class="number">111</span> <span class="number">110</span> <span class="number">44</span> <span class="number">32</span> <span class="number">109</span> <span class="number">276</span> <span class="number">101</span> <span class="number">121</span> <span class="number">33</span></div><div class="line">_________________________________________________<span class="number">_</span></div><div class="line">T o   b e   o r   n o t   t ā ă .   T h a ċ ă Č h Ą <span class="keyword">q</span> u e <span class="keyword">s</span> t i o n ,   <span class="keyword">m</span> Ĕ e <span class="keyword">y</span> !</div><div class="line">_________________________________________________<span class="number">_</span></div><div class="line"><span class="number">001010100001101111000100000001100010001100101000100000001101111001110010000100000001101110001101111001110100000100000001110100100000001100000011000101110000100000001010100001101000001100001100001011100000011100001100001101000100000100001110001001110101001100101001110011001110100001101001001101111001101110000101100000100000001101101100010100001100101001111001000100001</span></div><div class="line">_________________________________________________<span class="number">_</span></div><div class="line"><span class="keyword">x</span>@1QoB\<span class="number">7</span>NAt@0\</div><div class="line">C aBp<span class="number">4</span> CDu<span class="string">'h4Ms8,l(2O</span></div><div class="line">__________________________________________________</div><div class="line">[Finished in 0.658s]</div></pre></td></tr></table></figure>
<ul>
<li>validation_concurrent</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> @records = (</div><div class="line">    &#123; :Name&lt;Damian Conway&gt;, :Age(<span class="number">42</span>), :ID(<span class="string">'00012345'</span>)  &#125;,</div><div class="line">    &#123; :Name&lt;Leslie Duvall&gt;, :Age(<span class="number">29</span>), :ID(<span class="string">'668'</span>)       &#125;,</div><div class="line">    &#123; :Name&lt;Sam Georgious&gt;, :Age(-<span class="number">2</span>), :ID(<span class="string">'00000007'</span>)  &#125;,</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">normalize_data</span> (<span class="title">Hash</span> $<span class="title">record</span>) </span>&#123;</div><div class="line">    $record&lt;Name&gt;  .= subst(<span class="regexp">/&lt;lower&gt;/</span>,&#123;$&lt;lower&gt;.uc&#125;, :g);</div><div class="line">    $record&lt;Age&gt; max= <span class="number">18</span>;</div><div class="line">    $record&lt;ID&gt;    .= fmt(<span class="string">'%08d'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">report</span> ($<span class="title">outcome</span>) </span>&#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"\tInvalid record ($outcome)"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">invalid_name</span> ($<span class="title">rec</span>) </span>&#123; <span class="string">"Bad name: $rec"</span> <span class="keyword">if</span> $rec&lt;Name&gt; !~~ <span class="regexp">/\S/</span>;        &#125;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">invalid_age</span>  ($<span class="title">rec</span>) </span>&#123; <span class="string">"Bad age:  $rec"</span> <span class="keyword">if</span> $rec&lt;Age&gt;  &lt; <span class="number">18</span>;            &#125;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">invalid_ID</span>   ($<span class="title">rec</span>) </span>&#123; <span class="string">"Bad ID:   $rec"</span> <span class="keyword">if</span> $rec&lt;ID&gt;   !~~ <span class="regexp">/^\d ** 8$/</span>; &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'Validating...'</span>;</div><div class="line"><span class="keyword">my</span> @invalidations = (</div><div class="line">    @records».&amp;invalid_name,</div><div class="line">    @records».&amp;invalid_age,</div><div class="line">    @records».&amp;invalid_ID,</div><div class="line">);</div><div class="line"></div><div class="line">@invalidations».&amp;report;</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'Normalizing...'</span>;</div><div class="line">@records».&amp;normalize_data;</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'Revalidating...'</span>;</div><div class="line"></div><div class="line">@invalidations = (</div><div class="line">    @records».&amp;invalid_name,</div><div class="line">    @records».&amp;invalid_age,</div><div class="line">    @records».&amp;invalid_ID,</div><div class="line">);</div><div class="line"></div><div class="line">@invalidations».&amp;report;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Validating...</div><div class="line">postcircumfix:&lt;&#123; &#125;&gt; <span class="keyword">not</span> <span class="keyword">defined</span> <span class="keyword">for</span> type Str</div><div class="line">  in <span class="function"><span class="keyword">sub</span> <span class="title">invalid_name</span> <span class="title">at</span> -<span class="title">e</span>:67</span></div><div class="line">  <span class="title">in</span> <span class="title">block</span> &lt;<span class="title">unit</span>&gt; <span class="title">at</span> -<span class="title">e</span>:73</div><div class="line"></div><div class="line"><span class="title">Actually</span> <span class="title">thrown</span> <span class="title">at</span>:</div><div class="line">  <span class="title">in</span> <span class="title">sub</span> <span class="title">invalid_name</span> <span class="title">at</span> -<span class="title">e</span>:67</div><div class="line">  <span class="title">in</span> <span class="title">block</span> &lt;<span class="title">unit</span>&gt; <span class="title">at</span> -<span class="title">e</span>:73</div><div class="line"></div><div class="line">[<span class="title">Finished</span> <span class="title">in</span> 0.374<span class="title">s</span>]</div></pre></td></tr></table></figure>
<ul>
<li>validation_imperative</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> @records = (</div><div class="line">    &#123; :Name&lt;Damian Conway&gt;, :Age(<span class="number">42</span>), :ID(<span class="string">'00012345'</span>)  &#125;,</div><div class="line">    &#123; :Name&lt;Leslie Duvall&gt;, :Age(<span class="number">29</span>), :ID(<span class="string">'668'</span>)       &#125;,</div><div class="line">    &#123; :Name&lt;Sam Georgious&gt;, :Age(-<span class="number">2</span>), :ID(<span class="string">'00000007'</span>)  &#125;,</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">normalize_data</span> (<span class="title">Hash</span> $<span class="title">record</span>) </span>&#123;</div><div class="line">    $record&lt;Name&gt;  .= subst(<span class="regexp">/&lt;lower&gt;/</span>,&#123;$&lt;lower&gt;.uc&#125;, :g);</div><div class="line">    $record&lt;Age&gt; max= <span class="number">18</span>;</div><div class="line">    $record&lt;ID&gt;    .= fmt(<span class="string">'%08d'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">report</span> ($<span class="title">outcome</span>) </span>&#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"\tInvalid record ($outcome)"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">invalid_name</span> ($<span class="title">rec</span>) </span>&#123; <span class="string">"Bad name: $rec"</span> <span class="keyword">if</span> $rec&lt;Name&gt; !~~ <span class="regexp">/\S/</span>;        &#125;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">invalid_age</span>  ($<span class="title">rec</span>) </span>&#123; <span class="string">"Bad age:  $rec"</span> <span class="keyword">if</span> $rec&lt;Age&gt;  &lt; <span class="number">18</span>;            &#125;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">invalid_ID</span>   ($<span class="title">rec</span>) </span>&#123; <span class="string">"Bad ID:   $rec"</span> <span class="keyword">if</span> $rec&lt;ID&gt;   !~~ <span class="regexp">/^\d ** 8$/</span>; &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'Validating...'</span>;</div><div class="line"><span class="keyword">my</span> @invalidations = gather <span class="keyword">for</span> @records -&gt; $record &#123;</div><div class="line">    take invalid_name($record);</div><div class="line">    take invalid_age($record);</div><div class="line">    take invalid_ID($record);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> @invalidations -&gt; $errmsg &#123;</div><div class="line">    report( $errmsg );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'Normalizing...'</span>;</div><div class="line"><span class="keyword">for</span> @records -&gt; $record &#123;</div><div class="line">    normalize_data($record);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'Revalidating...'</span>;</div><div class="line"></div><div class="line">@invalidations = gather <span class="keyword">for</span> @records -&gt; $record &#123;</div><div class="line">    take invalid_name($record);</div><div class="line">    take invalid_age($record);</div><div class="line">    take invalid_ID($record);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> @invalidations -&gt; $errmsg &#123;</div><div class="line">    report( $errmsg );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Validating...</div><div class="line">	Invalid record (Bad ID:   Name	Leslie Duvall Age	<span class="number">29</span> ID	<span class="number">668</span>)</div><div class="line">	Invalid record (Bad age:  Name	Sam Georgious Age	-<span class="number">2</span> ID	<span class="number">00000007</span>)</div><div class="line">Normalizing...</div><div class="line">Revalidating...</div><div class="line">[Finished in <span class="number">0</span>.<span class="number">399</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<ul>
<li>validation_junctions</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> @records = (</div><div class="line">    &#123; :Name&lt;Damian Conway&gt;, :Age(<span class="number">42</span>), :ID(<span class="string">'00012345'</span>)  &#125;,</div><div class="line">    &#123; :Name&lt;Leslie Duvall&gt;, :Age(<span class="number">29</span>), :ID(<span class="string">'668'</span>)       &#125;,</div><div class="line">    &#123; :Name&lt;Sam Georgious&gt;, :Age(-<span class="number">2</span>), :ID(<span class="string">'00000007'</span>)  &#125;,</div><div class="line">);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">normalize_data</span> (<span class="title">Hash</span> $<span class="title">record</span>) </span>&#123;</div><div class="line">    $record&lt;Name&gt;  .= subst(<span class="regexp">/&lt;lower&gt;/</span>,&#123;$&lt;lower&gt;.uc&#125;, :g);</div><div class="line">    $record&lt;Age&gt; max= <span class="number">18</span>;</div><div class="line">    $record&lt;ID&gt;    .= fmt(<span class="string">'%08d'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">report</span> ($<span class="title">outcome</span>) </span>&#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"\tInvalid record ($outcome)"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">invalid_name</span> ($<span class="title">rec</span>) </span>&#123; <span class="string">"Bad name: $rec"</span> <span class="keyword">if</span> $rec&lt;Name&gt; !~~ <span class="regexp">/\S/</span>;        &#125;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">invalid_age</span>  ($<span class="title">rec</span>) </span>&#123; <span class="string">"Bad age:  $rec"</span> <span class="keyword">if</span> $rec&lt;Age&gt;  &lt; <span class="number">18</span>;            &#125;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">invalid_ID</span>   ($<span class="title">rec</span>) </span>&#123; <span class="string">"Bad ID:   $rec"</span> <span class="keyword">if</span> $rec&lt;ID&gt;   !~~ <span class="regexp">/^\d ** 8$/</span>; &#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $invalid_record = &amp;invalid_name | &amp;invalid_age | &amp;invalid_ID;</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'Validating...'</span>;</div><div class="line">report( $invalid_record(all @records) );</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'Normalizing...'</span>;</div><div class="line">normalize_data(all @records);</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'Revalidating...'</span>;</div><div class="line">report( $invalid_record(all @records) );</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Validating...</div><div class="line">	Invalid record (Bad ID:   Name	Leslie Duvall Age	<span class="number">29</span> ID	<span class="number">668</span>)</div><div class="line">	Invalid record (Bad age:  Name	Sam Georgious Age	-<span class="number">2</span> ID	<span class="number">00000007</span>)</div><div class="line">Normalizing...</div><div class="line">Revalidating...</div><div class="line">[Finished in <span class="number">0</span>.<span class="number">399</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<ul>
<li><p>prime_demo</p>
<p>​</p>
</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">is_prime</span>(<span class="title">Int</span> $<span class="title">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> $n % all(<span class="number">2</span>..$n.sqrt+<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">1</span>..<span class="number">1001</span> -&gt; $n &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"$n is prime"</span> <span class="keyword">if</span> is_prime($n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> is prime</div><div class="line"><span class="number">3</span> is prime</div><div class="line"><span class="number">5</span> is prime</div><div class="line"><span class="number">7</span> is prime</div><div class="line"><span class="number">11</span> is prime</div><div class="line"><span class="number">13</span> is prime</div><div class="line"><span class="number">17</span> is prime</div><div class="line"><span class="number">19</span> is prime</div><div class="line"><span class="number">23</span> is prime</div><div class="line"><span class="number">29</span> is prime</div><div class="line"><span class="number">31</span> is prime</div><div class="line"><span class="number">37</span> is prime</div><div class="line"><span class="number">41</span> is prime</div><div class="line"><span class="number">43</span> is prime</div><div class="line"><span class="number">47</span> is prime</div><div class="line"><span class="number">53</span> is prime</div><div class="line"><span class="number">59</span> is prime</div><div class="line"><span class="number">61</span> is prime</div><div class="line"><span class="number">67</span> is prime</div><div class="line"><span class="number">71</span> is prime</div><div class="line"><span class="number">73</span> is prime</div><div class="line"><span class="number">79</span> is prime</div><div class="line"><span class="number">83</span> is prime</div><div class="line"><span class="number">89</span> is prime</div><div class="line"><span class="number">97</span> is prime</div><div class="line"><span class="number">101</span> is prime</div><div class="line"><span class="number">103</span> is prime</div><div class="line"><span class="number">107</span> is prime</div><div class="line"><span class="number">109</span> is prime</div><div class="line"><span class="number">113</span> is prime</div><div class="line"><span class="number">127</span> is prime</div><div class="line"><span class="number">131</span> is prime</div><div class="line"><span class="number">137</span> is prime</div><div class="line"><span class="number">139</span> is prime</div><div class="line"><span class="number">149</span> is prime</div><div class="line"><span class="number">151</span> is prime</div><div class="line"><span class="number">157</span> is prime</div><div class="line"><span class="number">163</span> is prime</div><div class="line"><span class="number">167</span> is prime</div><div class="line"><span class="number">173</span> is prime</div><div class="line"><span class="number">179</span> is prime</div><div class="line"><span class="number">181</span> is prime</div><div class="line"><span class="number">191</span> is prime</div><div class="line"><span class="number">193</span> is prime</div><div class="line"><span class="number">197</span> is prime</div><div class="line"><span class="number">199</span> is prime</div><div class="line"><span class="number">211</span> is prime</div><div class="line"><span class="number">223</span> is prime</div><div class="line"><span class="number">227</span> is prime</div><div class="line"><span class="number">229</span> is prime</div><div class="line"><span class="number">233</span> is prime</div><div class="line"><span class="number">239</span> is prime</div><div class="line"><span class="number">241</span> is prime</div><div class="line"><span class="number">251</span> is prime</div><div class="line"><span class="number">257</span> is prime</div><div class="line"><span class="number">263</span> is prime</div><div class="line"><span class="number">269</span> is prime</div><div class="line"><span class="number">271</span> is prime</div><div class="line"><span class="number">277</span> is prime</div><div class="line"><span class="number">281</span> is prime</div><div class="line"><span class="number">283</span> is prime</div><div class="line"><span class="number">293</span> is prime</div><div class="line"><span class="number">307</span> is prime</div><div class="line"><span class="number">311</span> is prime</div><div class="line"><span class="number">313</span> is prime</div><div class="line"><span class="number">317</span> is prime</div><div class="line"><span class="number">331</span> is prime</div><div class="line"><span class="number">337</span> is prime</div><div class="line"><span class="number">347</span> is prime</div><div class="line"><span class="number">349</span> is prime</div><div class="line"><span class="number">353</span> is prime</div><div class="line"><span class="number">359</span> is prime</div><div class="line"><span class="number">367</span> is prime</div><div class="line"><span class="number">373</span> is prime</div><div class="line"><span class="number">379</span> is prime</div><div class="line"><span class="number">383</span> is prime</div><div class="line"><span class="number">389</span> is prime</div><div class="line"><span class="number">397</span> is prime</div><div class="line"><span class="number">401</span> is prime</div><div class="line"><span class="number">409</span> is prime</div><div class="line"><span class="number">419</span> is prime</div><div class="line"><span class="number">421</span> is prime</div><div class="line"><span class="number">431</span> is prime</div><div class="line"><span class="number">433</span> is prime</div><div class="line"><span class="number">439</span> is prime</div><div class="line"><span class="number">443</span> is prime</div><div class="line"><span class="number">449</span> is prime</div><div class="line"><span class="number">457</span> is prime</div><div class="line"><span class="number">461</span> is prime</div><div class="line"><span class="number">463</span> is prime</div><div class="line"><span class="number">467</span> is prime</div><div class="line"><span class="number">479</span> is prime</div><div class="line"><span class="number">487</span> is prime</div><div class="line"><span class="number">491</span> is prime</div><div class="line"><span class="number">499</span> is prime</div><div class="line"><span class="number">503</span> is prime</div><div class="line"><span class="number">509</span> is prime</div><div class="line"><span class="number">521</span> is prime</div><div class="line"><span class="number">523</span> is prime</div><div class="line"><span class="number">541</span> is prime</div><div class="line"><span class="number">547</span> is prime</div><div class="line"><span class="number">557</span> is prime</div><div class="line"><span class="number">563</span> is prime</div><div class="line"><span class="number">569</span> is prime</div><div class="line"><span class="number">571</span> is prime</div><div class="line"><span class="number">577</span> is prime</div><div class="line"><span class="number">587</span> is prime</div><div class="line"><span class="number">593</span> is prime</div><div class="line"><span class="number">599</span> is prime</div><div class="line"><span class="number">601</span> is prime</div><div class="line"><span class="number">607</span> is prime</div><div class="line"><span class="number">613</span> is prime</div><div class="line"><span class="number">617</span> is prime</div><div class="line"><span class="number">619</span> is prime</div><div class="line"><span class="number">631</span> is prime</div><div class="line"><span class="number">641</span> is prime</div><div class="line"><span class="number">643</span> is prime</div><div class="line"><span class="number">647</span> is prime</div><div class="line"><span class="number">653</span> is prime</div><div class="line"><span class="number">659</span> is prime</div><div class="line"><span class="number">661</span> is prime</div><div class="line"><span class="number">673</span> is prime</div><div class="line"><span class="number">677</span> is prime</div><div class="line"><span class="number">683</span> is prime</div><div class="line"><span class="number">691</span> is prime</div><div class="line"><span class="number">701</span> is prime</div><div class="line"><span class="number">709</span> is prime</div><div class="line"><span class="number">719</span> is prime</div><div class="line"><span class="number">727</span> is prime</div><div class="line"><span class="number">733</span> is prime</div><div class="line"><span class="number">739</span> is prime</div><div class="line"><span class="number">743</span> is prime</div><div class="line"><span class="number">751</span> is prime</div><div class="line"><span class="number">757</span> is prime</div><div class="line"><span class="number">761</span> is prime</div><div class="line"><span class="number">769</span> is prime</div><div class="line"><span class="number">773</span> is prime</div><div class="line"><span class="number">787</span> is prime</div><div class="line"><span class="number">797</span> is prime</div><div class="line"><span class="number">809</span> is prime</div><div class="line"><span class="number">811</span> is prime</div><div class="line"><span class="number">821</span> is prime</div><div class="line"><span class="number">823</span> is prime</div><div class="line"><span class="number">827</span> is prime</div><div class="line"><span class="number">829</span> is prime</div><div class="line"><span class="number">839</span> is prime</div><div class="line"><span class="number">853</span> is prime</div><div class="line"><span class="number">857</span> is prime</div><div class="line"><span class="number">859</span> is prime</div><div class="line"><span class="number">863</span> is prime</div><div class="line"><span class="number">877</span> is prime</div><div class="line"><span class="number">881</span> is prime</div><div class="line"><span class="number">883</span> is prime</div><div class="line"><span class="number">887</span> is prime</div><div class="line"><span class="number">907</span> is prime</div><div class="line"><span class="number">911</span> is prime</div><div class="line"><span class="number">919</span> is prime</div><div class="line"><span class="number">929</span> is prime</div><div class="line"><span class="number">937</span> is prime</div><div class="line"><span class="number">941</span> is prime</div><div class="line"><span class="number">947</span> is prime</div><div class="line"><span class="number">953</span> is prime</div><div class="line"><span class="number">967</span> is prime</div><div class="line"><span class="number">971</span> is prime</div><div class="line"><span class="number">977</span> is prime</div><div class="line"><span class="number">983</span> is prime</div><div class="line"><span class="number">991</span> is prime</div><div class="line"><span class="number">997</span> is prime</div><div class="line">[Finished in <span class="number">1.478</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<ul>
<li>统计</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> @values = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">99</span>);</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'mean (a) = '</span>, mean_a(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'mean (g) = '</span>, mean_g(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'    mode = '</span>,   mode(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'  median = '</span>, median(@values);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mean_a</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    ([+] @list) / @list.elems;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mean_g</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    ([*] @list) ** (<span class="number">1</span>/@list.elems);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mode</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">given</span> @list.Bag &#123;</div><div class="line">        .pairs.<span class="keyword">grep</span>(&#123;$^elem.value == .values.max&#125;)».key;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">median</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">given</span> @list.sort &#123;</div><div class="line">        .elems %% <span class="number">2</span></div><div class="line">            ?? mean_a( .[*<span class="regexp">/2-1, */</span><span class="number">2</span>] )</div><div class="line">            !!         .[*<span class="regexp">/2];</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mean (a) = <span class="number">10.444444</span></div><div class="line">mean (g) = <span class="number">4.95872541158849</span></div><div class="line">    mode = <span class="number">7</span> <span class="number">4</span></div><div class="line">  median = <span class="number">5</span></div><div class="line">[Finished in <span class="number">0</span>.<span class="number">319</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<ul>
<li>stats_hybird</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> @values = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">99</span>);</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'mean (a) = '</span>, mean_a(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'mean (g) = '</span>, mean_g(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'    mode = '</span>,   mode(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'  median = '</span>, median(@values);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mean_a</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">my</span> $sum = [+] @list;</div><div class="line">    <span class="keyword">return</span> $sum / @list.elems;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mean_g</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">my</span> $product = [*] @list;</div><div class="line">    <span class="keyword">return</span> $product ** (<span class="number">1</span>/@list.elems)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mode</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">my</span> $frequencies = @list.Bag;</div><div class="line">    <span class="keyword">my</span> $list_elems  = $frequencies.pairs;</div><div class="line">    <span class="keyword">my</span> $max_freq    = $frequencies.values.max;</div><div class="line">    <span class="keyword">my</span> @max_vals    = $list_elems.<span class="keyword">grep</span>(&#123;.value == $max_freq&#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> @max_vals».key;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">median</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">my</span> @sorted = @list.sort;</div><div class="line">    <span class="keyword">return</span> @sorted.elems %% <span class="number">2</span> ?? mean_a(@sorted.[*<span class="regexp">/2, */</span><span class="number">2</span>-<span class="number">1</span>])</div><div class="line">                              !!        @sorted.[*<span class="regexp">/2]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mean (a) = <span class="number">10.444444</span></div><div class="line">mean (g) = <span class="number">4.95872541158849</span></div><div class="line">    mode = <span class="number">7</span> <span class="number">4</span></div><div class="line">  median = <span class="number">5</span></div><div class="line">[Finished in <span class="number">0</span>.<span class="number">319</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<ul>
<li>stats_imperative</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> @values = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">99</span>);</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'mean (a) = '</span>, mean_a(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'mean (g) = '</span>, mean_g(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'    mode = '</span>,   mode(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'  median = '</span>, median(@values);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mean_a</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">my</span> $sum;</div><div class="line">    <span class="keyword">for</span> @list -&gt; $elem &#123;</div><div class="line">        $sum += $elem;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $sum / @list.elems;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mean_g</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">my</span> $product;</div><div class="line">    <span class="keyword">for</span> @list -&gt; $elem &#123;</div><div class="line">        $product *= $elem;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $product ** (<span class="number">1</span>/@list.elems);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mode</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">my</span> %counts;</div><div class="line">    %counts&#123;$_&#125;++ <span class="keyword">for</span> @list;</div><div class="line">    <span class="keyword">my</span> $max = %counts.values.max;</div><div class="line">    <span class="keyword">return</span> %counts.<span class="keyword">grep</span>(&#123; .value == $max &#125;)».key;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">median</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    @list.=<span class="keyword">sort</span>();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> @list.elems %% <span class="number">2</span></div><div class="line">            ?? mean_a( @list[*<span class="regexp">/2, */</span><span class="number">2</span>-<span class="number">1</span>] )</div><div class="line">            !!         @list[*<span class="regexp">/2];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mean (a) = <span class="number">10.444444</span></div><div class="line">mean (g) = <span class="number">4.95872541158849</span></div><div class="line">    mode = <span class="number">4</span> <span class="number">7</span></div><div class="line">  median = <span class="number">5</span></div><div class="line">[Finished in <span class="number">0</span>.<span class="number">316</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<ul>
<li>stats_mode_func</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> @values = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">99</span>);</div><div class="line"></div><div class="line"><span class="keyword">say</span> <span class="string">'mean (a) = '</span>, mean_a(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'mean (g) = '</span>, mean_g(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'    mode = '</span>,   mode(@values);</div><div class="line"><span class="keyword">say</span> <span class="string">'  median = '</span>, median(@values);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mean_a</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">sum</span> </span>&#123; [+] @list &#125;</div><div class="line">    <span class="keyword">return</span> sum() / @list.elems;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mean_g</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">product</span> </span>&#123; [*] @list &#125;</div><div class="line">    <span class="keyword">return</span> product() ** (<span class="number">1</span>/@list.elems)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">mode</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">frequencies</span> </span>&#123; @list.Bag                             &#125;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">list_elems</span>  </span>&#123; frequencies.pairs                     &#125;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">max_freq</span>    </span>&#123; frequencies.values.max                &#125;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">max_vals</span>    </span>&#123; list_elems.<span class="keyword">grep</span>: &#123;.value == max_freq&#125; &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> max_vals».keys;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">median</span> (*@<span class="title">list</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">sub</span> <span class="title">sorted</span> </span>&#123; @list.sort &#125;</div><div class="line">    <span class="keyword">return</span> sorted.elems %% <span class="number">2</span></div><div class="line">                ?? mean_a(sorted.[*<span class="regexp">/2, */</span><span class="number">2</span>-<span class="number">1</span>])</div><div class="line">                !!        sorted.[*<span class="regexp">/2]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mean (a) = <span class="number">10.444444</span></div><div class="line">mean (g) = <span class="number">4.95872541158849</span></div><div class="line">    mode = <span class="number">7</span> <span class="number">4</span></div><div class="line">  median = <span class="number">5</span></div><div class="line">[Finished in <span class="number">0</span>.<span class="number">357</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<ul>
<li>stats_OO</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env perl6</span></div><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">class StatList is List &#123;</div><div class="line">    method mean_a () &#123;</div><div class="line">        <span class="function"><span class="keyword">sub</span> <span class="title">sum</span> </span>&#123; [+] self &#125;</div><div class="line">        <span class="keyword">return</span> sum() / self.elems;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method mean_g () &#123;</div><div class="line">        <span class="function"><span class="keyword">sub</span> <span class="title">product</span> </span>&#123; [*] self &#125;</div><div class="line">        <span class="keyword">return</span> product() ** (<span class="number">1</span>/self.elems)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method median () &#123;</div><div class="line">        <span class="function"><span class="keyword">sub</span> <span class="title">sorted</span> </span>&#123; self.sort &#125;</div><div class="line">        <span class="keyword">return</span> sorted.elems %% <span class="number">2</span></div><div class="line">                    ?? StatList.new(sorted.[*<span class="regexp">/2, */</span><span class="number">2</span>-<span class="number">1</span>]).mean_a()</div><div class="line">                    !!              sorted.[*<span class="regexp">/2];</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method mode () &#123;</div><div class="line">        sub frequencies &#123; self.Bag                              &#125;</div><div class="line">        sub list_elems  &#123; frequencies.pairs                     &#125;</div><div class="line">        sub max_freq    &#123; frequencies.values.max                &#125;</div><div class="line">        sub max_vals    &#123; list_elems.grep: &#123;.value == max_freq&#125; &#125;</div><div class="line"></div><div class="line">        return  max_vals».keys;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $list = StatList.new(1,3,5,8,8,11);</div><div class="line"></div><div class="line">say $list.mean_a;</div><div class="line">say $list.mean_g;</div><div class="line">say $list.median;</div><div class="line">say $list.mode;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span></div><div class="line"><span class="number">4.68393277169202</span></div><div class="line"><span class="number">13</span></div><div class="line"><span class="number">8</span></div><div class="line">[Finished in <span class="number">0</span>.<span class="number">335</span><span class="keyword">s</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p>以上所有文件都可以在<a href="http://www.bit.do/P6TP" target="_blank" rel="external">这儿</a> 下载到 - a Perl 6 introductory tutorial by Damian Conway</p>
</blockquote>
<p>说明：以上脚本的结果都在 Atom 编辑器下运行得到，然而， 需要在终端中打开 Atom，并安装了 script 插件才行。快捷键 <code>command + i</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[S07-Lists]]></title>
      <url>http://ohmycloud.github.io/2016/02/12/S07-Lists/</url>
      <content type="html"><![CDATA[<p><strong>push</strong> 和 <strong>append</strong> 的表现不同, <strong>push</strong> 一次只添加单个参数到列表末端, <strong>append</strong> 一次可以添加多个参数。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> @d = ( [ <span class="number">1</span> .. <span class="number">3</span> ] );</div><div class="line">@d.push( [ <span class="number">4</span> .. <span class="number">6</span> ] );</div><div class="line">@d.push( [ <span class="number">7</span> .. <span class="number">9</span> ] );</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> @d -&gt; $r &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"$r[]"</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment"># 1</span></div><div class="line"><span class="comment"># 2</span></div><div class="line"><span class="comment"># 3</span></div><div class="line"><span class="comment"># 4 5 6</span></div><div class="line"><span class="comment"># 7 8 9</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> @d -&gt; $r &#123; <span class="keyword">say</span> $r.WHAT() &#125;</div><div class="line"><span class="comment"># (Int)</span></div><div class="line"><span class="comment"># (Int)</span></div><div class="line"><span class="comment"># (Int)</span></div><div class="line"><span class="comment"># (Array) 整个数组作为单个参数</span></div><div class="line"><span class="comment"># (Array)</span></div><div class="line"></div><div class="line"><span class="keyword">say</span> @d.perl;</div><div class="line"><span class="comment"># [1, 2, 3, [4, 5, 6], [7, 8, 9]]</span></div></pre></td></tr></table></figure>
<p>使用 <strong>append</strong> 一次能追加多个元素:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> @d =  ( [ <span class="number">1</span> .. <span class="number">3</span> ] );</div><div class="line">@d.append( [ <span class="number">4</span> .. <span class="number">6</span> ] );</div><div class="line">@d.append( [ <span class="number">7</span> .. <span class="number">9</span> ] );</div><div class="line"></div><div class="line"><span class="keyword">for</span> @d -&gt; $item &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"$item[]"</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment"># 打印 1\n2\n3\n4\n5\n6\n7\n8\n9</span></div><div class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></div></pre></td></tr></table></figure>
<p>这跟<a href="https://design.perl6.org/S07.html#The_single_argument_rule" target="_blank" rel="external">The single argument rule</a>有关。</p>
<h2 id="设计大纲"><a href="#设计大纲" class="headerlink" title="设计大纲"></a>设计大纲</h2><hr>
<p>Perl 6 提供了很多跟列表相关的特性, 包括 <code>eager</code>, <code>lazy</code>, <code>并行计算</code>, 还有紧凑型阵列和多维数组存储。</p>
<h3 id="Sequences-vs-Lists"><a href="#Sequences-vs-Lists" class="headerlink" title="Sequences vs. Lists"></a>Sequences vs. Lists</h3><hr>
<p>在 Perl 6 中, 我们使用项 <code>sequence</code> 来来指某个东西, 当需要的时候产生一个值的序列。即序列是惰性的。注意, 只能要求生成一次。我们使用项<code>list</code>来指能保存值的东西。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment"># 列表, 最简单的 list</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]    <span class="comment"># 数组, Scalar 容器的列表</span></div><div class="line">|(<span class="number">1</span>, <span class="number">2</span>)      <span class="comment"># a Slip, 一个展开到周围列表中的列表</span></div><div class="line">$*IN.lines   <span class="comment"># a Seq, 一个可以被连续处理的序列</span></div><div class="line">(^<span class="number">1000</span>).race <span class="comment"># a HyperSeq, 一个可以并行处理的序列</span></div></pre></td></tr></table></figure>
<h3 id="The-single-argument-rule"><a href="#The-single-argument-rule" class="headerlink" title="The single argument rule"></a><a href="https://design.perl6.org/S07.html#The_single_argument_rule" target="_blank" rel="external">The single argument rule</a></h3><hr>
<p>在 Perl 中 <strong>@</strong> 符号标示着 “这些”(<strong>these</strong>), 而 <strong>$</strong>符号标示着 “这个”(<strong>the</strong>)。这种<strong>复数</strong>/<strong>单数</strong>的明显差别出现在语言中的各种地方, Perl  中的很多便捷就是来源于这个特点。展平(Flattening)就是 @-like 的东西会在特定上下文中自动把它的值并入周围的列表中。之前这在 Perl 中既功能强大又很有迷惑性。在直截了当的发起知名的”单个参数规则”之前, Perl 6 在发展中通过了几次跟 flattening 有关的模仿。</p>
<p>对单个参数规则最好的理解是通过 <strong>for</strong>循环迭代的次数。对于 <strong>for</strong>循环, 要迭代的东西总是被当作单个参数。因此有了单个参数规则这个名字。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>   &#123; &#125;   <span class="comment"># 含有 3 个元素的列表, 3 次迭代</span></div><div class="line"><span class="keyword">for</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &#123; &#125;   <span class="comment"># 含有 3 个元素的列表, 3 次迭代</span></div><div class="line"><span class="keyword">for</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#123; &#125;   <span class="comment"># 含有 3 个元素的数组(存放在 Scalar 中),  3次迭代</span></div><div class="line"><span class="keyword">for</span> @a, @b    &#123; &#125;   <span class="comment"># 含有 2 个元素的列表, 2 次迭代</span></div><div class="line"><span class="keyword">for</span> (@a,)     &#123; &#125;   <span class="comment"># 含有 1 个元素的列表, 1 次迭代</span></div><div class="line"><span class="keyword">for</span> (@a)      &#123; &#125;   <span class="comment"># 含有 @a.elems 个元素的列表, @a.elems 次迭代</span></div><div class="line"><span class="keyword">for</span> @a        &#123; &#125;   <span class="comment"># 含有 @a.elems 个元素的列表, @a.elems 次迭代</span></div></pre></td></tr></table></figure>
<p>前两个是相同的, 因为圆括号事实上不构建列表, 而只是分组。是中缀操作符 <code>infix:&lt;,&gt;</code>组成的列表。第三个也执行了 3 次迭代, 因为在 Perl 6 中 <code>[...]</code> 构建了一个数组但是没有把它包裹进 <code>Scalar</code> 容器中。第四个会执行 2 次迭代, 因为参数是一个含有两个元素的列表, 而那两个元素恰好是数组, 它俩都有 @ 符号, 但是都没有导致展开。第 五 个同样, <code>infix:&lt;,&gt;</code> 很高兴地组成了只含一个元素的列表。</p>
<p>单个参数规则也考虑了 Scalar 容器。因此:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> $(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &#123; &#125;  <span class="comment"># Scalar 容器中的一个列表, 1 次迭代  </span></div><div class="line"><span class="keyword">for</span> $[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#123; &#125;  <span class="comment"># Scalar 容器中的一个数组, 1 次迭代  </span></div><div class="line"><span class="keyword">for</span> $@a        &#123; &#125;  <span class="comment"># Scalar 容器中的一个数组, 1 次迭代</span></div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">for</span> $(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) -&gt; $i &#123; <span class="keyword">say</span> $i.elems &#125;</div><div class="line"><span class="number">3</span></div><div class="line">&gt; <span class="keyword">for</span> $(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) -&gt; $i &#123; <span class="keyword">say</span> $i &#125;</div><div class="line">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</div><div class="line">&gt; <span class="keyword">for</span> $(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) -&gt; $i &#123; <span class="keyword">say</span> $i.WHAT &#125;</div><div class="line">(List)</div><div class="line">&gt; <span class="keyword">for</span> $(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) -&gt; $i &#123; <span class="keyword">say</span> $i.perl &#125;</div><div class="line">$(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"></div><div class="line">&gt; <span class="keyword">for</span> $[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] -&gt; $i &#123; <span class="keyword">say</span> $i &#125;</div><div class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</div><div class="line">&gt; <span class="keyword">for</span> $[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] -&gt; $i &#123; <span class="keyword">say</span> $i.perl &#125;</div><div class="line">$[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&gt; <span class="keyword">for</span> $[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] -&gt; $i &#123; <span class="keyword">say</span> $i.WHAT &#125;</div><div class="line">(Array)</div><div class="line">&gt; <span class="keyword">for</span> $[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] -&gt; $i &#123; <span class="keyword">say</span> $i.elems &#125;</div><div class="line"><span class="number">3</span></div><div class="line"></div><div class="line">&gt; <span class="keyword">my</span>  @a = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></div><div class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</div><div class="line">&gt; <span class="keyword">for</span> $@a -&gt; $a  &#123; <span class="keyword">say</span> $a.perl &#125;</div><div class="line">$[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>贯穿 Perl 6 语言, 单个参数规则(<strong>Single argument rule</strong>) 始终如一地被实现了。例如, 我们看 <strong>push</strong> 方法:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@a.push: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;       <span class="comment"># pushes 3 values to @a</span></div><div class="line">@a.push: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];     <span class="comment"># pushes 1 Array to @a</span></div><div class="line">@a.push: @b;            <span class="comment"># pushes 1 Array to @a</span></div><div class="line">@a.push: @b,;           <span class="comment"># same, trailing comma doesn't make &gt; 1 argument</span></div><div class="line">@a.push: $(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment"># pushes 1 value (a List) to @a</span></div><div class="line">@a.push: $[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];    <span class="comment"># pushes 1 value (an Array) to @a</span></div></pre></td></tr></table></figure>
<p>此外, 列表构造器(例如 <code>infix:&lt;,&gt;</code> 操作符) 和数组构造器(<code>[…]</code>环缀)也遵守这个规则:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]               <span class="comment"># Array of 3 elements</span></div><div class="line">[@a, @b]                <span class="comment"># Array of 2 elements</span></div><div class="line">[@a, <span class="number">1</span>..<span class="number">10</span>]             <span class="comment"># Array of 2 elements</span></div><div class="line">[@a]                    <span class="comment"># Array with the elements of @a copied into it</span></div><div class="line">[<span class="number">1</span>..<span class="number">10</span>]                 <span class="comment"># Array with 10 elements</span></div><div class="line">[$@a]                   <span class="comment"># Array with 1 element (@a)</span></div><div class="line">[@a,]                   <span class="comment"># Array with 1 element (@a)</span></div><div class="line">[[<span class="number">1</span>]]                   <span class="comment"># Same as [1]</span></div><div class="line">[[<span class="number">1</span>],]                  <span class="comment"># Array with a single element that is [1]</span></div><div class="line">[$[<span class="number">1</span>]]                  <span class="comment"># Array with a single element that is [1]</span></div></pre></td></tr></table></figure>
<p>所以, 要让最开始的那个例子工作, 使用:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @d = ( [ <span class="number">1</span> .. <span class="number">3</span> ], );  <span class="comment"># [[1 2 3]]</span></div><div class="line">@d.push: [ <span class="number">4</span> .. <span class="number">6</span> ];</div><div class="line">@d.push: [ <span class="number">7</span> .. <span class="number">9</span> ];</div><div class="line"><span class="comment"># [[1 2 3] [4 5 6] [7 8 9]]</span></div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @d = ( $[ <span class="number">1</span> .. <span class="number">3</span> ]);</div><div class="line">@d.push: [ <span class="number">4</span> ..<span class="number">6</span> ];</div><div class="line">@d.push: [ <span class="number">7</span> ..<span class="number">9</span> ];</div></pre></td></tr></table></figure>
<h2 id="User-level-Types"><a href="#User-level-Types" class="headerlink" title="User-level Types"></a>User-level Types</h2><hr>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><hr>
<p><strong>List</strong> 是不可变的, 可能是无限的, 值的列表。组成 List 最简单的一种方法是使用 <code>infix:&lt;,&gt;</code> 操作符:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div></pre></td></tr></table></figure>
<p><strong>List</strong> 可以被索引, 并且, 假设它是有限的, 也能询问列表中元素的个数:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)[<span class="number">1</span>];    <span class="comment"># 2</span></div><div class="line"><span class="keyword">say</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).elems; <span class="comment"># 3</span></div></pre></td></tr></table></figure>
<p>因为<strong>List</strong>是不可变的, 对它进行 push、pop、shift、unshift 或 splice 是不可能的。 <strong>reverse</strong> 和 <strong>rotate</strong> 操作会返回新的 <strong>Lists</strong>。</p>
<p>虽然<strong>List</strong>自身是不可变的, 但是它包含的元素可以是可变的, 包括 <code>Scalar</code> 容器:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $a = <span class="number">2</span>;</div><div class="line"><span class="keyword">my</span> $b = <span class="number">4</span>;</div><div class="line"></div><div class="line">($a, $b)[<span class="number">0</span>]++;</div><div class="line">($a, $b)[<span class="number">1</span>] *= <span class="number">2</span>;</div><div class="line"><span class="keyword">say</span> $a; <span class="comment"># 3</span></div><div class="line"><span class="keyword">say</span> $b; <span class="comment"># 8</span></div></pre></td></tr></table></figure>
<p>在 <strong>List</strong> 中尝试给不可变值赋值会导致错误:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)[<span class="number">0</span>]++; <span class="comment"># Dies: 不能给不可变值赋值</span></div></pre></td></tr></table></figure>
<h3 id="Slip"><a href="#Slip" class="headerlink" title="Slip"></a>Slip</h3><hr>
<p><strong>Slip</strong> 类型是 <strong>List</strong> 的一个子类。<strong>Slip</strong> 会把它的值并入周围的 <strong>List</strong> 中。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>), <span class="number">4</span>).elems      <span class="comment"># 3</span></div><div class="line">(<span class="number">1</span>, slip(<span class="number">2</span>, <span class="number">3</span>), <span class="number">4</span>).elems  <span class="comment"># 4</span></div></pre></td></tr></table></figure>
<p>把 <strong>List</strong> 强转为 <strong>Slip</strong> 是可能的, 所以上面的也能写为:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>).Slip, <span class="number">4</span>).elems <span class="comment"># 4</span></div></pre></td></tr></table></figure>
<p>在不发生 flattening 的地方使用 <strong>Slip</strong> 是一种常见的获取 flattening 的方式:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @a = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</div><div class="line"><span class="keyword">my</span> @b = <span class="number">4</span>, <span class="number">5</span>;</div><div class="line"></div><div class="line">.say <span class="keyword">for</span> @a.Slip, @b.Slip;  <span class="comment"># 5 次迭代</span></div></pre></td></tr></table></figure>
<p>这有点啰嗦, 使用 <code>prefix:&lt;|&gt;</code>来做 <strong>Slip</strong> 强转:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @a = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</div><div class="line"><span class="keyword">my</span> @b = <span class="number">4</span>, <span class="number">5</span>;</div><div class="line"></div><div class="line">.say <span class="keyword">for</span> |@a, |@b; <span class="comment"># 5 次迭代</span></div></pre></td></tr></table></figure>
<p><code>|</code>在如下形式中也很有用:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @prefixed-<span class="keyword">values</span> = <span class="number">0</span>, |@values;</div></pre></td></tr></table></figure>
<p>这儿, 单个参数规则会使 @prefixed-values 拥有两个元素, 即 0 和 @values。</p>
<p><strong>Slip</strong> 类型也可以用在 <code>map</code>、<code>gather/take</code>、和 <code>lazy</code>循环中。下面是一种 <code>map</code>能把多个值放进它的结果流里面的方法:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @a = <span class="number">1</span>, <span class="number">2</span>;</div><div class="line"><span class="keyword">say</span> @a.map(&#123; $_ xx <span class="number">2</span> &#125;).elems;      <span class="comment"># 2</span></div><div class="line"><span class="keyword">say</span> @a.map(&#123; |($_ xx <span class="number">2</span>) &#125;).elems;   <span class="comment"># 4</span></div></pre></td></tr></table></figure>
<p>因为 <code>$_ xx 2</code> 产生一个含有两个元素的列表(<strong>List</strong>)。</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><hr>
<p><strong>Array</strong> 是 <strong>List</strong> 的一个子类, 把赋值给数组的值放进 Scalar 容器中, 这意味着数组中的值可以被改变。<strong>Array</strong> 是 @-sigil 变量得到的默认类型。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @a = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</div><div class="line"><span class="keyword">say</span> @a.WHAT;     <span class="comment"># (Array)</span></div><div class="line">@a[<span class="number">1</span>]++;         <span class="comment"># Scalar 容器中的值可变</span></div><div class="line"><span class="keyword">say</span> @a;          <span class="comment"># 1 3 3</span></div></pre></td></tr></table></figure>
<p>如果没有 shape 属性, 数组会自动增长:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @a;</div><div class="line">@a[<span class="number">5</span>] = <span class="number">42</span>;</div><div class="line"><span class="keyword">say</span> @a.elems;  <span class="comment"># 6</span></div></pre></td></tr></table></figure>
<p><strong>Array</strong>支持 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code> 和 <code>splice</code>。</p>
<p>给数组赋值默认是迫切的(<strong>eager</strong>), 并创建一组新的 Scalar 容器:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @a = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</div><div class="line"><span class="keyword">my</span> @b = @a;</div><div class="line"></div><div class="line">@a[<span class="number">1</span>]++;</div><div class="line"><span class="keyword">say</span> @b;  <span class="comment"># 1, 2, 3</span></div></pre></td></tr></table></figure>
<p>注意, <code>[...]</code> 数组构造器等价于创建然后再赋值给一个匿名数组。</p>
<h3 id="Seq"><a href="#Seq" class="headerlink" title="Seq"></a>Seq</h3><hr>
<p><strong>Seq</strong> 是单次值生产者。大部分列表处理操作返回 <strong>Seq</strong>。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map(* + <span class="number">1</span>).^name;  <span class="comment"># Seq</span></div><div class="line"><span class="keyword">say</span> (<span class="number">1</span>, <span class="number">2</span> Z <span class="string">'a'</span>, <span class="string">'b'</span>).^name;     <span class="comment"># Seq</span></div><div class="line"><span class="keyword">say</span> (<span class="number">1</span>, <span class="number">1</span>, * + * ... *).^name;   <span class="comment"># Seq</span></div><div class="line"><span class="keyword">say</span> $*IN.lines.^name;            <span class="comment"># Seq</span></div></pre></td></tr></table></figure>
<p>因为 <strong>Seq</strong> 默认不会记住它的值(values), 所以 <strong>Seq</strong> 只能被使用一次。例如, 如果存储了一个 <strong>Seq</strong>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> \seq = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map(* + <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>只有第一次迭代会有效, 之后再尝试迭代就会死, 因为值已经被用完了:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> se<span class="string">q &#123; .say &#125;</span>    <span class="comment"># 2\n3\n4\n</span></div><div class="line"><span class="keyword">for</span> se<span class="string">q &#123; .say &#125;</span>    <span class="comment"># Dies: This Seq has already been iterated</span></div></pre></td></tr></table></figure>
<p>这意味着你可以确信 for 循环迭代了文件的行:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="keyword">open</span>(<span class="string">'data'</span>).lines &#123;</div><div class="line">    .say <span class="keyword">if</span> /beer/;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这不会把文件中的行保持在内存中。此外设立不会把所有行保持在内存中的处理管道也会很容易:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> \lines   = <span class="keyword">open</span>(<span class="string">'products'</span>).lines;</div><div class="line"><span class="keyword">my</span> \beer    = lines.<span class="keyword">grep</span>(<span class="regexp">/beer/</span>);</div><div class="line"><span class="keyword">my</span> \excited = beer.map(&amp;<span class="keyword">uc</span>);</div><div class="line">.say <span class="keyword">for</span> excited;</div></pre></td></tr></table></figure>
<p>然而, 任何重用 <code>lines</code>、<code>beer</code>、或<code>excited</code> 的尝试都会导致错误。这段程序在性能上等价于:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.say <span class="keyword">for</span> <span class="keyword">open</span>(<span class="string">'products'</span>).lines.<span class="keyword">grep</span>(<span class="regexp">/beer/</span>).map(&amp;<span class="keyword">uc</span>);</div></pre></td></tr></table></figure>
<p>但是提供了一个给阶段命名的机会。注意使用 Scalar 变量代替也是可以的, 但是单个参数规则需要最终的循环必须为:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.say <span class="keyword">for</span> |$excited;</div></pre></td></tr></table></figure>
<p>只要序列没有被标记为 <code>lazy</code>, 把 <strong>Seq</strong> 赋值给数组就会迫切的执行操作并把结果存到数组中。因此, 任何人这样写就不惊讶了:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @lines   = <span class="keyword">open</span>(<span class="string">'products'</span>).lines;</div><div class="line"><span class="keyword">my</span> @beer    = @lines.<span class="keyword">grep</span>(<span class="regexp">/beer/</span>);</div><div class="line"><span class="keyword">my</span> @excited = @beer.map(&amp;<span class="keyword">uc</span>);</div><div class="line">.say <span class="keyword">for</span> @excited;</div></pre></td></tr></table></figure>
<p>重用这些数组中的任何一个都没问题。当然, 该程序的内存表现完全不同, 并且它会较慢, 因为它创建了所有的额外的 Scalar 容器(导致额外的垃圾回收)和糟糕的位置引用。(我们不得不在程序的生命周期中多次谈论同一个字符串)。</p>
<p>偶尔, 要求 <strong>Seq</strong> 缓存自身也有用。这可以通过在<strong>Seq</strong> 身上调用 <code>cache</code>方法完成, 这从 <strong>Seq</strong> 得到一个惰性列表并返回它。之后再调用 <code>cache</code>方法会返回同样的惰性列表。注意, 第一次调用 <code>cache</code>方法会被算作消费了<strong>Seq</strong>, 所以如果之前已经发生了迭代它就不再有效, 而且之后任何在调用完 <code>cache</code>的迭代尝试都会失败。只有 <code>.cache</code>方法能被调用多于1 次。</p>
<p><strong>Seq</strong> 不像 <strong>List</strong> 那样遵守 <code>Positional</code> role。 因此, <strong>Seq</strong> 不能被绑定给含有 @ 符号的变量:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @lines := $*IN.lines;  <span class="comment"># Dies</span></div></pre></td></tr></table></figure>
<p>这样做的一个后果就是, 原生地, 你不能传递 Seq 作为绑定给@符号的参数:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">process</span>(@<span class="title">data</span>) </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">process($*IN.lines);</div></pre></td></tr></table></figure>
<p>这会极不方便。因此, 签名 binder(它实际使用 ::= 赋值语义而非 :=)会 spot 失败来绑定 @符号参数, 并检查参数是否遵守了 Positional role。 如果遵守了, 那么它会在参数上调用 cache 方法并绑定它的结果代替。</p>
<h3 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h3><hr>
<p><strong>Seq</strong> 和 <strong>List</strong> 这俩, 还有 Perl 6 中的各种其它类型, 遵守 <strong>Iterable</strong> role。这个 role 的主要意图是获得一个 <code>iterator</code>方法。中级 Perl 6 用户很少会关心 <code>iterator</code>方法和它返回什么。</p>
<p><strong>Iterable</strong> 的第二个目的是为了标记出会被按需展开的东西, 使用 <code>flat</code>方法或用在它们身上的函数。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @a = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</div><div class="line"><span class="keyword">my</span> @b = <span class="number">4</span>, <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> flat @a, @b &#123; &#125;          <span class="comment"># 5 次迭代</span></div><div class="line"><span class="keyword">say</span> [flat @a, @b].elems;     <span class="comment"># 5 次迭代</span></div></pre></td></tr></table></figure>
<p><strong>flat</strong> 的另一用途是展开嵌套的列表结构。例如, <strong>Z</strong>(zip)操作符产生一个列表的列表:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> (<span class="number">1</span>, <span class="number">2</span> Z <span class="string">'a'</span>, <span class="string">'b'</span>).perl;  <span class="comment"># ((1, "a"), (2, "b")).Seq</span></div></pre></td></tr></table></figure>
<p><strong>flat</strong> 能用于展开它们, 这在和使用带有多个参数的尖块 for 循环一块使用时很有用:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> flat <span class="number">1</span>, <span class="number">2</span> Z <span class="string">'a'</span>, <span class="string">'b'</span> -&gt; $num, $letter  &#123; &#125;</div></pre></td></tr></table></figure>
<p>注意 <strong>flat</strong> 也涉及 Scalar 容器, 所以:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> flat $(<span class="number">1</span>, <span class="number">2</span>) &#123; &#125;</div></pre></td></tr></table></figure>
<p>将只会迭代一次。记住数组把所有东西都存放在 Scalar 容器中, 在数组身上调用 <em>flat</em> 总是和迭代数组自身相同。实际上, 在数组上调用 <em>flat</em> 返回的同一性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[适当的使用proto]]></title>
      <url>http://ohmycloud.github.io/2016/02/11/%E9%80%82%E5%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8proto/</url>
      <content type="html"><![CDATA[<p>原文在此<a href="http://blogs.perl.org/users/yary/2016/02/apropos-proto-perl6c-multi-thoughts.html" target="_blank" rel="external">Apropos proto: Perl6.c multi thoughts</a></p>
<p>Multi 程序相当整洁, 但对于我来说是不彻底的。一些背景 — 有人可能这样计算阶乘:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">multi fac(0) &#123; 1 &#125;</div><div class="line">multi fac(Int $n where 1..Inf) &#123; $n * fac( $n-1 ) &#125;</div><div class="line">say fac(4); # 24</div></pre></td></tr></table></figure>
<p>现在假设我们要把我们的递归 multi-sub 作为一个回调传递会怎样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">given &amp;fac -&gt; $some_fun &#123; say &quot;some_fun(4)=&quot;, $some_fun(4) &#125;</div></pre></td></tr></table></figure>
<p>现在… 定义一个匿名的 multi-sub 怎么样？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my $anon_fac = do &#123;</div><div class="line">    multi hidden_fac(0) &#123; 1 &#125;</div><div class="line">    multi hidden_fac(Int $n where 1..Inf) &#123; $n * fac( $n - 1 ) &#125;</div><div class="line">    &amp;hidden_fac &#125;;</div><div class="line">   </div><div class="line">say $anon_fac(4); # 24</div></pre></td></tr></table></figure>
<p>这也会有作用, 但是有点 hack 的味道, 并且我们的 multi-sub 并不是真正的匿名。它仅仅是被隐藏了。真正匿名的对象不会在任何作用域中安装, 而在这个例子中, “hidden_fac” 被安装在 “do” block 中的本地作用域中。</p>
<p>Perl 6说明书没有排除匿名的 multi 程序, 而且事实上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $anon_fac = anon multi sub(0) &#123; 1 &#125;</div></pre></td></tr></table></figure>
<p>会报一个错误:</p>
<blockquote>
<p>Cannot use ‘anon’ with individual multi candidates. Please declare an anon-scoped proto instead</p>
</blockquote>
<p>不能对单独的 multi 候选者使用 <code>anon</code>。请声明一个 anon-scoped 的 <strong>proto</strong> 代替。</p>
<p>让我们回到原先那个以 “multi fac(0) { 1 }” 开始的例子。当编译器看到它, 就会在同一个作用域中为我们创建一个”proto fac” 作为 <em>multi</em> 定义。<em>proto</em> 的作用就像一个分发器(dispatcher) — 从概念上讲, 当我们调用 fac(4) 的时候, 我们让 <em>proto fac</em> 为我们从 <em>multi facs</em> 中挑选一个出来以调用。</p>
<p>我们可以提前显式地定义一个 <em>proto</em>, 而且我们甚至能通过指定它的所有程序都需要 <strong>Int</strong> 类型的参数来对默认的 “proto” 加以改良。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">proto fac_with_proto(Int) &#123; * &#125;</div><div class="line">multi fac_with_proto(0)   &#123; 1 &#125;</div><div class="line">multi fac_with_proto(Int $n where 1..Inf) &#123; $n * fac( $n - 1 ) &#125;</div><div class="line">say fac_with_proto(4); # 24</div></pre></td></tr></table></figure>
<p>因此, <em>anon muiti sub</em> 抛出的错误 — <em>Please declare an anon-scoped proto instead</em> — 正是告诉我们 “没有要安装到的作用域, 我不能为你获取一个 proto。 使用你自己的 <em>anon proto</em>, 并把这个程序附加给它”。</p>
<p>好的, 花蝴蝶, 感谢你的提醒! 我试试…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $fac_proto = anon proto uninstalled-fac(Int) &#123; * &#125;;</div><div class="line">say $fac_proto.name; # uninstalled-fac</div></pre></td></tr></table></figure>
<p>好极了! 现在所有我们要做的就是给那个 <em>proto</em> 添加 <em>multi</em>s。</p>
<p><strong>$fac_proto</strong> 是一个 <strong>Sub</strong> 对象, 它有方法来告诉你候选者, 但是没有办法设置(<strong>set</strong>) 候选者。并且我找不到任何方式在创建时传递一个候选者列表。</p>
<h2 id="适当的修补"><a href="#适当的修补" class="headerlink" title="适当的修补"></a>适当的修补</h2><hr>
<p>什么会让 <em>proto/multi</em> 干净并且正交是一种方式去</p>
<ul>
<li>在编译时指定候选者</li>
<li>在运行时添加候选者</li>
</ul>
<p>这有点像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my $future_fac = Proto( :dispatch( sub (Int) &#123;*&#125; ),</div><div class="line">                        :candidates( [sub (0) &#123;1&#125;] ),</div><div class="line">                        :mutable );</div><div class="line"></div><div class="line">$future_fac.candidates.push(</div><div class="line">    sub (Int $n where 1..Inf) &#123; $n * fac( $n-1 ) &#125;</div><div class="line">  );</div><div class="line"></div><div class="line">$future_fac(4); # 24</div></pre></td></tr></table></figure>
<p>我假定了一个 <strong>Sub</strong> 的子类 <strong>Proto</strong> 以揭露 multi 程序的内部工作原理。这个构造函数会允许定义任何 <em>proto</em> 声明符所做的: 签名 &amp; 默认程序和名字。 还有, 它会允许在初始的候选者列表中传递一个属性。</p>
<p>最后, 那个对象自身会让候选者方法返回一个数组, 而不是一个不可变列表, 如果 <em>Proto</em> 是使用 <em>mutable</em> 属性创建的话。不指定 <em>mutable</em> 将意味着所有的 <em>multi</em>s 需要在编译时添加, 而不允许在运行时添加。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[given-when和模式匹配]]></title>
      <url>http://ohmycloud.github.io/2016/02/06/given-when%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $bool1 = <span class="number">1</span>;</div><div class="line"><span class="keyword">my</span> $bool2 = <span class="number">0</span>;</div><div class="line"><span class="keyword">given</span> ($bool1, $bool2) &#123;</div><div class="line">    <span class="keyword">when</span> (<span class="number">0</span>, <span class="number">0</span>) &#123;<span class="keyword">say</span> <span class="string">"0, 0"</span>&#125;</div><div class="line">    <span class="keyword">when</span> (<span class="number">0</span>, <span class="number">1</span>) &#123;<span class="keyword">say</span> <span class="string">"0, 1"</span>&#125;</div><div class="line">    <span class="keyword">when</span> (<span class="number">1</span>, <span class="number">0</span>) &#123;<span class="keyword">say</span> <span class="string">"1, 0"</span>&#125;</div><div class="line">    <span class="keyword">when</span> (<span class="number">1</span>, <span class="number">1</span>) &#123;<span class="keyword">say</span> <span class="string">"1, 1"</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">given</span> (<span class="string">"15"</span>, <span class="string">"example"</span>, <span class="string">"3.14"</span>) &#123;</div><div class="line">    <span class="keyword">say</span> $_.WHAT; <span class="comment">#  ("15", "example", "3.14") =&gt; List</span></div><div class="line">    <span class="keyword">when</span> ($, $, Str) &#123; <span class="keyword">say</span> <span class="string">"I got a String of $_[2]"</span> &#125;  <span class="comment"># $ 代表一个匿名变量, 表示元组的前两个不参与智能匹配?</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">given</span> (<span class="number">4</span>, <span class="number">5</span>) &#123;</div><div class="line">    <span class="keyword">when</span> ( $,  $) &#123;<span class="keyword">say</span> <span class="string">"Ok"</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">given</span> (<span class="string">"fly.mp3"</span>, <span class="number">34</span>, <span class="string">"It's funny"</span>) &#123;</div><div class="line">    <span class="keyword">when</span> (<span class="regexp">/.mp3$/</span>, <span class="regexp">/4$/</span>, *.chars &gt; <span class="number">4</span>) &#123;<span class="keyword">say</span> <span class="string">"Perfact"</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">given</span> <span class="number">5</span> &#123;</div><div class="line">    <span class="keyword">when</span> <span class="number">1</span>..<span class="number">10</span> &#123;<span class="keyword">say</span> <span class="string">"1..10 contains 5"</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># &gt; (1,2, "SS") ~~ ($, $, Str)</span></div><div class="line"><span class="comment"># True</span></div><div class="line"><span class="comment"># &gt; (1,2) ~~ (Int, $)</span></div><div class="line"><span class="comment"># True</span></div><div class="line"><span class="comment"># &gt; (1,2) ~~ ($, $)</span></div><div class="line"><span class="comment"># True</span></div><div class="line"><span class="comment"># &gt; (1,2) ~~ ($, Str)</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-Grammars]]></title>
      <url>http://ohmycloud.github.io/2016/02/05/Perl-6-Grammars/</url>
      <content type="html"><![CDATA[<p><a href="http://doc.perl6.org/language/grammars" target="_blank" rel="external">doc.perl6.org</a>(<a href="http://doc.perl6.org/language/grammars" target="_blank" rel="external">http://doc.perl6.org/language/grammars</a>)</p>
<p>Grammars - 一组具名 regexes 组成正式的 grammar</p>
<p>Grammars 是一个很强大的工具用于析构文本并通常返回数据结构。</p>
<p>例如, Perl 6 是使用 Perl 6 风格 grammar 解析并执行的。</p>
<p>对普通 Perl 6 使用者更实用的一个例子是 <a href="https://github.com/moritz/json" target="_blank" rel="external">JSON::Tiny</a>模块, 它能反序列化任何合法的 JSON 文件, 而反序列代码只有不到 100 行, 还能扩展。</p>
<p>Grammars 允许你把 regexes 组织到一块儿, 就像类(class) 中组织方法那样。</p>
<h2 id="具名正则-Named-Regexes"><a href="#具名正则-Named-Regexes" class="headerlink" title="具名正则 (Named Regexes)"></a>具名正则 (Named Regexes)</h2><p>　<br>grammars 的主要组成部分是 <a href="http://doc.perl6.org/language/regexes" target="_blank" rel="external">regexes</a>。 而 Perl 6 的 <a href="http://doc.perl6.org/language/regexes" target="_blank" rel="external">regexes</a>语法不在该文档的讨论范围, 具名正则(named regexes) 有它自己的特殊语法, 这跟子例程(subroutine) 的定义很像:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> regex number &#123; \d+ [ \. \d+ ]?   &#125;   <span class="comment"># 普通 regex 中空格被忽略, [] 是非捕获组</span></div></pre></td></tr></table></figure>
<p>上面的代码使用 <code>my</code> 关键字指定了本地作用域的 regex, 因为具名正则(named regexes) 通常用在 grammars 里面。</p>
<p>正则有名字了就方便我们在任何地方重用那个正则了:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> <span class="string">"32.51"</span> ~~ &amp;number;</div><div class="line"><span class="keyword">say</span> <span class="string">"15 + 4.5"</span> ~~ <span class="regexp">/  \s* '+' \s*  /</span></div><div class="line">&amp;number           <span class="comment"># my regex number &#123; \d+ [ \. \d+ ]?   &#125;</span></div></pre></td></tr></table></figure>
<p>为什么用 <code>&amp;number</code>, 对比具名子例程你就知道了:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">sub</span> <span class="title">number</span> </span>&#123; <span class="keyword">say</span> <span class="string">"i am a subroutine"</span> &#125;  <span class="comment"># 具名子例程</span></div><div class="line">&gt; &amp;number                                 <span class="comment"># sub number () &#123; #`(Sub|140651249646256) ... &#125;</span></div></pre></td></tr></table></figure>
<p><code>&amp;number</code> 就是直接引用了具名的 regex 或 子例程。而在<code>/ /</code> 或 grammars 里面, 引用一个具名正则的语法也很特殊, 就是给名字包裹上 <code>&lt; &gt;</code>。<code>&lt;&gt;</code> 就像引号那样, 当用它引起某个具名正则后, 引用这个 `` 就会把该具名正则插入(带入)到整个正则之中, 就像字符串插值那样：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="comment"># 具名正则的声明</span></div><div class="line"><span class="keyword">my</span> regex number &#123; \d+ [ \. \d+]? &#125;  </div><div class="line"><span class="keyword">my</span> token ident  &#123; \w+            &#125;</div><div class="line"><span class="keyword">my</span> rule  alpha  &#123; &lt;[A..Za..z]&gt;   &#125;</div><div class="line"></div><div class="line"><span class="comment"># 1.0 通过 &amp; 来引用</span></div><div class="line"><span class="keyword">say</span> so <span class="string">"12.34"</span> ~~ &amp;number; <span class="comment"># true</span></div><div class="line"></div><div class="line"><span class="comment"># 2.0 在正则构造 // 里使用</span></div><div class="line"><span class="keyword">say</span> so <span class="string">"12.88 + 0.12"</span> ~~ <span class="regexp">/  \s* '+' \s*  /</span>; <span class="comment"># true</span></div><div class="line"><span class="comment"># say so "12.88 + 0.12" ~~ /  \s* '+' \s*  /;</span></div><div class="line"><span class="comment"># wrong, method 'number' not found for invocant of class 'Cursor'</span></div><div class="line"></div><div class="line"><span class="comment"># 3.0 在 grammar 里面使用</span></div><div class="line">grammar EquationParse &#123;</div><div class="line">    <span class="comment"># 这里也不能给 number 起别名, 除非 number 是在 grammar 内部声明的</span></div><div class="line">     token TOP &#123;  \<span class="keyword">s</span>* <span class="string">'+'</span> \<span class="keyword">s</span>*  \<span class="keyword">s</span>* <span class="string">'='</span> \<span class="keyword">s</span>*  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 等式解析</span></div><div class="line"><span class="keyword">my</span> $expr = EquationParse.parse(<span class="string">"12.88 + 0.12 = 13.00"</span>);</div><div class="line"><span class="keyword">say</span> $expr;</div></pre></td></tr></table></figure>
<p>声明具名正则不是只有一个 <code>regex</code> 声明符, 实际上 , regex 声明符用的最少, 大多数时候, 都是使用 <code>token</code> 或 <code>rule</code> 声明符。token 和 rule 这两个都是 <code>ratcheing</code> (棘轮)的, 这意味着如果匹配失败, 那么匹配引擎就不会回并尝试匹配了。这通常会是你想要的, 但不适用于所有情况:</p>
<blockquote>
<p>棘轮用于单向驱动, 防止逆转。</p>
</blockquote>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> regex works-but-slow &#123; .+ <span class="keyword">q</span> &#125; <span class="comment"># 可能会回溯</span></div><div class="line"><span class="keyword">my</span> token fails-but-fast &#123; .+ <span class="keyword">q</span> &#125; <span class="comment"># 不回溯</span></div><div class="line"><span class="keyword">my</span> $s = <span class="string">'Tokens and rules won\'t backtrack, which makes them fail quicker!'</span>;</div><div class="line"><span class="keyword">say</span> so $s ~~ &amp;works-but-slow; <span class="comment"># True</span></div><div class="line"><span class="keyword">say</span> so $s ~~ &amp;fails-but-fast; <span class="comment"># False, .+ 得到了整个字符串但不回溯</span></div></pre></td></tr></table></figure>
<p> <code>token</code> 和 <code>rule</code> 的唯一区别就是 <code>rule</code> 声明符会让正则中的 <code>:sigspace</code> 修饰符起效:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> token non-space-<span class="keyword">y</span> &#123; <span class="string">'once'</span> <span class="string">'upon'</span> <span class="string">'a'</span> <span class="string">'time'</span> &#125;</div><div class="line"><span class="keyword">my</span> rule space-<span class="keyword">y</span> &#123; <span class="string">'once'</span> <span class="string">'upon'</span> <span class="string">'a'</span> <span class="string">'time'</span> &#125;</div><div class="line"><span class="keyword">say</span> <span class="string">'onceuponatime'</span>    ~~ &amp;non-space-<span class="keyword">y</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">'once upon a time'</span> ~~ &amp;space-<span class="keyword">y</span>;</div></pre></td></tr></table></figure>
<h2 id="创建-Grammar"><a href="#创建-Grammar" class="headerlink" title="创建 Grammar"></a>创建 Grammar</h2><p>　<br>当使用 grammar 关键字而非 class 关键字声明来声明一个类时, 会自动得到以 <code>Grammar</code> 的父类。Grammars 应该只用于解析文本; 如果你想提取复杂的数据, 推荐 <a href="http://doc.perl6.org/language/grammars#Action_Objects" target="_blank" rel="external">action object</a>和 grammar 一块使用。</p>
<h2 id="Action-Object"><a href="#Action-Object" class="headerlink" title="Action Object"></a>Action Object</h2><p>　<br>一个成功的 grammar 匹配会给你一棵匹配对象(Match objects)的解析树, 匹配树(match tree)到达的越深, 则 grammar 中的分支越多, 那么在匹配树中航行以获取你真正感兴趣的东西就变的越来越困难。</p>
<p>为了避免你在匹配树(match tree)中迷失, 你可以提供一个 action object。grammar 中每次解析成功一个具名规则(named rule)之后, 它就会尝试调用一个和该 grammar rule 同名的方法, 并传递给这个方法一个<code>Match</code> 对象作为位置参数。如果不存在这样的同名方法, 就跳过。</p>
<p>这儿有一个例子来说明 grammar 和 action：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">grammar TestGrammar &#123;</div><div class="line">    token TOP &#123; ^ \d+ $ &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TestActions &#123;</div><div class="line">    method TOP($/) &#123;</div><div class="line">        $/.make(<span class="number">2</span> + $/);  <span class="comment"># 等价于 $/.make: 2 + $/</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">my</span> $actions = TestActions.new; <span class="comment"># 创建 Action 实例</span></div><div class="line"><span class="keyword">my</span> $match   = TestGrammar.parse(<span class="string">'40'</span>, :$actions);</div><div class="line"><span class="keyword">say</span> $match;       <span class="comment"># ｢40｣</span></div><div class="line"><span class="keyword">say</span> $match.made;  <span class="comment"># 42</span></div></pre></td></tr></table></figure>
<p><code>TestActions</code> 的一个实例变量作为具名参数 <code>actions</code> 被传递给 <code>parse</code> 调用, 然后当 token <code>TOP</code> 匹配成功之后, 就会自动调用方法 <code>TOP</code>, 并传递匹配对象(match object) 作为方法的参数。</p>
<p>为了让参数是匹配对象更清楚, 上面的例子使用 <code>$/</code> 作为 action 方法的参数名, 尽管那仅仅是一个方便的约定, 跟内在无关。 <code>$match</code> 也可以。(尽管使用 <code>$/</code>可以提供把 <code>$</code>作为<code>$/</code>的缩写的优势。)</p>
<p>下面是一个更有说服力的例子:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">grammar KeyValuePairs &#123;</div><div class="line">    token TOP &#123;</div><div class="line">        [ \n+]*</div><div class="line">    &#125;</div><div class="line">    token ws &#123; \h* &#125; <span class="comment"># 重写了关于"空白"的定义</span></div><div class="line">    rule pair &#123;</div><div class="line">         <span class="string">'='</span> </div><div class="line">    &#125;</div><div class="line">    token identifier &#123;</div><div class="line">        \w+</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class KeyValuePairsActions &#123;</div><div class="line">    method identifier($/)  &#123; $/.make: ~$/                          &#125;</div><div class="line">    method pair      ($/)  &#123; $/.make: $.<span class="string">made =&gt;</span> $.made &#125;</div><div class="line">    method TOP       ($/)  &#123; $/.make: $».made                &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $res = KeyValuePairs.parse(<span class="keyword">q</span>:to/EOI/, :actions(KeyValuePairsActions)).made;</div><div class="line">    second=b</div><div class="line">    hits=<span class="number">42</span></div><div class="line">    perl=<span class="number">6</span></div><div class="line">    EOI</div><div class="line"><span class="keyword">for</span> @$res -&gt; $p &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Key: $p.key()\tValue: $p.value()"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这会输出:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Key: second     Value: b</div><div class="line">Key: hits       Value: <span class="number">42</span></div><div class="line">Key: perl       Value: <span class="number">6</span></div></pre></td></tr></table></figure>
<p><code>pair</code> 这个 rule, 解析一对由等号分割的 pair, 并且给 <code>identifier</code> 这个 token 各自起了别名。对应的 action 方法构建了一个 <code>Pair</code> 对象, 并使用子匹配对象(sub match objects)的 <code>.made</code> 属性。这也暴露了一个事实: submatches 的 action 方法在那些调用正则/外部正则之前就被调用。所以 action 方法是按后续调用的。</p>
<p>名为 <code>TOP</code> 的 action 方法仅仅把由 <code>pair</code> 这个 rule 的多重匹配组成的所有对象收集到一块, 然后以一个列表的方式返回。</p>
<p>注意 <code>KeyValuePairsActions</code> 是作为一个类型对象(type object)传递给方法 <code>parse</code>的, 这是因为 action 方法中没有一个使用属性(属性只能通过实例来访问)。</p>
<p>其它情况下, action 方法可能会在属性中保存状态。 那么这当然需要你传递一个实例给 <code>parse</code> 方法。</p>
<p>注意, <code>token ws</code> 有点特殊: 当 <code>:sigspace</code> 开启的时候(就是我们使用 <code>rule</code>的时候), 我们覆写的 <code>ws</code> 会替换某些空白序列。这就是为什么 <code>rule pair</code> 中等号两边的空格解析没有问题并且闭合 <code>}</code> 之前的空白不会狼吞虎咽地吃下换行符, 因为换行符在 <code>TOP</code> token 已经占位置了, 并且 token 不会回溯。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ws 的内置定义</span></div><div class="line">/ &lt;.ws&gt; <span class="regexp">/                # match "whitespace":</span></div><div class="line">                         #   \s+ if it's between two \w characters,</div><div class="line">                         #   \s* otherwise</div><div class="line">          </div><div class="line">&gt; my token ws &#123; \h* &#125; # 重写 ws 这个内置的 token</div><div class="line">&gt; say so "\n" ~~ &amp;ws # True</div></pre></td></tr></table></figure>
<p>所以 <code>&lt;.ws&gt;</code> 内置的定义是：如果空白在两个 <code>\w</code> 单词字符之间, 则意思为 <code>\s+</code>, 否则为 <code>\s*</code>。 我们可以重写 <code>ws</code> 关于空白的定义, 重新定义我们需要的空白。比如把 <code>ws</code> 定义为 <code>{ \h* }</code> 就是所有水平空白符, 甚至可以将<code>ws</code> 定义为非空白字符。例如: <code>token ws { &#39;x&#39; }</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[comb-操作字符串的利器]]></title>
      <url>http://ohmycloud.github.io/2016/02/03/comb-%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>comb - 操作字符串的利器</p>
<h2 id="comb-子例程"><a href="#comb-子例程" class="headerlink" title="comb 子例程"></a>comb 子例程</h2><p>comb 子例程的定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">multi sub    comb(Regex $matcher, Str(Cool) $input, $limit = *) returns List:D</div><div class="line">multi method comb(Regex $matcher,                   $limit = *) returns List:D</div></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">comb /PATTERN/, STRING, LIMIT?  # 子例程形式</div><div class="line">STRING.comb(/PATTERN/, LIMIT?)  # 方法形式</div></pre></td></tr></table></figure>
<p>返回调用者（方法形式）的所有（或者至多 $limit 个，如果提供了的话）匹配，或者返回第二个参数（sub 形式）与 Regex 相匹配的字符串列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;6 or 12&quot;.comb(/\d+/).join(&quot;, &quot;); # 6, 12</div></pre></td></tr></table></figure>
<h2 id="Str-类中的-comb"><a href="#Str-类中的-comb" class="headerlink" title="Str 类中的 comb"></a>Str 类中的 comb</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">multi sub    comb(Str:D   $matcher, Str:D $input, $limit = Inf)</div><div class="line">multi sub    comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match)</div><div class="line">multi sub    comb(Int:D $size, Str:D $input, $limit = Inf)</div><div class="line"></div><div class="line">multi method comb(Str:D $input:)</div><div class="line">multi method comb(Str:D $input: Str:D   $matcher, $limit = Inf)</div><div class="line">multi method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match)</div><div class="line">multi method comb(Str:D $input: Int:D $size, $limit = Inf)</div></pre></td></tr></table></figure>
<p>在 <code>$input</code> 中搜索 <code>$matcher</code> 并返回所有匹配（默认是 Str，或者是 Match 对象，如果 <code>$match</code> 为真的话）的一个列表。<code>$limit</code> 表示至多返回 <code>$limit</code> 个匹配。</p>
<p>如果没有提供 <code>$matcher</code>(匹配器)， 那么会返回字符串中的所有字符的列表。等价于使用了 <code>$matcher = rx/./</code>。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">comb(/\w/, &quot;a;b;c&quot;).perl;        # (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).list</div><div class="line">comb(/\N/, &quot;a;b;c&quot;).perl;        # (&quot;a&quot;, &quot;;&quot;, &quot;b&quot;, &quot;;&quot;, &quot;c&quot;).list</div><div class="line">comb(/\w/, &quot;a;b;c&quot;, 2).perl;     # (&quot;a&quot;, &quot;b&quot;).list</div><div class="line">comb(/\w\;\w/, &quot;a;b;c&quot;, 2).perl; # (&quot;a;b&quot;,).list</div><div class="line"></div><div class="line">&quot;123abc456def&quot;.comb(3)           # (123 abc 456 def)</div><div class="line">&quot;123abc456def&quot;.comb(3,2);        # (123 abc)</div></pre></td></tr></table></figure>
<p>如果匹配器（matcher）是一个整数值，那么它被认为和 <code>/. ** matcher/</code> 类似，但是这个快了 30 倍。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的S操作符]]></title>
      <url>http://ohmycloud.github.io/2016/01/28/Perl6%E4%B8%AD%E7%9A%84S%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="Perl-6-S-操作符"><a href="#Perl-6-S-操作符" class="headerlink" title="Perl 6: S/// 操作符"></a><a href="http://blogs.perl.org/users/zoffix_znet/2016/04/perl-6-the-s-operator.html" target="_blank" rel="external">Perl 6: S/// 操作符</a></h1><p>By <a href="http://blogs.perl.org/users/zoffix_znet/" target="_blank" rel="external">Zoffix Znet</a></p>
<p>来自 Perl 5 背景的我， 第一次使用 Perl 6 的非破坏性替换操作符 <code>S///</code> 的经历就像下面这样:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-3a07abee4665adaf.gif?imageMogr2/auto-orient/strip" alt="img"></p>
<p>进展会更好的。我不但会改善错误信息，而且会解释当前的所有事情。</p>
<h2 id="智能匹配"><a href="#智能匹配" class="headerlink" title="智能匹配"></a>智能匹配</h2><p>我有问题的原因是因为，看到外形相似的操作符，我就简单地把 Perl 5 中的绑定操作符(<code>=~</code>)转换为 Perl 6 中的智能匹配操作符(<code>~~</code>) 还期望它能正常工作。事实上我是异想天开。<code>S///</code> 操作符没有文档，并且结合令人困惑的(那个时候)警告信息，这就是我痛苦的根源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my $orig = &apos;meowmix&apos;;</div><div class="line">my $new  = $orig ~~ S/me/c/;</div><div class="line">say $new;</div><div class="line"></div><div class="line"># OUTPUT warning:</div><div class="line"># Smartmatch with S/// can never succeed</div></pre></td></tr></table></figure>
<p>这个丑陋的警告说这儿的 <code>~~</code> 操作符是个错误的选择并且确实如此。<code>~~</code> 操作符不是 Perl 5 的 <code>=~</code> 操作符的等价物。<code>~~</code> 智能操作符把它左边的东西起了个叫做 <code>$_</code> 的别名，然后 <code>~~</code> 计算它右侧的东西，然后在右侧这个东西身上调用 <code>.ACCEPTS($_)</code> 方法。这就是所有的魔法。</p>
<p>所以上面的例子实际上发生了:</p>
<ul>
<li>我们到达 <code>S///</code> 的时候， <code>$orig</code> 被起了个叫做 <code>$_</code> 的别名。</li>
<li><code>S///</code> 非破坏性地在 <code>$_</code> 身上执行了替换并返回那个结果字符串。这是智能匹配将要操作的东西。</li>
<li>智能匹配，按照 Str 与 Str 相匹配的规则，会根据替换是否发生来给出 True 或 False（令人困惑的是，True 意味着没发生）</li>
</ul>
<p>结果一路下来，我们并没有得到我们想要的：替换过的字符串。</p>
<h2 id="使用-Given"><a href="#使用-Given" class="headerlink" title="使用 Given"></a>使用 Given</h2><p>既然我们知道了 <code>S///</code> 总是作用在 <code>$_</code> 上并且返回替换后的结果，很容易就想到几种方法把 <code>$_</code> 设置为我们原来的字符串并把 <code>S///</code> 的返回值收集回来，我们来看几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">my $orig = &apos;meowmix&apos;;</div><div class="line">my $new  = S/me/c/ given $orig;</div><div class="line">say $orig;</div><div class="line">say $new;</div><div class="line"></div><div class="line">my @orig = &lt;meow cow sow vow&gt;;</div><div class="line">my @new  = do for @orig &#123; S/\w+ &lt;?before &apos;ow&apos;&gt;/w/ &#125;;</div><div class="line">say @orig;</div><div class="line">say @new;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># meowmix</div><div class="line"># cowmix</div><div class="line"># [meow cow sow vow]</div><div class="line"># [wow wow wow wow]</div></pre></td></tr></table></figure>
<p>第一个作用在单个值上。我们使用后置形式的 <em>given</em> 块儿，这让我们避免了花括号（你可以使用 <em>with</em> 代替 <em>given</em> 得到同样的结果）。<code>given $orig</code> 会给 <code>$orig</code> 起个叫做 <code>$_</code> 的别名。从输出来看，原字符串没有被更改。</p>
<p>第二个例子作用在数组中的一堆字符串身上并且我们使用 <em>do</em> 关键字来执行常规的 <em>for</em> 循环(那种情况下，它把循环变量别名给 <code>$_</code> 了)并把结果赋值给 <code>@new</code> 数组。再次，输出显示原来的数组并没有发生改变。</p>
<h2 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h2><p><code>S///</code> 操作符 – 就像 <code>s///</code> 操作符和某些方法一样 – 允许你使用正则表达式副词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">given &apos;Lörem Ipsum Dolor Sit Amet&apos; &#123;</div><div class="line">    say S:g      /m/g/;  # Löreg Ipsug Dolor Sit Aget</div><div class="line">    say S:i      /l/b/;  # börem Ipsum Dolor Sit Amet</div><div class="line">    say S:ii     /l/b/;  # Börem Ipsum Dolor Sit Amet</div><div class="line">    say S:mm     /o/u/;  # Lürem Ipsum Dolor Sit Amet</div><div class="line">    say S:nth(2) /m /g/; # Lörem Ipsug Dolor Sit Amet</div><div class="line">    say S:x(2)   /m /g/; # Löreg Ipsug Dolor Sit Amet</div><div class="line">    say S:ss/Ipsum Dolor/Gipsum\nColor/; # Lörem Gipsum Color Sit Amet</div><div class="line">    say S:g:ii:nth(2) /m/g/;             # Lörem Ipsug Dolor Sit Amet</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">如你所见，它们以 *:foo* 的形式添加在操作符 **S** 这个部件的后面。你可以大大方方地使用空白符号并且几个副词可以同时使用。下面是它们的意义：</div><div class="line"></div><div class="line">- :g —(长形式：`:global`)全局匹配：替换掉所有的出现</div><div class="line">- :i —不区分大小写的匹配</div><div class="line">- :ii —(长形式： `:samecase`) 保留大小写：不管用作替换字母的大小写，使用原来被替换的字母的大小写</div><div class="line">- :mm —(长形式：`:samemark`) 保留重音符号：在上面的例子中，字母 o 上的分音符号被保留并被应用到替换字母 u 上</div><div class="line">- :nth(n) —只替换第 n 次出现的</div><div class="line">- :x(n) —至多替换 n 次（助记符: &apos;x&apos; 作为及时）</div><div class="line">- :ss —(长形式：`samespace`)保留空白类型：空白字符的类型被保留，而不管替换字符串中使用的是什么空白字符。在上面的例子中，我们使用换行作为替换，但是原来的空白被保留了。</div><div class="line"></div><div class="line">## 方法形式</div><div class="line"></div><div class="line">`S///` 操作符很好，但是有时候有点笨拙。不要害怕， Perl 6 提供了 `.subst` 方法能满足你所有的替换需求并且消除你对 `.subst/.substr` 的困惑。下面来看例子：</div><div class="line"></div><div class="line">```perl6</div><div class="line">say &apos;meowmix&apos;.subst: &apos;me&apos;, &apos;c&apos;;</div><div class="line">say &apos;meowmix&apos;.subst: /m./, &apos;c&apos;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># cowmix</div><div class="line"># cowmix</div></pre></td></tr></table></figure>
<p>这个方法要么接收一个正则表达式要么接收一个普通的字符串作为它的第一个位置参数，它是要在调用者里面(“meowmix”)查找的东西。第二个参数是替换字符串。</p>
<p>通过简单地把它们列为具名 Bool 参数，你也可以使用副词。在 <code>S///</code> 形式中， 副词 <code>:ss</code> 和 <code>:ii</code> 分别表明 <code>:s</code>(使空白有意义) 的出现和  <code>:i</code>(不区分大小写的匹配) 的出现。在方法形式中，你必须把这些副词应用到正则表达式自身身上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">given &apos;Lorem Ipsum Dolor Sit Amet&apos; &#123;</div><div class="line">    say .subst: /:i l/, &apos;b&apos;, :ii;</div><div class="line">    say .subst: /:s Ipsum Dolor/, &quot;Gipsum\nColor&quot;, :ss;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Borem Ipsum Dolor Sit Amet</div><div class="line"># Lorem Gipsum Color Sit Amet</div></pre></td></tr></table></figure>
<h2 id="方法形式的捕获"><a href="#方法形式的捕获" class="headerlink" title="方法形式的捕获"></a>方法形式的捕获</h2><p>捕获对于替换操作来说不陌生，所以我们来尝试捕获下方法调用形式的替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">say &apos;meowmix&apos;.subst: /me (.+)/, &quot;c$0&quot;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Use of Nil in string context  in block &lt;unit&gt; at test.p6 line 1</div><div class="line"># c</div></pre></td></tr></table></figure>
<p>不是我们要找的。我们的替换字符串构建在达到 <code>.subst</code> 方法之前，并且里面的 <code>$0</code> 变量实际上指向任何这个方法调用之前的东西，而不是 <code>.subst</code> 正则表达式中的捕获。所以我们怎么来修正它呢？</p>
<p><code>.subst</code> 方法的第二个参数也可以接受一个 <a href="http://docs.perl6.org/type/Callable" target="_blank" rel="external">Callable</a>。在它里面，你可以使用 <code>$0, $1, ... $n</code> 变量，直到你想要的编号，并从捕获中得到正确的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say &apos;meowmix&apos;.subst: /me (.+)/, -&gt; &#123; &quot;c$0&quot; &#125;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># cowmix</div></pre></td></tr></table></figure>
<p>这里，我们为我们的 <strong>Callable</strong> 使用了尖号块儿，但是 <strong>WhateverCode</strong> 和子例程也有效。每次替换都会调用这个 Callable，并且把 <a href="http://docs.perl6.org/type/Match" target="_blank" rel="external">Match</a> 对象作为第一个位置参数传递给 Callable， 如果你需要访问它的话。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>S///</code> 操作符在 Perl 6 中是 <code>s///</code> 操作符的战友，它不是修改原来的字符串，而是拷贝原来的字符串，修改，然后返回修改过的版本。这个操作符的使用方式跟 Perl 5 中的非破坏性替换操作符的使用方式不同。作为备选， 方法版本的 <code>.subst</code> 也能使用。 方法形式和操作符形式的替换都能接收一组副词以修改它们的行为，来满足你的需求。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Roles]]></title>
      <url>http://ohmycloud.github.io/2016/01/21/Roles/</url>
      <content type="html"><![CDATA[<p>Protocol 在 Swift 中是一组方法和属性的集合, 可用于代码复用。 Perl 6 中有与之类似的结构, 叫做 <code>Role</code>, 下面转换一个 Swift 的 Protocol 为 Perl 6 的 Role, 把部门人员的相关信息打印为一个表格:</p>
<h2 id="Protocol-in-Swift"><a href="#Protocol-in-Swift" class="headerlink" title="Protocol in Swift"></a>Protocol in Swift</h2><p>　<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">func padding(amount: Int) -&gt; String &#123;</div><div class="line">    var paddingString = <span class="string">""</span></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> in <span class="number">0</span>..&lt;amount &#123;</div><div class="line">        paddingString += <span class="string">" "</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> paddingString</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 协议</div><div class="line"></div><div class="line">protocol TabularDataSource &#123;</div><div class="line">    var numberOfRows: Int    &#123; get &#125;</div><div class="line">    var numberOfColumns: Int &#123; get &#125;</div><div class="line">    </div><div class="line">    func labelForRow(row: Int) -&gt; String        // 行标签</div><div class="line">    func labelForColumn(column: Int) -&gt; String  // 列标签</div><div class="line">    </div><div class="line">    func itemForRow(row: Int, column: Int) -&gt; Int // 表格中的单元格</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">struct Person &#123;</div><div class="line">    let name: String</div><div class="line">    let age: Int</div><div class="line">    let yearsOfExperience: Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 让 **Department** 遵守 **TabularDataSource**协议</div><div class="line">struct Department: TabularDataSource &#123;</div><div class="line">    let name: String</div><div class="line">    var people = [Person]()</div><div class="line">    </div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    mutating func addPerson(person: Person) &#123;</div><div class="line">        people.append(person)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 实现协议中声明的属性和方法</div><div class="line">    var numberOfRows: Int &#123;</div><div class="line">        <span class="keyword">return</span> people.count</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var numberOfColumns: Int &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func labelForRow(row: Int) -&gt; String &#123;</div><div class="line">        <span class="keyword">return</span> people[row].name</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func labelForColumn(column: Int) -&gt; String &#123;</div><div class="line">        switch column &#123;</div><div class="line">            case <span class="number">0</span>: <span class="keyword">return</span> <span class="string">"Age"</span></div><div class="line">            case <span class="number">1</span>: <span class="keyword">return</span> <span class="string">"Years of Experence"</span></div><div class="line">            default: fatalError(<span class="string">"Invalid column!"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func itemForRow(row: Int, column: Int) -&gt; Int &#123;</div><div class="line">         let person = people[row] // 指定的行</div><div class="line">         switch column &#123;</div><div class="line">             case <span class="number">0</span>: <span class="keyword">return</span> person.age</div><div class="line">             case <span class="number">1</span>: <span class="keyword">return</span> person.yearsOfExperience</div><div class="line">             default:fatalError(<span class="string">"Invalid column!"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var deparment = Department(name: <span class="string">"Engineering"</span>)</div><div class="line">deparment.addPerson(Person(name: <span class="string">"Joe"</span>, age: <span class="number">30</span>, yearsOfExperience: <span class="number">6</span>))</div><div class="line">deparment.addPerson(Person(name: <span class="string">"Karen"</span>, age: <span class="number">40</span>, yearsOfExperience: <span class="number">18</span>))</div><div class="line">deparment.addPerson(Person(name: <span class="string">"Fred"</span>, age: <span class="number">50</span>, yearsOfExperience: <span class="number">20</span>))</div><div class="line"></div><div class="line">// 传入一个数据源</div><div class="line">func printTable(dataSource: TabularDataSource) &#123;</div><div class="line">    let rowLabels = (<span class="number">0</span> ..&lt; dataSource.numberOfRows).map &#123; dataSource.labelForRow($0) &#125;</div><div class="line">    let columnLabels = (<span class="number">0</span> ..&lt; dataSource.numberOfColumns).map &#123; dataSource.labelForColumn($0) &#125;</div><div class="line">    </div><div class="line">    // 创建一个数组存储每个行标签的宽度</div><div class="line">    let rowLabelWidths = rowLabels.map &#123; $0.characters.count &#125;</div><div class="line">    </div><div class="line">    // 限定行标签的最大长度</div><div class="line">    guard let maxRowLabelWidth = rowLabelWidths.maxElement() <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 创建第一行, 包含列标题</div><div class="line">    var firstRow = padding(maxRowLabelWidth) + <span class="string">" |"</span></div><div class="line">    </div><div class="line">    // 跟踪每列的宽度</div><div class="line">    var columnWidths = [Int]()</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> columnLabel in columnLabels &#123;</div><div class="line">        let columnHeader = <span class="string">" \(columnLabel) |"</span></div><div class="line">        firstRow += columnHeader</div><div class="line">        columnWidths.append(columnHeader.characters.count)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">print</span>(firstRow)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i in <span class="number">0</span> ..&lt; dataSource.numberOfRows &#123;</div><div class="line">        let paddingAmount = maxRowLabelWidth - rowLabelWidths[i]</div><div class="line">        var out = rowLabels[i] + padding(paddingAmount) + <span class="string">" |"</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j in <span class="number">0</span> ..&lt; dataSource.numberOfColumns &#123;</div><div class="line">            let item = dataSource.itemForRow(i, column: j)</div><div class="line">            let itemString = <span class="string">" \(item) |"</span></div><div class="line">            let paddingAmount = columnWidths[j] - itemString.characters.count</div><div class="line">            out += padding(paddingAmount) + itemString</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">print</span>(out)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">printTable(deparment)</div></pre></td></tr></table></figure></p>
<p>其中的计算属性在 Perl 6 中可以使用重写属性的方法来完成。</p>
<h3 id="Role-in-Perl-6"><a href="#Role-in-Perl-6" class="headerlink" title="Role in Perl 6"></a>Role in Perl 6</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">padding</span>(<span class="title">Int</span> $<span class="title">amount</span>) </span>&#123;</div><div class="line">    <span class="keyword">my</span> $paddingString = <span class="string">""</span>;</div><div class="line">    $paddingString ~= <span class="string">" "</span> <span class="keyword">for</span>  <span class="number">0</span> ..^ $amount;</div><div class="line">    <span class="keyword">return</span> $paddingString;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 声明一个接口, 只定义了方法和属性, 没有做实现</span></div><div class="line">role TabularDataSource &#123;</div><div class="line">    has $.numberOfRows is rw;</div><div class="line">    has $.numberOfColumns is rw;</div><div class="line"></div><div class="line">    method labelForRow(Int $row)             &#123; ... &#125;</div><div class="line">    method labelForColumn(Int $column)       &#123; ... &#125;</div><div class="line">    method itemForRow(Int $row, Int $column) &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Person &#123;</div><div class="line">    has Str $.name;</div><div class="line">    has Int $.age;</div><div class="line">    has Int $.yearsOfExperience;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Department does TabularDataSource &#123;</div><div class="line">    has $.name;</div><div class="line">    has @.people;</div><div class="line"></div><div class="line">    method new(Str $name) &#123;</div><div class="line">        self.bless(<span class="string">name =&gt;</span> $name);</div><div class="line">    &#125;</div><div class="line">    <span class="comment"># 实现接口中的方法</span></div><div class="line"></div><div class="line">    <span class="comment"># 重写方法 has $.numberOfRows 其实是 has $!numberOfRows 加上 method numberOfRows() &#123; ... &#125; 方法。</span></div><div class="line">    method numberOfRows() &#123;</div><div class="line">        <span class="keyword">return</span> @!people.elems;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method numberOfColumns() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method addPerson(Person $person) is rw &#123;</div><div class="line">        @!people.append($person);</div><div class="line">    &#125;</div><div class="line">    <span class="comment"># 如果类遵守了某个 role 但是未实现其中的方法, 则会报错如下:</span></div><div class="line">    <span class="comment"># Method 'labelForRow' must be implemented by Department because it is required by a role</span></div><div class="line">    method labelForRow(Int $row) &#123;</div><div class="line">        <span class="keyword">return</span> @!people[$row].name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method labelForColumn(Int $column) &#123;</div><div class="line">        <span class="keyword">given</span> $column &#123;</div><div class="line">            <span class="keyword">when</span> <span class="number">0</span>  &#123; <span class="keyword">return</span> <span class="string">"Age"</span> &#125;</div><div class="line">            <span class="keyword">when</span> <span class="number">1</span>  &#123; <span class="keyword">return</span> <span class="string">"Years of Experence"</span> &#125;</div><div class="line">            default &#123; <span class="keyword">die</span>(<span class="string">"Invalid column!"</span>)&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method itemForRow(Int $row, Int $column) &#123;</div><div class="line">        <span class="keyword">my</span> $person = @!people[$row];</div><div class="line">        <span class="keyword">given</span> $column &#123;</div><div class="line">            <span class="keyword">when</span> <span class="number">0</span>  &#123; <span class="keyword">return</span> $person.age               &#125;</div><div class="line">            <span class="keyword">when</span> <span class="number">1</span>  &#123; <span class="keyword">return</span> $person.yearsOfExperience &#125;</div><div class="line">            default &#123; <span class="keyword">die</span>(<span class="string">"Invalid column"</span>)            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $department = Department.new(<span class="string">"Engineering"</span>);</div><div class="line">$department.addPerson(Person.new(<span class="string">name =&gt;</span> <span class="string">"Joe"</span>,   <span class="string">age =&gt;</span> <span class="number">30</span>, <span class="string">yearsOfExperience =&gt;</span> <span class="number">6</span>));</div><div class="line">$department.addPerson(Person.new(<span class="string">name =&gt;</span> <span class="string">"Karen"</span>, <span class="string">age =&gt;</span> <span class="number">40</span>, <span class="string">yearsOfExperience =&gt;</span> <span class="number">18</span>));</div><div class="line">$department.addPerson(Person.new(<span class="string">name =&gt;</span> <span class="string">"Fred"</span>,  <span class="string">age =&gt;</span> <span class="number">50</span>, <span class="string">yearsOfExperience =&gt;</span> <span class="number">20</span>));</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">printTable</span>(<span class="title">TabularDataSource</span> $<span class="title">dataSource</span>) </span>&#123;</div><div class="line">   <span class="keyword">my</span> @rowLabels = (<span class="number">0</span> ..^ $dataSource.numberOfRows ).map: &#123; $dataSource.labelForRow($_)&#125;;</div><div class="line">   <span class="keyword">my</span> @columnLabels = (<span class="number">0</span> ..^ $dataSource.numberOfColumns).map: &#123;$dataSource.labelForColumn($_)&#125;;</div><div class="line"></div><div class="line">   <span class="keyword">my</span> @rowLabelWidths = @rowLabels.map: &#123;$_.chars&#125;;</div><div class="line">   <span class="keyword">my</span> $maxRowLabelWidth = @rowLabelWidths.max // <span class="keyword">return</span>;</div><div class="line"></div><div class="line">   <span class="keyword">my</span> $firstRow = padding($maxRowLabelWidth) ~ <span class="string">" |"</span>;</div><div class="line">   <span class="keyword">my</span> @columnWidths;</div><div class="line"></div><div class="line">   <span class="keyword">for</span> @columnLabels -&gt; $columnLabel &#123;</div><div class="line">       <span class="keyword">my</span> $columnHeader = <span class="string">" $columnLabel |"</span>;</div><div class="line">       $firstRow ~= $columnHeader;</div><div class="line">       @columnWidths.append($columnHeader.chars);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">say</span>($firstRow);</div><div class="line"></div><div class="line">   <span class="keyword">for</span> <span class="number">0</span> ..^ $dataSource.numberOfRows -&gt; $i &#123;</div><div class="line">        <span class="keyword">my</span> $paddingAmount = $maxRowLabelWidth - @rowLabelWidths[$i];</div><div class="line">        <span class="keyword">my</span> $out = @rowLabels[$i] ~ padding($paddingAmount) ~ <span class="string">" |"</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> <span class="number">0</span> ..^ $dataSource.numberOfColumns -&gt; $j &#123;</div><div class="line">            <span class="keyword">my</span> $item = $dataSource.itemForRow($i, $j);</div><div class="line">            <span class="keyword">my</span> $itemString = <span class="string">" $item |"</span>;</div><div class="line">            <span class="keyword">my</span> $paddingAmount = @columnWidths[$j] - $itemString.chars;</div><div class="line">            $out ~= padding($paddingAmount) ~ $itemString;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">say</span>($out);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">printTable($department);</div></pre></td></tr></table></figure>
<p>role 中的 <code>{ ... }</code> 是 yadayada操作符, 起占位作用, 表示方法会在别处实现。类中的方法同样也可以这样声明。</p>
<p>最后输出:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">      | Age | Years of Experence |</div><div class="line">Joe   |  <span class="number">30</span> |                  <span class="number">6</span> |</div><div class="line">Karen |  <span class="number">40</span> |                 <span class="number">18</span> |</div><div class="line">Fred  |  <span class="number">50</span> |                 <span class="number">20</span> |</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Fallout-Hacking-Game]]></title>
      <url>http://ohmycloud.github.io/2016/01/12/Fallout-Hacking-Game/</url>
      <content type="html"><![CDATA[<p>流行游戏辐射3: New Vegas 有一台计算机, 玩家必须正确地从同样长度的单词列表中猜出正确的密码。你的挑战是你自己实现这个游戏。</p>
<p>玩家有只 4 次机会, 每一次不正确的猜测计算机会提示有多少个字母位置是正确的。</p>
<p>例如, 如果密码是 <strong>MIND</strong> , 玩家猜测为 <strong>MEND</strong>, 游戏会提示4个位置中的3个是正确的(M_ND)。如果密码是 COMPUT, 玩家猜测为 PLAYFUL, 游戏会报告 0/7。虽然某些字符是匹配的, 但是位置不匹配。</p>
<p>询问玩家难度设置为几（非常简单, 简单, 中等, 困难, 非常困难）, 然后给玩家展示5到15的同样长度的单词。长度可以是 4到15个字符。</p>
<p>这儿有一个游戏例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Difficulty (1-5)? 3</div><div class="line">SCORPION</div><div class="line">FLOGGING</div><div class="line">CROPPERS</div><div class="line">MIGRAINE</div><div class="line">FOOTNOTE</div><div class="line">REFINERY</div><div class="line">VAULTING</div><div class="line">VICARAGE</div><div class="line">PROTRACT</div><div class="line">DESCENTS</div><div class="line">Guess (4 left)? migraine</div><div class="line">0/8 correct</div><div class="line">Guess (3 left)? protract</div><div class="line">2/8 correct</div><div class="line">Guess (2 left)? croppers</div><div class="line">8/8 correct</div><div class="line">You win!</div></pre></td></tr></table></figure>
<p>你可以从我们的字典文件中获取单词：<a href="http://code.google.com/p/dotnetperls-controls/downloads/detail?name=enable1.txt" target="_blank" rel="external">enable1.txt</a> 。 你的程序应该在做位置检查时完全忽略大小写。</p>
<p>能增加游戏的难度, 或许甚至不能保证有解决方法, 根据你特别挑选的单词。例如, 你的程序能提供某些位置重叠的字符以至于暴露给玩家的信息越少越好。</p>
<h4 id="Perl-6-difficulty-levels-based-on-letter-overlaps"><a href="#Perl-6-difficulty-levels-based-on-letter-overlaps" class="headerlink" title="Perl 6 - difficulty levels based on letter overlaps"></a>Perl 6 - <em>difficulty levels based on letter overlaps</em></h4><hr>
<p>Rather than simply choosing random words of a certain length, it also requires a minimum number of total letter overlaps between them。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">sub get-words ($difficulty) &#123;</div><div class="line">    my %setting =</div><div class="line">        1 =&gt; (4     , 7),</div><div class="line">        2 =&gt; (5..6  , 5),</div><div class="line">        3 =&gt; (7..8  , 3),</div><div class="line">        4 =&gt; (9..11 , 1),</div><div class="line">        5 =&gt; (12..15, 0),</div><div class="line">    ;</div><div class="line">    my ($length, $similarity) = %setting&#123;$difficulty&#125;».pick;</div><div class="line"></div><div class="line">    my @dict = &apos;enable1.txt&apos;.IO.lines.grep(*.chars == $length);</div><div class="line"></div><div class="line">    my @words = @dict.pick($length + 1)</div><div class="line">        until letter-overlaps(@words) &gt;= $similarity;</div><div class="line">    @words;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub letter-overlaps (*@words) &#123;</div><div class="line">    [+] ([Z] @words».fc».comb).map(&#123; .elems - .Set.elems &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>I used a naive brute-force implementation - it simply keeps choosing random sets of words of the correct length, until it finds a set that fulfils the overlap condition.</p>
<p>Here’s an example of a set with 6 total letter overlaps (indicated by asterisks) which was found for difficulty 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GLUGS -&gt; GLUGS</div><div class="line">LOCAL -&gt; LOCAL</div><div class="line">CASKY -&gt; CASKY</div><div class="line">NATTY -&gt; N*TT*</div><div class="line">SAULT -&gt; S*ULT</div><div class="line">SAITH -&gt; **I*H</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">sub get-words ($difficulty) &#123;</div><div class="line">    my %lengths = 1 =&gt; 4..6,   2 =&gt; 7..8,  3 =&gt; 9..11,</div><div class="line">                  4 =&gt; 12..13, 5 =&gt; 14..15;</div><div class="line"></div><div class="line">    my $length = %lengths&#123;$difficulty&#125;.pick;</div><div class="line"></div><div class="line">    &apos;enable1.txt&apos;.IO.lines.grep(*.chars == $length).pick($length + 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub guess ($secret, $i) &#123;</div><div class="line">    my $word = prompt &quot;Guess (&#123;4 - $i&#125; left)? &quot;;</div><div class="line">    ($secret.fc.comb Z $word.fc.comb).flat.grep(* eq *).elems;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub play &#123;</div><div class="line">    my $difficulty = +prompt &apos;Difficulty (1-5)? &apos;;</div><div class="line">    my @words = get-words $difficulty;</div><div class="line"></div><div class="line">    say .uc for @words;</div><div class="line"></div><div class="line">    my $secret = @words.pick;</div><div class="line">    my $l = $secret.chars;</div><div class="line"></div><div class="line">    for ^4 &#123;</div><div class="line">        my $g = guess $secret, $_;</div><div class="line">        if $g == $l &#123; say &apos;You win !&apos;; return &#125;</div><div class="line">        else        &#123; say &quot;$g/$l correct&quot; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    say &quot;You lose, the word was $secret&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">play;</div></pre></td></tr></table></figure>
<p>I should steal somebody’s difficulty level determinations. Only thing of interest may be picking N random things from a stream in a single pass:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">constant $DEBUG = %*ENV&lt;DEBUG&gt; // 1;</div><div class="line"></div><div class="line"># most favorite one pass random picker</div><div class="line">class RandomAccumulator &#123;</div><div class="line">  has $.value;</div><div class="line">  has $!count = 0;</div><div class="line">  method accumulate($input) &#123;</div><div class="line">    $!value = $input if rand &lt; 1 / ++$!count;</div><div class="line">    self;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># get count random words with some filtering</div><div class="line">sub random-words(</div><div class="line">  Int :$count = 1,</div><div class="line">  Int :$length = 5,</div><div class="line">  Regex :$match = rx/^&lt;:Letter&gt;+$/,</div><div class="line">) &#123;</div><div class="line">  my @acc = RandomAccumulator.new xx $count;</div><div class="line">  for &quot;/usr/share/dict/words&quot;.IO.lines.grep($match)\</div><div class="line">    .grep(*.chars == $length) -&gt; $word &#123;</div><div class="line">    .accumulate($word) for @acc;</div><div class="line">  &#125;</div><div class="line">  @acc.map: *.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub count-matching-chars(Str $a, Str $b) &#123;</div><div class="line">  ($a.comb Zeq $b.comb).grep(?*).elems</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub MAIN &#123;</div><div class="line"></div><div class="line">  my $difficulty;</div><div class="line"></div><div class="line">  repeat &#123;</div><div class="line">    $difficulty = prompt(&quot;Difficulty (1-5): &quot;);</div><div class="line">  &#125; until 1 &lt;= $difficulty &lt;= 5;</div><div class="line"></div><div class="line">  # first pass at difficulty levels, tweak as desired</div><div class="line">  # maybe pick count/length as some function of $difficulty</div><div class="line">  my %level =</div><div class="line">    1 =&gt; [ count =&gt; 5, length =&gt; 4 ],</div><div class="line">    2 =&gt; [ count =&gt; 5, length =&gt; 4 ],</div><div class="line">    3 =&gt; [ count =&gt; 5, length =&gt; 4 ],</div><div class="line">    4 =&gt; [ count =&gt; 5, length =&gt; 4 ],</div><div class="line">    5 =&gt; [ count =&gt; 15, length =&gt; 15 ],</div><div class="line">    ;</div><div class="line"></div><div class="line">  my @words = random-words(|%level&#123;$difficulty&#125;.hash).map(*.fc);</div><div class="line">  my $target = @words.pick;</div><div class="line">  say &quot;target: $target&quot; if $DEBUG;</div><div class="line"></div><div class="line">  @words.join(&quot;\n&quot;).say;</div><div class="line"></div><div class="line">  my $won = False;</div><div class="line">  for ^4 &#123;</div><div class="line">    my $guess = prompt(&quot;Guess (&#123;4-$_&#125; left): &quot;).fc;</div><div class="line">    if ($guess eq $target) &#123; $won = True; last &#125;</div><div class="line">    say &quot;You got &amp;count-matching-chars($guess,$target) characters correct.&quot;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if $won &#123;</div><div class="line">    say &quot;You won!&quot;;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    say &quot;You loose!&quot;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Perl6的subsets和multiple辨别年龄]]></title>
      <url>http://ohmycloud.github.io/2016/01/04/%E4%BD%BF%E7%94%A8Perl6%E7%9A%84subsets%E5%92%8Cmultiple%E8%BE%A8%E5%88%AB%E5%B9%B4%E9%BE%84/</url>
      <content type="html"><![CDATA[<p>举个例子, 假设 person 有一个 age 属性. 我能写一个 <code>multimethod</code>, 让它接收一个 person 作为参数, 并返回这样的结果吗:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="string">"child"</span>  <span class="keyword">if</span> age &lt; <span class="number">16</span>;</div><div class="line"><span class="keyword">return</span> <span class="string">"adult"</span>  <span class="keyword">if</span> <span class="number">16</span> &lt;= age &lt; <span class="number">66</span>;</div><div class="line"><span class="keyword">return</span> <span class="string">"senior"</span> <span class="keyword">if</span> age &gt;= <span class="number">66</span>;</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    has Int $.age;</div><div class="line">    has Str $.name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这仅仅定义了一个拥有两个属性, 叫做 Person 的类. age 必须是 Int 型, name 必须是 Str 型. <code>.</code> 语法会生成一个只读访问器, 以使我们能从类的外部访问 getter 方法.</p>
<p>现在我们来定义一个 <code>age-group</code> multi 来告诉一个 person 属于哪个 age-group:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">multi age-group ($person where (*.age &lt; <span class="number">16</span>)  ) &#123; <span class="string">"child"</span> &#125;</div><div class="line">multi age-group ($person where (*.age &gt;= <span class="number">66</span>) ) &#123; <span class="string">"senior"</span>&#125;</div><div class="line">multi age-group ($person)                      &#123; <span class="string">"adult"</span> &#125;</div></pre></td></tr></table></figure>
<p><code>where</code>从句给参数添加了一个<code>约束</code>, 这个约束告诉参数必须匹配这个参数右边的东西.这用于区别将要选取的 multi. <code>where</code>从句可以是一个 regex, 类型, 一个确切的值, 一个断言 block,或者一些其它东西.</p>
<p><code>*.age &lt; 16</code> 部分可能看起来更让人迷惑. 星号是什么? 星号是一个特殊的值, 叫做 Whatever. 它通常在给定情况下满足你的需求. 在智能匹配中, 它总是匹配, 所以你可以在 <code>given/when</code> block 中将它用作默认值. 但是 Whatever 最有用的地方之一是创建匿名 block. 对于大部分操作符, 如果你在 Whatever 上执行它们, 它会产生一个匿名 block 并使用它们的参数执行操作符. 如果一个表达式中有多个 Whatever, 则生成的匿名 block 会有多个参数对应于相应的 Whatever 位置.</p>
<p>例如, <code>* + 1</code> 产生一个 block,使参数的值加1. <code>* + *</code> 产生一个 block 使它的两个参数相加. 这个例子中, 我们调用 Whatever 的 <code>age</code>方法, 并询问它是否小于 16. 我们能用其它几种方式达到同样的效果, 但是更啰嗦:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> ($<span class="title">person</span>) </span>&#123; $person.age &lt; <span class="number">16</span> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-&gt; $person    &#123; $person.age &lt; <span class="number">16</span> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; .age &lt; <span class="number">16</span> &#125;</div></pre></td></tr></table></figure>
<p>但是对于像这种简单的操作, Whatever 通常比其它方式更易读也更简洁. 不幸的是, 在参数列表的 where 从句中, 你需要使用括号括起很多复杂的表达式, 包括 Whatever block.</p>
<p>现在让我们在 Rakudo 的 REPL 中试试它吧:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; age-group Person.new(:name&lt;timmy&gt;, :age(<span class="number">10</span>))</div><div class="line">child</div><div class="line">&gt; age-group Person.new(:name&lt;john&gt;, :age(<span class="number">23</span>))</div><div class="line">adult</div><div class="line">&gt; age-group Person.new(:name&lt;ezekiel&gt;, :age(<span class="number">89</span>))</div><div class="line">senior</div></pre></td></tr></table></figure>
<p>目前为止, 很好. 但是如果我们意外地传递了一个 age 而不是 Person 给 age-group 呢?</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; age-group <span class="number">15</span></div><div class="line">Method <span class="string">'age'</span> <span class="keyword">not</span> found <span class="keyword">for</span> invocant of class <span class="string">'Int'</span></div></pre></td></tr></table></figure>
<p>我们能指定只有 Person 对于 age-group 是合法的:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">multi age-group (Person $person where (*.age &lt; <span class="number">16</span>)) &#123; <span class="string">"child"</span> &#125;</div><div class="line">multi age-group (Person $person where (*.age &gt;= <span class="number">66</span>)) &#123; <span class="string">"senior"</span> &#125;</div><div class="line">multi age-group (Person $person) &#123; <span class="string">"adult"</span> &#125;</div></pre></td></tr></table></figure>
<p>这正确地处理了 Person 问题. 调用带有 age 参数的 age-group 会怎样呢?</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; age-group <span class="number">15</span></div><div class="line">No applicable candidates found to dispatch to <span class="keyword">for</span> <span class="string">'age-group'</span>. Available candidates are:</div><div class="line">:(Person $person where (&#123; ... &#125;))</div><div class="line">:(Person $person where (&#123; ... &#125;))</div><div class="line">:(Person $person)</div></pre></td></tr></table></figure>
<p>看起来更好. 假如我们允许询问 age 所属的 age-group 呢?</p>
<p>我们能重写 age-group 的 Person 变体, 接收 Int 类型的 age, 并写一个单个的 Person 变体来调用 age-group:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">multi age-group(Int $age where (* &lt; <span class="number">16</span>)  ) &#123; <span class="string">"child"</span>  &#125;</div><div class="line">multi age-group(Int $age where (* &gt;= <span class="number">66</span>) ) &#123; <span class="string">"senior"</span> &#125;</div><div class="line">multi age-group(Int $age)                  &#123; <span class="string">"adult"</span>  &#125;</div><div class="line">multi age-group(Person $person) &#123; age-group $person.age &#125;</div></pre></td></tr></table></figure>
<p>这对于每个 Person 例子都有效, 还有它们的 ages.</p>
<p>现在,让我们使用 <code>age-group</code> 定义一个叫做 <code>print-name</code> 的 <code>multi</code> 来分发.<br>根据 <code>age-group</code> 分发最明显的方法是使用 where 从句.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">multi <span class="keyword">print</span>-name(Person $person where (age-group($person) eq <span class="string">"child"</span>)) &#123; <span class="string">"Little &#123;$person.name&#125;"</span> &#125;</div><div class="line">multi <span class="keyword">print</span>-name(Person $person where (age-group($person) eq <span class="string">"adult"</span>)) &#123; $person.name            &#125;</div><div class="line">multi <span class="keyword">print</span>-name(Person $person where (age-group($person) eq <span class="string">"senior"</span>))&#123; <span class="string">"Old Man &#123;$person.name&#125;"</span>&#125;</div></pre></td></tr></table></figure>
<p>双引号字符串中的 <code>{$person.name}</code> 将 block 的结果插值到字符串中.</p>
<p>让我们再试试:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">print</span>-name Person.new(:name&lt;timmy&gt;, :age(<span class="number">10</span>))</div><div class="line">Little Timmy</div><div class="line">&gt; <span class="keyword">print</span>-name Person.new(:name&lt;john&gt;, :age(<span class="number">23</span>))</div><div class="line">John</div><div class="line">&gt; <span class="keyword">print</span>-name Person.new(:name&lt;ezekiel&gt;, :age(<span class="number">89</span>))</div><div class="line">Old Man Ezekiel</div></pre></td></tr></table></figure>
<p>那很棒. 但是如果我们有更多的基于 person 的 <code>age-group</code> 的 multis 要分发呢? 难道我们真的每次都要写出 <code>(Person $person where (age-group($person) eq &quot;child&quot;))</code> 这样的代码吗? 不, 我们不需要, 感谢 subset 类型.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">subset Child  of Person where *.age &lt; <span class="number">16</span>;</div><div class="line">subset Adult  of Person where -&gt; $person &#123; <span class="number">16</span> &lt;= $person.age &lt; <span class="number">66</span> &#125;;</div><div class="line">subset Senior of Person where *.age &gt;= <span class="number">66</span>;</div><div class="line"></div><div class="line">multi <span class="keyword">print</span>-name(Child $person)  &#123; <span class="string">"Little &#123;$person.name&#125;"</span>  &#125;</div><div class="line">multi <span class="keyword">print</span>-name(Adult $person)  &#123; $person.name             &#125;</div><div class="line">multi <span class="keyword">print</span>-name(Senior $person) &#123; <span class="string">"Old Man &#123;$person.name&#125;"</span> &#125;</div></pre></td></tr></table></figure>
<p>由于 Rakudo 在处理含有组合的链式比较操作符的 Whatever 时有一个 bug, 我们不得不为 Adult 写一个显式的 block.</p>
<p>这个 bug 现已修复, 所以: </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subset Adult  of Person where -&gt; $person &#123; <span class="number">16</span> &lt;= $person.age &lt; <span class="number">66</span> &#125;;</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subset Adult  of Person where  <span class="number">16</span> &lt;= *.age &lt; <span class="number">66</span>;</div></pre></td></tr></table></figure>
<p>这个新版本的 <code>print-name</code> 与之前旧版本产生同样的结果. 现在我们能从 <code>Child/Adult/Senior</code> 的角度重写 <code>age-group</code> :</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">multi age-group(Child)  &#123; <span class="string">"child"</span>  &#125;</div><div class="line">multi age-group(Adult)  &#123; <span class="string">"adult"</span>  &#125;</div><div class="line">multi age-group(Senior) &#123; <span class="string">"senior"</span> &#125;</div><div class="line">multi age-group(Int $age) &#123; age-group Person.new(:$age) &#125;</div></pre></td></tr></table></figure>
<p><code>:$age</code> 是 <code>:age($age)</code> 的简写方式.</p>
<p>又一次, 我们有了产生想要的结果的更清晰的代码, 多亏了 multiple 分发和 subset 类型.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从正则表达式到Grammars-Part-2]]></title>
      <url>http://ohmycloud.github.io/2016/01/04/%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0Grammars-Part-2/</url>
      <content type="html"><![CDATA[<p>省略啰嗦的一堆。</p>
<p>使用量词匹配前面的东西至少 min 次, 至多 max 次, <strong>item</strong> <code>**</code>  <strong>min .. max</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my regex Date &#123; \d ** 4 &apos;-&apos; \d ** 2 &apos;-&apos; \d ** 2 &#125;</div></pre></td></tr></table></figure>
<p>还能精确地匹配 N 次。</p>
<p> /literal string here/ 匹配一个字母数字序列。任何不是字母数字(顺便说一下, 这里的字母数字不一定严格地限制为 USe ASCII, 任何带有 ‘Letter’ 或 ‘Number’  Unicode 属性的字符都符合要求)的东西都需要用引号引起来或者以某种形式转义。</p>
<p>如果你想让某个东西是可选的, 使用 <code>?</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;Skyfall&quot; ~~ /Sky &apos;fall&apos;?/;</div></pre></td></tr></table></figure>
<p>这会匹配 ‘Sky’ 或 ‘Skyfall’。</p>
<p>Perl 6 的正则表达式, 就像大多数  RE 引擎一样, 当它们找到了一个匹配后会停止匹配。从左到右, 以 ‘Skyfalling’ 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;Skyfalling&quot; ~~ /Sky &apos;fall&apos;?/ # Try &apos;Sky&apos;, succeed</div><div class="line">&quot;Skyfalling&quot; ~~ /Sky &apos;fall&apos;?/ # Try &apos;fall&apos;, succeed, report success</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-博文收集]]></title>
      <url>http://ohmycloud.github.io/2016/01/02/Perl-6-%E5%8D%9A%E6%96%87%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>本文意在收集 Perl 6 方面的博文, 如有侵权请告知删除。</p>
<p><a href="https://my.oschina.net/u/563463/blog/293900" target="_blank" rel="external">Perl 6 的 Grammar 学习总结</a><br><a href="https://my.oschina.net/u/563463/blog/293590" target="_blank" rel="external">Perl 6 的正则表达式</a><br><a href="https://my.oschina.net/u/563463/blog/371597" target="_blank" rel="external">Perl 6 的正则表达式</a><br><a href="https://my.oschina.net/u/563463/blog/392467" target="_blank" rel="external">Perl  6 的列表</a><br><a href="https://my.oschina.net/u/563463/blog/391975" target="_blank" rel="external">Perl 6 的字符串</a><br><a href="https://www.oschina.net/code/snippet_2531803_53480" target="_blank" rel="external">Perl 6 URB 解析</a><br><a href="https://www.oschina.net/code/snippet_2531803_53641" target="_blank" rel="external">Perl 6 格式化帮助信息</a><br><a href="https://www.oschina.net/code/snippet_2531803_53146" target="_blank" rel="external">Perl 6 解决 24 Game</a><br><a href="https://www.oschina.net/code/snippet_2531803_53623" target="_blank" rel="external">Perl 6 神的90亿名字整数版</a><br><a href="https://www.oschina.net/code/snippet_2531803_52457" target="_blank" rel="external">Perl 6 计算矩阵占比</a><br><a href="https://www.oschina.net/code/snippet_2531803_52932" target="_blank" rel="external">Perl 6 24游戏</a><br><a href="https://www.oschina.net/code/snippet_2531803_53446" target="_blank" rel="external">Perl 6 temporary</a><br><a href="https://www.oschina.net/code/snippet_2531803_52338" target="_blank" rel="external">Perl 6 括号匹配</a><br><a href="https://www.oschina.net/code/snippet_2531803_52655" target="_blank" rel="external">Perl 6 上传文件</a><br><a href="https://segmentfault.com/a/1190000004679283" target="_blank" rel="external">译 Perl 6 Object Orientation</a><br><a href="https://segmentfault.com/a/1190000004864391" target="_blank" rel="external">译 Perl 6] Native Calling Interface</a><br><a href="https://segmentfault.com/a/1190000004957515" target="_blank" rel="external">译 Perl 6 5to6-nutshell</a><br><a href="https://segmentfault.com/n/1330000004436212" target="_blank" rel="external">c++ Perl 6 括号的匹配</a><br><a href="https://segmentfault.com/n/1330000004493136" target="_blank" rel="external">c++ Perl 6] 神的90亿名字整数版</a><br><a href="https://segmentfault.com/n/1330000004541894" target="_blank" rel="external">Perl 6 正则替换</a><br><a href="https://segmentfault.com/n/1330000004616224" target="_blank" rel="external">c++|Perl 6 累加器工厂</a><br><a href="https://segmentfault.com/n/1330000004897576" target="_blank" rel="external">Perl 6 IEEE754</a><br><a href="https://segmentfault.com/n/1330000004929301" target="_blank" rel="external">Perl 6 usbip 自动 bind</a><br><a href="https://segmentfault.com/n/1330000004957503" target="_blank" rel="external">Perl 6 5to6-perlfunc</a><br><a href="https://segmentfault.com/n/1330000004975097" target="_blank" rel="external">Perl 6 GetOption</a><br><a href="https://segmentfault.com/n/1330000005053516" target="_blank" rel="external">Perl 6 Search Binary-Tree node</a><br><a href="https://segmentfault.com/n/1330000005053546" target="_blank" rel="external">Perl 6 Getopt::Kinoko</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-核心骇客--词法的胡言乱语]]></title>
      <url>http://ohmycloud.github.io/2016/01/01/Perl-6-%E6%A0%B8%E5%BF%83%E9%AA%87%E5%AE%A2-%E8%AF%8D%E6%B3%95%E7%9A%84%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/</url>
      <content type="html"><![CDATA[<p><a href="http://perl6.party/post/Perl-6-Core-Hacking-Grammatical-Babble" target="_blank" rel="external">Perl 6 核心骇客: 词法的胡言乱语</a></p>
<p>喜欢修复 Perl 6 编译器中的 bug? 这儿有一个<a href="https://rt.perl.org/Ticket/Display.html?id=128304" target="_blank" rel="external">great grammar bugglet</a>: 当 <code>„”</code> 引号用在引起的用空白分割的单词列表构造器中时看起来好像不能工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">say „hello world”;</div><div class="line">.say for qww&lt;„hello world”&gt;;</div><div class="line">.say for qww&lt;&quot;hello world&quot;&gt;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># hello world</div><div class="line"># „hello</div><div class="line"># world”</div><div class="line"># hello world</div></pre></td></tr></table></figure>
<p><code>”</code> 引号不应该出现在输出中并且在输出中我们应该只有 3 行输出; 这 3 行输出都是 <code>hello world</code>。看起来像是一个待修复的有趣的 bug! 我们进去看看。</p>
<h2 id="你怎样拼写它"><a href="#你怎样拼写它" class="headerlink" title="你怎样拼写它?"></a>你怎样拼写它?</h2><p>事实上这段代码没能正确解析表明这是一个 grammar bug。大部分的 grammar 住在 <a href="https://github.com/rakudo/rakudo/blob/83b8b1a/src/Perl6/Grammar.nqp" target="_blank" rel="external">src/Perl6/Grammar.nqp</a>中, 但是在我们的手变脏之前, 让我们来解决我们应该查看什么。</p>
<p>二进制 <code>perl6</code> 有一个 <code>--target</code> 命令行参数来接收其中之一的编译步骤并且会导致那个步骤的输出被产生出来。那儿有哪些步骤? 根据你正使用的后端它们也会有所不同, 但是你可以仅仅运行 <code>perl6 --stagestats -e &#39;&#39;</code> 把它们都打印出来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">zoffix@leliana:~$ perl6 --stagestats -e &apos;&apos;</div><div class="line">Stage start      :   0.000</div><div class="line">Stage parse      :   0.077</div><div class="line">Stage syntaxcheck:   0.000</div><div class="line">Stage ast        :   0.000</div><div class="line">Stage optimize   :   0.001</div><div class="line">Stage mast       :   0.004</div><div class="line">Stage mbc        :   0.000</div><div class="line">Stage moar       :   0.000</div></pre></td></tr></table></figure>
<p>Grammars 是关于解析的, 所以我们会查询 <code>parse</code> 目标(target)。至于要执行的代码, 我们会仅仅给它有问题的那块; 即 <code>qww&lt;&gt;</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">zoffix@leliana:~$ perl6 --target=parse -e &apos;qww&lt;„hello world”&gt;&apos;</div><div class="line">- statementlist: qww&lt;„hello world”&gt;</div><div class="line">  - statement: 1 matches</div><div class="line">    - EXPR: qww&lt;„hello world”&gt;</div><div class="line">      - value: qww&lt;„hello world”&gt;</div><div class="line">        - quote: qww&lt;„hello world”&gt;</div><div class="line">          - quibble: &lt;„hello world”&gt;</div><div class="line">            - babble:</div><div class="line">              - B:</div><div class="line">            - nibble: „hello world”</div><div class="line">          - quote_mod: ww</div><div class="line">            - sym: ww</div></pre></td></tr></table></figure>
<p>那很棒! 每一行前面都有能在 grammar 中找到的 token 的名字, 所以现在我们知道了在哪里查找问题。</p>
<p>我们还知道基本的引号能正确地工作, 所以我们也倾倒出它们的解析步骤, 来看看这两个输出之间是否有什么不同:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">zoffix@leliana:~$ perl6 --target=parse -e &apos;qww&lt;&quot;hello world&quot;&gt;&apos;</div><div class="line">- statementlist: qww&lt;&quot;hello world&quot;&gt;</div><div class="line">  - statement: 1 matches</div><div class="line">    - EXPR: qww&lt;&quot;hello world&quot;&gt;</div><div class="line">      - value: qww&lt;&quot;hello world&quot;&gt;</div><div class="line">        - quote: qww&lt;&quot;hello world&quot;&gt;</div><div class="line">          - quibble: &lt;&quot;hello world&quot;&gt;</div><div class="line">            - babble:</div><div class="line">              - B:</div><div class="line">            - nibble: &quot;hello world&quot;</div><div class="line">          - quote_mod: ww</div><div class="line">            - sym: ww</div></pre></td></tr></table></figure>
<p>那么… 好吧, 除了引号不同, 解析数完全一样。所以它看起来好像所有涉及的 tokens 都是相同的, 但是那些 tokens 所做的事情不同。</p>
<p>我们不必检查输出中我们看到的每个 tokens。<code>statementlist</code> 和 <code>statement</code> 是匹配普通语句的 tokens, <code>EXPR</code> 是占位符解析器, <code>value</code> 是它正操作的值中的一个。我们会忽略上面那些, 留给我们的是下面这样一个可疑的列表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">- quote: qww&lt;„hello world”&gt;</div><div class="line">  - quibble: &lt;„hello world”&gt;</div><div class="line">    - babble:</div><div class="line">      - B:</div><div class="line">    - nibble: „hello world”</div><div class="line">  - quote_mod: ww</div><div class="line">    - sym: ww</div><div class="line">```  </div><div class="line"></div><div class="line">让我们开始质问它们。</div><div class="line"></div><div class="line">## 到兔子洞里去...</div><div class="line"></div><div class="line">你自己搞一份本地的 [Rakudo 仓库](https://github.com/rakudo/rakudo/), 如果你已经有了一份,那么打开 [src/Perl6/Grammar.nqp](https://github.com/rakudo/rakudo/blob/83b8b1a/src/Perl6/Grammar.nqp), 然后放松点。</div><div class="line"></div><div class="line">我们会从树的顶部到底部跟随我们的 tokens, 所以我们首先需要找到的是 `token quote`, `rule quote`, `regex quote` 或 `method quote`; 以那个顺序搜索, 因为第一项很可能就是正确的东西。</div><div class="line"></div><div class="line">这种情况下, 它是一个 [token quote](https://github.com/rakudo/rakudo/blob/83b8b1a/src/Perl6/Grammar.nqp#L3555), 它是一个 [proto regex](https://docs.perl6.org/language/grammars#Protoregexes)。我们的代码使用了它的 `q` 版本并且你还可以认出靠近它的 `qq` 和 `Q` 版本:</div><div class="line"></div><div class="line">```perl6</div><div class="line">token quote:sym&lt;q&gt; &#123;</div><div class="line">    :my $qm;</div><div class="line">    &apos;q&apos;</div><div class="line">    [</div><div class="line">    | &lt;quote_mod&gt; &#123;&#125; &lt;.qok($/)&gt; &#123; $qm := $&lt;quote_mod&gt;.Str &#125;</div><div class="line">        &lt;quibble(%*LANG&lt;Quote&gt;, &apos;q&apos;, $qm)&gt;</div><div class="line">    | &#123;&#125; &lt;.qok($/)&gt; &lt;quibble(%*LANG&lt;Quote&gt;, &apos;q&apos;)&gt;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">token quote:sym&lt;qq&gt; &#123;</div><div class="line">    :my $qm;</div><div class="line">    &apos;qq&apos;</div><div class="line">    [</div><div class="line">    | &lt;quote_mod&gt; &#123; $qm := $&lt;quote_mod&gt;.Str &#125; &lt;.qok($/)&gt;</div><div class="line">        &lt;quibble(%*LANG&lt;Quote&gt;, &apos;qq&apos;, $qm)&gt;</div><div class="line">    | &#123;&#125; &lt;.qok($/)&gt; &lt;quibble(%*LANG&lt;Quote&gt;, &apos;qq&apos;)&gt;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">token quote:sym&lt;Q&gt; &#123;</div><div class="line">    :my $qm;</div><div class="line">    &apos;Q&apos;</div><div class="line">    [</div><div class="line">    | &lt;quote_mod&gt; &#123; $qm := $&lt;quote_mod&gt;.Str &#125; &lt;.qok($/)&gt;</div><div class="line">        &lt;quibble(%*LANG&lt;Quote&gt;, $qm)&gt;</div><div class="line">    | &#123;&#125; &lt;.qok($/)&gt; &lt;quibble(%*LANG&lt;Quote&gt;)&gt;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 <code>qq</code> 和 <code>Q</code> 的主体看起来像 <code>q</code>, 我们也来看看它们是否有我们要找的那个 bug:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">zoffix@leliana:~$ perl6 -e &apos;.say for qqww&lt;„hello world”&gt;&apos;</div><div class="line">„hello</div><div class="line">world”</div><div class="line">zoffix@leliana:~$ perl6 -e &apos;.say for Qww&lt;„hello world”&gt;&apos;</div><div class="line">„hello</div><div class="line">world</div></pre></td></tr></table></figure>
<p>是的, 它们也存在, 所以 <code>token quote</code> 不可能是那个问题。我们来分解下  <code>token quote:sym&lt;q&gt;</code> 是做什么的, 来算出怎么进行到下一步; 它的备选之一没有被用在我们当前的代码中, 所以我会省略它:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">token quote:sym&lt;q&gt; &#123;</div><div class="line">    :my $qm;</div><div class="line">    &apos;q&apos;</div><div class="line">    [</div><div class="line">    | &lt;quote_mod&gt; &#123;&#125; &lt;.qok($/)&gt; &#123; $qm := $&lt;quote_mod&gt;.Str &#125;</div><div class="line">        &lt;quibble(%*LANG&lt;Quote&gt;, &apos;q&apos;, $qm)&gt;</div><div class="line">    | # (this branch omited)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在第二行中, 我们创建了一个变量, 然后匹配字面值 <code>q</code> 然后是 <code>quote_mod</code> token。那个是我们的 <code>--target=parse</code> 输出中的一部分并且如果你像我们找出 <code>quote</code> token 那样找出它, 你会注意到它是一个 proto regex, 即, 在那种情况下, 匹配我们代码的 <code>ww</code> 块。后面跟着的空 <code>{}</code> 块我们可以忽略(那是一个 bug 的替代方法可能在你读到这儿时已经被修复了)。目前为止, 我们已经匹配了我们代码的 <code>qww</code> 块。</p>
<p>再往前走, 我们遇见了对 <code>qok</code> token 的调用, 当前的 <a href="https://docs.perl6.org/type/Match" target="_blank" rel="external">Match</a> 对象作为其参数。<code>&lt;.qok&gt;</code> 中的点号表明这是一个非捕获 token 匹配, 这就是它为什么它没有在我们的 <code>--target=parse</code> 输出中出现的原因。我们定位到那个 token 并看看它是关于什么的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">token qok($x) &#123;</div><div class="line">    » &lt;![(]&gt;</div><div class="line">    [</div><div class="line">        &lt;?[:]&gt; || &lt;!&#123;</div><div class="line">            my $n := ~$x; $*W.is_name([$n]) || $*W.is_name([&apos;&amp;&apos; ~ $n])</div><div class="line">        &#125;&gt;</div><div class="line">    ]</div><div class="line">    [ \s* &apos;#&apos; &lt;.panic: &quot;# not allowed as delimiter&quot;&gt; ]?</div><div class="line">    &lt;.ws&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我的天呐! 这么多符号, 但是这个家伙很容易了: <code>»</code> 是一个<a href="https://docs.perl6.org/language/regexes#%3C%3C_and_%3E%3E_,_left_and_right_word_boundary" target="_blank" rel="external">右单词边界</a>后面不能跟着一个开圆括号(<code>&lt;![(]&gt;</code>), 再跟着一个备选分支(<code>[]</code>), 再跟着一个检查, 即我们不想尝试使用 <code>#</code> 号作为分割符(<code>[...]?</code>), 最后跟着一个 <a href="https://docs.perl6.org/language/grammars#ws" target="_blank" rel="external">&lt;.ws&gt;</a> token 吞噬各种各样的空白。</p>
<p>在备选分支中, 我们使用了首个token匹配的 <code>||</code> 备选分支(和最长token匹配 <code>|</code> 相反), 并且首个 token 向前查看一个冒号 <code>&lt;?[:]&gt;</code>。 如果失败了, 我们就字符串化那个给定的参数(<code>~$x</code>)并且之后在 <a href="https://github.com/rakudo/rakudo/blob/83b8b1a/src/Perl6/World.nqp" target="_blank" rel="external">World对象</a> 身上调用 <code>is_name</code> 方法, 原样地传递带有前置 <code>&amp;</code> 符号的字符串化的参数。传递的 <code>~$x</code> 是目前为止我们的 <code>token quote:sym&lt;q&gt;</code> token 所匹配到的东西(并且那是字符串 <code>qww</code>)。<code>is_name</code> 方法仅仅检查那个给定的符号是否被定义还有根据那个返回值检查我们的 token 匹配会通过还是会失败。如果那个求值代码返回一个真值那么我们正在使用的  <code>&lt;!{ ... }&gt;</code> 结构就会失败。</p>
<p>总而言之, 这个 token 所做的所有事情就是检查我们没有使用 <code>#</code> 作为分隔符并且没有尝试去调用一个方法或sub。房间的这个角落没有 bug 迹象。 让我们回到我们的 <code>token quote:sym&lt;q&gt;</code> 来查看下一步做什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">token quote:sym&lt;q&gt; &#123;</div><div class="line">    :my $qm;</div><div class="line">    &apos;q&apos;</div><div class="line">    [</div><div class="line">    | &lt;quote_mod&gt; &#123;&#125; &lt;.qok($/)&gt; &#123; $qm := $&lt;quote_mod&gt;.Str &#125;</div><div class="line">        &lt;quibble(%*LANG&lt;Quote&gt;, &apos;q&apos;, $qm)&gt;</div><div class="line">    | # (this branch omited)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们已经完成了 <code>&lt;.qok&gt;</code> 的检查, 所以下一步是 <code>{ $qm := $&lt;quote_mod&gt;.Str }</code>, 那仅仅把匹配到 <code>quote_mod</code> token 的字符串值存到 <code>$qm</code> 变量中。在我们的例子中, 那个值就是字符串 <code>ww</code>。</p>
<p>下面跟着的是另外一个 token, 它在我们的 <code>--target=parse</code> s输出中出现过:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;quibble(%*LANG&lt;Quote&gt;, &apos;q&apos;, $qm)&gt;</div></pre></td></tr></table></figure>
<p>这里, 我们使用三个位置参数引用了那个 token: <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Perl6/Grammar.nqp#L424" target="_blank" rel="external">Quote language braid</a>, 字符串 <code>q</code> 和 我们保存在变量 <code>$qm</code> 中的字符串 <code>ww</code>。我想知道它是做什么的。那是我们的下一站。全力以赴!</p>
<h2 id="Nibble-Quibble-Babbling-Nibbler"><a href="#Nibble-Quibble-Babbling-Nibbler" class="headerlink" title="Nibble Quibble Babbling Nibbler"></a>Nibble Quibble Babbling Nibbler</h2><p>这里是完整的 <code>token quibble</code> 并且你马上可以发现我们不得不从开始往更深处挖掘, 因为第 5 行是另外一个 token 匹配:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">token quibble($l, *@base_tweaks) &#123;</div><div class="line">    :my $lang;</div><div class="line">    :my $start;</div><div class="line">    :my $stop;</div><div class="line">    &lt;babble($l, @base_tweaks)&gt;</div><div class="line">    &#123;</div><div class="line">        my $B  := $&lt;babble&gt;&lt;B&gt;.ast;</div><div class="line">        $lang  := $B[0];</div><div class="line">        $start := $B[1];</div><div class="line">        $stop  := $B[2];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $start &lt;nibble($lang)&gt;</div><div class="line">    [</div><div class="line">        $stop</div><div class="line">        || &#123;</div><div class="line">            $/.CURSOR.typed_panic(</div><div class="line">                &apos;X::Comp::AdHoc&apos;,</div><div class="line">                payload =&gt; &quot;Couldn&apos;t find terminator $stop (corresponding $start was at line &#123;</div><div class="line">                    HLL::Compiler.lineof(</div><div class="line">                        $&lt;babble&gt;&lt;B&gt;.orig(), $&lt;babble&gt;&lt;B&gt;.from()</div><div class="line">                    )</div><div class="line">                &#125;)&quot;,</div><div class="line">                expected =&gt; [$stop],</div><div class="line">            )</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        nqp::can($lang, &apos;herelang&apos;)</div><div class="line">        &amp;&amp; self.queue_heredoc(</div><div class="line">            $*W.nibble_to_str(</div><div class="line">                $/,</div><div class="line">                $&lt;nibble&gt;.ast[1], -&gt; &#123;</div><div class="line">                    &quot;Stopper &apos;&quot; ~ $&lt;nibble&gt; ~ &quot;&apos; too complex for heredoc&quot;</div><div class="line">                &#125;</div><div class="line">            ),</div><div class="line">            $lang.herelang,</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们定义了 3 个变量然后引用了 <code>babble</code> token, 这个 babble 引用了和 <code>quibble</code> token 所引用的同样的参数。我们来以和查找所有之前的 tokens 同样的方式查找它并窥探它的内核。为了简洁, 我移除了大约一半<a href="https://github.com/rakudo/rakudo/blob/bc35922/src/Perl6/Grammar.nqp#L111-L125" target="_blank" rel="external">代码</a>:那部分是处理副词的, 目前我们不能在我们的代码中使用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">token babble($l, @base_tweaks?) &#123;</div><div class="line">    :my @extra_tweaks;</div><div class="line"></div><div class="line">    # &lt;irrelevant portion redacted&gt;</div><div class="line"></div><div class="line">    $&lt;B&gt;=[&lt;?before .&gt;]</div><div class="line">    &#123;</div><div class="line">        # Work out the delimeters.</div><div class="line">        my $c := $/.CURSOR;</div><div class="line">        my @delims := $c.peek_delimiters($c.target, $c.pos);</div><div class="line">        my $start := @delims[0];</div><div class="line">        my $stop  := @delims[1];</div><div class="line"></div><div class="line">        # Get the language.</div><div class="line">        my $lang := self.quote_lang($l, $start, $stop, @base_tweaks, @extra_tweaks);</div><div class="line">        $&lt;B&gt;.&apos;!make&apos;([$lang, $start, $stop]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们通过把向前查看捕获到 <code>$&lt;B&gt;</code> 捕获中开始, 它用作更新当前的 Cursor 位置, 然后进入以执行那个代码块。我们把当前的 Cursor 存储在 <code>$c</code> 中, 然后在它身上调用 <code>.peek_delimiters</code> 方法。如果我们为了它在内置的 rakudo 目录中进行 <code>grep</code>, 我们会看到它被定义在 <a href="https://github.com/perl6/nqp/blob/4fd4b48afb45c8b25ccf7cfc5e39cb4bd658901d/src/HLL/Grammar.nqp#L200" target="_blank" rel="external">NQP</a>中, 在 <a href="https://github.com/perl6/nqp/blob/4fd4b48afb45c8b25ccf7cfc5e39cb4bd658901d/src/HLL/Grammar.nqp#L200" target="_blank" rel="external">nqp/src/HLL/Grammar.nqp</a>中, 但是在我们冲出去阅读它的代码之前, 注意它是怎样返回两个分隔符的。我们仅仅把它们打印出来好了?</p>
<p><code>src/Perl6/Grammar.nqp</code> 的 <code>.nqp</code> 后缀名表明我们正处在 NQP 的地盘儿, 所以我们不要使用 <a href="https://github.com/perl6/nqp/blob/master/docs/ops.markdown" target="_blank" rel="external">NQP ops</a>仅仅并且不是完全的 Perl 6 代码。通过把下面这一行代码添加到 <code>@delim</code> 被赋值给 <code>$start</code> 和 <code>$stop</code> 的地方, 我们能找出 <code>.peek_delimiters</code> 给我们的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nqp::say(&quot;$sart $stop&quot;);</div></pre></td></tr></table></figure>
<p>编译!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ perl Configure.pl --gen-moar --gen-nqp --backends=moar &amp;&amp;</div><div class="line">  make &amp;&amp;</div><div class="line">  make test &amp;&amp;</div><div class="line">  make install</div></pre></td></tr></table></figure>
<p>即使在编译期间, 通过吐出额外的东西, 我们的调试行已经给了我们所有那些分隔符是关于什么的启发。再次运行我们的有问题的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ./perl6 -e &apos;.say for qww&lt;„hello world”&gt;;&apos;</div><div class="line">&lt; &gt;</div><div class="line">hello world</div></pre></td></tr></table></figure>
<p>打印出的分隔符是 <code>qww</code> 里的尖括号分隔符。我们对那些不感兴趣, 所以我们可以忽略 <code>.peek_delimiters</code> 并继续。再往上是 <code>.quote_lang</code> 方法。 它的名字里有一个”引号”而我们有一个关于引号的问题.. 听起来我们离真相越来越近了。我们来看看我们正传递给它的是什么参数:</p>
<ul>
<li><code>$1</code> — <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Perl6/Grammar.nqp#L4752" target="_blank" rel="external">Quote language braid</a></li>
<li><code>$start</code> / <code>$stop</code> — 尖括号分隔符</li>
<li><code>@base_tweaks</code> — 包含一个元素: 字符串 <code>ww</code></li>
<li><code>@extra_tweaks</code> — 额外的副词, 这里我们没有, 所以这个数组是空的</li>
</ul>
<p>定位到 <code>method quote_lang</code>; 它仍然在 <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Perl6/Grammar.nqp#L65" target="_blank" rel="external">src/Perl6/Grammar.nqp</a>文件中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">method quote_lang($l, $start, $stop, @base_tweaks?, @extra_tweaks?) &#123;</div><div class="line">    sub lang_key() &#123;</div><div class="line">        # &lt;body redacted&gt;</div><div class="line">    &#125;</div><div class="line">    sub con_lang() &#123;</div><div class="line">        # &lt;body redacted&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    # Get language from cache or derive it.</div><div class="line">    my $key := lang_key();</div><div class="line">    nqp::existskey(%quote_lang_cache, $key) &amp;&amp; $key ne &apos;NOCACHE&apos;</div><div class="line">        ?? %quote_lang_cache&#123;$key&#125;</div><div class="line">        !! (%quote_lang_cache&#123;$key&#125; := con_lang());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们有两个词法子例程 <code>lang_key</code> 和 <code>con_lang</code>, 在它们下面我们把 <code>lang_key</code> 的输出存储到 <code>$key</code> 中, 在 <code>%quote_lang_cache</code> 中这个 <code>$key</code> 被用在整个缓存 dance 中, 所以我们可以忽略掉 <code>lang_key</code> sub 并直接进入 <code>con_lang</code>, 它被调用以生成我们的 <code>quote_lang</code> 方法的返回值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">sub con_lang() &#123;</div><div class="line">    my $lang := $l.&apos;!cursor_init&apos;(self.orig(), :p(self.pos()), :shared(self.&apos;!shared&apos;()));</div><div class="line">    for @base_tweaks &#123;</div><div class="line">        $lang := $lang.&quot;tweak_$_&quot;(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for @extra_tweaks &#123;</div><div class="line">        my $t := $_[0];</div><div class="line">        if nqp::can($lang, &quot;tweak_$t&quot;) &#123;</div><div class="line">            $lang := $lang.&quot;tweak_$t&quot;($_[1]);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            self.sorry(&quot;Unrecognized adverb: :$t&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    nqp::istype($stop,VMArray) ||</div><div class="line">    $start ne $stop ?? $lang.balanced($start, $stop)</div><div class="line">                    !! $lang.unbalanced($stop);</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">在初始化 Cursor 位置之后, `$lang` 继续包含我们的 Quote 语言编织然后我们落进一个 `for` 循环来迭代 `@base_tweaks`, 对于里面的每一个元素, 我们都调用方法 `tweak_$_`, 给它传递一个真值 `1`。因为我们仅仅只有一个 base tweak, 这意味着我们正在Quote braid上调用方法 `tweak_ww`。我们来看看那个方法是关于什么的。</div><div class="line"></div><div class="line">因为 Quote braid 被定义在同一个文件中, 仅仅搜索 `method tweak_ww` 好了:</div><div class="line"></div><div class="line"></div><div class="line">```perl6</div><div class="line">method tweak_ww($v) &#123;</div><div class="line">    $v ?? self.add-postproc(&quot;quotewords&quot;).apply_tweak(ww)</div><div class="line">       !! self</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">很好。我们给它的 `$v` 为真, 所以我们调用了 `.add-postproc` 然后调用 `.apply_tweak(ww)`。看一下那个方法的上面和下面, 我们看到 `.add-postproc` 也用在其它不含 bug 的引号中, 所以我们忽略它并直接跳到 `.apply_tweak`:</div><div class="line"></div><div class="line">```perl6</div><div class="line">method apply_tweak($role) &#123;</div><div class="line">    my $target := nqp::can(self, &apos;herelang&apos;) ?? self.herelang !! self;</div><div class="line">    $target.HOW.mixin($target, $role);</div><div class="line">    self</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>啊哈! 它的参数是一个 role 并且它把该 role 混进来我们的 Quote braid 中。我们来看看那个 role 是关于什么的(再一次, 仅仅在文件中搜索 <a href="https://github.com/rakudo/rakudo/blob/94b09ab9280d39438f84cb467d4b3d3042b8f672/src/Perl6/Grammar.nqp#L4846" target="_blank" rel="external">role ww</a>, 或者仅仅向上滚动一点):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">role ww &#123;</div><div class="line">    token escape:sym&lt;&apos; &apos;&gt; &#123;</div><div class="line">        &lt;?[&apos;]&gt; &lt;quote=.LANG(&apos;MAIN&apos;,&apos;quote&apos;)&gt;</div><div class="line">    &#125;</div><div class="line">    token escape:sym&lt;‘ ’&gt; &#123;</div><div class="line">        &lt;?[‘]&gt; &lt;quote=.LANG(&apos;MAIN&apos;,&apos;quote&apos;)&gt;</div><div class="line">    &#125;</div><div class="line">    token escape:sym&lt;&quot; &quot;&gt; &#123;</div><div class="line">        &lt;?[&quot;]&gt; &lt;quote=.LANG(&apos;MAIN&apos;,&apos;quote&apos;)&gt;</div><div class="line">    &#125;</div><div class="line">    token escape:sym&lt;“ ”&gt; &#123;</div><div class="line">        &lt;?[“]&gt; &lt;quote=.LANG(&apos;MAIN&apos;,&apos;quote&apos;)&gt;</div><div class="line">    &#125;</div><div class="line">    token escape:sym&lt;colonpair&gt; &#123;</div><div class="line">        &lt;?[:]&gt; &lt;!RESTRICTED&gt; &lt;colonpair=.LANG(&apos;MAIN&apos;,&apos;colonpair&apos;)&gt;</div><div class="line">    &#125;</div><div class="line">    token escape:sym&lt;#&gt; &#123;</div><div class="line">        &lt;?[#]&gt; &lt;.LANG(&apos;MAIN&apos;, &apos;comment&apos;)&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>奥, 我的天呐!引号! 如果这个地方不是我们修复 bug 的地方, 那么我就是一个芭蕾舞女演员。 我们找到它了!</p>
<p>我们定位到的 role 把进了某些 tokens 混合进了我们正使用的 Quote braid 中来解析 <code>qww</code> 的内容。我们带有 bug 的 <code>„”</code> 引号组合明显不在那个列表中。我们来把它添加进去!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">token escape:sym&lt;„ ”&gt; &#123;</div><div class="line">    &lt;?[„]&gt; &lt;quote=.LANG(&apos;MAIN&apos;,&apos;quote&apos;)&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译! 运行我们带有 bug 的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ./perl6 -e &apos;.say for qww&lt;foo „hello world” bar&gt;&apos;</div><div class="line">foo</div><div class="line">bar</div></pre></td></tr></table></figure>
<p>悲催! 好吧, 我们确实为引号处理找到了正确的地方, 但是我们让问题变得更加糟糕了。发生了什么?</p>
<h2 id="Quotastic-Inaction"><a href="#Quotastic-Inaction" class="headerlink" title="Quotastic Inaction"></a>Quotastic Inaction</h2><p>我们新的 token 肯定解析了那个引号, 但是我们绝对没有给它添加 Actions 动作… 好吧, 对它起作用。 Action 类和 Grammars 相邻, 在 <code>src/Perl6/Actions.nqp</code> 中。打开它并定位到匹配的方法那里; 比如 <a href="https://github.com/rakudo/rakudo/blob/94b09ab9280d39438f84cb467d4b3d3042b8f672/src/Perl6/Actions.nqp#L9243" target="_blank" rel="external">method escape:sym&lt;“ ”&gt;</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">method escape:sym&lt;&apos; &apos;&gt;($/) &#123; make mark_ww_atom($&lt;quote&gt;.ast); &#125;</div><div class="line">method escape:sym&lt;&quot; &quot;&gt;($/) &#123; make mark_ww_atom($&lt;quote&gt;.ast); &#125;</div><div class="line">method escape:sym&lt;‘ ’&gt;($/) &#123; make mark_ww_atom($&lt;quote&gt;.ast); &#125;</div><div class="line">method escape:sym&lt;“ ”&gt;($/) &#123; make mark_ww_atom($&lt;quote&gt;.ast); &#125;</div></pre></td></tr></table></figure>
<p>并在列表中添加我们自己的版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method escape:sym&lt;„ ”&gt;($/) &#123; make mark_ww_atom($&lt;quote&gt;.ast); &#125;</div></pre></td></tr></table></figure>
<p>编译! 运行我们带有 bug 的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ./perl6 -e &apos;.say for qww&lt;foo „hello world” bar&gt;&apos;</div><div class="line">foo</div><div class="line">hello world</div><div class="line">bar</div></pre></td></tr></table></figure>
<p>呼! 成功了! 不再有 bug 了。我们修复了那个 bug! </p>
<p>但是, 等一下…</p>
<h2 id="遗漏了-但是没有忘记"><a href="#遗漏了-但是没有忘记" class="headerlink" title="遗漏了, 但是没有忘记"></a>遗漏了, 但是没有忘记</h2><p>看一下<a href="https://docs.perl6.org/language/unicode_texas#Other_acceptable_single_codepoints" target="_blank" rel="external">所有可能的奢华的引号的列表</a>。尽管我们的 bug 报告中仅仅提到了 <code>„”</code> 引号对儿, 但是 <code>‚‘</code> 和 <code>「」</code> 都不在我们的 <code>role ww</code> tokens 中。远远不止的是, 某些左/右引号, 当它们交换位置后, 在引起字符串的时候也刚好能工作, 所以它们也应该在 <code>qww</code> 中起效。然而, 添加一整串额外的 tokens 和一整串其它的 actions 方法是相当不精彩的。有没有更好的方法?</p>
<p>我们仔细看看我们的 tokens:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">token escape:sym&lt;“ ”&gt; &#123;</div><div class="line">    &lt;?[“]&gt; &lt;quote=.LANG(&apos;MAIN&apos;,&apos;quote&apos;)&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sym&lt;“ ”&gt;</code> 我们可以把它省略了 — 这里它的功能仅仅是作为一个名字。我们留下的是一个向前查看的 <code>“</code> 引号还有 <code>&lt;quote=.LANG(&#39;MAIN&#39;,&#39;quote&#39;)&gt;</code>。所以我们可以向前查看所有的我们关心的开口引号并让 MAIN braid 接管所有的细节。</p>
<p>所以, 让我们用这个单个 token 替换掉所有的引号处理 tokens:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">token escape:sym&lt;&apos;&gt; &#123;</div><div class="line">    &lt;?[ &apos; &quot; ‘ ‚ ’ “ „ ” 「 ]&gt; &lt;quote=.LANG(&apos;MAIN&apos;,&apos;quote&apos;)&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且使用下面这个单个 action 替换掉所有的匹配 actions 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method escape:sym&lt;&apos;&gt;($/) &#123; make mark_ww_atom($&lt;quote&gt;.ast); &#125;</div></pre></td></tr></table></figure>
<p>编译! 运行我们的带有某些引号变体的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ./perl6 -e &apos;.say for qww&lt;„looks like” ‚we fixed‘ ｢this thing｣&gt;&apos;</div><div class="line">looks like</div><div class="line">we fixed</div><div class="line">this thing</div></pre></td></tr></table></figure>
<p>精彩! 我们不仅让所有的引号都能正常工作, 还设法清理的存在的 tokens 和 actions 方法。现在所有我们需要做的就是对我们的修复做测试并且我们已经准备提交了。</p>
<h2 id="享用-bug-烤肉"><a href="#享用-bug-烤肉" class="headerlink" title="享用 bug 烤肉"></a>享用 bug 烤肉</h2><p><a href="https://github.com/perl6/roast" target="_blank" rel="external">Perl 6 官方测试套件 Roast</a> 是在 Rakudo 内建目录中的 <code>t/spec</code> 中，如果它不存在, 仅仅运行 <code>make spectest</code> 就好了并且在它把 roast 仓库克隆到 <code>t/spec</code> 中后就中止它。我们需要找到在哪里插入我们的测试而 <code>grep</code> 是干那件事的好朋友:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">zoffix@VirtualBox:~/CPANPRC/rakudo/t/spec$ grep -R &apos;qww&apos; .</div><div class="line">Binary file ./.git/objects/pack/pack-5bdee39f28283fef4b500859f5b288ea4eec20d7.pack matches</div><div class="line">./S02-literals/allomorphic.t:    my @wordlist = qqww[1 2/3 4.5 6e7 8+9i] Z (IntStr, RatStr, RatStr, NumStr, ComplexStr);</div><div class="line">./S02-literals/allomorphic.t:        isa-ok $val, Str, &quot;&apos;$val&apos; from qqww[] is a Str&quot;;</div><div class="line">./S02-literals/allomorphic.t:        nok $val.isa($wrong-type), &quot;&apos;$val&apos; from qqww[] is not a $wrong-type.perl()&quot;;</div><div class="line">./S02-literals/allomorphic.t:    my @wordlist  = qqww:v[1 2/3 4.5 6e7 8+9i];</div><div class="line">./S02-literals/allomorphic.t:    my @written = qqww:v[1 2/3 $num 6e7 8+9i ten];</div><div class="line">./S02-literals/allomorphic.t:    is-deeply @angled, @written, &quot;«...» is equivalent to qqww:v[...]&quot;;</div><div class="line">./S02-literals/quoting.t:    is(qqww[$alpha $beta], &lt;foo bar&gt;, &apos;qqww&apos;);</div><div class="line">./S02-literals/quoting.t:    for (&lt;&lt;$a b c&gt;&gt;, qqww&#123;$a b c&#125;, qqw&#123;$a b c&#125;).kv -&gt; $i, $_ &#123;</div><div class="line">./S02-literals/quoting.t:    is-deeply qww&lt;a a ‘b b’ ‚b b’ ’b b‘ ’b b‘ ’b b’ ‚b b‘ ‚b b’ “b b” „b b”</div><div class="line">./S02-literals/quoting.t:    &apos;fancy quotes in qww work just like regular quotes&apos;;</div><div class="line">./integration/advent2014-day16.t:    for flat qww/ foo bar &apos;first second&apos; / Z @a -&gt; $string, $result &#123;</div></pre></td></tr></table></figure>
<p>看起来 <code>S02-literals/quoting.t</code> 是它的一个好地方。打开那个文件, 在它的顶部, 通过我们添加的测试的数量来增加 <code>plan</code> 的数量 — 在这个例子中仅仅增加一条就好了。然后滚动到底部并创建一个 block 块, 前面添加一个注释, 并为我们正修复的 <a href="https://rt.perl.org/Ticket/Display.html?id=128304" target="_blank" rel="external">bug 报告</a>引用那个 RT 标签数字。</p>
<p>在文件里面, 我们使用 <a href="https://docs.perl6.org/language/testing#index-entry-is-deeply-is-deeply%28%24value%2C_%24expected%2C_%24description%3F%29" target="_blank" rel="external">is-deeply</a> 测试函数, 它使用 <a href="https://docs.perl6.org/routine/eqv" target="_blank" rel="external">eqv 操作符</a>语义来做测试。我们会给它一个带有完整引号串的 <code>qww&lt;&gt;</code> 行并告诉它我们所期望返回的项目列表。还要写下测试描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># RT #128304</div><div class="line">&#123;</div><div class="line">    is-deeply qww&lt;a a ‘b b’ ‚b b’ ’b b‘ ’b b‘ ’b b’ ‚b b‘ ‚b b’ “b b” „b b”</div><div class="line">            ”b b“ ”b b“ ”b b” „b b“ „b b” ｢b b｣ ｢b b｣&gt;,</div><div class="line">        (&apos;a&apos;, &apos;a&apos;, |(&apos;b b&apos; xx 16)),</div><div class="line">    &apos;fancy quotes in qww work just like regular quotes&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回到 Rakudo checkout, 运行修改后的测试并保证它通过:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ make t/spec/S02-literals/quoting.t</div><div class="line"># &lt;lots of output&gt;</div><div class="line">All tests successful.</div><div class="line">Files=1, Tests=185,  3 wallclock secs ( 0.03 usr  0.01 sys +  2.76 cusr  0.11 csys =  2.91 CPU)</div><div class="line">Result: PASS</div></pre></td></tr></table></figure>
<p>漂亮。 提交测试 bug 修复好了并且把它们送走! 我们做到了!</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>当我们在修复 Perl 6 中的解析 bugs 的时候, 把程序减少到能重新产生那个 bug 的最小部分然后使用 <code>--target=parse</code> 命令行参数, 得到解析树的输出, 找到所匹配的那个 tokens。<code>statementlist</code></p>
<p>然后, 在 <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Perl6/Grammar.nqp" target="_blank" rel="external">src/Perl6/Grammar.nqp</a> 中跟随这些 tokens, 它也继承自 <a href="https://github.com/perl6/nqp/blob/4fd4b48afb45c8b25ccf7cfc5e39cb4bd658901d/src/HLL/Grammar.nqp" target="_blank" rel="external">NQP 的 src/HLL/Grammar.nqp</a> 。 与位于 <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Perl6/Actions.nqp" target="_blank" rel="external">src/Perl6/Actions.nqp</a> 中的 actions 类协作, 跟随着代码找出正在做什么并期望找出问题出现在什么位置。</p>
<p>修复它。测试它。发布它。</p>
<p>充满了乐趣。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[perl6intro-翻译]]></title>
      <url>http://ohmycloud.github.io/2015/12/21/perl6intro-%E7%BF%BB%E8%AF%91/</url>
      <content type="html"><![CDATA[<h2 id="第八章-函数式编程"><a href="#第八章-函数式编程" class="headerlink" title="第八章 函数式编程"></a>第八章 函数式编程</h2><hr>
<p>在本章中，我们将看看一些有利于函数式编程的功能。</p>
<h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p>　<br>函数/子例程是一等公民:</p>
<ul>
<li>它们能作为参数传递</li>
<li>它们能从另外一个函数中返回</li>
<li>它们能被赋值给变量</li>
</ul>
<p><code>map</code> 函数是用来说明这个概念的极好例子。<code>map</code> 是高阶函数, 它接收另外一个函数作为参数。</p>
<p><strong>脚本</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array = &lt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>&gt;;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">squared</span>($<span class="title">x</span>) </span>&#123;</div><div class="line">    $x ** <span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">say</span> <span class="keyword">map</span>(&amp;squared, @array);</div></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(1 4 9 16 25)</div></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>我们定义了一个叫做 <code>squared</code> 的子例程, 它接收一个数字并返回该数字的二次幂。下一步, 我们使用 <code>map</code> 这个高阶函数并传递给它两个参数, 一个子例程和一个数组。结果是所有数组元素的平方组成的列表。</p>
<p>注意当传递子例程作为参数时, 我们需要在子例程的名字前添加一个 <code>&amp;</code> 符号。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>　<br>在 Perl 6 中所有的代码对象都是闭包, 这意味着它们能从外部作用域(outer scope)引用词法变量(lexical variables)。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>　<br><strong>匿名函数</strong>也叫做<strong>拉姆达</strong>(lambda)。</p>
<p>匿名函数没有绑定到标识符(匿名函数没有名字)。</p>
<p>让我们使用匿名函数重写 <code>map</code> 那个例子。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array = &lt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>&gt;;</div><div class="line"><span class="keyword">say</span> <span class="keyword">map</span>(-&gt; $x &#123;$x ** <span class="number">2</span>&#125;, @array);</div></pre></td></tr></table></figure>
<p>我们没有声明子例程并把它作为参数传递给 <code>map</code>, 而是在里面直接定义了匿名函数。</p>
<p>匿名函数 <code>-&gt; $x {$x ** 2}</code> 没有句柄并且不能被调用。</p>
<p>按照 Perl 6 的说法我们把这个标记叫做 <strong>pointy block</strong>。</p>
<p>pointy block 也能用于把函数赋值给变量:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $squared = -&gt; $x &#123;</div><div class="line">    $x ** <span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">say</span> $squared(<span class="number">9</span>);</div></pre></td></tr></table></figure>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>　<br>在 Perl 6中, 方法可以链接起来, 你不再需要把一个方法的结果作为参数传递给另外一个方法了。</p>
<p>我们假设你有一个数组。你被要求返回该数组的唯一值, 并且按从大到小的顺序排序。</p>
<p>你可能会通过写出近似于这样的代码来解决那个问题:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array       = &lt;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> &gt;;</div><div class="line"><span class="keyword">my</span> @final-array = <span class="keyword">reverse</span>(<span class="keyword">sort</span>(unique(@array)));</div><div class="line"><span class="keyword">say</span> @final-array;</div></pre></td></tr></table></figure>
<p>首先我们在 <code>@array</code> 身上调用 <code>unique</code> 函数, 然后我们把它的结果作为参数传递给 <code>sort</code> 函数, 再然后我们把结果传递给 <code>reverse</code> 函数。</p>
<p>和上面的例子相比, Perl  6 允许链式方法。</p>
<p>上面的例子可以像下面这样写, 利用<strong>方法链</strong>的优点:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array       = &lt;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> &gt;;</div><div class="line"><span class="keyword">my</span> @final-array = @array.unique.sort.<span class="keyword">reverse</span>;</div><div class="line"><span class="keyword">say</span> @final-array;</div></pre></td></tr></table></figure>
<p>你已经看到链式方法看起来有多清爽啦。</p>
<h3 id="Feed-操作符"><a href="#Feed-操作符" class="headerlink" title="Feed 操作符"></a>Feed 操作符</h3><p>　<br><strong>feed 操作符</strong>, 在有些函数式编程语言中也叫<strong>管道</strong>, 然而它是链式方法的一个更好的可视化产出。</p>
<p><strong>向前流</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array = &lt;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span>&gt;;</div><div class="line">@array ==&gt; unique()</div><div class="line">       ==&gt; <span class="keyword">sort</span>()</div><div class="line">       ==&gt; <span class="keyword">reverse</span>()</div><div class="line">       ==&gt; <span class="keyword">my</span> @final-array;</div><div class="line"><span class="keyword">say</span> @final-array;</div></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">从 `@array` 开始 然后 返回一个唯一元素的列表</div><div class="line">                 然后 排序它</div><div class="line">                 然后 反转它</div><div class="line">                 然后 把结果保存到 @final-array 中</div></pre></td></tr></table></figure>
<p>就像你看到的那样, 方法的流向是自上而下的。</p>
<p><strong>向后流</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array = &lt;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span>&gt;;</div><div class="line"><span class="keyword">my</span> @final-array-v2 &lt;== <span class="keyword">reverse</span>()</div><div class="line">                   &lt;== <span class="keyword">sort</span>()</div><div class="line">                   &lt;== unique()</div><div class="line">                   &lt;== @array;</div><div class="line"><span class="keyword">say</span> @final-array-v2;</div></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>向后流就像向前流一样, 但是是以反转的顺序写的。</p>
<p>方法的流动方向是自下而上。</p>
<h3 id="Hyper-操作符"><a href="#Hyper-操作符" class="headerlink" title="Hyper 操作符"></a>Hyper 操作符</h3><p>　<br><strong>hyper 操作符</strong> <code>».</code> 会在列表的所有元素身上调用一个方法并返回所有结果的一个列表。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array = &lt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>&gt;;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">is</span>-<span class="title">even</span>($<span class="title">var</span>) </span>&#123; $var %% <span class="number">2</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">say</span> @array».is-prime;</div><div class="line"><span class="keyword">say</span> @array».&amp;is-even;</div></pre></td></tr></table></figure>
<p>使用 hyper 操作符我们能调用 Perl 6 中已经定义过的方法, 例如. <code>is-prime</code> 告诉我们一个数字是否是质数。</p>
<p>此外我们能定义新的子例程并使用 hyper 操作符调用它们。但是这时我们必须在方法的名字前面加上 <code>&amp;</code> 符号。例如. <code>&amp;is-even</code>。</p>
<p>这很实用因为它使我们不必写 <code>for</code> 循环就可以迭代每个值。</p>
<h3 id="Junctions"><a href="#Junctions" class="headerlink" title="Junctions"></a>Junctions</h3><p>　<br><strong>junction</strong> 是值的逻辑叠加。</p>
<p>在下面的例子中 <code>1|2|3</code> 是一个 junction。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $var = <span class="number">2</span>;</div><div class="line"><span class="keyword">if</span> $var == <span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"The variable is 1 or 2 or 3"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>junctions 的使用常常触发<strong>自动线程化</strong>; 每个 junction 元素都执行该操作, 并且所有的结果被组合到一个新的 junction 中并返回。</p>
<h3 id="Lazy-Lists"><a href="#Lazy-Lists" class="headerlink" title="Lazy Lists"></a>Lazy Lists</h3><p>　<br><strong>惰性列表</strong>是被惰性求值的列表。</p>
<p>惰性求值延迟表达式的计算直到需要时, 并把结果存储到查询表中以避免重复计算。</p>
<p>惰性列表的优点包括:</p>
<ul>
<li>通过避免不必要的计算带来的性能提升</li>
<li>构建潜在的无限数据结构的能力</li>
<li>定义控制流的能力</li>
</ul>
<p>我们使用中缀操作符 <code>...</code> 来创建惰性列表。</p>
<p>惰性列表拥有一个<strong>初始元素</strong>, 一个<strong>发生器</strong>和一个<strong>结束点</strong>。</p>
<p><strong>简单的惰性列表</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span>  $lazylist = (<span class="number">1</span> ... <span class="number">10</span>);</div><div class="line"><span class="keyword">say</span> $lazylist;</div></pre></td></tr></table></figure>
<p>初始元素为 1 而结束点为 10。因为没有定义发生器所以默认的发生器为 successor(+1)。换句话说, 这个惰性列表可能返回(如果需要的话)下面的元素 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)。</p>
<p><strong>无限惰性列表</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span>  $lazylist = (<span class="number">1</span> ... Inf);</div><div class="line"><span class="keyword">say</span> $lazylist;</div></pre></td></tr></table></figure>
<p>该列表可能返回(如果需要的话) 1 到无穷大之间的任何整数, 换句话说, 可以返回任何整数。</p>
<p><strong>使用推断发生器创建惰性列表</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span>  $lazylist = (<span class="number">0</span>,<span class="number">2</span> ... <span class="number">10</span>);</div><div class="line"><span class="keyword">say</span> $lazylist;</div></pre></td></tr></table></figure>
<p>初始的元素是 0 和 2 而结束点是 10。虽然没有定义发生器, 但是使用了初始元素, Perl 6 会把生成器推断为 (+2)。</p>
<p>这个惰性列表可能返回(如果需要的话)下面的元素 (0, 2, 4, 6, 8, 10)。</p>
<p><strong>使用定义的发生器创建惰性列表</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span>  $lazylist = (<span class="number">0</span>, &#123; $_ + <span class="number">3</span> &#125; ... <span class="number">12</span>);</div><div class="line"><span class="keyword">say</span> $lazylist;</div></pre></td></tr></table></figure>
<p>在这个例子中, 我们在闭合 <code>{ }</code> 中显式地定义了一个发生器。</p>
<p>这个惰性列表可能返回(如果需要的话)下面的元素 (0, 3, 6, 9, 12)。</p>
<blockquote>
<p>当使用显式的发生器时, 结束点必须是发生器能返回的一个值。</p>
<p>如果在上面的例子中我们使用的结束点是 10 而非 12, 那么发生器就不会停止。发生器会跳过那个结束点。</p>
<p>二选一, 你可以使用 <code>0 ...^ * &gt; 10</code> 代替 <code>0 ... 10</code>。你可以把它读作: 从 0 直到第一个大于 10(不包括它)的值</p>
<p><strong>这不会使发生器停止</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span>  $lazylist = (<span class="number">0</span>, &#123; $_ + <span class="number">3</span> &#125; ... <span class="number">10</span>);</div><div class="line">&gt; <span class="keyword">say</span> $lazylist;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>这会使发生器停止</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span>  $lazylist = (<span class="number">0</span>, &#123; $_ + <span class="number">3</span> &#125; ...^ * &gt; <span class="number">10</span>);</div><div class="line">&gt; <span class="keyword">say</span> $lazylist;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;<br>&gt;</p>
<h2 id="第九章-类和对象"><a href="#第九章-类和对象" class="headerlink" title="第九章 类和对象"></a>第九章 类和对象</h2><hr>
<p>在上一章中我们学习了 Perl 6 中函数式编程的便利性。在这一章中我们将看看 Perl 6 中的面向对象编程。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　<br>面向对象编程是当今广泛使用的范式之一。<strong>对象</strong>是一组绑定在一起的变量和子例程。</p>
<p>其中的变量叫做<strong>属性</strong>, 而子例程被叫做<strong>方法</strong>。属性定义对象的<strong>状态</strong>, 而方法定义对象的<strong>行为</strong>。</p>
<p><strong>类</strong>定义一组<strong>对象</strong>结构。</p>
<p>为了理解它们之间的关系, 考虑下面的例子:</p>
<table>
<thead>
<tr>
<th style="text-align:left">房间里有 4 个 people</th>
<th style="text-align:left"><strong>objects</strong> =&gt; 4 people</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">这 4 个人是 humans</td>
<td style="text-align:left"><strong>class</strong> =&gt; Human</td>
</tr>
<tr>
<td style="text-align:left">它们有不同的名字,年纪,性别和国籍</td>
<td style="text-align:left"><strong>attribute</strong> =&gt; name,age,sex,nationality</td>
</tr>
</tbody>
</table>
<p>按面向对象的说法, 对象是类的<strong>实例</strong>。</p>
<p>考虑下面的脚本:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">    has $name;</div><div class="line">    has $age;</div><div class="line">    has $sex;</div><div class="line">    has $nationality;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $john = Human.new(<span class="string">name =&gt;</span> <span class="string">'John'</span>,</div><div class="line">                     <span class="string">age  =&gt;</span> <span class="number">23</span>,</div><div class="line">                     <span class="string">sex  =&gt;</span> <span class="string">'M'</span></div><div class="line">                     <span class="string">nationality =&gt;</span> <span class="string">'American'</span>)</div><div class="line"><span class="keyword">say</span> $john;</div></pre></td></tr></table></figure>
<p><code>class</code> 关键字用于定义类。<br><code>has</code> 关键字用于定义类的属性。<br><code>.new</code> 方法被称之为 <strong>构造函数</strong>。它创建了对象作为类的实例。</p>
<p>在上面的例子中, 新的变量 <code>$john</code> 保存了由 <code>Human.new()</code> 所定义的新 “Human” 实例。<br>传递给 <code>.new()</code> 方法的参数用于设置底层对象的属性。<br>类可以使用 <code>my</code> 来声明一个本地作用域:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> class Human &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>　<br>封装是一个面向对象的概念, 它把一组数据和方法捆绑在一块。<br>对象中的数据(属性)应该是<strong>私有的</strong>, 换句话说, 只能从对象内部访问它。<br>为了从对象外部访问对象的属性, 我们使用叫做<strong>存取器</strong>的方法。<br>下面两个脚本拥有同样的结果。</p>
<p><strong>直接访问变量</strong>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span>  $var = <span class="number">7</span>;</div><div class="line"><span class="keyword">say</span> $var;</div></pre></td></tr></table></figure>
<p><strong>封装</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $var = <span class="number">7</span>;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">sayvar</span> </span>&#123;</div><div class="line">    $var;</div><div class="line">&#125;</div><div class="line"><span class="keyword">say</span> sayvar;</div></pre></td></tr></table></figure>
<p><code>sayvar</code> 是一个存取器。它让我们通过不直接访问这个变量来访问这个变量。<br>在 Perl 6 中使用  <strong>twigils</strong> 使得封装很便利。<br>Twigils 是第二 <strong><em>符号</em></strong>。它们存在于符号和属性名之间。<br>有两个 twigils 用在类中:</p>
<ul>
<li><code>!</code> 用于显式地声明属性是私有的</li>
<li><code>.</code> 用于为属性自动生成存取器</li>
</ul>
<p>默认地, 所有的属性都是私有的, 但是总是用 <code>!</code> twigil 是一个好习惯。<br>为了和我说的相一致, 我们应该把上面的类重写成下面这样:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">    has $!name;</div><div class="line">    has $!age;</div><div class="line">    has $!sex;</div><div class="line">    has $!nationality;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $john = Human.new(<span class="string">name =&gt;</span> <span class="string">'John'</span>, <span class="string">age =&gt;</span> <span class="number">23</span>, <span class="string">sex =&gt;</span> <span class="string">'M'</span>, <span class="string">nationality =&gt;</span> <span class="string">'American'</span>);</div><div class="line"><span class="keyword">say</span> $john;</div></pre></td></tr></table></figure>
<p>给脚本追加这样的的语句: <code>say $john.age</code>;<br>它会返回这样的错误: <code>Method &#39;age&#39; not found for invocant of class &#39;Human&#39;</code>。<br>原因是 <code>$!age</code> 是私有的并且只能用于对象内部。 尝试在对象外部访问它会返回一个错误。<br>现在用 <code>has $.age</code> 代替 <code>$!age</code> 并看看 <code>say $john.age;</code> 的结果是什么。</p>
<h3 id="具名参数-vs-位置参数"><a href="#具名参数-vs-位置参数" class="headerlink" title="具名参数 vs. 位置参数"></a>具名参数 vs. 位置参数</h3><p>　<br>在 Perl 6 中, 所有的类继承了一个默认的 <code>.new</code> 构造函数。<br>通过为他提供参数, 它能用于创建对象。<br>只能提供<strong>具名参数</strong>给默认的构造函数。</p>
<p>如果你考虑到上面的例子, 你会看到所有提供给 <code>.new</code> 方法的参数都是按名字定义的:</p>
<ul>
<li>name =&gt; ‘John’</li>
<li>age     =&gt; 23</li>
</ul>
<p>假如我不想在每次创建新对象的时候为每个属性提供一个名字呢?<br>那么我需要创建另外一个接收<strong>位置参数</strong>的构造函数。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">    has $.name;</div><div class="line">    has $.age;</div><div class="line">    has $.sex;</div><div class="line">    has $.nationality;</div><div class="line"></div><div class="line">    <span class="comment"># 重写默认构造函数的新构造函数</span></div><div class="line">    method new ($name, $age, $sex, $nationality) &#123;</div><div class="line">        self.bless(:$name, :$age, :$sex, :$nationality);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $john = Human.new(<span class="string">'John'</span>, <span class="number">23</span>, <span class="string">'M'</span>, <span class="string">'American'</span>);</div><div class="line"><span class="keyword">say</span> $john;</div></pre></td></tr></table></figure>
<p>能接收位置参数的构造函数需要按上面那样定义。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>　</p>
<h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>　<br>方法是对象的子例程。<br>像子例程一样, 方法是一种打包一组功能的手段, 它们接收<strong>参数</strong>, 拥有<strong>签名</strong>并可以被定义为 <strong>multi</strong>。<br>方法是使用关键字 <code>method</code> 来定义的。</p>
<p>正常情况下, 方法被要求在对象的属性身上执行一些动作。这强制了封装的概念。对象的属性只能在对象里面使用方法来操作。在对象外面, 只能和对象的方法交互, 并且不能访问它的属性。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">  has $.name;</div><div class="line">  has $.age;</div><div class="line">  has $.sex;</div><div class="line">  has $.nationality;</div><div class="line">  has $.eligible;</div><div class="line">  method assess-eligibility &#123;</div><div class="line">      <span class="keyword">if</span> self.age &lt; <span class="number">21</span> &#123;</div><div class="line">          $!eligible = <span class="string">'No'</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          $!eligible = <span class="string">'Yes'</span></div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $john = Human.new(<span class="string">name =&gt;</span> <span class="string">'John'</span>, <span class="string">age =&gt;</span> <span class="number">23</span>, <span class="string">sex =&gt;</span> <span class="string">'M'</span>, <span class="string">nationality =&gt;</span> <span class="string">'American'</span>);</div><div class="line">$john.assess-eligibility;</div><div class="line"><span class="keyword">say</span> $john.eligible;</div></pre></td></tr></table></figure>
<p>一旦方法定义在类中, 它们就能在对象身上使用<strong>点记号</strong>来调用:<br><code>object.method</code> 或像上面的例子那样: <code>$john.assess-eligibility</code>。<br>在方法的定义中, 如果我们需要引用对象本身以调用另一个方法, 则使用 <code>self</code> 关键字。<br>在方法的定义中, 如果我们需要引用属性, 则使用 <code>!</code> , 即使属性是使用 <code>.</code> 定义的。<br>理由是 <code>.</code> twigil 做的就是使用 <code>!</code> 声明一个属性并自动创建存取器。</p>
<p>在上面的例子中, <code>if self.age &lt; 21</code> 和  <code>if $!age &lt; 21</code> 会有同样的效果, 尽管它们从技术上来讲是不同的:</p>
<ul>
<li><code>self.age</code> 调用了 <code>.age</code> 方法(存取器)</li>
</ul>
<p>​       二选一, 还能写成 <code>$.age</code></p>
<ul>
<li><code>$!age</code> 是直接调用那个变量</li>
</ul>
<h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>　<br>正常的方法能从类的外面在对象身上调用。<br><strong>私有方法</strong>是只能从类的内部调用的方法。</p>
<p>一个可能的使用情况是一个方法调用另外一个执行特定动作的方法。连接外部世界的方法是公共的而被引用的那个方法应该保持私有。我们不想让用户直接调用它, 所以我们把它声明为私有的。</p>
<p>私有方法的声明需要在方法的名字前使用 <code>!</code> twigil。<br>私有方法是使用 <code>!</code> 而非 <code>.</code> 调用的。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">method !iamprivate &#123;</div><div class="line">    <span class="comment"># code goes in here</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">method iampublic &#123;</div><div class="line">    self!iamprivate;</div><div class="line">    <span class="comment"># do additional things</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>　<br><strong>类属性</strong>是属于类自身而非类的对象的属性。<br>它们能在定义期间初始化。<br>类属性是使用 <code>my</code> 关键字而非 <code>has</code> 关键字声明的。<br>它们是在类自己身上而非它的对象身上调用的。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">    has $.name;</div><div class="line">    <span class="keyword">my</span>  $.counter = <span class="number">0</span>;</div><div class="line">    method new($name) &#123;</div><div class="line">      Human.counter++;</div><div class="line">      self.bless(:$name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">my</span> $a = Human.new(<span class="string">'a'</span>);</div><div class="line"><span class="keyword">my</span> $b = Human.new(<span class="string">'b'</span>);</div><div class="line"></div><div class="line"><span class="keyword">say</span> Human.counter;</div></pre></td></tr></table></figure>
<h3 id="访问类型"><a href="#访问类型" class="headerlink" title="访问类型"></a>访问类型</h3><p>　<br>到现在为止我们看到的所以例子都使用存取器来从对象属性中获取信息。<br>假如我们需要修改属性的值呢?<br>我们需要使用下面的 <code>is rw</code> 关键字把它标记为 <code>read/write</code>。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">    has $.name;</div><div class="line">    has $.age is rw;</div><div class="line">&#125;</div><div class="line"><span class="keyword">my</span> $john = Human.new(<span class="string">name =&gt;</span> <span class="string">'John'</span>, <span class="string">age =&gt;</span> <span class="number">21</span>);</div><div class="line"><span class="keyword">say</span> $john.age;</div><div class="line"></div><div class="line">$john.age = <span class="number">23</span>;</div><div class="line"><span class="keyword">say</span> $john.age;</div></pre></td></tr></table></figure>
<p>默认地, 所有属性都声明为只读, 但是你可以显式地使用 <code>is readonly</code> 来声明。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>　</p>
<h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>　<br><strong>继承</strong>是面向对象编程的另一个概念。<br>当定义类的时候, 很快我们会意思到很多属性/方法在很多类中是共有的。<br>我们应该重复代码吗?</p>
<p>不! 我们应该使用<strong>继承</strong>。<br>假设我们想定义两个类, 一个类是 Human, 一个类是 Employees。<br>Human 拥有两个属性: name 和 age。</p>
<p>Employees 拥有 4  个属性: name, age, company 和 salary。<br>尝试按下面定义类:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">    has $.name;</div><div class="line">    has $.age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Employee &#123;</div><div class="line">    has $.name;</div><div class="line">    has $.age;</div><div class="line">    has $.company;</div><div class="line">    has $.salary;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然上面的代码技术上是正确的, 但是概念上差。<br>更好的写法是下面这样:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">    has $.name;</div><div class="line">    has $.age;</div><div class="line">&#125;</div><div class="line">class Employee is Human &#123;</div><div class="line">    has $.company;</div><div class="line">    has $.salary;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>is</code> 关键字定义了继承。<br>按面向对象的说法, Employee 是 Human 的<strong>孩子</strong>, 而 Human 是 Employee 的<strong>父亲</strong>。</p>
<p>所有的子类继承了父类的属性和方法, 所以没有必要重新它们。</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>　<br>类从它们的父类中继承所有的属性和方法。<br>有些情况下, 我们需要让子类中的方法表现得和继承的方法不一样。<br>为了做到这, 我们在子类中重新定义方法。</p>
<p>这个概念就叫做<strong>重写</strong>。</p>
<p>在下面的例子中, <code>introduce-yourself</code> 方法被 Employee 类继承。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">    has $.name;</div><div class="line">    has $.age;</div><div class="line">    method introduce-yourself &#123;</div><div class="line">      <span class="keyword">say</span> <span class="string">'Hi 我是人类, 我的名字是 '</span> ~ self.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Employee is Human &#123;</div><div class="line">    has $.company;</div><div class="line">    has $.salary;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $john = Human.new(<span class="string">name =&gt;</span> <span class="string">'John'</span>, <span class="string">age =&gt;</span> <span class="number">23</span>,);</div><div class="line"><span class="keyword">my</span> $jane = Employee.new(<span class="string">name =&gt;</span> <span class="string">'Jane'</span>, <span class="string">age =&gt;</span> <span class="number">25</span>, <span class="string">company =&gt;</span> <span class="string">'Acme'</span>, <span class="string">salary =&gt;</span> <span class="number">4000</span>);</div><div class="line"></div><div class="line">$john.introduce-yourself;</div><div class="line">$jane.introduce-yourself;</div></pre></td></tr></table></figure>
<p>重写工作如下:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">    has $.name;</div><div class="line">    has $.age;</div><div class="line">    method introduce-yourself &#123;</div><div class="line">      <span class="keyword">say</span> <span class="string">'Hi 我是人类, 我的名字是 '</span> ~ self.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Employee is Human &#123;</div><div class="line">    has $.company;</div><div class="line">    has $.salary;</div><div class="line">    method introduce-yourself &#123;</div><div class="line">      <span class="keyword">say</span> <span class="string">'Hi 我是一名员工, 我的名字是 '</span> ~ self.name ~ <span class="string">' 我工作在: '</span> ~ self.comapny;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $john = Human.new(<span class="string">name =&gt;</span><span class="string">'John'</span>,<span class="string">age =&gt;</span> <span class="number">23</span>,);</div><div class="line"><span class="keyword">my</span> $jane = Employee.new(<span class="string">name =&gt;</span><span class="string">'Jane'</span>,<span class="string">age =&gt;</span> <span class="number">25</span>,<span class="string">company =&gt;</span> <span class="string">'Acme'</span>,<span class="string">salary =&gt;</span> <span class="number">4000</span>);</div><div class="line"></div><div class="line">$john.introduce-yourself;</div><div class="line">$jane.introduce-yourself;</div></pre></td></tr></table></figure>
<p>根据对象所属的类, 会调用正确的方法。</p>
<h4 id="Submethods"><a href="#Submethods" class="headerlink" title="Submethods"></a>Submethods</h4><p>　<br><strong>Submethods</strong> 是一种子类继承不到的方法。</p>
<p>它们只能从所声明的类中访问。<br>它们使用 <code>submethod</code> 关键字定义。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>　<br>在 Perl 6 中允许多重继承。一个类可以继承自多个其它的类。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class bar-chart &#123;</div><div class="line">  has Int @.bar-<span class="keyword">values</span>;</div><div class="line">  method plot &#123;</div><div class="line">    <span class="keyword">say</span> @.bar-<span class="keyword">values</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class line-chart &#123;</div><div class="line">  has Int @.line-<span class="keyword">values</span>;</div><div class="line">  method plot &#123;</div><div class="line">    <span class="keyword">say</span> @.line-<span class="keyword">values</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class combo-chart is bar-chart is line-chart &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $actual-sales   = bar-chart.new(bar<span class="string">-values =&gt;</span> [<span class="number">10</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">10</span>]);</div><div class="line"><span class="keyword">my</span> $forecast-sales = line-chart.new(line<span class="string">-values =&gt;</span> [<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>]);</div><div class="line"></div><div class="line"><span class="keyword">my</span> $actual-vs-forecast = combo-chart.new(bar<span class="string">-values =&gt;</span> [<span class="number">10</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">10</span>],</div><div class="line">                                         line<span class="string">-values =&gt;</span> [<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>]);</div><div class="line"><span class="keyword">say</span> <span class="string">"实际的销售: "</span>;</div><div class="line">$actual-sales.plot;</div><div class="line"><span class="keyword">say</span> <span class="string">"预测的销售: "</span>;</div><div class="line">$forecast-sales.plot;</div><div class="line"><span class="keyword">say</span> <span class="string">"实际 vs 预测:"</span>;</div><div class="line">$actual-vs-forecast.plot;</div></pre></td></tr></table></figure>
<p><code>输出</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">实际的销售:</div><div class="line">[10 9 11 8 7 10]</div><div class="line">预测的销售:</div><div class="line">[9 8 10 7 6 9]</div><div class="line">实际 vs 预测:</div><div class="line">[10 9 11 8 7 10]</div></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p><code>combo-chart</code> 类应该能持有两个序列, 一个是绘制条形图的实际值, 另一个是绘制折线图的预测值。</p>
<p>这就是我们为什么把它定义为 <code>line-chart</code> 和 <code>bar-chart</code> 的孩子的原因。</p>
<p>你应该注意到了, 在 <code>combo-chart</code> 身上调用 <code>plot</code> 方法并没有产生所要求的结果。它只绘制了一个序列。</p>
<p>发生了什么事?</p>
<p><code>combo-chart</code> 继承自 <code>line-chart</code> 和 <code>bar-chart</code>, 它们都有一个叫做 <code>plot</code> 的方法。当我们在 <code>combo-chart</code> 身上调用那个方法时, Perl 6 内部会尝试通过调用其所继承的方法之一来解决冲突。</p>
<p><strong>纠正</strong></p>
<p>为了表现得正确, 我们应该在 <code>combo-chart</code> 中重写 <code>plot</code> 方法。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class bar-chart &#123;</div><div class="line">  has Int @.bar-<span class="keyword">values</span>;</div><div class="line">  method plot &#123;</div><div class="line">    <span class="keyword">say</span> @.bar-<span class="keyword">values</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class line-chart &#123;</div><div class="line">  has Int @.line-<span class="keyword">values</span>;</div><div class="line">  method plot &#123;</div><div class="line">    <span class="keyword">say</span> @.line-<span class="keyword">values</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class combo-chart is bar-chart is line-chart &#123;</div><div class="line">  method plot &#123;</div><div class="line">    <span class="keyword">say</span> @.bar-<span class="keyword">values</span>;</div><div class="line">    <span class="keyword">say</span> @.line-<span class="keyword">values</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $actual-sales = bar-chart.new(bar<span class="string">-values =&gt;</span> [<span class="number">10</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">10</span>]);</div><div class="line"><span class="keyword">my</span> $forecast-sales = line-chart.new(line<span class="string">-values =&gt;</span> [<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>]);</div><div class="line"></div><div class="line"><span class="keyword">my</span> $actual-vs-forecast = combo-chart.new(bar<span class="string">-values =&gt;</span> [<span class="number">10</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">10</span>],</div><div class="line">                                         line<span class="string">-values =&gt;</span> [<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>]);</div><div class="line"><span class="keyword">say</span> <span class="string">"实际的销售: "</span>;</div><div class="line">$actual-sales.plot;</div><div class="line"><span class="keyword">say</span> <span class="string">"预测的销售: "</span>;</div><div class="line">$forecast-sales.plot;</div><div class="line"><span class="keyword">say</span> <span class="string">"实际 vs 预测:"</span>;</div><div class="line">$actual-vs-forecast.plot;</div></pre></td></tr></table></figure>
<p><code>输出</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">实际的销售:</div><div class="line">[10 9 11 8 7 10]</div><div class="line">预测的销售:</div><div class="line">[9 8 10 7 6 9]</div><div class="line">实际 vs 预测:</div><div class="line">[10 9 11 8 7 10]</div><div class="line">[9 8 10 7 6 9]</div></pre></td></tr></table></figure>
<h3 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h3><p>　<br><strong>Roles</strong> 在它们是属性和方法的集合这个意义上和类有点类似。<br>Roles 使用关键字 <code>role</code> 声明, 而想实现该 role 的类可以使用 <code>does</code> 关键字。</p>
<p><strong>使用 roles 重写多重继承的例子</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">role bar-chart &#123;</div><div class="line">  has Int @.bar-<span class="keyword">values</span>;</div><div class="line">  method plot &#123;</div><div class="line">    <span class="keyword">say</span> @.bar-<span class="keyword">values</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">role line-chart &#123;</div><div class="line">  has Int @.line-<span class="keyword">values</span>;</div><div class="line">  method plot &#123;</div><div class="line">    <span class="keyword">say</span> @.line-<span class="keyword">values</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class combo-chart does bar-chart does line-chart &#123;</div><div class="line">  method plot &#123;</div><div class="line">    <span class="keyword">say</span> @.bar-<span class="keyword">values</span>;</div><div class="line">    <span class="keyword">say</span> @.line-<span class="keyword">values</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $actual-sales = bar-chart.new(bar<span class="string">-values =&gt;</span> [<span class="number">10</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">10</span>]);</div><div class="line"><span class="keyword">my</span> $forecast-sales = line-chart.new(line<span class="string">-values =&gt;</span> [<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>]);</div><div class="line"></div><div class="line"><span class="keyword">my</span> $actual-vs-forecast = combo-chart.new(bar<span class="string">-values =&gt;</span> [<span class="number">10</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">10</span>],</div><div class="line">                                         line<span class="string">-values =&gt;</span> [<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>]);</div><div class="line"><span class="keyword">say</span> <span class="string">"实际的销售: "</span>;</div><div class="line">$actual-sales.plot;</div><div class="line"><span class="keyword">say</span> <span class="string">"预测的销售: "</span>;</div><div class="line">$forecast-sales.plot;</div><div class="line"><span class="keyword">say</span> <span class="string">"实际 vs 预测:"</span>;</div><div class="line">$actual-vs-forecast.plot;</div></pre></td></tr></table></figure>
<p>运行上面的脚本你会看到结果是一样的。</p>
<p>现在你问问自己, 如果 roles 表现得像类的话那么它们的用途是什么呢?</p>
<p>要回答你的问题, 修改第一个用于展示多重继承的脚本,  这个脚本中我们忘记重写 <code>plot</code> 方法了。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">role bar-chart &#123;</div><div class="line">  has Int @.bar-<span class="keyword">values</span>;</div><div class="line">  method plot &#123;</div><div class="line">    <span class="keyword">say</span> @.bar-<span class="keyword">values</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">role line-chart &#123;</div><div class="line">  has Int @.line-<span class="keyword">values</span>;</div><div class="line">  method plot &#123;</div><div class="line">    <span class="keyword">say</span> @.line-<span class="keyword">values</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class combo-chart does bar-chart does line-chart &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $actual-sales = bar-chart.new(bar<span class="string">-values =&gt;</span> [<span class="number">10</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">10</span>]);</div><div class="line"><span class="keyword">my</span> $forecast-sales = line-chart.new(line<span class="string">-values =&gt;</span> [<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>]);</div><div class="line"></div><div class="line"><span class="keyword">my</span> $actual-vs-forecast = combo-chart.new(bar<span class="string">-values =&gt;</span> [<span class="number">10</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">10</span>],</div><div class="line">                                         line<span class="string">-values =&gt;</span> [<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>]);</div><div class="line"><span class="keyword">say</span> <span class="string">"Actual sales:"</span>;</div><div class="line">$actual-sales.plot;</div><div class="line"><span class="keyword">say</span> <span class="string">"Forecast sales:"</span>;</div><div class="line">$forecast-sales.plot;</div><div class="line"><span class="keyword">say</span> <span class="string">"Actual vs Forecast:"</span>;</div><div class="line">$actual-vs-forecast.plot;</div></pre></td></tr></table></figure>
<p><code>输出</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">===SORRY!===</div><div class="line">Method &apos;plot&apos; must be resolved by class combo-chart because it exists in multiple roles (line-chart, bar-chart)</div></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>如果多个 roles 被应用到同一个类中, 会出现冲突并抛出一个编译时错误。<br>这是比多重继承更安全的方法, 其中冲突不被认为是错误并且简单地在运行时解决。<br>Roles 会提醒你有冲突。</p>
<h3 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h3><p>　<br><strong>内省</strong>是获取诸如对象的类型、属性或方法等对象属性的信息的过程。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Human &#123;</div><div class="line">  has Str $.name;</div><div class="line">  has Int $.age;</div><div class="line">  method introduce-yourself &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">'Hi i am a human being, my name is '</span> ~ self.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Employee is Human &#123;</div><div class="line">  has Str $.company;</div><div class="line">  has Int $.salary;</div><div class="line">  method introduce-yourself &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">'Hi i am a employee, my name is '</span> ~ self.name ~ <span class="string">' and I work at: '</span> ~ self.company;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $john = Human.new(<span class="string">name =&gt;</span><span class="string">'John'</span>,<span class="string">age =&gt;</span> <span class="number">23</span>,);</div><div class="line"><span class="keyword">my</span> $jane = Employee.new(<span class="string">name =&gt;</span><span class="string">'Jane'</span>,<span class="string">age =&gt;</span> <span class="number">25</span>,<span class="string">company =&gt;</span> <span class="string">'Acme'</span>,<span class="string">salary =&gt;</span> <span class="number">4000</span>);</div><div class="line"></div><div class="line"><span class="keyword">say</span> $john.WHAT;</div><div class="line"><span class="keyword">say</span> $jane.WHAT;</div><div class="line"><span class="keyword">say</span> $john.^attributes;</div><div class="line"><span class="keyword">say</span> $jane.^attributes;</div><div class="line"><span class="keyword">say</span> $john.^methods;</div><div class="line"><span class="keyword">say</span> $jane.^methods;</div><div class="line"><span class="keyword">say</span> $jane.^parents;</div><div class="line"><span class="keyword">if</span> $jane ~~ Human &#123;<span class="keyword">say</span> <span class="string">'Jane is a Human'</span>&#125;;</div></pre></td></tr></table></figure>
<p>内省使用了:</p>
<ul>
<li><code>.WHAT</code>  返回已经创建的对象所属的类。</li>
<li><code>.^attributes</code> 返回一个包含该对象所有属性的列表。</li>
<li><code>.^mtethods</code> 返回能在该对象身上调用的所有方法。</li>
<li><code>.^parents</code> 返回该对象所属类的所有父类。</li>
<li><code>~~</code> 叫做智能匹配操作符。如果对象是从它所进行比较的类或任何它继承的类创建的, 则计算为 True。</li>
</ul>
<h2 id="第十章-异常处理"><a href="#第十章-异常处理" class="headerlink" title="第十章 异常处理"></a>第十章 异常处理</h2><hr>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>　　<br><strong>异常</strong>是当某些东西出错时发生在运行时的特殊行为。<br>我们说异常被抛出。<br>考虑下面这个运行正确的脚本:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> Str $name;</div><div class="line">$name = <span class="string">"Joanna"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"Hello "</span> ~ $name;</div><div class="line"><span class="keyword">say</span> <span class="string">"How are you doing today?"</span></div></pre></td></tr></table></figure>
<p><code>输出</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello Joanna</div><div class="line">How are you doing today?</div></pre></td></tr></table></figure>
<p>现在让这个脚本抛出异常:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> Str $name;</div><div class="line">$name = <span class="number">123</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"Hello "</span> ~ $name;</div><div class="line"><span class="keyword">say</span> <span class="string">"How are you doing today?"</span></div></pre></td></tr></table></figure>
<p><code>输出</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Type check failed in assignment to $name; expected Str but got Int</div><div class="line">   in block &lt;unit&gt; at exceptions.pl6:2</div></pre></td></tr></table></figure>
<p>你应该看到当错误出现时(在这个例子中把数组赋值给字符串变量)程序会停止并且其它行的代码不会被执行, 即使它们是正确的。</p>
<p><strong>异常处理</strong>是捕获已经抛出的异常的过程以使脚本能继续工作。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> Str $name;</div><div class="line">try &#123;</div><div class="line">  $name = <span class="number">123</span>;</div><div class="line">  <span class="keyword">say</span> <span class="string">"Hello "</span> ~ $name;</div><div class="line">  CATCH &#123;</div><div class="line">    default &#123;</div><div class="line">      <span class="keyword">say</span> <span class="string">"Can you tell us your name again, we couldn't find it in the register."</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">say</span> <span class="string">"How are you doing today?"</span>;</div></pre></td></tr></table></figure>
<p><code>输出</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Can you tell us your name again, we couldn&apos;t find it in the register.</div><div class="line">How are you doing today?</div></pre></td></tr></table></figure>
<p>异常处理是使用 <code>try-catch</code> block 完成的。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  <span class="comment"># code goes in here</span></div><div class="line">  <span class="comment"># 如果有东西出错, 脚本会进入到下面的 CATCH block 中</span></div><div class="line">  <span class="comment"># 如果什么错误也没有, 那么 CATCH block 会被忽略</span></div><div class="line">  CATCH &#123;</div><div class="line">    default &#123;</div><div class="line">      <span class="comment"># 只有抛出异常时, 这儿的代码才会被求值</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>CATCH</code> block 能像定义 <code>given</code> block 那样定义。这意味着我们能捕获并处理各种不同类型的异常。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  <span class="comment">#code goes in here</span></div><div class="line">  <span class="comment">#if anything goes wrong, the script will enter the below CATCH block</span></div><div class="line">  <span class="comment">#if nothing goes wrong the CATCH block will be ignored</span></div><div class="line">  CATCH &#123;</div><div class="line">    <span class="keyword">when</span> X::AdHoc &#123; <span class="comment">#do something if an exception of type X::AdHoc is thrown &#125;</span></div><div class="line">    <span class="keyword">when</span> X::IO &#123; <span class="comment">#do something if an exception of type X::IO is thrown &#125;</span></div><div class="line">    <span class="keyword">when</span> X::OS &#123; <span class="comment">#do something if an exception of type X::OS is thrown &#125;</span></div><div class="line">    default &#123; <span class="comment">#do something if an exception is thrown and doesn't belong to the above types &#125;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>　<br>和捕获异常相比, Perl  6 也允许你显式地抛出异常。<br>有两种类型的异常可以抛出:</p>
<ul>
<li>ad-hoc 异常</li>
<li>类型异常</li>
</ul>
<p><strong>ad-hoc</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> Int $age = <span class="number">21</span>;</div><div class="line"><span class="keyword">die</span> <span class="string">"Error !"</span>;</div></pre></td></tr></table></figure>
<p><strong>typed</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> Int $age = <span class="number">21</span>;</div><div class="line">X::AdHoc.new(<span class="string">payload =&gt;</span> <span class="string">'Error !'</span>).throw;</div></pre></td></tr></table></figure>
<p>使用 <code>die</code> 子例程后面跟着异常消息来抛出 Ad-hoc 异常。</p>
<p>Typed 异常是对象, 因此上面的例子中使用了 <code>.new()</code> 构造函数。</p>
<p>所有类型化的异常都是从类 <code>X</code> 开始, 下面是一些例子:</p>
<p><code>X::AdHoc</code> 是最简单的异常类型</p>
<p><code>X::IO</code> 跟 IO 错误有关。</p>
<p><code>X::OS</code> 跟 OS 错误有关。</p>
<p><code>X::Str::Numeric</code> 跟把字符串强制转换为数字有关。</p>
<blockquote>
<p>查看异常类型和相关方法的完整列表请到  <a href="http://doc.perl6.org/type.html" target="_blank" rel="external">http://doc.perl6.org/type.html</a> 并导航到以 X 开头的类型。</p>
</blockquote>
<h2 id="第十一章-正则表达式"><a href="#第十一章-正则表达式" class="headerlink" title="第十一章 正则表达式"></a>第十一章 正则表达式</h2><hr>
<p>正则表达式, 或 <strong>regex</strong> 是一个用于模式匹配的字符序列。</p>
<p>理解它最简单的一种方式是把它看作模式。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'enlightenment'</span> ~~ <span class="regexp">m/ light /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"enlightenment contains the word light"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中, 智能匹配操作符 <code>~~</code> 用于检查一个字符串(enlightenment)是否包含一个单词(light)。</p>
<p>“Enlightenment”  与正则表达式 <code>m/ light /</code> 匹配。</p>
<h3 id="Regex-定义"><a href="#Regex-定义" class="headerlink" title="Regex 定义"></a>Regex 定义</h3><p>　<br>正则表达式可以按如下方式定义:</p>
<ul>
<li>/light/</li>
<li>m/light/</li>
<li>rx/light/</li>
</ul>
<p>除非显式地指定, 否则空白是无关紧要的, <code>m/light/</code> 和 <code>m/ light /</code> 是相同的。</p>
<h3 id="匹配字符"><a href="#匹配字符" class="headerlink" title="匹配字符"></a>匹配字符</h3><p>　<br>字母数字字符和下划线 <code>_</code> 在正则表达式中是按原样写出的。</p>
<p>所有其它字符必须使用反斜线或用引号围起来以转义。</p>
<p><strong>反斜线</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'Temperature: 13'</span> ~~ <span class="regexp">m/ \: /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"The string provided contains a colon :"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>单引号</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'Age = 13'</span> ~~ <span class="regexp">m/ '=' /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"The string provided contains an equal character = "</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>双引号</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'name@company.com'</span> ~~ <span class="regexp">m/ "@" /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"This is a valid email address because it contains an @ character"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="匹配字符类"><a href="#匹配字符类" class="headerlink" title="匹配字符类"></a>匹配字符类</h3><p>　<br>就像之前章节看到的, 匹配字符类很方便。</p>
<p>话虽这么说，更系统的方法是使用 Unicode 属性。</p>
<p>Unicode 属性闭合在 <code>&lt;: &gt;</code> 中。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">"John123"</span> ~~ <span class="regexp">/ &lt;:N&gt; /</span> &#123;</div><div class="line">  <span class="keyword">say</span> <span class="string">"Contains a number"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">say</span> <span class="string">"Doesn't contain a number"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">"John-Doe"</span> ~~ <span class="regexp">/ &lt;:Lu&gt; /</span> &#123;</div><div class="line">  <span class="keyword">say</span> <span class="string">"Contains an uppercase letter"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">say</span> <span class="string">"Doesn't contain an upper case letter"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">"John-Doe"</span> ~~ <span class="regexp">/ &lt;:Pd&gt; /</span> &#123;</div><div class="line">  <span class="keyword">say</span> <span class="string">"Contains a dash"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">say</span> <span class="string">"Doesn't contain a dash"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>　<br>通配符也可以用在正则表达式中。</p>
<p>点 <code>.</code> 意味着任何单个字符。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'abc'</span> ~~ <span class="regexp">m/ a.c /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'a2c'</span> ~~ <span class="regexp">m/ a.c /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'ac'</span> ~~ <span class="regexp">m/ a.c /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>　<br>量词在字符后面用于指定我们期望匹配它前面的东西的次数。</p>
<p>问号 <code>?</code> 意思是 0 或 1 次。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'ac'</span> ~~ <span class="regexp">m/ a?c /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'c'</span> ~~ <span class="regexp">m/ a?c /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>星号 <code>*</code> 意思是 0 或多次。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'az'</span> ~~ <span class="regexp">m/ a*z /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'aaz'</span> ~~ <span class="regexp">m/ a*z /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'aaaaaaaaaaz'</span> ~~ <span class="regexp">m/ a*z /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'z'</span> ~~ <span class="regexp">m/ a*z /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>+</code> 意思是至少匹配 1 次。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'az'</span> ~~ <span class="regexp">m/ a+z /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'aaz'</span> ~~ <span class="regexp">m/ a+z /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'aaaaaaaaaaz'</span> ~~ <span class="regexp">m/ a+z /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'z'</span> ~~ <span class="regexp">m/ a+z /</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"Match"</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"No Match"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="匹配结果"><a href="#匹配结果" class="headerlink" title="匹配结果"></a>匹配结果</h3><p>　<br>当匹配字符串的正则表达式成功时, 匹配结果被存储在一个特殊的变量 <code>$/</code> 中。</p>
<p><strong>脚本</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'Rakudo is a Perl 6 compiler'</span> ~~ <span class="regexp">m/:s Perl 6/</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"The match is: "</span> ~ $/;</div><div class="line">    <span class="keyword">say</span> <span class="string">"The string before the match is: "</span> ~ $/.prematch;</div><div class="line">    <span class="keyword">say</span> <span class="string">"The string after the match is: "</span> ~ $/.postmatch;</div><div class="line">    <span class="keyword">say</span> <span class="string">"The matching string starts at position: "</span> ~ $/.from;</div><div class="line">    <span class="keyword">say</span> <span class="string">"The matching string ends at position: "</span> ~ $/.to;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The match is: Perl <span class="number">6</span></div><div class="line">The string before the match is: Rakudo is a</div><div class="line">The string after the match is:  compiler</div><div class="line">The matching string starts at position: <span class="number">12</span></div><div class="line">The matching string ends at position: <span class="number">18</span></div></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p><code>$/</code> 返回一个 <strong>Match Object</strong>(匹配 regex 的字符串)。</p>
<p>下面的方法可以在 <strong>Match Object</strong> 身上调用:</p>
<p><code>.prematch</code> 返回匹配前面的字符串</p>
<p><code>.postmatch</code> 返回匹配后面的字符串</p>
<p><code>.from</code> 返回匹配的开始位置</p>
<p><code>.to</code> 返回匹配的结束位置</p>
<blockquote>
<p>默认地空白在 regex 中是无关紧要的。<br>如果我们想在 regex 中包含空白, 我们必须显式地这样做。<br>regex <code>m/:s Perl 6/</code> 中的 <code>:s</code> 强制考虑空白并且不会被删除。<br>二选一, 我们能把 regex 写为 <code>m/Perl\s6/</code> 并使用 <code>\s</code> 占位符。<br>如果 regex 中包含的空白不止一个, 使用 <code>:s</code> 比使用 <code>\s</code> 更高效。</p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>　<br>让我们检查一个邮件是否合法。</p>
<p>我们假设一个合法的电子邮件地址的形式如下:</p>
<p>first name [dot] last name [at] company [dot] (com/org/net)</p>
<blockquote>
<p>这个例子中用于电子邮件检测的 regex 不是很准确。它的核心意图是用来解释 Perl 6 中的 regex 的功能的。 不要在生产中原样使用它。</p>
</blockquote>
<p><strong>脚本</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $email = <span class="string">'john.doe@perl6.org'</span>;</div><div class="line"><span class="keyword">my</span> $regex = <span class="regexp">/ &lt;:L&gt;+\.&lt;:L&gt;+\@&lt;:L+:N&gt;+\.&lt;:L&gt;+ /</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> $email ~~ $regex &#123;</div><div class="line">  <span class="keyword">say</span> $/ ~ <span class="string">" is a valid email"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">say</span> <span class="string">"This is not a valid email"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">john.doe@perl6.org is a valid email</div></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p><code>&lt;:L&gt;</code>  匹配单个字符<br><code>&lt;:L&gt;+</code> 匹配单个字符或更多字符<br><code>\.</code>  匹配单个点号字符<br><code>\@</code>  匹配单个  [at] 符号<br><code>&lt;:L+:N&gt;</code> 匹配一个字母和数字<br><code>&lt;:L+:N&gt;+</code> 匹配一个或多个字母和数字</p>
<p>其中的 regex 可以分解成如下:</p>
<ul>
<li><strong>first name</strong> <code>&lt;:L&gt;+</code></li>
<li><strong>[dot]</strong> <code>\.</code></li>
<li><strong>last name</strong> <code>&lt;:L&gt;+</code></li>
<li><strong>[at]</strong> <code>\@</code></li>
<li><strong>company name</strong> <code>&lt;:L+:N&gt;+</code></li>
<li><strong>[dot]</strong> <code>\.</code></li>
<li><strong>com/org/net</strong> <code>&lt;:L&gt;+</code></li>
</ul>
<p>可选地, 一个 regex 可以被分解成多个具名 regexes。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $email = <span class="string">'john.doe@perl6.org'</span>;</div><div class="line"><span class="keyword">my</span> regex many-letters &#123; &lt;:L&gt;+ &#125;;</div><div class="line"><span class="keyword">my</span> regex dot &#123; \. &#125;;</div><div class="line"><span class="keyword">my</span> regex at &#123; \@ &#125;;</div><div class="line"><span class="keyword">my</span> regex many-letters-numbers &#123; &lt;:L+:N&gt;+ &#125;;</div><div class="line"></div><div class="line"><span class="keyword">if</span> $email ~~ <span class="regexp">/ &lt;many-letters&gt; &lt;dot&gt; &lt;many-letters&gt; &lt;at&gt; &lt;many-letters-numbers&gt; &lt;dot&gt; &lt;many-letters&gt; /</span> &#123;</div><div class="line">  <span class="keyword">say</span> $/ ~ <span class="string">" is a valid email"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">say</span> <span class="string">"This is not a valid email"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具名 regex 是使用 <code>my regex regex-name { regex definition }</code> 定义的。</p>
<p>具名 regex 可以使用 <code>&lt;regex-name&gt;</code> 来调用。</p>
<blockquote>
<p>更多关于 regexes 的东西, 查看 <a href="http://doc.perl6.org/language/regexes" target="_blank" rel="external">http://doc.perl6.org/language/regexes</a></p>
</blockquote>
<h2 id="第十二章-Perl-6-模块"><a href="#第十二章-Perl-6-模块" class="headerlink" title="第十二章 Perl 6 模块"></a>第十二章 Perl 6 模块</h2><hr>
<p>Rakudo 自带了 Panda 这个模块安装工具。</p>
<p>要安装指定的模块, 在终端中键入如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">panda install &quot;module name&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>Perl  6 的模块目录可以在  <a href="http://modules.perl6.org/" target="_blank" rel="external">http://modules.perl6.org/</a> 中找到。</p>
</blockquote>
<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>　<br>MD5是一个关于密码的散列函数，它产生一个128位的散列值。<br>MD5有多种加密存储在数据库中的口令的应用程序。当新用户注册时，其证书并不存储为纯文本，而是散列。这样做的理由是，如果该数据库被破解，攻击者将不能够知道口令是什么。</p>
<p>比方说，你需要一个生成密码的MD5哈希以存储在数据库中备用的脚本。</p>
<p>幸运的是， Perl 6 已经有一个能实现MD5算法的模块。我们安装下:</p>
<p><code>panda install Digest::MD5</code></p>
<p>现在运行下面的脚本:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> Digest::MD5;</div><div class="line"><span class="keyword">my</span> $password = <span class="string">"password123"</span>;</div><div class="line"><span class="keyword">my</span> $hashed-password = Digest::MD5.new.md5_hex($password);</div><div class="line"></div><div class="line"><span class="keyword">say</span> $hashed-password;</div></pre></td></tr></table></figure>
<p>为了运行创建哈希的 <code>md5_hex()</code> 函数, 我们需要加载需要的模块。<code>use</code> 关键字用于加载模块。</p>
<h2 id="第十三章-Unicode"><a href="#第十三章-Unicode" class="headerlink" title="第十三章 Unicode"></a>第十三章 Unicode</h2><hr>
<p>Unicode 是编码并表现文本的标准, 它满足了世界上的大部分系统。</p>
<p>UTF-8 是能够以Unicode编码所有可能的字符或代码点的字符编码。</p>
<p>字符的定义是通过:</p>
<p><strong>字素</strong>: 可见的表示</p>
<p><strong>代码点</strong>: 赋值给字符的数字</p>
<h3 id="使用-Unicode"><a href="#使用-Unicode" class="headerlink" title="使用 Unicode"></a>使用 Unicode</h3><p>　<br><strong>让我们看一下使用 Unicode 能输出什么</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> <span class="string">"a"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"\x0061"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"\c[LATIN SMALL LETTER A]"</span>;</div></pre></td></tr></table></figure>
<p>上面 3 行展示了构建字符的不同方法:</p>
<ol>
<li>直接写出字符(字素)</li>
<li>使用 <code>\x</code> 和代码点</li>
<li>使用 <code>\c</code> 和代码点名字</li>
</ol>
<p><strong>现在我们来输出笑脸</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> <span class="string">"☺"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"\x263a"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"\c[WHITE SMILING FACE]"</span>;</div></pre></td></tr></table></figure>
<p><strong>组合两个代码点的另外一个例子</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> <span class="string">"á"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"\x00e1"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"\x0061\x0301"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"\c[LATIN SMALL LETTER A WITH ACUTE]"</span>;</div></pre></td></tr></table></figure>
<p>字母 <code>á</code> 可以被写为:</p>
<ul>
<li>使用它的唯一代码点 <code>\x00e1</code></li>
<li>或作为 <code>a</code> 和 重音符号 <code>\x0061\x0301</code> 代码点的组合</li>
</ul>
<p><strong>有些方法可以使用</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> <span class="string">"á"</span>.NFC;</div><div class="line"><span class="keyword">say</span> <span class="string">"á"</span>.NFD;</div><div class="line"><span class="keyword">say</span> <span class="string">"á"</span>.uniname;</div></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NFC:0x&lt;00e1&gt;</div><div class="line">NFD:0x&lt;0061 0301&gt;</div><div class="line">LATIN SMALL LETTER A WITH ACUTE</div></pre></td></tr></table></figure>
<p><code>NFC</code> 返回唯一的代码点。</p>
<p><code>NFD</code> 分解(decompose)那个字符并返回每部分的代码点。</p>
<p><code>uniname</code> 返回代码点的名字。</p>
<p><strong>Unicode 字符可以用作标识符</strong>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $Δ = <span class="number">1</span>;</div><div class="line">$Δ++;</div><div class="line"><span class="keyword">say</span> $Δ;</div></pre></td></tr></table></figure>
<h2 id="第十四章-并行、并发和异步"><a href="#第十四章-并行、并发和异步" class="headerlink" title="第十四章 并行、并发和异步"></a>第十四章 并行、并发和异步</h2><hr>
<p>在正常情况下, 程序中的所有任务都是相继地运行的。</p>
<p>这可能不是个事儿除非你正尝试去做的东西需要耗费很多时间。</p>
<p>很自然地说, Perl 6 拥有能让你并行地运行东西的功能。</p>
<p>在这个阶段, 注意并行可以是下面两个东西之一是很重要的:</p>
<ul>
<li><strong>任务并行化</strong>: 两个(或更多)独立的表达式并行地运行。</li>
<li><strong>数据并行化</strong>: 单个表达式并行地迭代列表中的元素。</li>
</ul>
<p>让我们从后者开始。</p>
<h3 id="数据并行化"><a href="#数据并行化" class="headerlink" title="数据并行化　"></a>数据并行化　</h3><p>　<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array = (<span class="number">0</span>..<span class="number">50000</span>);                     <span class="comment">#Array population</span></div><div class="line"><span class="keyword">my</span> @result = @array.map(&#123; is-prime $_ &#125;);   <span class="comment">#call is-prime for each array element</span></div><div class="line"><span class="keyword">say</span> now - INIT now;                         <span class="comment">#Output the time it took for the script to complete</span></div></pre></td></tr></table></figure></p>
<p><strong>考虑上面的例子</strong><br>　<br>我们只做一个操作 <code>@array.map({is-prime $_})</code>。<code>is-prime</code> 子例程相继被每个数组元素所调用:</p>
<p><code>is-prime @array[0]</code> 然后是 <code>is-prime @array[1]</code> 然后是 <code>is-prime @array[2]</code> 等等。</p>
<p><strong>幸运的是, 我们能同时在多个数组元素身上调用 <code>is-prime</code> 函数:</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array = (<span class="number">0</span>..<span class="number">50000</span>);                         <span class="comment">#Array population</span></div><div class="line"><span class="keyword">my</span> @result = @array.race.map(&#123; is-prime $_ &#125;);  <span class="comment">#call is-prime for each array element</span></div><div class="line"><span class="keyword">say</span> now - INIT now;                             <span class="comment">#Output the time it took to complete</span></div></pre></td></tr></table></figure>
<p>注意表达式中使用的 <code>race</code>。这个方法会使数组元素能够并行地迭代。</p>
<p>运行两个例子(使用和不使用 <code>race</code>)运行之后, 比较两个脚本运行结束所花费的时间。</p>
<blockquote>
<p><code>race</code> 不会保存元素的顺序。如果你想那样做, 使用 <code>hyper</code> 代替。</p>
<p><strong>race</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span> @array = (<span class="number">1</span>..<span class="number">1000</span>);</div><div class="line">&gt; <span class="keyword">my</span> @result = @array.race.map( &#123;$_ + <span class="number">1</span>&#125; );</div><div class="line">&gt; @result».say;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>hyper</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span> @array = (<span class="number">1</span>..<span class="number">1000</span>);</div><div class="line">&gt; <span class="keyword">my</span> @result = @array.hyper.map( &#123;$_ + <span class="number">1</span>&#125; );</div><div class="line">&gt; @result».say;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>如果你俩个脚本都运行了, 你应该注意到一个排序了一个没有排序。</p>
</blockquote>
<h3 id="任务并行化"><a href="#任务并行化" class="headerlink" title="任务并行化"></a>任务并行化</h3><p>　<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array1 = (<span class="number">0</span>..<span class="number">49999</span>);</div><div class="line"><span class="keyword">my</span> @array2 = (<span class="number">2</span>..<span class="number">50001</span>);</div><div class="line"></div><div class="line"><span class="keyword">my</span> @result1 = @array1.map( &#123;is-prime($_ + <span class="number">1</span>)&#125; );</div><div class="line"><span class="keyword">my</span> @result2 = @array2.map( &#123;is-prime($_ - <span class="number">1</span>)&#125; );</div><div class="line"></div><div class="line"><span class="keyword">say</span> @result1 == @result2;</div><div class="line"></div><div class="line"><span class="keyword">say</span> now - INIT now;</div></pre></td></tr></table></figure></p>
<p><strong>考虑上面的例子</strong>:</p>
<ol>
<li>我们定义了 2 个数组</li>
<li>对每个数组应用不同的操作并保存结果</li>
<li>并检查两个结果是否相同</li>
</ol>
<p>该脚本等到 <code>@array1.map( {is-prime($_ +1)} )</code> 完成然后计算 <code>@array1.map( {is-prime($_ +1)} )</code>。</p>
<p>应用到每个数组的俩个操作彼此间没有依赖。</p>
<p><strong>为什么不并行地执行呢?</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array1 = (<span class="number">0</span>..<span class="number">49999</span>);</div><div class="line"><span class="keyword">my</span> @array2 = (<span class="number">2</span>..<span class="number">50001</span>);</div><div class="line"></div><div class="line"><span class="keyword">my</span> $promise1 = start @array1.map( &#123;$_ + <span class="number">1</span>&#125; );</div><div class="line"><span class="keyword">my</span> $promise2 = start @array2.map( &#123;$_ - <span class="number">1</span>&#125; );</div><div class="line"></div><div class="line"><span class="keyword">my</span> @result1 = await $promise1;</div><div class="line"><span class="keyword">my</span> @result2 = await $promise2;</div><div class="line"></div><div class="line"><span class="keyword">say</span> @result1 == @result2;</div><div class="line"></div><div class="line"><span class="keyword">say</span> now - INIT now;</div></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p><code>start</code> 方法计算它后面的代码并返回<strong>promise 类型的对象</strong>或<strong>promise</strong>。</p>
<p>如果代码被正确地求值, 那么 promise 会被<strong>保留</strong>(kept)。</p>
<p>如果代码抛出异常, 那么 promise 会被<strong>破坏</strong>(broken)。</p>
<p><code>await</code> 方法等待一个 <strong>promise</strong>。</p>
<p>如果那个 promise 是被<strong>保留</strong>的, await 会获取到返回值。</p>
<p>如果那个 promise 是被<strong>破坏</strong>的, await 会获取到抛出异常。</p>
<p>检查每个脚本完成所花费的时间。</p>
<blockquote>
<p>并行总是添加线程开销。如果开销抵消不了运算速度的增长，那么该脚本会显得较慢。<br>这就是为什么，在很简单的脚本中使用 <strong>race</strong>，<strong>hyper</strong>，<strong>start</strong> 和 <strong>await</strong> 实际上可以使它们慢下来。</p>
</blockquote>
<h3 id="并发和异步"><a href="#并发和异步" class="headerlink" title="并发和异步"></a>并发和异步</h3><p>　</p>
<blockquote>
<p> 关于并发和异步编程的更多信息, 请查看  <a href="http://doc.perl6.org/language/concurrency" target="_blank" rel="external">http://doc.perl6.org/language/concurrency</a></p>
</blockquote>
<h2 id="第十五章-社区"><a href="#第十五章-社区" class="headerlink" title="第十五章 社区"></a>第十五章 社区</h2><hr>
<p>很多讨论发生在 <a href="irc://irc.freenode.net/#perl6" target="_blank" rel="external">#perl6</a> IRC 频道中。你可以到 <a href="http://perl6.org/community/irc" target="_blank" rel="external">http://perl6.org/community/irc</a> 进行任何询问。</p>
<p><a href="http://pl6anet.org/" target="_blank" rel="external">http://pl6anet.org/</a> 是一个 Perl 6 博客聚合器。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[stackoverflow0902]]></title>
      <url>http://ohmycloud.github.io/2015/12/18/stackoverflow0902/</url>
      <content type="html"><![CDATA[<p><a href="http://stackoverflow.com/questions/37979519/how-do-i-chain-to-an-inline-block-in-perl-6" target="_blank" rel="external">How do I chain to an inline block in Perl 6?</a></p>
<p>我想修改一个数组(我在这个例子中使用了 <code>splice</code>, 但是它也可能是修改数组的任何操作)并返回修改后的数组 - 和 <code>slice</code> 不一样, slice 返回的是从数组中抠出的项。我可以很容易地通过在数组中存储一个 block 来做到, 就像下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $1 = -&gt; $a &#123; splice($a,1,3,[1,2,3]); $a &#125;;</div><div class="line">say (^6).map( &#123; $_ &lt; 4 ?? 0 !! $_ &#125; ).Array;</div><div class="line"># [0 0 0 0 4 5]</div><div class="line">say (^6).map( &#123; $_ &lt; 4 ?? 0 !! $_ &#125; ).Array.$1;</div><div class="line"># [0 1 2 3 4 5]</div></pre></td></tr></table></figure>
<p>我怎么把由 <code>$1</code> 代表的 block 内联到单个表达式中呢？ 下面的解决方法不正确:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say (^6).map( &#123; $_ &lt; 4 ?? 0 !! $_ &#125; ).Array.(-&gt; $a &#123; splice($a,1,3,[1,2,3]); $a &#125;)</div><div class="line">Invocant requires a type object of type Array, but an object instance was passed.  Did you forget a &apos;multi&apos;?</div></pre></td></tr></table></figure>
<p>解决方法是添加一个 <code>&amp;</code> 符号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say (^6).map( &#123; $_ &lt; 4 ?? 0 !! $_ &#125; ).Array.&amp;(-&gt; $a &#123; splice($a,1,3,[1,2,3]); $a &#125;)</div><div class="line"># 输出 [0 1 2 3 4 5]</div></pre></td></tr></table></figure>
<h2 id="Getting-a-positional-slice-using-a-Range-variable-as-a-subscript"><a href="#Getting-a-positional-slice-using-a-Range-variable-as-a-subscript" class="headerlink" title="Getting a positional slice using a Range variable as a subscript"></a><a href="http://stackoverflow.com/questions/38535690/getting-a-positional-slice-using-a-range-variable-as-a-subscript" target="_blank" rel="external">Getting a positional slice using a Range variable as a subscript</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my @numbers = &lt;4 8 16 16 23 42&gt;;</div><div class="line">.say for @numbers[0..2]; # this works</div><div class="line"># 4</div><div class="line"># 8</div><div class="line"># 15</div><div class="line"></div><div class="line"># but this doesn&apos;t</div><div class="line">my $range = 0..2;</div><div class="line">.say for @numbers[$range];</div><div class="line"># 16</div></pre></td></tr></table></figure>
<p>最后的那个下标看起来好像把 <code>$range</code> 解释为range中元素的个数(3)。怎么回事?</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用 <code>@numbers[|$range]</code> 把 range 对象展平到列表中。或者在 <strong>Range</strong> 对象上使用绑定来传递它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># On Fri Jul 2016, gfldex wrote:</div><div class="line">my @numbers =  &lt;4 8 15 16 23 42&gt;; my $range = 0..2; .say for @numbers[$range];</div><div class="line"></div><div class="line"># OUTPUT«16»</div><div class="line"># expected:</div><div class="line"># OUTPUT«4\n 8\n 15»</div><div class="line"></div><div class="line"></div><div class="line"># 这是对的, 并且还跟 &quot;Scalar container implies item&quot; 规则有关.</div><div class="line"># Changing it would break things like the second evaluation here:</div><div class="line"></div><div class="line">my @x = 1..10; my @y := 1..3; @x[@y]</div><div class="line"># (2 3 4)</div><div class="line"></div><div class="line">@x[item @y]</div><div class="line"># 4</div><div class="line"></div><div class="line"># 注意在签名中 range 可以被绑定给 @y, 而特殊的 Range 可以生成一个像 @x[$(@arr-param)] 的表达式</div><div class="line"># 这在它的语义中是不可预期的。</div><div class="line"></div><div class="line"># 同样, 绑定给 $range 也能提供预期的结果</div><div class="line">my @numbers =  &lt;4 8 15 16 23 42&gt;; my $range := 0..2; .say for @numbers[$range];</div><div class="line"># OUTPUT«4␤8␤15␤»</div><div class="line"></div><div class="line"># 这也是预期的结果, 因为使用绑定就没有标量容器来强制被当成一个 item 了。</div><div class="line"># So, all here is working as designed.</div></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.say for @numbers[@($range)]</div><div class="line"># 4</div><div class="line"># 8</div><div class="line"># 15</div></pre></td></tr></table></figure>
<p>绑定到标量容器的符号输出一个东西<br>可以达到你想要的选择包含：</p>
<p>前置一个 @ 符号来得到单个东西的复数形式：numbers[@$range]; 或者以不同的形式来声明 ragne 变量, 以使它直接工作。<br>对于后者, 考虑下面的形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># Bind the symbol `numbers` to the value 1..10:</div><div class="line">my \numbers = [0,1,2,3,4,5,6,7,8,9,10];</div><div class="line"></div><div class="line"># Bind the symbol `rangeA` to the value 1..10:</div><div class="line">my \rangeA  := 1..10;</div><div class="line"># Bind the symbol `rangeB` to the value 1..10:</div><div class="line">my \rangeB   = 1..10;</div><div class="line"></div><div class="line"># Bind the symbol `$rangeC` to the value 1..10:</div><div class="line">my $rangeC  := 1..10;</div><div class="line"></div><div class="line"># Bind the symbol `$rangeD` to a Scalar container</div><div class="line"># and then store the value 1..10 in it:`</div><div class="line">my $rangeD   = 1..10;</div><div class="line"></div><div class="line"># Bind the symbol `@rangeE` to the value 1..10:</div><div class="line">my @rangeE  := 1..10;</div><div class="line"></div><div class="line"># Bind the symbol `@rangeF` to an Array container and then</div><div class="line"># store 1 thru 10 in the Scalar containers 1 thru 10 inside the Array</div><div class="line">my @rangeF   = 1..10;</div><div class="line"></div><div class="line">say numbers[rangeA];  # (1 2 3 4 5 6 7 8 9 10)</div><div class="line">say numbers[rangeB];  # (1 2 3 4 5 6 7 8 9 10)</div><div class="line">say numbers[$rangeC]; # (1 2 3 4 5 6 7 8 9 10)</div><div class="line">say numbers[$rangeD]; # 10</div><div class="line">say numbers[@rangeE]; # (1 2 3 4 5 6 7 8 9 10)</div><div class="line">say numbers[@rangeF]; # (1 2 3 4 5 6 7 8 9 10)</div></pre></td></tr></table></figure>
<p>绑定到标量容器(<code>$rangeD</code>)上的符号总是产生单个值。在 <code>[...]</code>下标中单个值必须是数字。<br>对于 range, 被当作单个数字时, 产生的是 range 的长度。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[给数字添加千分位分割符]]></title>
      <url>http://ohmycloud.github.io/2015/12/14/%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E5%88%86%E5%89%B2%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h2 id="使用链式函数调用"><a href="#使用链式函数调用" class="headerlink" title="使用链式函数调用"></a>使用链式函数调用</h2><hr>
<p>考虑最简单的一种情况, 不带小数点的数字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;1234567890&quot;.comb.reverse.rotor(3,:partial).map(*.join(&apos;&apos;)).join(&apos;,&apos;).comb.reverse.join(&apos;&apos;)  </div><div class="line"># 1,234,567,890</div></pre></td></tr></table></figure>
<p>使用 <code>\\</code> 转义空白, 使代码对齐:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&quot;1234567890&quot;.comb\</div><div class="line">            .reverse\</div><div class="line">            .rotor(3,:partial)\</div><div class="line">            .map(*.join(‘’))\</div><div class="line">            .join(‘,’)\</div><div class="line">            .comb\</div><div class="line">            .reverse\</div><div class="line">            .join(‘’)\</div><div class="line">            .say;</div></pre></td></tr></table></figure>
<h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><hr>
<p>comming soon!</p>
<h2 id="使用-Grammar"><a href="#使用-Grammar" class="headerlink" title="使用 Grammar"></a>使用 Grammar</h2><hr>
<p>comming soon!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类中的twigils]]></title>
      <url>http://ohmycloud.github.io/2015/12/11/%E7%B1%BB%E4%B8%AD%E7%9A%84twigils/</url>
      <content type="html"><![CDATA[<h2 id="Perl-6中的-和-twigil-是什么？"><a href="#Perl-6中的-和-twigil-是什么？" class="headerlink" title="Perl 6中的 . 和 ! twigil 是什么？"></a>Perl 6中的 <code>.</code> 和 <code>!</code> <strong>twigil</strong> 是什么？</h2><p><code>.</code> <strong>twigil</strong> 的意思是”这是类公用的”,  <code>!</code> <strong>twigil</strong> 的意思是“这是类私有的”, 只能用在类的内部。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class ScoreKeeper &#123;</div><div class="line">    has @.options;</div><div class="line">    has %!player-points;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>普通的符号表明了词法作用域或包作用域, 但是 <strong>twigils</strong> 就像是 <strong>sigils</strong> 的兄弟, 表明了不同的作用域, 它影响了变量的作用域。<code>.</code> 和 <code>!</code> 是二级 <strong>sigils</strong>。</p>
<p>属性存在于每个类的实例中, 在类的内部, 可以直接使用 <code>!</code>访问到实例的属性:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    has $.<span class="keyword">x</span>;</div><div class="line">    has $.<span class="keyword">y</span>;</div><div class="line">    method Str() &#123;</div><div class="line">        <span class="string">"($!x, $!y)"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么 <code>.</code> <strong>twigil</strong> 和 <code>!</code> <strong>twigil</strong> 之间有什么关系呢？下面看一个例子:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">class Point &#123;</div><div class="line">    has $.<span class="keyword">x</span>;</div><div class="line">    has $.<span class="keyword">y</span>;</div><div class="line"></div><div class="line">    method Str() &#123;</div><div class="line">        <span class="comment"># 注意这次我们使用 . 而非 !</span></div><div class="line">        <span class="string">"\$.x 等价于 self.x()"</span>.say  <span class="keyword">if</span> $.<span class="keyword">x</span> == self.x();</div><div class="line">        <span class="string">"\$.y 等价于 self.y()"</span>.say  <span class="keyword">if</span> $.<span class="keyword">y</span> == self.y();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method <span class="keyword">print</span>() &#123;</div><div class="line">        <span class="keyword">say</span> self.x(); <span class="comment"># 调用实例的名为 x 的方法</span></div><div class="line">        <span class="keyword">say</span> self.y(); <span class="comment"># 调用实例的名为 y 的方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $point = Point.new(<span class="string">x =&gt;</span> <span class="number">10</span>, <span class="string">y =&gt;</span> <span class="number">20</span>);</div><div class="line">$point.Str;   </div><div class="line">$point.<span class="keyword">print</span>;</div></pre></td></tr></table></figure>
<p>会输出:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$.<span class="keyword">x</span> 等价于 self.x()</div><div class="line">$.<span class="keyword">y</span> 等价于 self.y()</div><div class="line"><span class="number">10</span></div><div class="line"><span class="number">20</span></div></pre></td></tr></table></figure>
<p>注意到, 属性被声明为 <code>$.x</code> 和 <code>$.y</code>, 但是在类的内部仍旧能通过 <code>$!x</code> 和 <code>$!y</code>来访问属性。这是因为在 Perl 6 中所有的属性都是私有的并且在类中可以通过 <code>$!attribute-name</code>直接访问这些属性。 Perl 6 可以为你自动生成<code>存取方法</code>。</p>
<p>公共属性拥有 <code>.</code> twigil, 私有属性拥有 <code>!</code> twigil。</p>
<p><code>has $.x</code> 就是私有属性 <code>has $!x</code> 加上一个<code>getter</code>方法, 即 <code>method x() { ... }</code></p>
<p><code>has $.x is rw</code> 就是私有属性 <code>has $!x</code> 加上一个<code>getter/setter</code>方法。</p>
<h2 id="twigil-就是调用了与属性同名的方法"><a href="#twigil-就是调用了与属性同名的方法" class="headerlink" title=". twigil 就是调用了与属性同名的方法"></a>. <strong>twigil</strong> 就是调用了与属性同名的方法</h2><hr>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class SaySomething &#123;</div><div class="line">    method a() &#123; <span class="keyword">say</span> <span class="string">"a"</span>;  &#125;</div><div class="line"></div><div class="line">    method b() &#123; $.a;      &#125;</div><div class="line">    method c() &#123; self.a(); &#125; <span class="comment"># 这证明了 $.a 的 . twigil 做了一次隐式的实例方法调用。</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">SaySomething.b; <span class="comment"># 打印 "a"</span></div><div class="line">SaySomething.c; <span class="comment"># 打印 "a"</span></div></pre></td></tr></table></figure>
<h2 id="twigil-中自动生成的方法可以被子类重写"><a href="#twigil-中自动生成的方法可以被子类重写" class="headerlink" title=". twigil 中自动生成的方法可以被子类重写"></a>. <strong>twigil</strong> 中自动生成的方法可以被子类重写</h2><hr>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"></div><div class="line">class Point &#123;</div><div class="line">    has $.<span class="keyword">x</span>;</div><div class="line">    has $.<span class="keyword">y</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Circle is Point &#123;</div><div class="line">    has $!radius;</div><div class="line"></div><div class="line">    <span class="comment"># 重写父类中的 x() 方法和 y() 方法</span></div><div class="line">    method <span class="keyword">x</span>() &#123;</div><div class="line">        <span class="string">"I am x point in a Circle"</span>;</div><div class="line">    &#125;</div><div class="line">    method <span class="keyword">y</span>() &#123;</div><div class="line">        <span class="string">"I am y point in a Circle"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $circle = Circle.new(<span class="string">radius =&gt;</span> <span class="number">10</span>);</div><div class="line">$circle.x().say; <span class="comment"># I am x point in a Circle</span></div><div class="line">$circle.y.say;   <span class="comment"># I am y point in a Circle</span></div></pre></td></tr></table></figure>
<p>如果不想子类重写父类中的方法, 那么在父类中声明属性的时候, 使用 <code>!</code> <strong>twigil</strong> 替代 <code>.</code> <strong>twigil</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简单字符串解析]]></title>
      <url>http://ohmycloud.github.io/2015/11/25/%E7%AE%80%E5%8D%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="简单字符串解析"><a href="#简单字符串解析" class="headerlink" title="简单字符串解析"></a>简单字符串解析</h2><p>我已经以好几种方式使用 Perl 6 解析用引号引起的字符串了。 但是我想知道有没有更好更干净的方法。下面有一个为引起的字符串准备的小型 grammar 而且还有一些测试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">grammar String::Simple::Grammar &#123;</div><div class="line">    our $quote;</div><div class="line"></div><div class="line">    rule TOP &#123;^ &lt;string&gt; $&#125;</div><div class="line">    # Note for now, &#123;&#125; gets around a rakudo binding issue</div><div class="line">    token string &#123; &lt;quote&gt; &#123;&#125; :temp $quote = $&lt;quote&gt;; &lt;quotebody&gt; $&lt;quote&gt; &#125;</div><div class="line">    token quote &#123; &apos;&quot;&apos; | &quot;&apos;&quot; &#125;</div><div class="line">    token quotebody &#123; ( &lt;escaped&gt; | &lt;!before $quote&gt; . )* &#125;</div><div class="line">    token escaped &#123; &apos;\\&apos; ( $quote | &apos;\\&apos; ) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class String::Simple::Actions &#123;</div><div class="line">    method TOP($/) &#123; make $&lt;string&gt;.made &#125;</div><div class="line">    method string($/) &#123; make $&lt;quotebody&gt;.made &#125;</div><div class="line">    method quotebody($/) &#123; make [~] $0.map: &#123;$^e&lt;escaped&gt;.made or ~$^e&#125; &#125;</div><div class="line">    method escaped($/) &#123; make ~$0 &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">use Test;</div><div class="line"></div><div class="line">plan(5);</div><div class="line"></div><div class="line">my $grammar = ::String::Simple::Grammar;</div><div class="line">my $actions = String::Simple::Actions.new();</div><div class="line"></div><div class="line"># The semantics of our string are:</div><div class="line"># * Backslash before a backslash is backslash</div><div class="line"># * Backslash before a quote of the type enclosing the string is that quote</div><div class="line"># * All chars including backslash are otherwise literal</div><div class="line"></div><div class="line">ok $grammar.parse(q&#123;&quot;foo&quot;&#125;, :$actions), &quot;Simple string parsing&quot;;</div><div class="line">is $grammar.parse(q&#123;&quot;foo&quot;&#125;, :$actions).made, &quot;foo&quot;, &quot;Content of matched string&quot;;</div><div class="line">is $grammar.parse(q&#123;&quot;f\oo&quot;&#125;, :$actions).made, &quot;f\\oo&quot;, &quot;Content of matched string&quot;;</div><div class="line">is $grammar.parse(q&#123;&quot;f\&quot;oo&quot;&#125;, :$actions).made, &quot;f\&quot;oo&quot;, &quot;Content of matched string&quot;;</div><div class="line">is $grammar.parse(q&#123;&quot;f\\\\oo&quot;&#125;, :$actions).made, &quot;f\\oo&quot;, &quot;Content of matched string&quot;;</div></pre></td></tr></table></figure>
<p>另外一个版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">grammar String::Simple::Grammar &#123;</div><div class="line">    rule TOP &#123;^ &lt;string&gt; $&#125;</div><div class="line">    # Note for now, &#123;&#125; gets around a rakudo binding issue</div><div class="line">    token string &#123; &lt;quote&gt; &#123;&#125; &lt;quotebody($&lt;quote&gt;)&gt; $&lt;quote&gt; &#125;</div><div class="line">    token quote &#123; &apos;&quot;&apos; | &quot;&apos;&quot; &#125;</div><div class="line">    token quotebody($quote) &#123; ( &lt;escaped($quote)&gt; | &lt;!before $quote&gt; . )* &#125;</div><div class="line">    token escaped($quote) &#123; &apos;\\&apos; ( $quote | &apos;\\&apos; ) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class String::Simple::Actions &#123;</div><div class="line">    method TOP($/) &#123; make $&lt;string&gt;.made &#125;</div><div class="line">    method string($/) &#123; make $&lt;quotebody&gt;.made &#125;</div><div class="line">    method quotebody($/) &#123; make [~] $0.map: &#123;.&lt;escaped&gt;.made // .Str&#125; &#125;</div><div class="line">    method escaped($/) &#123; make ~$0 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不同之处是:</p>
<ul>
<li>参数化的 rule 用于传递开始的引号</li>
<li>更简单版本的 <code>quotebody</code> 方法使用了一元的点号和 <code>//</code> 用于定义。</li>
</ul>
<p><a href="https://www.reddit.com/r/perl6/comments/4snhqr/simple_string_parsing/" target="_blank" rel="external">原文</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[扩展Perl6中的类型]]></title>
      <url>http://ohmycloud.github.io/2015/11/25/%E6%89%A9%E5%B1%95Perl6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="扩展-Perl-6-中的类型"><a href="#扩展-Perl-6-中的类型" class="headerlink" title="扩展 Perl 6 中的类型"></a>扩展 Perl 6 中的类型</h1><h2 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class BetterInt is Int &#123;</div><div class="line">    method even &#123; self %% 2 &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my BetterInt $x .= new: 42;</div><div class="line">say $x.even; </div><div class="line"></div><div class="line">$x .= new: 71;</div><div class="line">say $x.even;</div><div class="line"></div><div class="line">say $x + 42;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># True</div><div class="line"># False</div><div class="line"># 113</div></pre></td></tr></table></figure>
<p><code>my BetterInt $x</code> 约束 <code>$x</code> 只能包含  <em>BetterInt</em> 或它的子类这种类型的对象。<code>.= new: 42</code> 等价于 <code>= BetterInt.new: 42</code>。<br>下面的子例程期望接收一个 <em>Int</em> 型的参数，但是你给它传递一个 <em>BetterInt</em> 类型的参数它会很高兴:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sub foo(Int $x) &#123; say &quot;\$x is $x&quot;&#125;</div><div class="line"></div><div class="line">my BetterInt $x .= new: 42;</div><div class="line">foo $x;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># $x is 42</div></pre></td></tr></table></figure>
<h2 id="But…-But…-But…"><a href="#But…-But…-But…" class="headerlink" title="But… But… But…"></a>But… But… But…</h2><p>另外一个选择是掺合进一个角色(role)。<em>but</em> 中缀操作符创建对象的一份拷贝并为该对象添加一个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $x = 42 but role &#123; method even &#123; self %% 2 &#125; &#125;;</div><div class="line">say $x.even;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># True</div></pre></td></tr></table></figure>
<p>当然角色不一定是内联的。这儿有另外一个例子使用了一个预定义的角色并且还展示了我们的对象确实被拷贝了一份：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">role Better &#123;</div><div class="line">    method better &#123; &quot;Yes, I am better&quot; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Foo &#123;</div><div class="line">    has $.attr is rw</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $original = Foo.new: :attr&lt;original&gt;;</div><div class="line">my $copy     = $original but Better;</div><div class="line">$copy.attr   = &apos;copy&apos;; </div><div class="line"></div><div class="line">say $original.attr;  # still &apos;original&apos;</div><div class="line">say $copy.attr;      # this one is &apos;copy&apos;</div><div class="line"></div><div class="line">say $copy.better;</div><div class="line">say $original.better; # fatal error: can&apos;t find method</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># original</div><div class="line"># copy</div><div class="line"># Yes, I am better</div><div class="line"># Method &apos;better&apos; not found for invocant of class &apos;Foo&apos;</div><div class="line">#   in block &lt;unit&gt; at test.p6 line 18</div></pre></td></tr></table></figure>
<p>这看起来挺不错的，但是对于我们原来的目标来说，这个方法还是相当弱的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $x = 42 but role &#123; method even &#123; self %% 2 &#125; &#125;;</div><div class="line">say $x.even; # True</div><div class="line">$x = 72;</div><div class="line">say $x.even; # No such method!</div></pre></td></tr></table></figure>
<p>那个角色被混合进我们容器里面存储的对象中了；所以一旦我们在容器中放进了一个新的值，或高级点的东西，那么 <em>.even</em> 方法就不见了，除非我们再次把那个角色混合进来。</p>
<h2 id="子例程"><a href="#子例程" class="headerlink" title="子例程"></a>子例程</h2><p>你知道你可以把子例程当做方法用嘛？ 你接收那个对象作为子例程的第一个位置参数并且你甚至能继续使用链式方法调用，但是不能把那些链子分解成多行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub even &#123; $^a %% 2 &#125;;</div><div class="line">say 42.&amp;even.uc;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># TRUE</div></pre></td></tr></table></figure>
<p>这确实是为核心类型添加额外功能的一种得体方式。我们的子例程定义中的 <code>$^a</code> 引用第一个参数（我们在调用的那个对象）并且整个子例程也可以被写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub ($x) &#123; $x %% 2 &#125;</div></pre></td></tr></table></figure>
<h2 id="飞龙在天"><a href="#飞龙在天" class="headerlink" title="飞龙在天"></a>飞龙在天</h2><p>不管<a href="http://shop.oreilly.com/product/9780596517748.do" target="_blank" rel="external">Javaccript 的那些人们怎么跟你说</a>, 然而扩充原生类型是危险的。因为你正影响程序的所有部分。甚至看不到你的扩充的模块也受到影响。</p>
<p>现在我有权告诉你，我跟你说过，你工作的核电厂融化了，让我们看看一些代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># Foo.pm6</div><div class="line">unit module Foo;</div><div class="line">sub fob is export &#123;</div><div class="line">    say 42.even;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># Bar.pm6</div><div class="line">unit module Bar;</div><div class="line">use MONKEY-TYPING;</div><div class="line">augment class Int &#123;</div><div class="line">    method even &#123; self %% 2 &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># test.p6</div><div class="line">use Foo;</div><div class="line">use Bar;</div><div class="line"></div><div class="line">say 72.even;</div><div class="line">fob;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># True</div><div class="line"># True</div></pre></td></tr></table></figure>
<p>所有的行为都发生在 <em>Bar.pm6</em> 中。首先，我们写了一行 <em>use MONKEY-TYPING</em> 声明，它告诉我们正在做一些危险的行为。然后我们在类 <strong>class Int</strong> 的前面使用了 <em>augment</em> 关键字以扩充这个已经存在的类。我们的扩充添加了一个叫 <em>even</em> 的方法以告诉我们那个 Int 是否是偶数。</p>
<p>所有的整数都可以使用 <em>even</em> 方法了，这虽然达到了我们的要求但是有点危险。</p>
<h2 id="我邪恶了"><a href="#我邪恶了" class="headerlink" title="我邪恶了"></a>我邪恶了</h2><p>我们来扩充 <a href="http://docs.perl6.org/type/Cool" target="_blank" rel="external">Cool 类型</a>以涵盖所有的西文排版行长单位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">use MONKEY-TYPING;</div><div class="line">augment class Cool &#123;</div><div class="line">    method even &#123; self %% 2 &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.say for 72.even, &apos;72&apos;.even, pi.even, ½.even;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># Method &apos;even&apos; not found for invocant of class &apos;Int&apos;</div><div class="line"># in block &lt;unit&gt; at test.p6 line 8</div></pre></td></tr></table></figure>
<p>糟糕，程序奔溃了！原因是在我们扩充 <strong>Cool</strong> 类型的时候，派生自 <strong>Cool</strong> 的所有类型已经成型了(composed)。所以为了让它能工作，我们必须使用 <code>.^compose</code> 元对象协议方法来重新构成它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">use MONKEY-TYPING;</div><div class="line">augment class Cool &#123;</div><div class="line">    method even &#123; self %% 2 &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.^compose for Int, Num, Rat, Str, IntStr, NumStr, RatStr;</div><div class="line"></div><div class="line">.say for 72.even, &apos;72&apos;.even, pi.even, ½.even;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># True</div><div class="line"># True</div><div class="line"># False</div><div class="line"># False</div></pre></td></tr></table></figure>
<p>它现在能工作了！Int, Num, Rat, Str, IntStr, NumStr, RatStr 类型拥有了 <code>.even</code> 方法(注意：这些不是继承自 Cool 的仅有的类型)! 这既邪恶又让人吃惊。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>当扩充 Perl 6 的核心类型或其它任意类的功能时，你有几种选择。</p>
<ul>
<li>使用 <strong>is Class</strong> 子类</li>
<li>使用 <strong>but Role</strong> 混合一个角色</li>
<li>使用 <code>$objec.&amp;sub</code> 调用子例程作为方法使用</li>
<li>使用  augment（注意安全）</li>
</ul>
<p><a href="http://blogs.perl.org/users/zoffix_znet/2016/04/extra-typical-perl-6.html" target="_blank" rel="external">Perl 6 — There Is More Than One Way To Extend it</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[项]]></title>
      <url>http://ohmycloud.github.io/2015/11/21/%E9%A1%B9/</url>
      <content type="html"><![CDATA[<p>Perl 6 中的大部分句法结构能归类为项和操作符. 这儿你能找到各种不同类型的项的概览.</p>
<h2 id="Literals"><a href="#Literals" class="headerlink" title="Literals"></a>Literals</h2><hr>
<h3 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">42</div><div class="line">12_300_00</div><div class="line">:16&lt;DEAD_BEEF&gt;    #十六进制</div></pre></td></tr></table></figure>
<p>Int 字面量由数字组成, 并且能在数字之间包含下划线. 使用 <code>:radix&lt;number&gt;</code> 冒号对儿形式能指定 10 进制外的其它进制.</p>
<h3 id="Rat-有理数"><a href="#Rat-有理数" class="headerlink" title="Rat   有理数"></a>Rat   有理数</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">12.34</div><div class="line">1_200.345_678</div></pre></td></tr></table></figure>
<p>Rat(有理数)字面量由一个点号分割的两部分整数组成. 注意尾部的点号是不允许的, 所以你必须写成 <code>1.0</code> 而非 <code>1.</code> ( 这个规则很重要, 因为有一个以点号开头的中缀操作符, 例如 <code>..</code> 范围操作符 ).</p>
<h3 id="Num-浮点数"><a href="#Num-浮点数" class="headerlink" title="Num  浮点数"></a>Num  浮点数</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">12.3e-32</div><div class="line">3e8</div></pre></td></tr></table></figure>
<p>Num(浮点数)字面量由 Rat 或 Int 字面量后面再跟着一个字母 e 和 一个指数(可能为负)组成. <code>3e8</code> 使用 值 <code>3* 10**8</code> 构建了一个 Num.</p>
<h3 id="Str"><a href="#Str" class="headerlink" title="Str"></a>Str</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&apos;a string&apos;&apos;I\&apos;m escaped!&apos;</div><div class="line">&quot;I don&apos;t need to be&quot;</div><div class="line">&quot;\&quot;But I still can be,\&quot; he said.&quot;</div><div class="line">q|Other delimiters can be used too!|</div></pre></td></tr></table></figure>
<p>字符串字面量常常使用 <code>&#39;</code> 或 <code>&quot;</code> 创建, 然儿, 字符串在 Perl 6 中其实是一种强大的子语言.</p>
<h3 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/ match some text /</div><div class="line">rx/slurp \s rest (.*) $/</div></pre></td></tr></table></figure>
<p>这两种会产生字面正则</p>
<h3 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  a =&gt; 1</div><div class="line">&apos;a&apos; =&gt; &apos;b&apos;</div><div class="line">:identifier</div><div class="line">:!identifier</div><div class="line">:identifier&lt;value&gt;</div><div class="line">:identifier&lt;value1 value2&gt;</div><div class="line">:identifier($value)</div><div class="line">:identifier[&apos;val1&apos;, &apos;val2&apos;]</div><div class="line">:identifier&#123;key1 =&gt; &apos;val1&apos;, key2 =&gt; &apos;value2&apos;&#125;</div><div class="line">:$item</div><div class="line">:@array</div><div class="line">:%hash</div><div class="line">:&amp;callable</div></pre></td></tr></table></figure>
<p>Pair 对象的创建要么使用 <code>infix:«=&gt;»</code> (它会自动括起左边, 如果左边是标识符的话), 要么使用各种冒号对儿形式.  那些总是以一个冒号开头的创建形式, 冒号后面要么跟着一个标识符, 要么跟着一个已经存在的变量(不带符号的变量名作为 pair 的键, 变量的值作为 pair 的键值).</p>
<p>在标识符形式的冒号对儿中, 可选的值可以是任意环缀. 如果没有环缀, 那它的值就是 <code>Bool::True</code>. <code>!:identifier</code> 形式的值是 <code>Bool::False</code>.</p>
<p>如果冒号对儿在参数列表中, 所有的冒号对儿都会作为命名参数,   但是 <code>&#39;quoted string&#39; =&gt; $value</code> 除外.</p>
<h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><hr>
<p>什么是 Parcel? -&gt; Immutable sequence of values - 不可变值的序列.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">calss Parcel is Cool does Positional &#123; &#125;</div></pre></td></tr></table></figure>
<p>Parcel 代表 <code>Parenthesis cell</code>, 例如, 被圆括号环绕的表达式. 除了空的 parcel 之外, 实际上是使用逗号来创建一个 Parcel.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(1 + 2)  # not a Parcel</div><div class="line">()       # empty Parcel</div><div class="line">(1,)     # Parcel with one element</div><div class="line">(1,3)    # Parcel with two element</div><div class="line">1, 2, 3  # parenthesis are optional</div><div class="line">&lt;a b c&gt;  # word-quoting</div><div class="line">«a b c»  # also word-quoting</div><div class="line">qw/a b c/</div></pre></td></tr></table></figure>
<p>Parcel 字面量有: 空的圆括号 (),  逗号分割的列表, 还有几种引号结构.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; say (1,2,3).WHAT</div><div class="line">(Parcel)</div><div class="line">&gt; say &lt;a b c&gt;.WHAT</div><div class="line">(Parcel)</div><div class="line">&gt; say «a b c».WHAT</div><div class="line">(Parcel)</div><div class="line">&gt; say (qw/a b c/).WHAT</div><div class="line">(Parcel)</div></pre></td></tr></table></figure>
<p>Parcels 是不可变的, 但是能包含可变容器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $x;</div><div class="line">my $p = (0, $x, 2); # can assign to $p[1], but not</div><div class="line">                    # to any other element of $p</div></pre></td></tr></table></figure>
<p>像 <code>&lt;...&gt;</code> 这种 <code>Word-quoting</code> 结构也会创建 parcels:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a b c&gt; # 3-element Parcel</div></pre></td></tr></table></figure>
<p>在 flattening 列表上下文中, parcels 被展平并且会消失:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @flat = &lt;a b&gt;, &lt;c, d&gt;;</div><div class="line">say @flat.elems;</div></pre></td></tr></table></figure>
<h3 id="term"><a href="#term" class="headerlink" title="term *"></a>term *</h3><hr>
<p><code>*</code> 会创建一个类型为 Whatever 的对象. 详情查看 <a href="http://doc.perl6.org/type/Whatever" target="_blank" rel="external">Whatever</a>.</p>
<h2 id="Identifier-terms"><a href="#Identifier-terms" class="headerlink" title="Identifier terms"></a>Identifier terms</h2><hr>
<p>Perl 6中有内建的标识符项, 列出如下. 此外, 使用该语法能添加新的标识符项.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub term:&lt;fourty-two&gt; &#123; 42 &#125;;</div><div class="line">say fourty-two</div></pre></td></tr></table></figure>
<p>或者作为常量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">constant forty-two = 42;</div><div class="line">say fourty-two</div></pre></td></tr></table></figure>
<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><hr>
<p>在方法中, self 指向方法的调用者( 例如, 方法被调用的对象). 如果把它用在没有意义的上下文中, 会抛出一个 <code>X::Syntax::NoSelf</code> 类型的编译时错误.</p>
<h3 id="now"><a href="#now" class="headerlink" title="now"></a>now</h3><hr>
<p>返回一个代表当前时间的实例对象.</p>
<h3 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h3><hr>
<p>返回一个范围为 <code>0..^1</code>的伪随机浮点数.</p>
<h3 id="pi"><a href="#pi" class="headerlink" title="pi"></a>pi</h3><hr>
<p>返回数值 pi, 例如, 圆的周长和半径之间的比率.</p>
<h3 id="e"><a href="#e" class="headerlink" title="e"></a>e</h3><hr>
<p>返回欧拉数值.</p>
<h3 id="i"><a href="#i" class="headerlink" title="i"></a>i</h3><hr>
<p>返回复数的虚部.</p>
<h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><hr>
<p>Variables are discussed in variable language docs.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[reddit-Guess-Who]]></title>
      <url>http://ohmycloud.github.io/2015/11/20/reddit-Guess-Who/</url>
      <content type="html"><![CDATA[<p>你是一个刚成立的小公司里的一名软件工程师, 有天晚上你收到了一封来自CEO 的电子邮件:</p>
<blockquote>
<p>亲爱的工程师,</p>
<p>​    好新闻！看起来我们的网站越来越受欢迎。我们要变的有钱了! 每秒钟有成千上万的人在同时访问我们的网站, 而且还在快速增长。</p>
<p>我们必须立即识别出谁的通信量最大。幸运的是我的朋友给我发送了一份巨大的 IP 地址和名字的列表。很酷不是吗？你能写一段程序接收我们大量的访问者, 把它和地址/ 名字列表相比, 并创建一些统计吗？我的意思是, 生成一个国家的名字列表, 每个</p>
<p>做好了的话我给你们开个披萨聚会。</p>
</blockquote>
<p>邮件的附件文件包含了一个 IP 地址和名字的列表。写一个程序来统计下有多少 IP 访问了你的网站。</p>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><hr>
<p>输入来自两部分。第一个是一个文本文件, 包含 IP 地址范围。每行一项,使用两个空格分割 IP 和名字。</p>
<p>第二个文件是一个 IP 地址的列表, 每行一个, 它们是必须被查询的IP。</p>
<h4 id="IP-输入样本"><a href="#IP-输入样本" class="headerlink" title="IP 输入样本"></a>IP 输入样本</h4><hr>
<p>输入是有包含两个 IP 地址和一个跟 IP 范围关联的名字的大量行组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">123.45.17.8 123.45.123.45 University of Vestige</div><div class="line">123.50.1.1 123.50.10.1 National Center for Pointlessness</div><div class="line">188.0.0.3 200.0.0.250 Mayo Tarkington</div><div class="line">200.0.0.251 200.0.0.255 Daubs Haywire Committee</div><div class="line">200.0.1.1 200.255.255.255 Geopolitical Encyclopedia</div><div class="line">222.222.222.222 233.233.233.233 SAP Rostov</div><div class="line">250.1.2.3 250.4.5.6 Shavian Refillable Committee</div><div class="line">123.45.100.0 123.60.32.1 United Adverbs</div><div class="line">190.0.0.1 201.1.1.1 Shavian Refillable Committee</div><div class="line">238.0.0.1 254.1.2.3 National Center for Pointlessness</div></pre></td></tr></table></figure>
<p>注意: 这些 IP 范围不能保证是 IPv4 “子网”。这意味着它们可能不能精确地由基于前缀的 CIDR 块来表示。</p>
<p>范围可以重叠。可能多余2层深。</p>
<p>可可有多个范围关联同一个名字。</p>
<h4 id="查询输入样本"><a href="#查询输入样本" class="headerlink" title="查询输入样本"></a>查询输入样本</h4><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">250.1.3.4</div><div class="line">123.50.1.20</div><div class="line">189.133.73.57</div><div class="line">123.50.1.21</div><div class="line">250.1.2.4</div><div class="line">123.50.1.21</div><div class="line">250.1.3.100</div><div class="line">250.1.3.5</div><div class="line">188.0.0.5</div><div class="line">123.50.1.100</div><div class="line">123.50.2.34</div><div class="line">123.50.1.100</div><div class="line">123.51.100.52</div><div class="line">127.0.0.1</div><div class="line">123.50.1.22</div><div class="line">123.50.1.21</div><div class="line">188.0.0.5</div><div class="line">123.45.101.100</div><div class="line">123.45.31.52</div><div class="line">230.230.230.230</div></pre></td></tr></table></figure>
<h4 id="输出格式化"><a href="#输出格式化" class="headerlink" title="输出格式化"></a>输出格式化</h4><hr>
<p>倒序输出访问次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">8 - National Center for Pointlessness</div><div class="line">4 - Shavian Refillable Committee</div><div class="line">3 - Mayo Tarkington</div><div class="line">2 - University of Vestige</div><div class="line">1 - SAP Rostov</div><div class="line">1 - United Adverbs</div><div class="line">1 - &lt;unknown&gt;</div></pre></td></tr></table></figure>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><hr>
<p>这儿是一个输入 IP 和它的名字的映射:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">National Center for Pointlessness</div><div class="line">123.50.1.20</div><div class="line">123.50.1.21</div><div class="line">123.50.1.22</div><div class="line">123.50.1.21</div><div class="line">123.50.1.21</div><div class="line">123.50.1.100</div><div class="line">123.50.1.100</div><div class="line">123.50.2.34</div><div class="line"></div><div class="line">Shavian Refillable Committee</div><div class="line">250.1.2.4</div><div class="line">250.1.3.4</div><div class="line">250.1.3.5</div><div class="line">250.1.3.100</div><div class="line"></div><div class="line">Mayo Tarkington</div><div class="line">188.0.0.5</div><div class="line">188.0.0.5</div><div class="line">189.133.73.57</div><div class="line"></div><div class="line">University of Vestige</div><div class="line">123.45.101.100</div><div class="line">123.45.31.52</div><div class="line"></div><div class="line">SAP Rostov</div><div class="line">230.230.230.230</div><div class="line"></div><div class="line">United Adverbs</div><div class="line">123.51.100.52</div><div class="line"></div><div class="line">&lt;unknown&gt;</div><div class="line">127.0.0.1</div></pre></td></tr></table></figure>
<p>smls的解决方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">sub ip-to-number ($ip) &#123;</div><div class="line">    do given $ip.split(&apos;.&apos;) &#123;</div><div class="line">        .[0] +&lt; 24 +</div><div class="line">        .[1] +&lt; 16 +</div><div class="line">        .[2] +&lt;  8 +</div><div class="line">        .[3] +&lt;  0</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class IntervalTree &#123;</div><div class="line">    has $.min;</div><div class="line">    has $.max;</div><div class="line">    has $!center = ($!min + $!max) div 2;</div><div class="line">    has @!intervals;</div><div class="line">    has IntervalTree $!left;</div><div class="line">    has IntervalTree $!right;</div><div class="line">    method new ($min, $max) &#123; self.bless(:$min, :$max) &#125;</div><div class="line">    method insert (|c ($start, $end, $name)) &#123;</div><div class="line">        if $end &lt; $!center and $!min &lt; $!center - 1 &#123;</div><div class="line">            ($!left //= self.new($!min, $!center)).insert(|c)</div><div class="line">        &#125;</div><div class="line">        elsif $start &gt; $!center and $!max &gt; $!center &#123;</div><div class="line">            ($!right //= self.new($!center, $!max)).insert(|c)</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            @!intervals.push: [$start, $end, $name, $end-$start]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    method prepare &#123;</div><div class="line">        @!intervals.=sort(*[3]);</div><div class="line">        $!left .prepare if $!left;</div><div class="line">        $!right.prepare if $!right;</div><div class="line">    &#125;</div><div class="line">    method lookup ($n) &#123;</div><div class="line">        my $best = ($n &lt; $!center ?? ($!left .lookup($n) if $!left)</div><div class="line">                                  !! ($!right.lookup($n) if $!right));</div><div class="line">        $best ?? @!intervals.first(&#123; return $best if .[3] &gt; $best[3];</div><div class="line">                                     .[0] &lt;= $n &lt;= .[1] &#125;) // $best</div><div class="line">              !! @!intervals.first(&#123; .[0] &lt;= $n &lt;= .[1] &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">sub MAIN ($ip-file, $query-file) &#123;</div><div class="line">    my $index = IntervalTree.new(0, ip-to-number &apos;255.255.255.255&apos;);</div><div class="line">    for $ip-file.IO.lines &#123;</div><div class="line">        my ($start, $end, $name) = .split(&apos; &apos;, 3);</div><div class="line">        $index.insert(ip-to-number($start), ip-to-number($end), $name);</div><div class="line">    &#125;</div><div class="line">    $index.prepare;</div><div class="line">    for $query-file.IO.lines -&gt; $ip &#123;</div><div class="line">        my $name = $index.lookup(ip-to-number $ip)[2];</div><div class="line">        say &quot;$ip &#123;$name // &apos;&lt;unknown&gt;&apos;&#125;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[roles冲突]]></title>
      <url>http://ohmycloud.github.io/2015/11/16/roles%E5%86%B2%E7%AA%81/</url>
      <content type="html"><![CDATA[<p>学会了怎么创建类, 我们继续用它来构建我们的中心内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Hammer &#123;</div><div class="line">    method hammer($stuff) &#123;</div><div class="line">        say &quot;You hammer on $stuff. BAM BAM BAM!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Gavel &#123;</div><div class="line">    method hammer($stuff) &#123;</div><div class="line">        say &quot;You hammer on $stuff. BAM BAM BAM!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Mallet &#123;</div><div class="line">    method hammer($stuff) &#123;</div><div class="line">        say &quot;You hammer on $stuff. BAM BAM BAM!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是注意到了吗？ 这三个方法包含了同样的方法, 在类中重复了。我们必须那样做如果我们想让每个 <strong>Hammar</strong>、<strong>Gavel</strong> 和 <strong>Mallet</strong> 有能力击打的话。（并且那是合理的）。 但是遗憾的是我们不得不把那个方法一式三份。</p>
<p>为什么遗憾？ 因为一方面在真实世界中, 方法并不是很彼此相似, 有一天你决定在 <strong>hammer</strong>  方法中更改某些东西, 并没有意识到这个方法在三个不同的地方… 这导致了一堆痛苦和难受。</p>
<p>所以我们的新玩具, 类, 展现出了一个问题。我们想在每个类中重用 hammer 方法。一个新的概念, <strong>role</strong> 来拯救我们来了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">role Hammering &#123;</div><div class="line">    method hammer($stuff) &#123;</div><div class="line">        say &quot;You hammer on $stuff. BAM BAM BAM!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然类经常以一个合适的名词命名, 但是 roles 经常以一个分词命名, 例如 <strong>Hammering</strong>。这不是一个必须遵守的规则, 但是它是一个好的经验法则。现在类的定义变的简单了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Hammer does Hammering &#123; &#125;</div><div class="line">class Gavel  does Hammering &#123; &#125;</div><div class="line">class Mallet does Hammering &#123; &#125;</div></pre></td></tr></table></figure>
<p>是的, 我们喜欢那样。</p>
<p>这发生了什么？ 我们在类上使用 <strong>does</strong> 是干什么用的？ role 定义中的所有方法都被拷贝到类定义中。因为它是一个拷贝操作, 所以我们可以使用尽可能多的类。</p>
<p>所以, 我们做的是: 当我们想重用方法的时候把方法放进 roles 里面。</p>
<p>但是好处不止这一点儿。至少有两个好处:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my $hammer = Hammer.new;    # create a new hammer object</div><div class="line">say $hammer ~~ Hammer;      # &quot;Bool::True&quot; -- yes, this we know</div><div class="line">say $hammer ~~ Hammering;   # &quot;Bool::True&quot; -- ooh!</div></pre></td></tr></table></figure>
<p>所以 <code>$hammer</code> 知道它遵守了(does)<strong>Hammering</strong>, 我们现在不仅知道了对象属于哪个类, 还知道了对象并入了什么 role。这很有用如果我们不确定我们处理的是什么类型的对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">if $unkown_object ~~ Hammering &#123;</div><div class="line">    $unknown_object.hammer(&quot;砸在钉子上&quot;);     # will always work</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个类能一次接收几个 roles 吗？ 是的, 它可以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">role Flying &#123;</div><div class="line">    method fly &#123;</div><div class="line">        say &quot;Whooosh!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class FlyingHammer does Hammering does Flying &#123; &#125;</div></pre></td></tr></table></figure>
<p>让一个类像那样遵守几个 roles 引入了一个有意思的可能: 冲突, 当来自两个不同 roles 的两个同名方法尝试占领同一个类时。这时会发生什么？ 好吧, 至少有 3 种可能:</p>
<ul>
<li><ol>
<li>第一个 role 赢了。 它的方法住进了类中</li>
</ol>
</li>
<li><ol>
<li>最后一个 role 赢了。 它覆盖了之前的方法</li>
</ol>
</li>
<li><ol>
<li>编译失败。冲突必须被解决。</li>
</ol>
</li>
</ul>
<p>这种情况下选项 3  应该是正确答案。原因和之前相同: 因为类和工程越来越庞大, 程序员可能意识不到两个 role 之间在哪儿发生冲突。所以我们标记了它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">role Sleeping &#123;</div><div class="line">    method lie &#123;</div><div class="line">        say &quot;水平躺下&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">role Lying &#123;</div><div class="line">    method lie &#123;</div><div class="line">        say &quot;说谎...&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SleepingLiar does Sleeping does Lying &#123; &#125;    # 冲突!</div></pre></td></tr></table></figure>
<p>下一个问题, 那么: 当在类中有  role 冲突时, 我们怎么修复它？ 简单: 在类中自己定义一个同名的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class SleepingLiar does Sleeping does Lying &#123;</div><div class="line">    method lie &#123;</div><div class="line">        say &quot;Lying in my sleep....&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想从一个贴别的 role 中调用一个方法, 语法是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class SleepingLiar does Sleeping does Lying &#123;</div><div class="line">    method lie &#123;</div><div class="line">        self.Sleeping::lie;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>﻿</p>
<p>这就是 roles。它们把可重用的行为混合进类中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl6中的可变Grammar]]></title>
      <url>http://ohmycloud.github.io/2015/11/16/Perl6%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98Grammar/</url>
      <content type="html"><![CDATA[<h2 id="A-Mutable-Grammar-For-Perl-6"><a href="#A-Mutable-Grammar-For-Perl-6" class="headerlink" title="A Mutable Grammar For Perl 6"></a>A Mutable Grammar For Perl 6</h2><hr>
<h3 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h3><hr>
<p><code>Rules</code> 就像 perl5的 <code>regexes</code>，并且更好。它们像子例程和方法那样申明，并且还能调用其它 rules</p>
<p>下面是一个解析 Perl 6 基本变量名的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">grammar Perl6 &#123;  </div><div class="line"># among other stuff:</div><div class="line"></div><div class="line">    # token alpha 是一个预定义好的 rule</div><div class="line">    token identifier &#123;           </div><div class="line">       &lt;alpha&gt; \w+     </div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">   # 匹配一个全限定名标识符</div><div class="line">    # [ ... ]  是非捕获组</div><div class="line">    token name &#123;        </div><div class="line">        &lt;identifier&gt;         </div><div class="line">        [ &apos;::&apos; &lt;identifier&gt; ] *     </div><div class="line">    &#125;</div><div class="line">     # .. | .. 是分支. 最长匹配胜出.</div><div class="line">    token sigil &#123;        </div><div class="line">       &apos;$&apos; | &apos;@&apos; | &apos;&amp;&apos; | &apos;%&apos; | &apos;::&apos;    </div><div class="line">    &#125;    </div><div class="line">    # &lt;rule&gt; 调用命名 rule, 隐式地锚定在当前位置</div><div class="line">    token variable &#123;      </div><div class="line">        &lt;sigil&gt; &lt;name&gt;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Grammars"><a href="#Grammars" class="headerlink" title="Grammars"></a>Grammars</h3><hr>
<p><code>Grammar</code> 跟类很像，含有 <code>rules</code> 而不是 methods。 grammars 是 <code>rules</code> 的集合并支持<code>继承</code>。</p>
<p>如果要求 Perl 6 中变量的名字必须大写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 我们继承原来那个 grammar</div><div class="line">grammar PERL6 is Perl6 &#123;    </div><div class="line">    # ... 重写我们想改变的解析规则</div><div class="line">    token identifier &#123;        </div><div class="line">   # Perl 6 中的字符类现在写作 &lt;[ ... ]&gt;         </div><div class="line">       &lt;[A..Z]&gt; &lt;[A..Z0..9_]&gt;*   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们只需告诉编译器使用 <code>PERL6</code> 这个 grammar 而非默认 grammar 。还记得类中的方法调用顺序吗？ 先从本类开始， 沿着继承树从下而上到父类… 。 grammar 与之类似。</p>
<p>然而有一个缺陷。假设你想更改一个符号， 例如把 <code>$</code> 更改 为 <code>¢</code>（因为你没有足够的 <code>$$$</code> 来买下所有的变量，不是吗？）看起来很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">grammar LowBudgetPerl6 is Perl6 &#123;</div><div class="line">    # token 就像类中的方法一样, 继承后可以修改</div><div class="line">    token sigil &#123; &apos;¢&apos; | &apos;@&apos; | &apos;&amp;&apos; | &apos;%&apos; | &apos;::&apos; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新的 grammar 解析工作的很好， 但是那之后的所有东西肯定会失败。当编译器在解析树里看见 <code>sigil</code> 匹配时，它得找出到底是哪一个 - 这意味着它必须要检查匹配文本的字面值， 而它并不知道怎么处理 <code>¢</code></p>
<p>所以，我们需要更多的技能…</p>
<h2 id="Proto-Regexes"><a href="#Proto-Regexes" class="headerlink" title="Proto Regexes"></a>Proto Regexes</h2><hr>
<p> <code>proto regex</code> 是一套有着相同名字的 regexes/rules，当前的 <a href="http://svn.pugscode.org/pugs/src/perl6/STD.pm" target="_blank" rel="external">Perl 6 grammar</a> 使用这个结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">proto token sigil &#123;*&#125;</div><div class="line"># ...</div><div class="line">token sigil:sym&lt;$&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">token sigil:sym&lt;@&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">token sigil:sym&lt;%&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">token sigil:sym&lt;&amp;&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">token sigil:sym&lt;::&gt; &#123; &lt;sym&gt; &#125;</div></pre></td></tr></table></figure>
<p>这创建了一个叫做 <code>sigil</code> 的组(<code>proto</code>)，组里面有使用 <code>sym</code> 标识符参数化的5 个规则(rules)（它们属于这个组因为它们跟组的名字相同）。 第一个把 <code>sym</code> 设置为 <code>$</code> 然后匹配这个符号(使用<code>&lt;sym&gt;</code>). 第二个匹配 <code>@</code>等等。现在如果调用规则 <code>&lt;sigil&gt;</code> ,你会得到一个含有上述所有 5 个规则的列表，列表元素之间是<code>或</code>的关系。所以它依然跟正则 <code>&#39;$&#39; | &#39;@&#39; | &#39;%&#39; | &#39;&amp;&#39; | &#39;::&#39;</code> 匹配相同的东西， 但是更容易扩展。</p>
<p>如果你想添加一个新的符号，  grammar 中唯一要修改的就是添加另外一个 <code>sigil</code>规则： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grammar SigilRichP6 is Perl6 &#123;</div><div class="line">    token sigil:sym&lt;ħ&gt; &#123; &lt;sym&gt; &#125; # 物理学家会很爱你</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回到原来那个例子， 你可以重写已存在的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grammar LowBudgetPerl6 is Perl6 &#123;</div><div class="line">    token sigil:sym&lt;$&gt; &#123; &apos;¢&apos; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在这个 grammar 为标量使用了一个不同的符号， 但是它和原来的 grammar 有着相同的规则和相同的参数(<code>sigil:sym&lt;$&gt;</code>) ， 编译器仍然知道怎么处理它。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[圆括号和方括号在创建数组时的区别]]></title>
      <url>http://ohmycloud.github.io/2015/11/14/%E5%9C%86%E6%8B%AC%E5%8F%B7%E5%92%8C%E6%96%B9%E6%8B%AC%E5%8F%B7%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="和-的区别"><a href="#和-的区别" class="headerlink" title="[ ] 和 ( ) 的区别"></a>[ ] 和 ( ) 的区别</h1><hr>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 无法正常排序</span></div><div class="line"><span class="keyword">my</span>  @s = [<span class="number">2443</span>,<span class="number">5</span>,<span class="number">33</span>, <span class="number">90</span>, -<span class="number">9</span>, <span class="number">2</span>, <span class="number">764</span>];</div><div class="line"><span class="keyword">say</span> @s.sort;     <span class="comment"># 2443 5 33 90 -9 2 764 </span></div><div class="line"><span class="keyword">say</span> @s.WHAT;     <span class="comment"># (Array)</span></div><div class="line"><span class="keyword">say</span> @s.perl;     <span class="comment"># [[2443, 5, 33, 90, -9, 2, 764]]&lt;&gt;</span></div><div class="line"></div><div class="line"><span class="comment"># 正常排序</span></div><div class="line"><span class="keyword">my</span>  $array = [<span class="number">2443</span>,<span class="number">5</span>,<span class="number">33</span>, <span class="number">90</span>, -<span class="number">9</span>, <span class="number">2</span>, <span class="number">764</span>];</div><div class="line"><span class="keyword">say</span> $array.sort; <span class="comment">#  -9 2 5 33 90 764 2443</span></div><div class="line"><span class="keyword">say</span> $array.WHAT; <span class="comment"># (Array)</span></div><div class="line"><span class="keyword">say</span> $array.perl; <span class="comment"># [2443, 5, 33, 90, -9, 2, 764]</span></div><div class="line"></div><div class="line"><span class="keyword">my</span>  @s = (<span class="number">2443</span>,<span class="number">5</span>,<span class="number">33</span>,<span class="number">90</span>,-<span class="number">9</span>,<span class="number">2</span>,<span class="number">764</span>); </div><div class="line"><span class="keyword">say</span> @s.sort;     <span class="comment"># -9 2 5 33 90 764 2443</span></div><div class="line"><span class="keyword">say</span> $array.WHAT; <span class="comment"># (Array)</span></div><div class="line"><span class="keyword">say</span> @s.perl;     <span class="comment"># [2443, 5, 33, 90, -9, 2, 764]&lt;&gt;</span></div></pre></td></tr></table></figure>
<p>可见, 使用 <code>[ ]</code> 和 <code>( )</code> 创建数组是不一样的.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @s = [<span class="number">2443</span>, <span class="number">5</span>, <span class="number">33</span>, <span class="number">90</span>, -<span class="number">9</span>, <span class="number">2</span>, <span class="number">764</span>];</div></pre></td></tr></table></figure>
<p>这创建了一个数组, 并把该数组赋值给 <code>@s[0]</code>, 所以 <code>@s</code> 只有一个元素, 所以对 @s 进行排序是没有意义的. 然而你可以使用:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@s[<span class="number">0</span>].sort.say</div></pre></td></tr></table></figure>
<p>来实现你要求的排序.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Perl6中怎么为已存在的类添加方法]]></title>
      <url>http://ohmycloud.github.io/2015/11/11/%E5%9C%A8Perl6%E4%B8%AD%E6%80%8E%E4%B9%88%E4%B8%BA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="How-do-you-add-a-method-to-an-existing-class-in-Perl-6"><a href="#How-do-you-add-a-method-to-an-existing-class-in-Perl-6" class="headerlink" title="How do you add a method to an existing class in Perl 6?"></a>How do you add a method to an existing class in Perl 6?</h2><h2 id="Perl-6-中怎么为已存在的类添加方法"><a href="#Perl-6-中怎么为已存在的类添加方法" class="headerlink" title="Perl 6 中怎么为已存在的类添加方法?"></a>Perl 6 中怎么为已存在的类添加方法?</h2><p>Int 类有一个方法叫做 <code>is-prime</code>, 我想为 <code>Int</code>类型添加其它的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class MyInt is Int &#123;</div><div class="line">    method is-even () returns Bool:D &#123;</div><div class="line">        return False if self % 2;</div><div class="line">        return True;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">my $n = MyInt.new(138);</div><div class="line">say $n.is-even;</div></pre></td></tr></table></figure>
<p>通过类的继承也是一种方法, 但是不是我想要的。Swift 中可以通过扩展来实现, Perl 6 中有一个 <code>add_method</code>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method add_method(Metamodel::MethodContainer: $obj, $name, $code)</div></pre></td></tr></table></figure>
<p>这会给元类(meta class)添加一个方法, 使用 <code>$name</code> 作为调用的方法名。这只会在类型被组合前使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Int.^add_method( &apos;is-even&apos;, method () returns Bool:D &#123;</div><div class="line">    return False if self % 2;</div><div class="line">    return True;</div><div class="line">    &#125; );</div><div class="line"></div><div class="line">say 137.is-even;</div><div class="line">say Int.^methods;</div></pre></td></tr></table></figure>
<p>如果我调用 <code>Int.^methods</code>时, <code>is-even</code>没有出现。但是上面的代码能被调用并起作用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Int.^add_method(&apos;fac&apos;, method () returns Int:D &#123;</div><div class="line">     return 1 if self == 0;</div><div class="line">     return 1 if self == 1;</div><div class="line">     my $sum = 1; for 1 .. self  &#123;$sum *= $_&#125;; return $sum;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">1.fac # 1</div><div class="line">5.fac # 120</div></pre></td></tr></table></figure>
<p><code>method</code> 后面的圆括号是方法的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Int.^add_method(&apos;power&apos;, method (Int $num) returns Int:D &#123;</div><div class="line">     return self ** $num;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">2.power(3).say;  # 8</div><div class="line">2.power(10).say; # 1024</div></pre></td></tr></table></figure>
<h2 id="词法方法"><a href="#词法方法" class="headerlink" title="词法方法"></a>词法方法</h2><hr>
<p>我可以让方法不依附于任何类, 并且能在对象上调用该方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my &amp;is-even = method (Int:D :) returns Bool:D &#123; self %% 2 &#125;;</div></pre></td></tr></table></figure>
<p>这构建了一个 <code>Callable</code> （查看以下 <code>&amp;is-even.WHAT</code>）。 在签名中, 我把它约束为一个定义了的 Int 类型的值(<code>Int:D</code>), 但是没有给它名字。我在类型约束后面添加冒号来说明第一个参数是调用者。现在我能把这个方法应用到任何我想要的对象上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say 137.&amp;is-even;</div><div class="line">say 138.&amp;is-even;</div><div class="line">say &quot;foo&quot;.&amp;is-even;  # works, although inside is-even blow up</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[D在Perl6中是什么意思]]></title>
      <url>http://ohmycloud.github.io/2015/11/05/D%E5%9C%A8Perl6%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</url>
      <content type="html"><![CDATA[<p>一个裸的 <strong>:D</strong>、<strong>:U</strong>、<strong>:T</strong> 或 <strong>:_</strong> 是限制默认类型为定义、未定义、类型对象或任何对象的类型约束。所以</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Con &#123;</div><div class="line">    method man(:U: :D $x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其签名等价于  <code>(Con:U: Any:D $x)</code>。</p>
<p>Con:U 是调用者, 在调用者后面加上一个冒号。要标记一个显式的调用者, 在它后面放上一个冒号就好了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method doit ($x: $a, $b, $c) &#123; ... &#125;</div></pre></td></tr></table></figure>
<h3 id="Abstract-vs-Concrete-types"><a href="#Abstract-vs-Concrete-types" class="headerlink" title="Abstract vs Concrete types"></a>Abstract vs Concrete types</h3><p>　<br>对于任何有名字的类型, 某些其它子集类型可以自动地通过在类型的名字后面追加一个合适的状语来派生出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Int:_       允许定义或未定的 Int 值</div><div class="line">Int:D       只允许有定义的(强制的)Int 值</div><div class="line">Int:U       只允许未定义值(抽象或失败)Int 值</div><div class="line">Int:T       允许Int只作为类型对象</div></pre></td></tr></table></figure>
<p>即, 它们的意思有点像:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Int:D       Int:_ where DEFINITE($_)</div><div class="line">Int:U       Int:_ where not(DEFINITE($_))</div><div class="line">Int:T       Int:U where none(Failure)</div></pre></td></tr></table></figure>
<p><code>where DEFINITE</code> 是一个布尔宏, 它说正处理的对象是否有一个合法的强制表示。(查看下面的自省) .</p>
<p>在 Perl 6 中, <strong>Int</strong> 通常假定意为 <code>Int:_</code>, 除了调用者, 其中默认为 <code>Int:D</code>。 （默认的 new 方法有一个原型, 它的调用者是 <code>:T</code>, 所以所有的 new 方法都默认允许类型对象。）</p>
<p>这些默认可以通过各种编译指令在词法作用域中更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">use parameters :D;</div></pre></td></tr></table></figure>
<p>会让非调用者的参数默认为 <code>:D</code>。</p>
<p>作为对比,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">use variables :D;</div></pre></td></tr></table></figure>
<p>会对用于变量声明中的类型做同样的事情。<br>在这样的词法作用域中, 你可以使用 <code>:_</code> 形式回到标准的行为。特别地, 因为调用者默认为定义的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">use invocant :_;</div></pre></td></tr></table></figure>
<p>会让调用者允许任何类型的有定义的和未定义的调用者。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的正则表达式(三)]]></title>
      <url>http://ohmycloud.github.io/2015/11/05/Perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%89/</url>
      <content type="html"><![CDATA[<h1 id="预定义-Subrules"><a href="#预定义-Subrules" class="headerlink" title="预定义 Subrules"></a>预定义 Subrules</h1><p>下面这些是为任意 grammar 或 regex 预定义好的 <code>subrules</code>:</p>
<ul>
<li><p>ident </p>
<p>匹配一个标识符.</p>
</li>
<li><p>upper </p>
<p>匹配单个大写字符.</p>
</li>
<li><p>lower </p>
<p>匹配单个小写字符.</p>
</li>
<li><p>alpha </p>
<p>匹配单个字母字符, 或者是一个下划线.</p>
<p>要匹配不带下划线的 Unicode 字母字符, 使用 <code>&lt;:alpha&gt;</code>.</p>
</li>
<li><p>digit </p>
<p>匹配单个数字.</p>
</li>
<li><p>xdigit </p>
<p>匹配单个十六进制数字.</p>
</li>
<li><p>print </p>
<p>匹配单个可打印字符.</p>
</li>
<li><p>graph </p>
<p>匹配单个图形字符.</p>
</li>
<li><p>cntrl </p>
<p>匹配单个控制字符. (等价于 &lt;:Cc&gt; 属性). 控制字符通常不产生输出, 相反, 它们以某种方式控制末端:例如换行符和退格符都是控制字符. 所有使用 <code>ord()</code> 之后小于 32 的字符通常归类为控制字符. 就像 ord() 的值为 127 的字符是控制字符(DEL) 一样, 128 到 159 之间的也是控制字符.</p>
</li>
<li><p>punct </p>
<p>匹配单个标点符号字符(即, 任何来自于 Unicode General Category “Punctuation” 的字符).</p>
</li>
<li><p>alnum </p>
<p>匹配单个字母数字字符. 那等价于 <code>&lt;+alpha +digit&gt;</code> .</p>
</li>
<li><p>wb </p>
<p>在单词边界匹配成功并返回一个零宽匹配.  一个单词边界是这样一个点, 它的一边是一个 <code>\w</code>, 另一边是一个 <code>\W</code>. (以任一顺序),  字符串的开头和结尾被看作为匹配 <code>\W</code>.</p>
</li>
<li><p>ww </p>
<p>在两个单词字符之间匹配(零宽匹配).</p>
</li>
<li><p>ws </p>
<p>在两个单词字符之间匹配要求的空白, 否则匹配可选的空白. 这等价于 <code>\s*</code> (<code>ws</code> 不要求使用 <code>ww</code> subrule).</p>
</li>
<li><p>space </p>
<p>匹配单个空白字符character (和 <code>\s 相同</code>).</p>
</li>
<li><p>blank </p>
<p>匹配单个 “blank” 字符 – 在大部分区域, 这相当于 <code>space</code> 和 <code>tab</code>.</p>
</li>
<li><p>before <code>pattern</code></p>
<p>执行向前查看– 例如, 检查我们是否在某个能匹配的位置. 如果匹配成功返回一个零宽 Match 对象.</p>
</li>
<li><p>after <code>pattern</code></p>
<p>执行向后查看 –例如,检查当前位置之前的字符串是否匹配 <code>&lt;pattern&gt;</code>(在结尾锚定). 如果匹配成功就返回一个零宽 Match 对象. </p>
</li>
<li><p>&lt;?&gt; </p>
<p>匹配一个 null 字符串,即, 总是返回真. </p>
</li>
<li><p>&lt;!&gt; </p>
<p><code>&lt;?&gt;</code> 的反转, 总是返回假<br><a href="https://github.com/perl6/roast/blob/master/S05-mass/stdrules.t#L310-L326" target="_blank" rel="external"><code>S05-mass/stdrules.t lines 310–326</code></a><br>​</p>
<h1 id="反斜线改良"><a href="#反斜线改良" class="headerlink" title="反斜线改良"></a>反斜线改良</h1></li>
<li><p>很多 <code>\p</code> 和 <code>\P</code> 属性变成诸如 <code>&lt;alpha&gt;</code> 和 <code>&lt;-alpha&gt;</code> 等内在的 grammar rules. 它们可以使用上面提到的字符类标记法进行组合.<code>&lt;[-]+alpha+digit&gt;</code>. 不管高层级字符类的名字, 所有的低层级 Unicode 属性总是可以使用一个前置冒号访问, 即, 在尖括号中使用 pair 标记法.因此 <code>&lt;+:Lu+:Lt&gt;</code> 等价于 <code>&lt;+upper+title&gt;</code>.</p>
</li>
<li><p><code>\L...\E</code>, <code>\U...\E</code>, 和 <code>\Q...\E</code> 序列被废弃了. 单个字符的大小写修饰符 <code>\l</code> 和 <code>\u</code> 也被废弃了. 在极少需要使用它们的地方, 你可以使用 <code>&lt;{ lc $regex }&gt;</code>, <code>&lt;{tc $word}&gt;</code>, 等.</p>
</li>
<li><p>就像上面提到的, <code>\b</code> 和 <code>\B</code> 单词边界断言被废弃了, 并且被 <code>&lt;|w&gt;</code> (或 <code>&lt;wb&gt;</code>) 和 <code>&lt;!|w&gt;</code> (或 <code>&lt;!wb&gt;</code>) 零宽断言代替.</p>
</li>
<li><p><code>\G</code>  序列也没有了. 使用 <code>:p</code> 代替. (注意, 虽然, 在模式内使用 <code>:p</code> 没有影响, 因为每个内部模式都被隐式的锚定到当前位置) 查看下面的 at 断言.</p>
</li>
<li><p>向后引用 (例如. <code>\1</code>, <code>\2</code>, 等.) 都没有了; 可以使用 <code>$0</code>, <code>$1</code>, 等代替. 因为正则中变量不再进行插值.<br><a href="https://github.com/perl6/roast/blob/master/S05-capture/dot.t#L56-L61" target="_blank" rel="external"><code>S05-capture/dot.t lines 56–61</code></a><br>​<br>数字变量被假定是每次都会改变的, 因此被看作是程序化的, 不像普通变量那样.<br>​</p>
</li>
<li>新的反斜线序列, <code>\h</code> 和 <code>\v</code>, 分别匹配水平空白和垂直空白, 包括 Unicode. 水平空白被定义为任何匹配 <code>\s</code> 并且不匹配 <code>\v</code> 的东西. 垂直空白被定义为下面的任一方式:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">U+000A  LINE FEED (LF)</div><div class="line">U+000B  LINE TABULATION</div><div class="line">U+000C  FORM FEED (FF)</div><div class="line">U+000D  CARRIAGE RETURN (CR)</div><div class="line">U+0085  NEXT LINE (NEL)</div><div class="line">U+2028  LINE SEPARATOR</div><div class="line">U+2029  PARAGRAPH SEPARATOR</div></pre></td></tr></table></figure>
<p> ​<br>注意 <code>U+000D</code> (CARRIAGE RETURN) 被认为是垂直空白.<br> ​</p>
<ul>
<li><code>\s</code> 现在匹配任何 Unicode 空白字符.</li>
<li>新的反斜线序列和 <code>\N</code> 匹配除逻辑换行符之外的任何字符, 它是 <code>\n</code> 的否定.</li>
<li><p>其它新的大写的反斜线序列也都是它们小写身份的反义:</p>
<ul>
<li><code>\H</code> 匹配任何非水平空白字符.</li>
<li><code>\V</code> 匹配任何非垂直空白字符.</li>
<li><code>\T</code> 匹配任何非 tab 字符.</li>
<li><code>\R</code> 匹配任何非 return 字符.</li>
<li><code>\F</code> 匹配任何非格式字符.</li>
<li><code>\E</code> 匹配任何非转义字符.</li>
<li><code>\X...</code> 匹配任何非指定的(指定为十六进制)字符.</li>
<li>在普通字符串中反斜线转义字面字符串在 regexes 中是允许的(\a, \x 等等). 然而, 这个规则的例外是 <code>\b</code>., 它被禁用了,为了避免跟之前作为单词边界断言冲突. 要匹配字面反斜线, 使用 <code>\c8</code>, <code>\x8</code>或双引号引起的 <code>\b</code>.</li>
</ul>
</li>
</ul>
<h1 id="便捷的字符类"><a href="#便捷的字符类" class="headerlink" title="便捷的字符类"></a>便捷的字符类</h1><p>因为历史原因和使用方便, 下面的字符类可以作为反斜线序列使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">\d      &lt;digit&gt;    A digit</div><div class="line">\D      &lt;-digit&gt;   A nondigit</div><div class="line">\w      &lt;alnum&gt;    A word character</div><div class="line">\W      &lt;-alnum&gt;   A non-word character</div><div class="line">\s      &lt;sp&gt;       A whitespace character</div><div class="line">\S      &lt;-sp&gt;      A non-whitespace character</div><div class="line">\h                 A horizontal whitespace</div><div class="line">\H                 A non-horizontal whitespace</div><div class="line">\v                 A vertical whitespace</div><div class="line">\V                 A non-vertical whitespace</div></pre></td></tr></table></figure>
<h1 id="Regexes构成一等语言"><a href="#Regexes构成一等语言" class="headerlink" title="Regexes构成一等语言"></a>Regexes构成一等语言</h1><p>而不仅仅是字符串.</p>
<ul>
<li><p>Perl 5 的 <code>qr/pattern/</code> 正则构造器滚蛋了.</p>
</li>
<li><p>Perl 6 中的正则构造:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">regex &#123; pattern &#125;    # 总是把 &#123;...&#125; 作为模式分隔符</div><div class="line">rx    / pattern /    # 几乎能使用任何字符作为模式分割符</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/delimiters.t#L6-L20" target="_blank" rel="external"><code>S05-metasyntax/delimiters.t lines 6–20</code></a></p>
<p>你不能使用空格或字母数字作为分隔符.你可以使用圆括号作为你的 rx 分隔符, 但是这只有当你插入空格时才行(标识符后面直接跟着圆括号会被认为是函数调用):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rx ( pattern )      # okay</div><div class="line">rx( 1,2,3 )         # 尝试调用 rx 函数</div></pre></td></tr></table></figure>
<p>(在 Perl 6 中 这对所有类似 quotelike 的结构都适用.)</p>
<p> <code>//</code> 匹配能使用的地方 <code>rx</code> 这种形式也能直接作为模式使用. <code>regex</code> 这种形式实际上是一个方法定义, 必须用于 grammar 类中.</p>
<ul>
<li>如果 <code>regex</code> 或 <code>rx</code> 需要修饰符, 就把修饰符直接放在开放分隔符前面:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$regex = regex :s:i &#123; my name is (.*) &#125;;</div><div class="line">$regex = rx:s:i     / my name is (.*) /;    # same thing</div></pre></td></tr></table></figure>
<p>如果使用任何括号字符作为分隔符, 那么最后的修饰符之后是需要空格的. ( 否则, 它会被看作修饰符的参数)</p>
<ul>
<li>不能使用冒号作为分隔符. 修饰符之间可以有空格:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$regex = rx :s :i / my name is (.*) /;</div></pre></td></tr></table></figure>
<ul>
<li><p>正则构建器的名字是从 qr 修改而来, 因为它不再是一个能插值的 quote-like 操作符. <code>rx</code> 是 <code>regex</code> 的简写形式.(不要对regular expressions 感到困惑, 除了它们是的时候 )</p>
</li>
<li><p>像语法指示的那样, 它现在跟 <code>sub { ... }</code> 构建器很像. 实际上, 这种类似物深深根植于 Perl 6 中.</p>
</li>
<li><p>就像一个原始的 <code>{...}</code>现在总是一个闭包 (它仍然能在特定上下文中被立即执行并在其它上下文中作为对象传递), 所以原始的 <code>/.../</code> 总是一个 <code>Regex</code> 对象(它可能仍然在特定上下文中被立即匹配并在其它上下文中作为对象传递.)</p>
</li>
<li><p>特别地, 在 value 上下文(<code>sink</code>, <code>Boolean</code>, <code>string</code> 或 <code>numeric</code>),或它是 <code>~~</code> 的显式参数时, <code>/.../</code>会立即匹配. 否则, 它就是一个跟显式的 regex 形式同一的<code>Regex</code> 构建器, 所以这个:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$var = /pattern/;</div></pre></td></tr></table></figure>
<p>不再进行匹配并把结果设置为 <code>$var</code>. 相反, 它把一个 <code>Regex</code> 对象赋值给 <code>$var</code>.</p>
<ul>
<li>这种情况总是可以使用 <code>m{...}</code> 或 <code>rx{...}</code>进行区分:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$match = m&#123;pattern&#125;;    # 立刻匹配 regex, 然后把匹配结果赋值给变量</div><div class="line">$regex = rx&#123;pattern&#125;;   # Assign regex expression itself</div></pre></td></tr></table></figure>
<ul>
<li>注意前面有个像这样魔法般的用法:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@list = split /pattern/, $str;</div></pre></td></tr></table></figure>
<p>现在来看就是理所当然的了.</p>
<ul>
<li>就是现在, 建立一个像 grep 那样的用户自定义子例程也成为可能:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sub my_grep($selector, *@list) &#123;</div><div class="line">  given $selector &#123;</div><div class="line">    when Regex &#123; ... &#125;</div><div class="line">    when Code  &#123; ... &#125;</div><div class="line">    when Hash  &#123; ... &#125;</div><div class="line">    # etc.</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你调用 <code>my_grep</code> 时, 第一个参数被绑定到 item 上下文, 所以传递 <code>{...}</code> 或 <code>/.../</code> 产生 <code>Code</code> 或 <code>Regex</code> 对象,  switch 语句随后选中它作为条件.(正常的 grep 只是让智能匹配操作符做了所有的工作)</p>
<ul>
<li>就像 <code>rx</code> 拥有变体一样, <code>regex</code> 声明符也有. 特别地, regex 有两个用在 grammars 中的变体: <code>token</code> 和 <code>rule</code>.</li>
</ul>
<p>token声明长这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">token ident &#123; [ &lt;alpha&gt; | \- ] \w* &#125;</div></pre></td></tr></table></figure>
<p>默认<strong>从不回溯</strong>. 即, 它倾向于保留任何目前位置扫描到的东西.所以,上面的代码等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">regex ident &#123; [ &lt;alpha&gt;: | \-: ]: \w*: &#125;</div></pre></td></tr></table></figure>
<p>但是相当易读. 在 token 中裸的 <code>*</code>, <code>+</code> 和 <code>?</code> 量词绝不回溯. 在普通的 regexes 中, 使用 <code>*:</code>, <code>+:</code>, 或 <code>?:</code> 阻止量词的回溯. 如果你确实要回溯, 在量词后面添加 <code>?</code> 或 <code>!</code>.  <code>?</code> 像平常一样进行非懒惰匹配, 而 <code>!</code> 强制进行贪婪匹配. <code>token</code> 声明符就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">regex :ratchet &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>的简写.</p>
<p>另外一个是 <code>rule</code> 声明符, 像 token 一样, 它默认也不会回溯. 此外, 一个 <code>rule</code> 这样的正则表达式也采取了 <code>:sigspace</code> 修饰符. <code>rule</code> 实际上是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">regex :ratchet :sigspace &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>的简写.  ratchet 这个单词的意思是: (防倒转的)棘齿, 意思它是不能回溯的!</p>
<ul>
<li>Perl 5 的 <code>?...?</code> 语法(成功一次)极少使用, 并且现在能使用 <code>state</code> 变量以更清晰的方式模拟:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$result = do &#123; state $x ||= m/ pattern /; &#125;    # 只在第一次匹配</div></pre></td></tr></table></figure>
<p>要重置模式, 仅仅让 <code>$x = 0</code> 尽管你想要 <code>$x</code> 可见, 你还是必须避免使用 block:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$result = state $x ||= m/ pattern /;</div><div class="line">...</div><div class="line">$x = 0;</div></pre></td></tr></table></figure></p>
<h1 id="回溯控制"><a href="#回溯控制" class="headerlink" title="回溯控制"></a>回溯控制</h1><p>在这些被认为是程序的而非陈述性的模式的部分中, 你可以控制回溯行为.</p>
<ul>
<li><p>默认的, 在 <code>rx</code>,<code>m</code>, <code>s</code> 中的回溯是贪婪的. 在普通的 regex 声明中它们也是贪婪的. 在 rule 和 token 声明中, 回溯必须是显式的.</p>
</li>
<li><p>为了强制前面的原子执行节俭回溯(有时也是所谓的”急切的匹配” 或 “最少化的匹配”), 要在原子后面追加一个 <code>:?</code> 或 <code>?</code>. 如果前面的 token 是一个量词, <code>:</code> 就可以被省略, 所以 <code>*?</code> 就像在 Perl 5 中那样起作用.</p>
</li>
<li><p>为了强制前面的原子执行贪婪回溯, 在原子后面追加一个 <code>:!</code>.  如果前面的 token 是一个量词, <code>:</code> 可以被省略. (Perl 5 没有对应的结构, 因为在 Perl 5 中回溯默认是贪婪的.)</p>
</li>
<li><p>为了强制前面的原子不执行回溯, 使用不带 <code>?</code> 或 <code>!</code> 的单个 <code>:</code>.  单个冒号让正则引擎不再重试前面的原子:<br><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L8-L32" target="_blank" rel="external"><code>S05-mass/rx.t lines 8–32</code></a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ms/ \( &lt;expr&gt; [ , &lt;expr&gt; ]*: \) /</div></pre></td></tr></table></figure>
<p>(i.e. there’s no point trying fewer `` matches, if there’s no closing parenthesis on the horizon)</p>
<p>当修饰一个量词的时候,  可以使用 <code>+</code> 代替 <code>:</code>, 这种情况下, 量词常常是所谓的占有量词.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ms/ \( &lt;expr&gt; [ , &lt;expr&gt; ]*+ \) /  # same thing</div></pre></td></tr></table></figure></p>
<p>为了强制表达式中所有的原子默认不去回溯, 要使用 <code>:ratchet</code> 或 <code>rule</code> 或 <code>token</code>.</p>
<ul>
<li>对双冒号进行求值会抛弃当前 LTM 备选分支中所有保存的选择点。<br><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L33-L51" target="_blank" rel="external">S05-mass/rx.t lines 33–51</a><br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ms/ [ if :: &lt;expr&gt; &lt;block&gt;</div><div class="line">   | for :: &lt;list&gt; &lt;block&gt;</div><div class="line">   | loop :: &lt;loop_controls&gt;? &lt;block&gt;</div><div class="line">   ]</div><div class="line">/</div></pre></td></tr></table></figure>
</li>
</ul>
<p>​<br>到目前为止 2016.4.29 ，(<code>::</code>) 还没有实现。</p>
<p><code>::</code> 还有通过 <code>|</code> 从「最长 token」中隐藏右侧的任何陈述性匹配的效果。为了确定性，只有 <code>::</code> 左侧的东西被求值。</p>
<p>如果没有当前 LTM 备选分支，那么 <code>::</code> 什么也不会做。「当前」是被动态地定义的，而非词法地。<em>subrule</em> 中的 <code>::</code> 会影响闭合的备选分支。<br>​  ​</p>
<ul>
<li>对<code>::&gt;</code>进行求值会抛弃当前最里面的临时备选分支中所有保存的选择点。它因此表现得像 “then” 那样。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ms/ [</div><div class="line">    || &lt;?&#123; $a == 1 &#125;&gt; ::&gt; &lt;foo&gt;</div><div class="line">    || &lt;?&#123; $a == 2 &#125;&gt; ::&gt; &lt;bar&gt;</div><div class="line">    || &lt;?&#123; $a == 3 &#125;&gt; ::&gt; &lt;baz&gt;</div><div class="line">    ]</div><div class="line">/</div></pre></td></tr></table></figure>
<p>这儿省略了一部分还没实现的内容。</p>
<h1 id="Regex-子例程-具名和匿名"><a href="#Regex-子例程-具名和匿名" class="headerlink" title="Regex 子例程, 具名和匿名"></a>Regex 子例程, 具名和匿名</h1><ul>
<li><p><code>sub</code> 和 <code>regex</code> 之间的类推更为相似.</p>
</li>
<li><p>就像你可以有匿名子例程和具名子例程…</p>
</li>
<li><p>所以你也可以有匿名正则和具名正则(还有 tokens 和 rules)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">token ident &#123; [&lt;alpha&gt;|\-] \w* &#125;</div><div class="line"># 然后...</div><div class="line">@ids = grep /&lt;ident&gt;/, @strings;</div></pre></td></tr></table></figure>
<ul>
<li>就像上面的例子标示的那样, 引用具名正则也是可以的, 例如:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">regex serial_number &#123; &lt;[A..Z]&gt; \d**8 &#125;</div><div class="line">token type &#123; alpha | beta | production | deprecated | legacy &#125;</div></pre></td></tr></table></figure>
<p>在其它作为具名断言的正则表达式中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rule identification &#123; [soft|hard]ware &lt;type&gt; &lt;serial_number&gt; &#125;</div></pre></td></tr></table></figure>
<p>这些使用关键字声明的 regexes 官方类型为 <code>method</code>, 是从 <code>Routine</code> 派生出来的.<br>​<br>通常, 任何 subrule 的锚定是由它的调用上下文控制的. 当 regex, token, 或 rule 方法被作为 subrule 调用时, 前面被锚定到当前位置(与 <code>:p</code> 一样), 而后面没有被锚定, 因为调用上下文可能会继续解析. 然而, 当这样一个方法被直接智能匹配, 它会自动的锚定两端到字符串的开始和结尾. 因此, 你可以使用一个匿名的 regex 子例程作为单独的模式来直接模式匹配:<br>  ​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$string ~~ regex &#123; \d+ &#125;</div><div class="line">$string ~~ token &#123; \d+ &#125;</div><div class="line">$string ~~ rule  &#123; \d+ &#125;</div></pre></td></tr></table></figure></p>
<p>它们等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$string ~~ m/^ \d+ $/;</div><div class="line">$string ~~ m/^ \d+: $/;</div><div class="line">$string ~~ m/^ &lt;.ws&gt; \d+: &lt;.ws&gt; $/;</div></pre></td></tr></table></figure>
<p>基本经验就是关键字定义的方法绝对不会做 <code>.*?</code> 那样的扫描, 而如引号那种形式的 <code>m//</code>和<code>s///</code> 在缺少显式锚定的时候会做这样的扫描.</p>
<p><code>rx//</code> 和<code>//</code> 这两种形式, 怎么扫描都可以: 当被直接用在智能匹配或布尔上下文中时, 但是当它被作为一个 subrule 间接被调用时,就不会扫描. 即, 当直接使用时, <code>rx//</code> 返回的对象表现的像 <code>m//</code>, 但是用作 subrule 时, 表现的就像 <code>regex {}</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$pattern = rx/foo/;</div><div class="line">$string ~~ $pattern;                  # 等价于 m/foo/;</div><div class="line">$string ~~ /&apos;[&apos; &lt;$pattern&gt; &apos;]&apos;/       # 等价于 /&apos;[foo]&apos;/</div></pre></td></tr></table></figure>
<h1 id="空模式是非法的"><a href="#空模式是非法的" class="headerlink" title="空模式是非法的"></a>空模式是非法的</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L2378-L2392" target="_blank" rel="external"><code>S05-mass/rx.t lines 2378–2392</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/null.t#L17-L25" target="_blank" rel="external"><code>S05-metasyntax/null.t lines 17–25</code></a></p>
<p>在 Perl 6 中, <code>Null regex</code> 是非法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//</div></pre></td></tr></table></figure>
<p>要匹配一个零宽字符, 需要显式地表示 null 匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/ &apos;&apos; /;</div><div class="line">/ &lt;?&gt; /;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">split /&apos;&apos;/, $string</div></pre></td></tr></table></figure>
<p> 分割字符串。所以这样也行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">split &apos;&apos;, $string</div></pre></td></tr></table></figure>
<p>同样地，匹配一个空的分支，使用这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/a|b|c|&lt;?&gt;/</div><div class="line">/a|b|c|&apos;&apos;/</div></pre></td></tr></table></figure>
<p>更容易捕获错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/a|b|c|/</div></pre></td></tr></table></figure>
<p> 作为一种特殊情况, 匹配中的第一个 null 分支会被忽略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ms/ [</div><div class="line">         | if :: &lt;expr&gt; &lt;block&gt;</div><div class="line">         | for :: &lt;list&gt; &lt;block&gt;</div><div class="line">         | loop :: &lt;loop_controls&gt;? &lt;block&gt;</div><div class="line">    ]</div><div class="line">  /</div></pre></td></tr></table></figure>
<p>这在格式化 regex 时会有用。</p>
<p>但是注意, 只有<code>第一个分支</code>是特殊的, 如果你这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ms/ [</div><div class="line">             if :: &lt;expr&gt; &lt;block&gt;              |</div><div class="line">             for :: &lt;list&gt; &lt;block&gt;             |</div><div class="line">             loop :: &lt;loop_controls&gt;? &lt;block&gt;  |</div><div class="line">    ]</div><div class="line">  /</div></pre></td></tr></table></figure>
<p> 就是错的。因为最后一个分支是 null 。<br> 然而, non-null句法结构有一种退化的情况能匹配 null 字符串:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$something = &quot;&quot;;</div><div class="line">/a|b|c|$something/;</div></pre></td></tr></table></figure>
<p>特别地,  <code>&lt;?&gt;</code> 总是成功地匹配 null 字符串,  并且 <code>&lt;!&gt;</code> 总是让任何匹配都会失败.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作符]]></title>
      <url>http://ohmycloud.github.io/2015/11/03/%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      <content type="html"><![CDATA[<hr>
<p>title: 操作符<br>date: 2015-03-16 13:16<br>categories: Perl 6</p>
<h2 id="comments-true"><a href="#comments-true" class="headerlink" title="comments: true"></a>comments: true</h2><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><hr>
<h3 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h3><hr>
<p>在像 <code>1 + 2 * 3</code> 这样的表达式中， <code>2 * 3</code> 被首先计算， 因为中缀操作符  <code>*</code> 的优先级比 <code>+</code> 的优先级高。下面的表中总结了 Perl  6 中  的优先级级别， 从最牢固到最松散：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">A	Level	           Examples</div><div class="line">N	Terms	           42 3.14 &quot;eek&quot; qq[&quot;foo&quot;] $x :!verbose @$array</div><div class="line">L	方法后缀	        .meth .+ .? .* .() .[] .&#123;&#125; .&lt;&gt; .«» .:: .= .^ .:</div><div class="line">N	自增	              ++ --</div><div class="line">R	求幂	              **</div><div class="line">L	Symbolic unary	   ! + - ~ ? | || +^ ~^ ?^ ^</div><div class="line">L	乘法	              * / % %% +&amp; +&lt; +&gt; ~&amp; ~&lt; ~&gt; ?&amp; div mod gcd lcm</div><div class="line">L	加法	              + - +| +^ ~| ~^ ?| ?^</div><div class="line">L	重复	              x xx</div><div class="line">X	连结                ~</div><div class="line">X	Junctive and	   &amp;</div><div class="line">X	Junctive or	       | ^</div><div class="line">L	Named unary	       temp let</div><div class="line">N	Structural infix   but does &lt;=&gt; leg cmp .. ..^ ^.. ^..^</div><div class="line">C	Chaining infix	   != == &lt; &lt;= &gt; &gt;= eq ne lt le gt ge ~~ === eqv !eqv</div><div class="line">X	Tight and	       &amp;&amp;</div><div class="line">X	Tight or	       || ^^ // min max</div><div class="line">R	Conditional	       ?? !! ff fff</div><div class="line">R	Item assignment	   = =&gt; += -= **= xx= .=</div><div class="line">L	Loose unary	       so not</div><div class="line">X	Comma operator	   , :</div><div class="line">X	List infix	       Z minmax X X~ X* Xeqv ...</div><div class="line">R	List prefix	       print push say die map substr ... [+] [*] any Z=</div><div class="line">X	Loose and	       and andthen</div><div class="line">X	Loose or	       or xor orelse</div><div class="line">X	Sequencer	       &lt;==, ==&gt;, &lt;&lt;==, ==&gt;&gt;</div><div class="line">N	Terminator	       ; &#123;...&#125;, unless, extra ), ], &#125;</div></pre></td></tr></table></figure>
<p>下面使用的两处 <code>!</code> 符号一般代表任何一对儿拥有相同优先级的操作符， 上表指定的二元操作符的结合性解释如下(其中 A 代表结合性， associativities )：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">A	Assoc	Meaning of $a ! $b ! $c</div><div class="line">L	left	($a ! $b) ! $c</div><div class="line">R	right	$a ! ($b ! $c)</div><div class="line">N	non	    ILLEGAL</div><div class="line">C	chain	($a ! $b) and ($b ! $c)</div><div class="line">X	list	infix:&lt;!&gt;($a; $b; $)</div></pre></td></tr></table></figure>
<p>对于一元操作符， 这解释为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A	Assoc	Meaning of !$a!</div><div class="line">L	left	(!$a)!</div><div class="line">R	right	!($a!)</div><div class="line">N	non	    ILLEGAL</div></pre></td></tr></table></figure>
<p>下面描述的操作符， 默认假定为 left 结合性。</p>
<h3 id="操作符种类"><a href="#操作符种类" class="headerlink" title="操作符种类"></a>操作符种类</h3><hr>
<p>操作符能出现在相对于 term 的几个位置处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+term	        prefix         (后缀)</div><div class="line">term1 + term2	infix          (中缀)</div><div class="line">term++	        postfix        (后缀)</div><div class="line">(term)	        circumfix      (环缀)</div><div class="line">term1[term2]	postcircumfix  (后环缀)</div></pre></td></tr></table></figure>
<p>每个操作符也可以用作子例程。 这样的子例程的名字由操作符的种类， 然后后跟一个冒号，再加上一组引号结构， 引号结构中是组成操作符的符号(s):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">infix:&lt;+&gt;(1, 2)                           # same as 1 + 2</div><div class="line">circumfix:«( )»(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)            # same as (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;), 目前编译错误。</div><div class="line">circumfix:&lt;[ ]&gt;(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;).perl.say   # [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div></pre></td></tr></table></figure>
<p>作为一种特殊情况， listop(列表操作符)既能作为 term 又能作为前缀。子例程调用是最常见的列表操作符。其它情况包括元运算中缀操作符 <code>[+]| 1, 2, 3</code> 和 <code>prefix</code> 等 stub 操作符。</p>
<p>定义自定义操作符在 <a href="http://doc.perl6.org/language/functions#Defining_Operators" target="_blank" rel="external"> /language/functions#Defining_Operators.</a>  中有涉及。</p>
<h3 id="Term-优先级"><a href="#Term-优先级" class="headerlink" title="Term 优先级"></a>Term 优先级</h3><hr>
<p>Term 怎么翻译才合适？ 我觉得翻译成 <code>项</code> 更合适， 表明这是一个名词。</p>
<h4 id="环缀-lt-gt"><a href="#环缀-lt-gt" class="headerlink" title="环缀 &lt; &gt;"></a>环缀 &lt; &gt;</h4><hr>
<p>引起单词的结构。以空白隔开内容， 并返回一个单词的 <code>Parcel</code>。 如果单词看起来像数字字面量或 <code>Pair</code> 字面量， 那么它会被转为合适的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &lt;a b c&gt;[1]  # b</div></pre></td></tr></table></figure>
<p>(Rakudo 当前总是返回一块儿字符串)。</p>
<h3 id="环缀"><a href="#环缀" class="headerlink" title="环缀 ( )"></a>环缀 ( )</h3><hr>
<p>分组操作符。</p>
<p>空的分组 <code>()</code> 创建一个空的 <code>Pracel</code>。 非空表达式周围的圆括号只是构建了表达式， 而没有额外的语义。</p>
<p>在参数列表中，在参数周围放上圆括号防止了参数被解释为具名参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">multi sub p(:$a!) &#123; say &apos;named&apos;      &#125;</div><div class="line">multi sub p($a)   &#123; say &apos;positional&apos; &#125;</div><div class="line">p a =&gt; 1;       # named</div><div class="line">p (a =&gt; 1);     # positional</div></pre></td></tr></table></figure>
<h3 id="环缀-1"><a href="#环缀-1" class="headerlink" title="环缀 { }"></a>环缀 { }</h3><hr>
<p>Block 或 散列构造器。</p>
<p>如果<code>{}</code> 里面的内容看起来像一组 pairs 并且没有 <code>$_</code> 或其它占位符参数，就返回一个散列， 这个散列由逐项逐项的 pair 组成。</p>
<p>否则就返回一个 Block。</p>
<p>注意，这个结构没有重新解析内容； 而里面的内容总是被解析为一组句子（例如，像一个 block）， 并且如果后面的分析表明它需要被解析成一个散列， 那么 block 就会被执行并强转为散列。</p>
<h3 id="环缀-2"><a href="#环缀-2" class="headerlink" title="环缀 [ ]"></a>环缀 [ ]</h3><hr>
<p>数组构造器。在列表上下文中返回一个不会展平的 item 化的数组。</p>
<h2 id="方法后缀优先级"><a href="#方法后缀优先级" class="headerlink" title="方法后缀优先级"></a>方法后缀优先级</h2><hr>
<h3 id="后环缀"><a href="#后环缀" class="headerlink" title="后环缀 [ ]"></a>后环缀 [ ]</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub postcircumfix:&lt;[ ]&gt;(@container, **@index,</div><div class="line">                        :$k, :$v, :$kv, :$p, :$exists, :$delete)</div></pre></td></tr></table></figure>
<p><code>:$k</code> 会创建一个 pair， 它是散列中的一个条目。 键是 <code>k</code>， 键值为 <code>$kv</code>。 所以， <code>$k</code> 等价于 <code>k</code> =&gt; <code>$k</code></p>
<p>访问 <code>@container</code>  中的一个或多个元素，即数组索引操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my @alphabet = &apos;a&apos; .. &apos;z&apos;;</div><div class="line">say @alphabet[0];                   #-&gt; a</div><div class="line">say @alphabet[1];                   #-&gt; b</div><div class="line">say @alphabet[*-1];                 #-&gt; z</div><div class="line">say @alphabet[100]:exists;          #-&gt; False</div><div class="line">say @alphabet[15, 4, 17, 11].join;  #-&gt; perl</div><div class="line">say @alphabet[23 .. *].perl;        #-&gt; (&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)</div><div class="line"></div><div class="line">@alphabet[1, 2] = &quot;B&quot;, &quot;C&quot;;</div><div class="line">say @alphabet[0..3].perl            #-&gt; (&quot;a&quot;, &quot;B&quot;, &quot;C&quot;, &quot;d&quot;)</div></pre></td></tr></table></figure>
<p>查看 <a href="http://doc.perl6.org/language/subscripts" target="_blank" rel="external">Subscripts</a> 获取关于该操作符行为的更详细的解释， 还有怎么在自定义类型中实现对它的支持。</p>
<h3 id="后环缀-1"><a href="#后环缀-1" class="headerlink" title="后环缀 { }"></a>后环缀 { }</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub postcircumfix:&lt;&#123; &#125;&gt;(%container, **@key,</div><div class="line">                        :$k, :$v, :$kv, :$p, :$exists, :$delete)</div></pre></td></tr></table></figure>
<p>访问 <code>%container</code> 的一个或多个元素， 即散列索引操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my  %color = kiwi =&gt; &quot;green&quot;, banana =&gt; &quot;yellow&quot;, cherry =&gt; &quot;red&quot;;</div><div class="line">say %color&#123;&quot;banana&quot;&#125;;               #-&gt; yellow</div><div class="line">say %color&#123;&quot;cherry&quot;, &quot;kiwi&quot;&#125;.perl;  #-&gt; (&quot;red&quot;, &quot;green&quot;)</div><div class="line">say %color&#123;&quot;strawberry&quot;&#125;:exists;    #-&gt; False</div><div class="line"></div><div class="line">%color&#123;&quot;banana&quot;, &quot;lime&quot;&#125; = &quot;yellowish&quot;, &quot;green&quot;;</div><div class="line">%color&#123;&quot;cherry&quot;&#125;:delete;</div><div class="line">say %color;  #-&gt; banana =&gt; yellowish, kiwi =&gt; green, lime =&gt; green</div></pre></td></tr></table></figure>
<p>查看 <code>后环缀 &lt; &gt;</code> 和 <code>后环缀 « »</code> 作为便捷形式， 查看 <code>Subscripts</code> 获取这个操作符行为的更详细解释， 还有怎么在自定义类型中实现对它的支持。</p>
<h3 id="后环缀-lt-gt"><a href="#后环缀-lt-gt" class="headerlink" title="后环缀 &lt; &gt;"></a>后环缀 &lt; &gt;</h3><hr>
<p><code>后环缀 { }</code> 的简写形式， 它会引起它的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my %color = kiwi =&gt; &quot;green&quot;, banana =&gt; &quot;yellow&quot;, cherry =&gt; &quot;red&quot;;</div><div class="line">say %color&lt;banana&gt;;             #-&gt; yellow</div><div class="line">say %color&lt;cherry kiwi&gt;.perl;   #-&gt; (&quot;red&quot;, &quot;green&quot;)</div><div class="line">say %color&lt;strawberry&gt;:exists;  #-&gt; False</div></pre></td></tr></table></figure>
<p>这不是一个真正的操作符， 它仅仅是一个在编译时把 <code>&lt; &gt;</code> 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
<h3 id="后环缀-«-»"><a href="#后环缀-«-»" class="headerlink" title="后环缀 « »"></a>后环缀 « »</h3><hr>
<p><code>后环缀 { }</code> 的简写形式。它会引起它的参数，并且 « » 中能进行变量插值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my %color = kiwi =&gt; &quot;green&quot;, banana =&gt; &quot;yellow&quot;, cherry =&gt; &quot;red&quot;;</div><div class="line">my $fruit = &quot;kiwi&quot;;</div><div class="line">say %color«cherry $fruit».perl;   #-&gt; (&quot;red&quot;, &quot;green&quot;)</div></pre></td></tr></table></figure>
<p>这不是一个真正的操作符， 它仅仅是一个在编译时把 « » 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
<h3 id="后环缀-2"><a href="#后环缀-2" class="headerlink" title="后环缀 ( )"></a>后环缀 ( )</h3><hr>
<p>调用操作符。把调用者当作 <code>Callable</code> 并引用它，它使用圆括号之间的表达式作为参数。</p>
<p>注意，标识符后面直接跟着一对儿圆括号总是被解析为子例程调用。</p>
<p>如果你想要你的对象响应该调用操作符， 你需要实现 <code>CALL-ME</code> 方法。</p>
<h3 id="postfix"><a href="#postfix" class="headerlink" title="postfix ."></a>postfix .</h3><hr>
<p>该操作符用于调用一个方法， <code>$invocant.method</code>。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-1"><a href="#postfix-1" class="headerlink" title="postfix .="></a>postfix .=</h3><hr>
<p>可变的方法调用。 <code>$invocant.=method</code> ， 脱去语法糖后就是 <code>$invocant = $invocant.method</code> , 这与 <a href="http://doc.perl6.org/routine/op%3D" target="_blank" rel="external">op=.</a> 类似。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-2"><a href="#postfix-2" class="headerlink" title="postfix .^"></a>postfix .^</h3><hr>
<p>元方法调用。 <code>$invocant.^method</code> 在  <code>$invocant</code> 的元类身上调用方法。脱去语法糖后， 它就是 <code>$invocant.HOW.method($invocant, ...)</code> 。 查看 <a href="http://doc.perl6.org/type/HOW" target="_blank" rel="external">HOW</a> 获取更多信息。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-3"><a href="#postfix-3" class="headerlink" title="postfix .?"></a>postfix .?</h3><hr>
<p><code>有可能被调用</code>的方法调用。如果有名为 <code>method</code> 的方法，  <code>$invocant.?method</code> 就在 <code>$invocant</code> 上调用 <code>method</code> 方法。否则它就返回 <code>Nil</code>。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-4"><a href="#postfix-4" class="headerlink" title="postfix .+"></a>postfix .+</h3><hr>
<p><code>$invocant.+method</code> 从 <code>$invocant</code> 身上调用所有叫做     <code>method</code> 的方法， 并返回一个 Parcel 作为结果。 如果没有找到这个名字的方法， 就会死掉。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-5"><a href="#postfix-5" class="headerlink" title="postfix .*"></a>postfix .*</h3><hr>
<p><code>$invocant.*method</code> <code>从</code>$invocant<code>身上调用所有叫做</code>method` 的方法， 并返回一个 Parcel 作为结果。 如果没有找到这个名字的方法，则返回一个空的 Parcel。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-postfix"><a href="#postfix-postfix" class="headerlink" title="postfix .postfix"></a>postfix .postfix</h3><hr>
<p>大多数情况下， 可以在后缀或后环缀前面放上一个点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@a[1, 2, 3];</div><div class="line">@a.[1, 2, 3]; # Same</div></pre></td></tr></table></figure>
<p>这对于视觉清晰或简洁很有帮助。例如，如果对象的属性是一个函数，在属性名后面放置一对儿圆括号会变成方法调用的一部分。 所以要么使用两对儿圆括号， 要么在圆括号前面放上一个点来阻止方法调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Operation &#123;</div><div class="line">    has $.symbol;</div><div class="line">    has &amp;.function;</div><div class="line">&#125;</div><div class="line">my $addition = Operation.new(:symbol&lt;+&gt;, :function&#123; $^a + $^b &#125;);</div><div class="line">say $addition.function()(1, 2); # 3</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $addition.function.(1,2); # 3</div></pre></td></tr></table></figure>
<p> 然而，如果后缀是一个标识符， 那么它会被解释为一个普通的方法调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.i # No such method &apos;i&apos; for invocant of type &apos;Int&apos;</div></pre></td></tr></table></figure>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-6"><a href="#postfix-6" class="headerlink" title="postfix .:"></a>postfix .:<prefix></prefix></h3><hr>
<p>前缀能够像方法那样， 使用冒号对儿标记法来调用。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $a = 1;</div><div class="line">say ++$a;     # 2</div><div class="line">say $a.:&lt;++&gt;; # 3</div></pre></td></tr></table></figure>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-7"><a href="#postfix-7" class="headerlink" title="postfix .::"></a>postfix .::</h3><hr>
<p>一个类限定的方法调用， 用于调用一个定义在父类或 role 中的方法， 甚至在子类中重新定义了之后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Bar &#123;</div><div class="line">    method baz &#123; 42 &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Foo is Bar &#123;</div><div class="line">    method baz &#123; &quot;nope&quot; &#125;</div><div class="line">&#125;</div><div class="line">say Foo.Bar::baz; # 42</div></pre></td></tr></table></figure>
<h2 id="自增优先级"><a href="#自增优先级" class="headerlink" title="自增优先级"></a>自增优先级</h2><hr>
<h3 id="prefix"><a href="#prefix" class="headerlink" title="prefix ++"></a>prefix ++</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;++&gt;($x is rw) is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>把它的参数增加 1， 并返回增加后的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $x = 3;</div><div class="line">say ++$x;    # 4</div><div class="line">say $x;      # 4</div></pre></td></tr></table></figure>
<p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法， 这可以让自定义类型自由地实现它们自己的增量语义。</p>
<h3 id="prefix-–"><a href="#prefix-–" class="headerlink" title="prefix –"></a>prefix –</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;--&gt;($x is rw) is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>把它的参数减少 1， 并返回减少后的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $x = 3;</div><div class="line">say --$x;       # 2</div><div class="line">say $x;         # 2</div></pre></td></tr></table></figure>
<p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法， 这可以让自定义类型自由地实现它们自己的减量语义。</p>
<h3 id="postfix-8"><a href="#postfix-8" class="headerlink" title="postfix ++"></a>postfix ++</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub postfix:&lt;++&gt;($x is rw) is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>把它的参数增加 1， 并返回<code>unincremented</code>的那个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $x = 3;</div><div class="line">say $x++;       # 3</div><div class="line">say $x;         # 4</div></pre></td></tr></table></figure>
<p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法， 这可以让自定义类型自由地实现它们自己的增量语义。</p>
<p>注意这并不一定返回它的参数。 例如，对于未定义的值， 它返回 0:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $x;</div><div class="line">say $x++;       # 0</div><div class="line">say $x;         # 1</div></pre></td></tr></table></figure>
<h3 id="postfix-–"><a href="#postfix-–" class="headerlink" title="postfix –"></a>postfix –</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub postfix:&lt;--&gt;($x is rw) is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>把它的参数减少 1， 并返回<code>undecremented</code>的那个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $x = 3;</div><div class="line">say $x--;       # 3</div><div class="line">say $x;         # 2</div></pre></td></tr></table></figure>
<p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法， 这可以让自定义类型自由地实现它们自己的减量语义。</p>
<p>注意这并不一定返回它的参数。 例如，对于未定义的值， 它返回 0:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $x;</div><div class="line">say $x--;       # 0</div><div class="line">say $x;         # -1</div></pre></td></tr></table></figure>
<h2 id="求幂优先级"><a href="#求幂优先级" class="headerlink" title="求幂优先级"></a>求幂优先级</h2><hr>
<h3 id="infix"><a href="#infix" class="headerlink" title="infix **"></a>infix **</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;**&gt;(Any, Any) returns Numeric:D is assoc&lt;right&gt;</div></pre></td></tr></table></figure>
<p>求幂操作符把它的两个参数都强制转为 <code>Numeric</code> , 然后计算，右侧为幂。</p>
<p>如果 <code>**</code> 右边是一个非负整数，并且左侧是任意精度类型(Int, FatRat)，那么计算不会损失精度。</p>
<h2 id="象形一元操作符的优先级"><a href="#象形一元操作符的优先级" class="headerlink" title="象形一元操作符的优先级"></a>象形一元操作符的优先级</h2><hr>
<h3 id="prefix-1"><a href="#prefix-1" class="headerlink" title="prefix ?"></a>prefix ?</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;?&gt;(Mu) returns Bool:D</div></pre></td></tr></table></figure>
<p>布尔上下文操作符。</p>
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool。注意， 这会使 Junctions 失效。</p>
<h3 id="prefix-2"><a href="#prefix-2" class="headerlink" title="prefix !"></a>prefix !</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;!&gt;(Mu) returns Bool:D</div></pre></td></tr></table></figure>
<p>否定的布尔上下文操作符。</p>
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool， 并返回结果的否定值。注意， 这会使 Junctions 失效。</p>
<h3 id="prefix-3"><a href="#prefix-3" class="headerlink" title="prefix +"></a>prefix +</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;+&gt;(Any) returns Numeric:D</div></pre></td></tr></table></figure>
<p>Numeric 上下文操作符。</p>
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型。</p>
<h3 id="prefix-4"><a href="#prefix-4" class="headerlink" title="prefix -"></a>prefix -</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;-&gt;(Any) returns Numeric:D</div></pre></td></tr></table></figure>
<p>否定的 Numeric 上下文操作符。</p>
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型， 并返回结果的否定值。</p>
<h3 id="prefix-5"><a href="#prefix-5" class="headerlink" title="prefix ~"></a>prefix ~</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;-&gt;(Any) returns Str:D</div></pre></td></tr></table></figure>
<p>字符串上下文操作符。</p>
<p>通过在参数身上调用 <code>Str</code> 方法强制把参数转为 <code>Str</code> 类型。</p>
<h3 id="prefix-6"><a href="#prefix-6" class="headerlink" title="prefix |"></a>prefix |</h3><hr>
<p>将  Capture, Enum, Pair, List, Parcel, EnumMap 和 Hash 展平到参数列表中。</p>
<p>（在 Rakudo 中，这不是作为一个合适的操作符来实现的，而是编译器中的一种特殊情况， 这意味着它只对参数列表有效，而非在任意代码中都有效。）</p>
<h3 id="prefix-7"><a href="#prefix-7" class="headerlink" title="prefix +^"></a>prefix +^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;+^&gt;(Any) returns Int:D</div></pre></td></tr></table></figure>
<p>Integer bitwise negation</p>
<p>整数按位取反。</p>
<p>将参数强转为 Int 类型并对结果按位取反， 假设两者互补。</p>
<h3 id="prefix-8"><a href="#prefix-8" class="headerlink" title="prefix ?^"></a>prefix ?^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;?^&gt;(Mu) returns Bool:D</div></pre></td></tr></table></figure>
<p>布尔按位取反。</p>
<p>将参数强转为 Bool， 然后按位反转，这使它和 prefix:&lt;!&gt;  一样。</p>
<h3 id="prefix-9"><a href="#prefix-9" class="headerlink" title="prefix ^"></a>prefix ^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;^&gt;(Any) returns Range:D</div></pre></td></tr></table></figure>
<p>upto 操作符.</p>
<p>强制把它的参数转为 Numeric， 生成一个从 0 直到（但是排除） 参数为止的范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say ^5;         # 0..^5</div><div class="line">for ^5 &#123; &#125;      # 5 iterations</div></pre></td></tr></table></figure>
<h2 id="乘法优先级"><a href="#乘法优先级" class="headerlink" title="乘法优先级"></a>乘法优先级</h2><hr>
<h3 id="infix-1"><a href="#infix-1" class="headerlink" title="infix *"></a>infix *</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;*&gt;(Any, Any) returns Numeric:D</div></pre></td></tr></table></figure>
<p>把两边的参数都强转为 Numeric 并把它们相乘。 结果是一个更宽的类型。 查看 Numeric 获取更详细信息。</p>
<h3 id="infix-2"><a href="#infix-2" class="headerlink" title="infix /"></a>infix /</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;/&gt;(Any, Any) returns Numeric:D</div></pre></td></tr></table></figure>
<p>把两边的参数都强制为 Numeric， 并用左边除以右边的数。整数相除返回 Rat， 否则返回”更宽类型” 的结果。</p>
<h3 id="infix-div"><a href="#infix-div" class="headerlink" title="infix div"></a>infix div</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;div&gt;(Int:D, Int:D) returns Int:D</div></pre></td></tr></table></figure>
<p>整除。向下取整。</p>
<h3 id="infix-3"><a href="#infix-3" class="headerlink" title="infix %"></a>infix %</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;%&gt;($x, $y) return Numeric:D</div></pre></td></tr></table></figure>
<p>模操作符。首先强制为 Numeric。</p>
<p>通常，下面的等式是成立的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$x % $y == $x - floor($x / $y) * $y</div></pre></td></tr></table></figure>
<h3 id="infix-4"><a href="#infix-4" class="headerlink" title="infix %%"></a>infix %%</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;%%&gt;($a, $b) returns Bool:D</div></pre></td></tr></table></figure>
<p>整除操作符， 如果 <code>$a % $b == 0</code> 则返回 True.</p>
<h3 id="infix-mod"><a href="#infix-mod" class="headerlink" title="infix mod"></a>infix mod</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;mod&gt;(Int:D $a, Int:D $b) returns Int:D</div></pre></td></tr></table></figure>
<p>整数取模操作符。 返回整数取模操作的剩余部分。</p>
<h3 id="infix-amp"><a href="#infix-amp" class="headerlink" title="infix +&amp;"></a>infix +&amp;</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;+&amp;&gt;($a, $b) returns Int:D</div></pre></td></tr></table></figure>
<p>Numeric 按位 <code>AND</code>。 把两个参数都强转为 Int 并执行按位 AND 操作，假定两者是互补的。</p>
<h3 id="infix-lt"><a href="#infix-lt" class="headerlink" title="infix +&lt;"></a>infix +&lt;</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;&lt; +&lt; &gt;&gt;($a, $b) returns Int:D</div></pre></td></tr></table></figure>
<p>向左移动整数个位。</p>
<h3 id="infix-gt"><a href="#infix-gt" class="headerlink" title="infix +&gt;"></a>infix +&gt;</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;&lt; +&gt; &gt;&gt;($a, $b) returns Int:D</div></pre></td></tr></table></figure>
<p>向右移动整数个位。</p>
<h3 id="infix-gcd"><a href="#infix-gcd" class="headerlink" title="infix gcd"></a>infix gcd</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;gcd&gt;($a, $b) returns Int:D</div></pre></td></tr></table></figure>
<p>强制两个参数都为 Int 并返回最大公分母（greatest common denominator）。</p>
<h3 id="infix-lcm"><a href="#infix-lcm" class="headerlink" title="infix lcm"></a>infix lcm</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;lcm&gt;($a, $b) returns Int:D</div></pre></td></tr></table></figure>
<p>强制两个参数为 Int 并返回最小公倍数(least common multiple)</p>
<h2 id="加法优先级"><a href="#加法优先级" class="headerlink" title="加法优先级"></a>加法优先级</h2><hr>
<h3 id="infix-5"><a href="#infix-5" class="headerlink" title="infix +"></a>infix +</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;+&gt;($a, $b) returns Numeric:D</div></pre></td></tr></table></figure>
<p>强制两个参数为 Numeric 并把它们相加。</p>
<h3 id="infix-6"><a href="#infix-6" class="headerlink" title="infix -"></a>infix -</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;-&gt;($a, $b) returns Numeric:D</div></pre></td></tr></table></figure>
<p>强制两个参数为 Numeric 并用第一个参数减去第二个参数。</p>
<h3 id="infix-7"><a href="#infix-7" class="headerlink" title="infix +|"></a>infix +|</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;+|&gt;($a, $b) returns Int:D</div></pre></td></tr></table></figure>
<p>强制两个参数为 Int 并执行按位 OR（包括 OR）</p>
<h3 id="infix-8"><a href="#infix-8" class="headerlink" title="infix +^"></a>infix +^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;+^&gt;($a, $b) returns Int:D</div></pre></td></tr></table></figure>
<p>强制两个参数为 Int 并执行按位 XOR（不包括 OR）</p>
<h3 id="infix-9"><a href="#infix-9" class="headerlink" title="infix ?|"></a>infix ?|</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;?|&gt;($a, $b) returns Bool:D</div></pre></td></tr></table></figure>
<p>强制两个参数为 Bool 并执行逻辑 OR（不包括 OR）</p>
<h2 id="重复操作符优先级"><a href="#重复操作符优先级" class="headerlink" title="重复操作符优先级"></a>重复操作符优先级</h2><hr>
<h3 id="infix-x"><a href="#infix-x" class="headerlink" title="infix x"></a>infix x</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;x&gt;(Any, Any) returns Str:D</div><div class="line">multi sub infix:&lt;x&gt;(Any, Any)</div><div class="line">multi sub infix:&lt;x&gt;(Str:D, Int:D)</div></pre></td></tr></table></figure>
<p>把 <code>$a</code> 强转为 Str ， 把 <code>$b</code> 强转为 Int， 并重复字符串 <code>$b</code> 次。 如果 <code>$b &lt;= 0</code> 则返回空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say &apos;ab&apos; x 3;       # ababab</div><div class="line">say 42 x 3;         # 424242</div></pre></td></tr></table></figure>
<h3 id="infix-xx"><a href="#infix-xx" class="headerlink" title="infix xx"></a>infix xx</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;xx&gt;($a, $b) returns List:D</div></pre></td></tr></table></figure>
<p>返回一组重复的 <code>$a</code> 并计算 <code>$b</code> 次（<code>$b</code> 被强转为 Int）。 如果 <code>$b &lt;= 0</code> ,则返回一个空列表。</p>
<p>每次重复都会计算左侧的值， 所以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[1, 2] xx 5</div></pre></td></tr></table></figure>
<p>返回 5 个不同的数组（但是每次都是相同的内容）并且</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rand xx 3</div></pre></td></tr></table></figure>
<p>返回 3 个独立的伪随机数。右侧可以是 <code>*</code>, 这时会返回一个惰性的，无限的列表。</p>
<h2 id="连结"><a href="#连结" class="headerlink" title="连结"></a>连结</h2><hr>
<h3 id="infix-10"><a href="#infix-10" class="headerlink" title="infix ~"></a>infix ~</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;~&gt;(Any, Any) returns Str:D</div><div class="line">multi sub infix:&lt;~&gt;(Any,   Any)</div><div class="line">multi sub infix:&lt;~&gt;(Str:D, Str:D)</div></pre></td></tr></table></figure>
<p>强制两个参数为 Str 并连结它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &apos;ab&apos; ~ &apos;c&apos;;     # abc</div></pre></td></tr></table></figure>
<h2 id="Junctive-AND-all-优先级"><a href="#Junctive-AND-all-优先级" class="headerlink" title="Junctive AND (all) 优先级"></a>Junctive AND (all) 优先级</h2><hr>
<h3 id="infix-amp-1"><a href="#infix-amp-1" class="headerlink" title="infix &amp;"></a>infix &amp;</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;&amp;&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;</div></pre></td></tr></table></figure>
<p>用它的参数创建一个 <code>all</code> Junction。查看 Junctions 获取更多详情。</p>
<h2 id="Junctive-OR-any-Precedence"><a href="#Junctive-OR-any-Precedence" class="headerlink" title="Junctive OR (any) Precedence"></a>Junctive OR (any) Precedence</h2><hr>
<h3 id="infix-11"><a href="#infix-11" class="headerlink" title="infix |"></a>infix |</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;|&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;</div></pre></td></tr></table></figure>
<p>用它的参数创建一个 <code>any</code> Junction。查看 Junctions 获取更多详情。</p>
<h3 id="infix-12"><a href="#infix-12" class="headerlink" title="infix ^"></a>infix ^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;^&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;</div></pre></td></tr></table></figure>
<p>用它的参数创建一个 <code>one</code> Junction。查看 Junctions 获取更多详情。</p>
<h2 id="Named-Unary-Precedence"><a href="#Named-Unary-Precedence" class="headerlink" title="Named Unary Precedence"></a>Named Unary Precedence</h2><hr>
<h3 id="prefix-temp"><a href="#prefix-temp" class="headerlink" title="prefix temp"></a>prefix temp</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub prefix:&lt;temp&gt;(Mu $a is rw)</div></pre></td></tr></table></figure>
<p>temporizes 传入的变量作为参数， 这意味着退出作用域后它被重置为旧值。（这和 Perl 5 中的 local 操作符类似， 除了 temp 不重置值之外。）</p>
<h3 id="prefix-let"><a href="#prefix-let" class="headerlink" title="prefix let"></a>prefix let</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub prefix:&lt;let&gt;(Mu $a is rw)</div></pre></td></tr></table></figure>
<p>假定重置：如果通过异常或 fail()退出当前作用域, 旧值就会被恢复。</p>
<h2 id="Nonchaining-Binary-Precedence"><a href="#Nonchaining-Binary-Precedence" class="headerlink" title="Nonchaining Binary Precedence"></a>Nonchaining Binary Precedence</h2><hr>
<h3 id="infix-does"><a href="#infix-does" class="headerlink" title="infix does"></a>infix does</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;does&gt;(Mu $obj, Mu $role) is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>在运行时把 <code>$role</code> 混合进 <code>$obj</code> 中。 要求 <code>$obj</code> 是可变的。</p>
<p>参数 <code>$role</code> 不一定要求是一个 role， 它可以表现的像是一个 role， 例如枚举值。</p>
<h3 id="infix-but"><a href="#infix-but" class="headerlink" title="infix but"></a>infix but</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;but&gt;(Mu $obj, Mu $role) is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>把 <code>$role</code> 混合进 <code>$obj</code> 并创建一个 <code>$obj</code> 的副本。因为 <code>$obj</code> 是不能修改的，但是能使用 mixins 用于创建不可变值。</p>
<p>参数 <code>$role</code> 不一定要求是一个 role， 它可以表现的像是一个 role， 例如枚举值。</p>
<h3 id="infix-cmp"><a href="#infix-cmp" class="headerlink" title="infix cmp"></a>infix cmp</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;cmp&gt;(Any, Any) returns Order:D is assoc&lt;none&gt;</div><div class="line">multi sub infix:&lt;cmp&gt;(Any,       Any)</div><div class="line">multi sub infix:&lt;cmp&gt;(Real:D,    Real:D)</div><div class="line">multi sub infix:&lt;cmp&gt;(Str:D,     Str:D)</div><div class="line">multi sub infix:&lt;cmp&gt;(Enum:D,    Enum:D)</div><div class="line">multi sub infix:&lt;cmp&gt;(Version:D, Version:D)</div></pre></td></tr></table></figure>
<p>一般的， “智能的” 三路比较器。</p>
<p>比较字符串时使用字符串语义， 比较数字时使用数字语义， 比较 Pair 对象时， 先比较键， 再比较值，等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if $a eqv $b, then $a cmp $b always returns Order::Same.</div><div class="line">say (a =&gt; 3) cmp (a =&gt; 4);      # Less</div><div class="line">say 4        cmp 4.0;           # Same</div><div class="line">say &apos;b&apos;      cmp &apos;a&apos;;           # More</div></pre></td></tr></table></figure>
<h3 id="infix-leg"><a href="#infix-leg" class="headerlink" title="infix leg"></a>infix leg</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;leg&gt;($a, $b) returns Order:D is assoc&lt;none&gt;</div><div class="line">multi sub infix:&lt;leg&gt;(Any,   Any)</div><div class="line">multi sub infix:&lt;leg&gt;(Str:D, Str:D)</div></pre></td></tr></table></figure>
<p>字符串三路比较器。 leg 是  less, equal 还有 greater 的简写形式？</p>
<p>把两个参数都强转为 <code>Str</code> , 然后按照字母次序比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say &apos;a&apos; leg &apos;b&apos;;        Less</div><div class="line">say &apos;a&apos; leg &apos;a&apos;;        Same</div><div class="line">say &apos;b&apos; leg &apos;a&apos;;        More</div></pre></td></tr></table></figure>
<h3 id="infix-lt-gt"><a href="#infix-lt-gt" class="headerlink" title="infix &lt;=&gt;"></a>infix &lt;=&gt;</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:«&lt;=&gt;»($a, $b) returns Order:D is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>Numeric 三路比较器。</p>
<p>把两个参数强转为 Real， 并执行数值比较。</p>
<h3 id="infix-13"><a href="#infix-13" class="headerlink" title="infix .."></a>infix ..</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;..&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>由参数创建一个  Range。</p>
<h3 id="infix-14"><a href="#infix-14" class="headerlink" title="infix ..^"></a>infix ..^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;..^&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>由参数创建一个 Range， 不包含末端。</p>
<h3 id="infix-15"><a href="#infix-15" class="headerlink" title="infix ^.."></a>infix ^..</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;^..&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>由参数创建一个 Range， 不包含开始端点。</p>
<h3 id="infix-16"><a href="#infix-16" class="headerlink" title="infix ^..^"></a>infix ^..^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;^..^&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</div></pre></td></tr></table></figure>
<p>由参数创建一个 Range， 不包含开端和末端。</p>
<h2 id="Chaining-Binary-Precedence"><a href="#Chaining-Binary-Precedence" class="headerlink" title="Chaining Binary Precedence"></a>Chaining Binary Precedence</h2><hr>
<h3 id="infix-17"><a href="#infix-17" class="headerlink" title="infix =="></a>infix ==</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;==&gt;($, $) returns Bool:D is assoc:&lt;chain&gt;</div><div class="line">multi sub infix:&lt;==&gt;(Any, Any)</div><div class="line">multi sub infix:&lt;==&gt;(Int:D, Int:D)</div><div class="line">multi sub infix:&lt;==&gt;(Num:D, Num:D)</div><div class="line">multi sub infix:&lt;==&gt;(Rational:D, Rational:D)</div><div class="line">multi sub infix:&lt;==&gt;(Real:D, Real:D)</div><div class="line">multi sub infix:&lt;==&gt;(Complex:D, Complex:D)</div><div class="line">multi sub infix:&lt;==&gt;(Numeric:D, Numeric:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Numeric（如果必要）， 并返回 True 如果它们相等。</p>
<h3 id="infix-18"><a href="#infix-18" class="headerlink" title="infix !="></a>infix !=</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;!=&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;</div></pre></td></tr></table></figure>
<p>强转两个参数为 Numeric（如果必要）， 并返回 True 如果它们不相等。</p>
<h3 id="infix-lt-1"><a href="#infix-lt-1" class="headerlink" title="infix &lt;"></a>infix &lt;</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">proto sub infix:«&lt;»(Any, Any) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:«&lt;»(Int:D, Int:D)</div><div class="line">multi sub infix:«&lt;»(Num:D, Num:D)</div><div class="line">multi sub infix:«&lt;»(Real:D, Real:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
<h3 id="infix-lt-2"><a href="#infix-lt-2" class="headerlink" title="infix &lt;="></a>infix &lt;=</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">proto sub infix:«&lt;=»(Any, Any) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:«&lt;=»(Int:D, Int:D)</div><div class="line">multi sub infix:«&lt;=»(Num:D, Num:D)</div><div class="line">multi sub infix:«&lt;=»(Real:D, Real:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
<h3 id="infix-gt-1"><a href="#infix-gt-1" class="headerlink" title="infix &gt;"></a>infix &gt;</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">proto sub infix:«&gt;»(Any, Any) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:«&gt;»(Int:D, Int:D)</div><div class="line">multi sub infix:«&gt;»(Num:D, Num:D)</div><div class="line">multi sub infix:«&gt;»(Real:D, Real:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
<h3 id="infix-gt-2"><a href="#infix-gt-2" class="headerlink" title="infix &gt;="></a>infix &gt;=</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">proto sub infix:«&gt;=»(Any, Any) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:«&gt;=»(Int:D, Int:D)</div><div class="line">multi sub infix:«&gt;=»(Num:D, Num:D)</div><div class="line">multi sub infix:«&gt;=»(Real:D, Real:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数大于或等于第二个参数。</p>
<h3 id="infix-eq"><a href="#infix-eq" class="headerlink" title="infix eq"></a>infix eq</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;eq&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:&lt;eq&gt;(Any,   Any)</div><div class="line">multi sub infix:&lt;eq&gt;(Str:D, Str:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数等于第二个参数。</p>
<p>助记法: equal</p>
<h3 id="infix-ne"><a href="#infix-ne" class="headerlink" title="infix ne"></a>infix ne</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;ne&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:&lt;ne&gt;(Mu,    Mu)</div><div class="line">multi sub infix:&lt;ne&gt;(Str:D, Str:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Str（如果必要）， 并返回 False 如果第一个参数等于第二个参数。</p>
<p>助记法: not equal</p>
<h3 id="infix-gt-3"><a href="#infix-gt-3" class="headerlink" title="infix gt"></a>infix gt</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;gt&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:&lt;gt&gt;(Mu,    Mu)</div><div class="line">multi sub infix:&lt;gt&gt;(Str:D, Str:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
<p>助记法: greater than</p>
<h3 id="infix-ge"><a href="#infix-ge" class="headerlink" title="infix ge"></a>infix ge</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;ge&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:&lt;ge&gt;(Mu,    Mu)</div><div class="line">multi sub infix:&lt;ge&gt;(Str:D, Str:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
<p>助记法: greater or equal</p>
<h3 id="infix-lt-3"><a href="#infix-lt-3" class="headerlink" title="infix lt"></a>infix lt</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;lt&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:&lt;lt&gt;(Mu,    Mu)</div><div class="line">multi sub infix:&lt;lt&gt;(Str:D, Str:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
<p>助记法: less than</p>
<h3 id="infix-le"><a href="#infix-le" class="headerlink" title="infix le"></a>infix le</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;le&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:&lt;le&gt;(Mu,    Mu)</div><div class="line">multi sub infix:&lt;le&gt;(Str:D, Str:D)</div></pre></td></tr></table></figure>
<p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数小于或等于第二个参数。</p>
<p>助记法: less or equal</p>
<h3 id="infix-before"><a href="#infix-before" class="headerlink" title="infix before"></a>infix before</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;before&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:&lt;before&gt;(Any,       Any)</div><div class="line">multi sub infix:&lt;before&gt;(Real:D,    Real:D)</div><div class="line">multi sub infix:&lt;before&gt;(Str:D,     Str:D)</div><div class="line">multi sub infix:&lt;before&gt;(Enum:D,    Enum:D)</div><div class="line">multi sub infix:&lt;before&gt;(Version:D, Version:D)</div></pre></td></tr></table></figure>
<p>一般的排序， 使用和 cmp 相同的语义。 如果第一个参数小于第二个参数则返回 True。</p>
<h3 id="infix-after"><a href="#infix-after" class="headerlink" title="infix after"></a>infix after</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;after&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:&lt;after&gt;(Any,       Any)</div><div class="line">multi sub infix:&lt;after&gt;(Real:D,    Real:D)</div><div class="line">multi sub infix:&lt;after&gt;(Str:D,     Str:D)</div><div class="line">multi sub infix:&lt;after&gt;(Enum:D,    Enum:D)</div><div class="line">multi sub infix:&lt;after&gt;(Version:D, Version:D)</div></pre></td></tr></table></figure>
<p>一般的排序， 使用和 cmp 相同的语义。 如果第一个参数大于第二个参数则返回 True。</p>
<h3 id="infix-eqv"><a href="#infix-eqv" class="headerlink" title="infix eqv"></a>infix eqv</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;eqv&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">proto sub infix:&lt;eqv&gt;(Any, Any)</div></pre></td></tr></table></figure>
<p>等值操作符。如果两个参数在结构上相同就返回 True。例如， 相同类型（并且递归）包含相同的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say [1, 2, 3] eqv [1, 2, 3];        # True</div><div class="line">say Any eqv Any;                    # True</div><div class="line">say 1 eqv 2;                        # False</div><div class="line">say 1 eqv 1.0;                      # False</div></pre></td></tr></table></figure>
<p>对于任意对象使用默认的 eqv 操作是不可能的。例如， eqv 不认为同一对象的两个实例在结构上是相等的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">    has $.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say A.new(a =&gt; 5) eqv A.new(a =&gt; 5);  #=&gt; False</div></pre></td></tr></table></figure>
<p>要得到这个类的对象相等（eqv）语义， 需要实现一个合适的中缀 eqv 操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">    has $.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multi infix:&lt;eqv&gt;(A $l, A $r) &#123; $l.a eqv $r.a &#125;</div><div class="line">say A.new(a =&gt; 5) eqv A.new(a =&gt; 5);  #=&gt; True</div></pre></td></tr></table></figure>
<h3 id="infix-19"><a href="#infix-19" class="headerlink" title="infix ==="></a>infix ===</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;===&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">proto sub infix:&lt;===&gt;(Any, Any)</div></pre></td></tr></table></figure>
<p>值相等。如果两个参数都是同一个对象则返回 True。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class A &#123; &#125;;</div><div class="line"></div><div class="line">my $a = A.new;</div><div class="line">say $a === $a;              # True</div><div class="line">say A.new === A.new;        # False</div><div class="line">say A === A;                # True</div></pre></td></tr></table></figure>
<p>对于值的类型，  <code>===</code> 表现的和 eqv 一样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">say &apos;a&apos; === &apos;a&apos;;            # True</div><div class="line">say &apos;a&apos; === &apos;b&apos;;            # False</div><div class="line"></div><div class="line"># different types</div><div class="line">say 1 === 1.0;              # False</div></pre></td></tr></table></figure>
<p><code>===</code> 使用 <code>WHICH</code> 方法来获取对象相等， 所以所有的值类型必须重写方法 <code>WHICH</code>。</p>
<h3 id="infix-20"><a href="#infix-20" class="headerlink" title="infix =:="></a>infix =:=</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proto sub infix:&lt;=:=&gt;(Mu \a, Mu \b) returns Bool:D is assoc&lt;chain&gt;</div><div class="line">multi sub infix:&lt;=:=&gt;(Mu \a, Mu \b)</div></pre></td></tr></table></figure>
<p>容器相等。返回 True 如果两个参数都绑定到同一个容器上。 如果它返回 True， 那通常意味着修改一个参数也会同时修改另外一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my ($a, $b) = (1, 3);</div><div class="line">say $a =:= $b;      # False</div><div class="line">$b = 2;</div><div class="line">say $a;             # 1</div><div class="line">$b := $a;</div><div class="line">say $a =:= $b;      # True</div><div class="line">$a = 5;</div><div class="line">say $b;             # 5</div></pre></td></tr></table></figure>
<h3 id="infix-21"><a href="#infix-21" class="headerlink" title="infix ~~"></a>infix ~~</h3><hr>
<p>智能匹配操作符。把左侧参数起别名为 <code>$_</code> , 然后计算右侧的值， 并在它身上调用 <code>.ACCEPTS($_)</code> 。 匹配的语义由右侧操作数的类型决定。  </p>
<p>这儿有一个内建智能匹配函数的摘要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">右侧      比较语义</div><div class="line">Mu:U	  类型检查</div><div class="line">Str	      字符串相等</div><div class="line">Numeric	  数值相等</div><div class="line">Regex	  正则匹配</div><div class="line">Callable  调用的布尔结果</div><div class="line">Any:D	  对象相等</div></pre></td></tr></table></figure>
<h2 id="Tight-AND-Precedence"><a href="#Tight-AND-Precedence" class="headerlink" title="Tight AND Precedence"></a>Tight AND Precedence</h2><hr>
<h3 id="infix-amp-amp"><a href="#infix-amp-amp" class="headerlink" title="infix &amp;&amp;"></a>infix &amp;&amp;</h3><hr>
<p>在布尔上下文中返回第一个求值为 False 的参数， 否则返回最后一个参数。</p>
<p>注意这是短路操作符，如果其中的一个参数计算为 false 值， 那么该参数右侧的值绝不会被计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub a &#123; 1 &#125;</div><div class="line">sub b &#123; 0 &#125;</div><div class="line">sub c &#123; die &quot;never called&quot; &#125;;</div><div class="line">say a() &amp;&amp; b() &amp;&amp; c();      # 0</div></pre></td></tr></table></figure>
<h2 id="Tight-OR-Precedence"><a href="#Tight-OR-Precedence" class="headerlink" title="Tight OR Precedence"></a>Tight OR Precedence</h2><hr>
<h3 id="infix-22"><a href="#infix-22" class="headerlink" title="infix ||"></a>infix ||</h3><hr>
<p>在布尔上下文中返回第一个求值为 True 的参数， 否则返回最后一个参数。</p>
<p>注意这是短路操作符，如果其中的一个参数计算为 true 值， 那么该参数右侧的值绝不会被计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub a &#123; 0 &#125;</div><div class="line">sub b &#123; 1 &#125;</div><div class="line">sub c &#123; die &quot;never called&quot; &#125;;</div><div class="line">say a() || b() || c();      # 1</div></pre></td></tr></table></figure>
<h3 id="infix-23"><a href="#infix-23" class="headerlink" title="infix ^^"></a>infix ^^</h3><hr>
<p>返回第一个值为 true 的参数如果只有一个的话， 否则返回 Nil。只要找到两个值为 true 的参数就发生短路。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say 0 ^^ 42;                # 42</div><div class="line">say 0 ^^ 42 ^^ 1 ^^ die 8;  # (empty line)</div></pre></td></tr></table></figure>
<p>注意， 这个操作符的语义可能不是你假想的那样： infix ^^ 翻到它找到的第一个 true 值， 找到第二个 true 值后永远地反转为 Nil 值， 不管还有多少 true 值。（换句话说，它的语义是”找到一个真值”， 而不是布尔起奇偶校验语义）</p>
<h3 id="infix-24"><a href="#infix-24" class="headerlink" title="infix //"></a>infix //</h3><hr>
<p>Defined-or  操作符。返回第一个定义了的操作数， 否则返回最后一个操作数。短路操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say Any // 0 // 42;         # 0</div></pre></td></tr></table></figure>
<h3 id="infix-min"><a href="#infix-min" class="headerlink" title="infix min"></a>infix min</h3><hr>
<p>返回参数的最小值。语义由 cmp 语义决定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$foo min= 0  # read as: $foo decreases to 0</div></pre></td></tr></table></figure>
<h3 id="infix-max"><a href="#infix-max" class="headerlink" title="infix max"></a>infix max</h3><hr>
<p>返回参数的最大值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$foo max= 0  # read as: $foo increases to 0</div></pre></td></tr></table></figure>
<h2 id="Conditional-Operator-Precedence"><a href="#Conditional-Operator-Precedence" class="headerlink" title="Conditional Operator Precedence"></a>Conditional Operator Precedence</h2><hr>
<h3 id="infix-25"><a href="#infix-25" class="headerlink" title="infix ?? !!"></a>infix ?? !!</h3><hr>
<p>三目操作符， 条件操作符。</p>
<p><code>$condition ?? $true !! $false</code> 计算并返回 <code>$true</code> 表达式，如果 <code>$condition</code> 为真的话。 否则计算并返回 <code>$false</code> 分支。</p>
<h3 id="infix-ff"><a href="#infix-ff" class="headerlink" title="infix ff"></a>infix ff</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;ff&gt;(Mu $a, Mu $b)</div></pre></td></tr></table></figure>
<p>Flipflop operator. 触发器操作符。</p>
<p>把两个参数都跟 <code>$_</code> 进行比较（即，<code>$_ ~~ $a</code> 和 <code>$_ ~~ $b</code>）。求值为 False 直到左侧的智能匹配为真， 这时，它求值为真， 直到右侧的智能匹配为真。</p>
<p>实际上，左边的参数是”开始”条件， 右侧的参数是”停止” 条件。 这种结构一般用于收集只在特定区域的行。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">my $excerpt = q:to/END/;</div><div class="line">Here&apos;s some unimportant text.</div><div class="line">=begin code</div><div class="line">    This code block is what we&apos;re after.</div><div class="line">    We&apos;ll use &apos;ff&apos; to get it.</div><div class="line">=end code</div><div class="line">More unimportant text.</div><div class="line">END</div><div class="line"></div><div class="line">my @codelines = gather for $excerpt.lines &#123;</div><div class="line">    take $_ if &quot;=begin code&quot; ff &quot;=end code&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># this will print four lines,</div><div class="line"># starting with &quot;=begin code&quot; and ending with &quot;=end code&quot;</div><div class="line">say @codelines.join(&quot;\n&quot;);</div></pre></td></tr></table></figure>
<p>匹配开始条件之后，操作符会继续将停止条件与 <code>$_</code> 进行匹配， 如果成功就做相应地表现。在这个例子中， 只有第一个元素被打印了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for &lt;AB C D B E F&gt; &#123;</div><div class="line">    say $_ if /A/ ff /B/;  # prints only &quot;AB&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想测试开始条件， 并且没有结束条件， <code>*</code> 能用作 “停止” 条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for &lt;A B C D E&gt; &#123;</div><div class="line">    say $_ if /C/ ff *; # prints C, D, and E</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 sed-like 版本， 在开始条件匹配成功之后，它不会使用停止条件与 <code>$_</code> 进行匹配。</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-1"><a href="#infix-ff-1" class="headerlink" title="infix ^ff"></a>infix ^ff</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;^ff&gt;(Mu $a, Mu $b)</div></pre></td></tr></table></figure>
<p>像 ff 那样工作，除了它不会在条目匹配开始条件时返回真。（包括匹配停止条件的条目）</p>
<p>一个比较:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @list = &lt;A B C&gt;;</div><div class="line">say $_ if /A/ ff /C/ for @list;  # prints A, B, and C</div><div class="line">say $_ if /A/ ^ff /C/ for @list; # prints B and C</div></pre></td></tr></table></figure>
<p>sed-like 版本 可以在 ^fff 中找到.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-2"><a href="#infix-ff-2" class="headerlink" title="infix ff^"></a>infix ff^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;ff^&gt;(Mu $a, Mu $b)</div></pre></td></tr></table></figure>
<p>像 ff 那样工作，除了它不会在条目匹配停止条件时返回真。（包括第一次匹配开始条件的条目）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @list = &lt;A B C&gt;;</div><div class="line">say $_ if /A/ ff /C/ for @list;  # prints A, B, and C</div><div class="line">say $_ if /A/ ff^ /C/ for @list; # prints A and B</div></pre></td></tr></table></figure>
<p>sed-like 版本 可以在 fff^ 中找到.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-3"><a href="#infix-ff-3" class="headerlink" title="infix ^ff^"></a>infix ^ff^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;^ff^&gt;(Mu $a, Mu $b)</div></pre></td></tr></table></figure>
<p>像 ff 那样工作，除了它不会在条目匹配停止条件时返回真, 也不会在条目匹配开始时返回真。（或者两者）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @list = &lt;A B C&gt;;</div><div class="line">say $_ if /A/ ff /C/ for @list;  # prints A, B, and C</div><div class="line">say $_ if /A/ ^ff^ /C/ for @list; # prints B</div></pre></td></tr></table></figure>
<p>sed-like 版本 可以在 ^fff^ 中找到.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff"><a href="#infix-fff" class="headerlink" title="infix fff"></a>infix fff</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;fff&gt;(Mu $a, Mu $b)</div></pre></td></tr></table></figure>
<p>执行 sed-like 那样的 flipflop 操作，在其中，它返回 False 直到左侧的参数与 <code>$_</code> 智能匹配， 并且在那之后返回 True 直到右侧的参数和 <code>$_</code>  智能匹配。</p>
<p>像 ff 那样工作， 除了它每次调用只尝试一个参数之外。即， 如果 <code>$_</code> 和左侧的参数智能匹配， fff 随后不会尝试将同一个 <code>$_</code> 和右侧的参数进行匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for &lt;AB C D B E F&gt; &#123;</div><div class="line">    say $_ if /A/ fff /B/;  # Prints &quot;AB&quot;, &quot;C&quot;, &quot;D&quot;, and &quot;B&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 non-sed-like 版本， 查看 <code>ff</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-1"><a href="#infix-fff-1" class="headerlink" title="infix ^fff"></a>infix ^fff</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;^fff&gt;(Mu $a, Mu $b)</div></pre></td></tr></table></figure>
<p>像 fff那样， 除了它对于左侧的匹配不返回真之外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @list = &lt;A B C&gt;;</div><div class="line">say $_ if /A/ fff /C/ for @list;  # prints A, B, and C</div><div class="line">say $_ if /A/ ^fff /C/ for @list; # prints B and C</div></pre></td></tr></table></figure>
<p>对于 non-sed 版本， 查看 <code>^ff</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-2"><a href="#infix-fff-2" class="headerlink" title="infix fff^"></a>infix fff^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;fff^&gt;(Mu $a, Mu $b)</div></pre></td></tr></table></figure>
<p>像 fff 那样， 除了它对于右侧的匹配不返回真之外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @list = &lt;A B C&gt;;</div><div class="line">say $_ if /A/ fff /C/ for @list;  # prints A, B, and C</div><div class="line">say $_ if /A/ fff^ /C/ for @list; # prints A and B</div></pre></td></tr></table></figure>
<p>对于 non-sed 版本， 查看 <code>ff^</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-3"><a href="#infix-fff-3" class="headerlink" title="infix ^fff^"></a>infix ^fff^</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;^fff^&gt;(Mu $a, Mu $b)</div></pre></td></tr></table></figure>
<p>像 fff 那样， 除了它对于左侧和右侧的匹配都不返回真之外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @list = &lt;A B C&gt;;</div><div class="line">say $_ if /A/ fff /C/ for @list;  # prints A, B, and C</div><div class="line">say $_ if /A/ ^fff^ /C/ for @list; # prints B</div></pre></td></tr></table></figure>
<p>对于 non-sed 版本， 查看 <code>^ff^</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h2 id="Item-Assignment-Precedence"><a href="#Item-Assignment-Precedence" class="headerlink" title="Item Assignment Precedence"></a>Item Assignment Precedence</h2><hr>
<h3 id="infix-26"><a href="#infix-26" class="headerlink" title="infix ="></a>infix =</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;=&gt;(Mu $a is rw, Mu $b)</div></pre></td></tr></table></figure>
<p>Item 赋值.</p>
<p>把 = 号右侧的值放入左侧的容器中。 它真正的语义是由左侧的容器类型决定的。</p>
<p>（注意 item 赋值和列表赋值的优先级级别不同， 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符）。</p>
<h3 id="infix-gt-4"><a href="#infix-gt-4" class="headerlink" title="infix =&gt;"></a>infix =&gt;</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:«=&gt;»($key, Mu $value) returns Pair:D</div></pre></td></tr></table></figure>
<p>Pair 构造器.</p>
<p>使用左侧值作为键， 右侧值作为值，构造一个 Pair 对象。</p>
<p>注意 <code>=&gt;</code> 操作符是语法上的特例，在这个结构中， 它允许左侧是一个未被引起的标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $p = a =&gt; 1;</div><div class="line">say $p.key;         # a</div><div class="line">say $p.value;       # 1</div></pre></td></tr></table></figure>
<p>在参数列表中，在 <code>=&gt;</code> 左侧使用未被引起的标识符构建的 Pair 会被解释为一个具名参数。</p>
<p>查看 Terms 语言文档了解更多创建 Pair 对象的方式。</p>
<h2 id="Loose-Unary-Precedence"><a href="#Loose-Unary-Precedence" class="headerlink" title="Loose Unary Precedence"></a>Loose Unary Precedence</h2><hr>
<h3 id="prefix-not"><a href="#prefix-not" class="headerlink" title="prefix not"></a>prefix not</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;not&gt;(Mu $x) returns Bool:D</div></pre></td></tr></table></figure>
<p>在布尔上下文中计算它的参数（因此使 Junctions 失效）， 并返回否定的结果。</p>
<h3 id="prefix-so"><a href="#prefix-so" class="headerlink" title="prefix so"></a>prefix so</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multi sub prefix:&lt;so&gt;(Mu $x) returns Bool:D</div></pre></td></tr></table></figure>
<p>在布尔上下文中计算它的参数（因此使 Junctions 失效）， 并返回结果。</p>
<h2 id="逗号操作符优先级"><a href="#逗号操作符优先级" class="headerlink" title="逗号操作符优先级"></a>逗号操作符优先级</h2><hr>
<h3 id="infix-27"><a href="#infix-27" class="headerlink" title="infix ,"></a>infix ,</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;,&gt;(*@a) is assoc&lt;list&gt; returns Parcel:D</div></pre></td></tr></table></figure>
<p>从它的参数宏构建一个 Parcel。也在语法构成上用作函数用的参数的分隔符。</p>
<h3 id="infix-28"><a href="#infix-28" class="headerlink" title="infix :"></a>infix :</h3><hr>
<p>就像中缀操作符  <code>,</code> 那样， <code>:</code> 用作参数分隔符， 并把它左侧的参数标记为调用者。</p>
<p>那会把函数调用转为方法调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">substr(&apos;abc&apos;: 1);       # same as &apos;abc&apos;.substr(1)</div></pre></td></tr></table></figure>
<p><code>Infix :</code> 只允许出现在非方法调用的第一个参数后面。 在其它位置它会是语法错误。</p>
<h2 id="List-Infix-Precedence"><a href="#List-Infix-Precedence" class="headerlink" title="List Infix Precedence"></a>List Infix Precedence</h2><hr>
<h3 id="infix-Z"><a href="#infix-Z" class="headerlink" title="infix Z"></a>infix Z</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;Z&gt;(**@lists) returns List:D is assoc&lt;chain&gt;</div></pre></td></tr></table></figure>
<p>Zip operator.</p>
<p>Z 像一个拉链那样把列表插入进来， 只要第一个输入列表耗尽就停止：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say (1, 2 Z &lt;a b c&gt; Z &lt;+ -&gt;).perl;  # ((1, &quot;a&quot;, &quot;+&quot;), (2, &quot;b&quot;, &quot;-&quot;)).list</div></pre></td></tr></table></figure>
<p><code>Z</code> 操作符也作为元操作符存在， 此时内部的 parcels 被应用了元操作符的列表替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say 100, 200 Z+ 42, 23;             # 142, 223</div><div class="line">say 1..3 Z~ &lt;a b c&gt; Z~ &apos;x&apos; xx 3;    # 1ax 2bx 3cx</div></pre></td></tr></table></figure>
<h3 id="infix-X"><a href="#infix-X" class="headerlink" title="infix X"></a>infix X</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub infix:&lt;X&gt;(**@lists) returns List:D is assoc&lt;chain&gt;</div></pre></td></tr></table></figure>
<p>从所有列表创建一个外积。最右边的元素变化得最迅速。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1..3 X &lt;a b c&gt; X 9</div><div class="line"></div><div class="line"># produces   (1, &apos;a&apos;, 9), (1, &apos;b&apos;, 9), (1, &apos;c&apos;, 9),</div><div class="line">         (2, &apos;a&apos;, 9), (2, &apos;b&apos;, 9), (2, &apos;c&apos;, 9),</div><div class="line">         (3, &apos;a&apos;, 9), (3, &apos;b&apos;, 9), (3, &apos;c&apos;, 9)</div></pre></td></tr></table></figure>
<p>X 操作符也可以作为元操作符， 此时内部的 parcels 被应用了元操作符的列表的值替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1..3 X~ &lt;a b c&gt; X~ 9</div><div class="line"></div><div class="line"># produces   &apos;1a9&apos;, &apos;1b9&apos;, &apos;1c9&apos;,</div><div class="line"></div><div class="line">         &apos;2a9&apos;, &apos;2b9&apos;, &apos;2c9&apos;,</div><div class="line">         &apos;3a9&apos;, &apos;3b9&apos;, &apos;3c9&apos;</div></pre></td></tr></table></figure>
<h3 id="infix-…"><a href="#infix-…" class="headerlink" title="infix …"></a>infix …</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">multi sub infix:&lt;...&gt;(**@) is assoc&lt;list&gt;</div><div class="line">multi sub infix:&lt;...^&gt;(**@) is assoc&lt;list&gt;</div></pre></td></tr></table></figure>
<p>序列操作符是一个用于产生惰性列表的普通操作符。</p>
<p>它可以有一个初始元素和一个生成器在 <code>…</code> 的左侧， 在右侧是一个端点。</p>
<p>序列操作符会使用尽可能多的参数来调用生成器。参数会从初始元素和已生成元素中获取。</p>
<p>默认的生成器是 <code>*.succ</code> 或 <code>*.pred</code> ， 取决于末端怎么比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say 1 ... 4;        # 1 2 3 4</div><div class="line">say 4 ... 1;        # 4 3 2 1</div><div class="line">say &apos;a&apos; ... &apos;e&apos;;    # a b c d e</div><div class="line">say &apos;e&apos; ... &apos;a&apos;;    # e d c b a</div></pre></td></tr></table></figure>
<p><code>*</code>  (Whatever) 末端生成一个无限序列，使用的是默认的生成器 <code>*.succ</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say (1 ... *)[^5];  # 1 2 3 4 5</div></pre></td></tr></table></figure>
<p>自定义生成器是在 <code>…</code> 操作符之前的最后一个参数。下面这个自定义生成器接收两个参数， 生成了斐波纳契数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say (1, 1, -&gt; $a, $b &#123; $a + $b &#125; ... *)[^8];    # 1 1 2 3 5 8 13 21</div><div class="line"># same but shorter</div><div class="line">say (1, 1, *+* ... *)[^8];                      # 1 1 2 3 5 8 13 21</div></pre></td></tr></table></figure>
<p>当然自定义生成器也能只接收一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say 5, &#123; $_ * 2 &#125; ... 40;                       # 5 10 20 40</div></pre></td></tr></table></figure>
<p>生成器的参数个数至少要和初始元素的个数一样多。</p>
<p>如果没有生成器，并且有不止一个初始元素，所有的初始元素都是数值，那么序列操作符会尝试推导出生成器。它知道数学和几何序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say 2, 4, 6 ... 12;     # 2 4 6 8 10 12</div><div class="line">say 1, 2, 4 ... 32;     # 1 2 4 8 16 32</div></pre></td></tr></table></figure>
<p>如果末端不是 <code>*</code>， 它会和每个生成的元素进行智能匹配，当智能匹配成功的时候序列就被终止。对于 <code>...</code>  操作符， 会包含最后一个元素， 对于 <code>...^</code> 操作符，会排除最后的那个元素。</p>
<p>这允许你这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say 1, 1, *+* ...^ *&gt;= 100;</div></pre></td></tr></table></figure>
<p>来生成所有直到 100 但不包括 100 的斐波纳契数。</p>
<p><code>...</code> 操作符还会把初始值看作”已生成的元素”，所以它们也会对末端进行检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $end = 4;</div><div class="line">say 1, 2, 4, 8, 16 ... $end;</div><div class="line"># outputs 1 2 4</div></pre></td></tr></table></figure>
<h2 id="List-Prefix-Precedence"><a href="#List-Prefix-Precedence" class="headerlink" title="List Prefix Precedence"></a>List Prefix Precedence</h2><hr>
<h3 id="infix-29"><a href="#infix-29" class="headerlink" title="infix ="></a>infix =</h3><hr>
<p>列表赋值。  它真正的语义是由左侧的容器类型决定的。查看 Array 和 Hash 获取普通案例。</p>
<p> item 赋值和列表赋值的优先级级别不同， 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符。</p>
<h3 id="infix-30"><a href="#infix-30" class="headerlink" title="infix :="></a>infix :=</h3><hr>
<p>绑定。 而 <code>$x = $y</code> 是把 <code>$y</code> 中的值放到 <code>$x</code> 里面， <code>$x := $y</code> 会让 <code>$x</code> 和 <code>$y</code> 引用同一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $a = 42;</div><div class="line">my $b = $a;</div><div class="line">$b++;</div><div class="line">say $a;</div></pre></td></tr></table></figure>
<p>这会输出 42， 因为 $a 和 $b 都包含了数字 42， 但是容器是不同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $a = 42;</div><div class="line">my $b := $a;</div><div class="line">$b++;</div><div class="line">say $a;</div></pre></td></tr></table></figure>
<p>这会打印 43， 因为 <code>$b</code> 和 <code>$a</code> 都代表着<code>同一个对象</code>。</p>
<h3 id="infix-31"><a href="#infix-31" class="headerlink" title="infix ::="></a>infix ::=</h3><hr>
<p>只读绑定. 查看  infix :=.</p>
<h3 id="listop-…"><a href="#listop-…" class="headerlink" title="listop …"></a>listop …</h3><hr>
<p>这是yada, yada, yada 操作符 或 stub 操作符。如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>...</code> 语句被执行了， 它会调用 <code>&amp;fail</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h3 id="listop"><a href="#listop" class="headerlink" title="listop !!!"></a>listop !!!</h3><hr>
<p>如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>!!!</code> 语句被执行了， 它会调用 <code>&amp;die</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h3 id="listop-1"><a href="#listop-1" class="headerlink" title="listop ???"></a>listop ???</h3><hr>
<p>如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>???</code> 语句被执行了， 它会调用 <code>&amp;warn</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h2 id="Loose-AND-precedence"><a href="#Loose-AND-precedence" class="headerlink" title="Loose AND precedence"></a>Loose AND precedence</h2><hr>
<h3 id="infix-and"><a href="#infix-and" class="headerlink" title="infix and"></a>infix and</h3><hr>
<p>和中缀操作符 <code>&amp;&amp;</code> 一样，除了优先级更宽松。</p>
<p>在布尔上下文中返回第一个求值为 False 的操作数， 否则返回最后一个操作数。短路操作符。</p>
<h3 id="infix-andthen"><a href="#infix-andthen" class="headerlink" title="infix andthen"></a>infix andthen</h3><hr>
<p>返回第一个未定义的参数，否则返回最后一个参数。短路操作符。左侧的结果被绑定到 <code>$_</code> 身上， 在右侧中使用， 或者作为参数被传递，如果右侧是一个 block 或 pointy block.</p>
<h2 id="Loose-OR-Precedence"><a href="#Loose-OR-Precedence" class="headerlink" title="Loose OR Precedence"></a>Loose OR Precedence</h2><hr>
<h3 id="infix-or"><a href="#infix-or" class="headerlink" title="infix or"></a>infix or</h3><hr>
<p>和中缀操作符 <code>||</code> 一样，除了优先级更宽松。</p>
<p>在布尔上下文中返回第一个求值为 True 的参数， 否则返回最后一个参数。短路操作符。</p>
<h3 id="infix-orelse"><a href="#infix-orelse" class="headerlink" title="infix orelse"></a>infix orelse</h3><hr>
<p>和中缀操作符 <code>//</code> 一样，除了优先级更宽松之外。</p>
<p>返回第一个定义过的参数， 否则返回最后一个参数。短路操作符。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从正则表达式到Grammar]]></title>
      <url>http://ohmycloud.github.io/2015/10/29/%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0Grammar/</url>
      <content type="html"><![CDATA[<p>「<a href="http://theperlfisher.blogspot.fr/2016/02/from-regular-expressions-to-grammars-pt_28.html" target="_blank" rel="external">原文链接</a>」</p>
<p>如果你是正则表达式新人(至少当它们用于 Perl 6 中时), 那我建议你从这个系列的<a href="http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt.html" target="_blank" rel="external">第一部分</a>开始。那些掌握了一定正则表达式的人可以跳过<a href="http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt_20.html" target="_blank" rel="external">上周</a>的文章。现在, 继续演示!</p>
<h2 id="上周轶事"><a href="#上周轶事" class="headerlink" title="上周轶事"></a>上周轶事</h2><p>我们开始开发一个接收诸如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">3</span>; <span class="built_in">console</span>.log(<span class="string">"Hey, did you konw a = "</span> + a + <span class="string">"?"</span>);</div></pre></td></tr></table></figure>
<p> Javascript 表达式的 Perl 6 编译器, 并把这段代码转换为 <a href="http://perl6.org/" target="_blank" rel="external">Rakudo Perl</a> 那样的编译器能运行的 Perl 6 代码。在我们开始之前, 想想转换后的 Perl 6 代码看起来是什么样的可能会是个好主意。如果你已经知道了 Perl 5, 那么你应该熟悉这样的代码。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $a = <span class="number">3</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"Hey, did you konw a = "</span> ~ $a ~ <span class="string">"?"</span>;</div></pre></td></tr></table></figure>
<p> 我们将需要确保我们的正则表达式捕获到了 Javascript 的要素。如果你还记得上一次, 我们使用这样一组正则表达式来捕获我们的文本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my rule Number                &#123; \d+                                                          &#125;;</div><div class="line">my rule Variable              &#123; \w+                                                          &#125;;</div><div class="line">my rule String                &#123; &apos;&quot;&apos; &lt;-[&quot; ]&gt;+ &apos;&quot;&apos;                                             &#125;;</div><div class="line">my rule Assignment-Expression &#123; var &lt;Variable&gt; &apos;=&apos; &lt;Number&gt;                                  &#125;;</div><div class="line">my rule Function-Call         &#123; console &apos;.&apos; log &apos;(&apos; &lt;String&gt; &apos;+&apos; &lt;Variable&gt; &apos;+&apos; &lt;String&gt; &apos;)&apos; &#125;;</div><div class="line"></div><div class="line">say &apos;var a = 3; console.log(&quot;Hey, did you konw a = &quot; + a + &quot;?&quot;);&apos; ~~ rule &#123; &lt;Assignment-Expression&gt; &apos;;&apos;  &lt;Function-Call&gt; &apos;;&apos; &#125;;</div></pre></td></tr></table></figure>
<p> 如果你把这段代码放到一个 Perl 6 源文件中并运行它, 那么它的输出第一次看起来可能会有点奇怪:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">｢var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );｣</div><div class="line"> Assignment-Expression =&gt; ｢var a = 3｣</div><div class="line">    Variable =&gt; ｢a ｣</div><div class="line">    Number =&gt; ｢3｣</div><div class="line"> Function-Call =&gt; ｢console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; )｣</div><div class="line">    String =&gt; ｢&quot;Hey, did you know a = &quot; ｣</div><div class="line">    Variable =&gt; ｢a ｣</div><div class="line">    String =&gt; ｢&quot;?&quot; ｣</div></pre></td></tr></table></figure>
<p>如果你愿意暂时忽略  「」  标记, 你会看到匹配被缩进了, 几乎像资源管理器窗口一样, ‘<assignment-expression>‘ 作为目录, ‘Variable’ 和 ‘Number’ 作为目录里面的文件。实际上, 那离真相不远了。 当我看到这种结构时, 我发现使用一点添加的语法能帮助我们像这样来观察它:</assignment-expression></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$/ =&gt; ｢var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );｣</div><div class="line"> &lt;Assignment-Expression&gt; =&gt; ｢var a = 3｣</div><div class="line">    &lt;Variable&gt; =&gt; ｢a ｣</div><div class="line">    &lt;Number&gt; =&gt; ｢3｣</div><div class="line"> &lt;Function-Call&gt; =&gt; ｢console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; )｣</div><div class="line">    &lt;String&gt; =&gt; ｢&quot;Hey, did you know a = &quot; ｣</div><div class="line">    &lt;Variable&gt; =&gt; ｢a ｣</div><div class="line">    &lt;String&gt; =&gt; ｢&quot;?&quot; ｣</div></pre></td></tr></table></figure>
<p>这几乎让怎么打印出文本变得更容易, 并在我们的正则表达式中指出了一个小问题。我们来打印给变量 <em>a</em> 所赋的数字, 从这儿开始。第一行告诉我们目录的根, 或者匹配树是 <code>$/</code>。 如果你在测试文件的末尾添加上 <code>say $/;</code> 并返回它, 那么你会看到整个表达式被打印出了 2 次。 那一定意味着 <code>$/</code> 就是整个匹配。</p>
<p>每向下推进一层就是把 <code>=&gt;</code> 箭头的左侧的东西添加到 <code>$/</code> 的右边。把之前的 <code>say</code> 语句修改为 <code>say  $/&lt;Assignment-Expression&gt;;</code>, 并看看输出发生了什么改变。它现在看起来应该像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">｢var a = 3｣</div><div class="line">  Variable =&gt; ｢a ｣</div><div class="line">  Number =&gt; ｢3｣</div></pre></td></tr></table></figure>
<p>让我们把把标记(不可见)添加进来, 所以我们能知道到了哪里…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$/&lt;Assignment-Expression&gt; =&gt; ｢var a = 3｣</div><div class="line">  &lt;Variable&gt; =&gt; ｢a ｣</div><div class="line">  &lt;Number&gt; =&gt; ｢3｣</div></pre></td></tr></table></figure>
<p>我们现在能看到我们的目标, 数字 3, 仅仅实在更下面的一层。和上次一样, 我们能够添加表达式左侧的东西, 所以我们就动手吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say $/&lt;Assignment-Expression&gt;&lt;Number&gt;;</div><div class="line">  ｢3｣</div></pre></td></tr></table></figure>
<p>我们几乎得到我们想要的了。 「」  挡道, 所以我们在这儿把值转换回数字。我把转换(cast)用引号扩起来, 因为它不是C/C++ 程序员那样认为的”casting”。我们想做的大约等价于 <code>sscanf(str,&quot;%d&quot;,&amp;num)</code>, 但是在 Perl 6 中, 这个操作符更加简单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say +$/&lt;Assignment-Expression&gt;&lt;Number&gt;;</div><div class="line">  3</div></pre></td></tr></table></figure>
<p>如果不深入更多细节, 那么 <code>$/</code> 是一个里面藏着隐式数字、字符串和布尔值的对象。前面添加的 <code>+</code> 把隐藏在 <code>$/</code> 对象中的数字显示出来了。</p>
<h2 id="从-Javascript-到-Perl"><a href="#从-Javascript-到-Perl" class="headerlink" title="从 Javascript 到 Perl"></a>从 Javascript 到 Perl</h2><p>我们离从 Javascript 生成 Perl 6 代码不远了。让我们使用上面所学的开始我们的第一个语句, 赋值语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say &apos;my $&apos; ~ $/&lt;Assignment-Expression&gt;&lt;Variable&gt; ~ &apos; = &apos; ~</div><div class="line">      $/&lt;Assignment-Expression&gt;&lt;Number&gt; ~ &apos;;&apos;;</div><div class="line"></div><div class="line">my $a = 3;</div></pre></td></tr></table></figure>
<p>我们仅仅使用了 7 行 Perl 6 就把代码从一种语言转换为另外一种语言。并且大部分的 Perl 6 代码都是可重用的, 因为字符串, 数字, 和 Javascript/C/Java 风格的变量名在大部分语言之间是通用的。</p>
<p>上次, 我们学习了怎么使用正则表达式来创建匹配。这次我们学会了怎么使用我们说匹配到的东西, 还有怎么在 <em>say</em> 语句中找出我们想要的东西。 不可见的匹配标记相当有用, 我可能会写一个模块来把它们放回到匹配表达式中, 那应该不难。</p>
<p>那个方案有一个问题, 如果我们看一下 <code>&lt;Function-Call&gt;</code> 匹配, 会很容易发现那个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$/&lt;Function-Call&gt; =&gt; ｢console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; )｣</div><div class="line">  &lt;String&gt; =&gt; ｢&quot;Hey, did you know a = &quot; ｣</div><div class="line">  &lt;Variable&gt; =&gt; ｢a ｣</div><div class="line">  &lt;String&gt; =&gt; ｢&quot;?&quot; ｣</div></pre></td></tr></table></figure>
<p>当我们写了 <code>say $/&lt;Function-Call&gt;&lt;String&gt;;</code> 时, 我们会获取哪个 <code>&lt;String&gt;</code>? 在你运行这段代码之前, 先猜测一下。会是第一个吗, 因为一旦匹配对象被创建,  Perl 6 就不会把它替换掉? 会是最后一个吗, 因为最后一个”覆盖”了第一个? 编译器会仅仅”感到困惑”然后什么也不打印吗? 运行一下看看!</p>
<p>它实际上以一个列表的形式把两个匹配都返回了, 所以你可以引用任何一个。 我们的不可见标记现在看起来长这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$/&lt;Function-Call&gt; =&gt; ｢console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; )｣</div><div class="line">  &lt;String&gt;[0] =&gt; ｢&quot;Hey, did you know a = &quot; ｣</div><div class="line">  &lt;Variable&gt; =&gt; ｢a ｣</div><div class="line">  &lt;String&gt;[1] =&gt; ｢&quot;?&quot; ｣</div></pre></td></tr></table></figure>
<p>所以, 如果我们想打印第一个字符串, 我们可以写上 <code>say $/&lt;Function-Call&gt;&lt;String&gt;[0];</code> 并得到含有时髦的日语标记的   「”Hey, did you know a = “ 」。幸运的是有一种便捷方式来避免那些日语标记, 就像数字 3 中的那样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say ~$/&lt;Function-Call&gt;&lt;String&gt;[0];</div><div class="line"> &quot;Hey, did you know a = &quot;</div></pre></td></tr></table></figure>
<p><strong>~</strong> 操作符使匹配字符串化, 就像 <code>+</code> 让返回的匹配数字化一样。所以你可能自己把最后一行写作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">say &apos;say &apos; ~ $/&lt;Function-Call&gt;&lt;String&gt;[0] ~ &apos; ~ &apos;</div><div class="line">  &apos; $&apos; ~ $/&lt;Function-Call&gt;&lt;Variable&gt; ~ &apos; ~ &apos;</div><div class="line">  $&lt;Function-Call&gt;&lt;String&gt;[1] ~ &apos;;&apos;;</div><div class="line"></div><div class="line">say &quot;Hey, did you know a = &quot; ~ $a ~ &quot;?&quot;;</div></pre></td></tr></table></figure>
<p>我们已经把我们的两行 Javascript 代码编译成 Perl 6 代码了。</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>现在已经能工作了, 但是有很多重复。目前我们得到是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my rule Variable               &#123; \w+                                                          &#125;;</div><div class="line">my rule String                 &#123; &apos;&quot;&apos; &lt;-[ &quot; ]&gt;+ &apos;&quot;&apos;                                            &#125;;</div><div class="line">my rule Assignment-Expression  &#123; var &lt;Variable&gt; &apos;=&apos; &lt;Number&gt;                                  &#125;;</div><div class="line">my rule Function-Call          &#123; console &apos;.&apos; log &apos;(&apos; &lt;String&gt; &apos;+&apos; &lt;Variable&gt; &apos;+&apos; &lt;String&gt; &apos;)&apos; &#125;;</div><div class="line"></div><div class="line">&apos;var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );&apos; ~~ rule &#123; &lt;Assignment-Expression&gt; &apos;;&apos; &lt;Function-Call&gt; &apos;;&apos; &#125;</div><div class="line"></div><div class="line">say &apos;my $&apos; ~ $/&lt;Assignment-Expression&gt;&lt;Variable&gt; ~ &apos; = &apos; ~ $/&lt;Assignment-Expression&gt;&lt;Number&gt; ~ &apos;;&apos;;</div><div class="line">say &apos;say &apos; ~ $/&lt;Function-Call&gt;&lt;String&gt;[0] ~ &apos; ~ $&apos; ~ $/&lt;Function-Call&gt;&lt;Variable&gt; ~  &apos; ~ &apos; ~ $/&lt;Function-Call&gt;&lt;String&gt;[1] ~  &apos;;&apos;;</div></pre></td></tr></table></figure>
<p>那些 rules 看起来相当好,  <code>&lt;String&gt;</code> 和 <code>&lt;Variable&gt;</code> 的重复也是不可避免的。 但是看看 <code>say</code> 语句, 你会看到 <code>&lt;Assignment-Expression&gt;</code> 和 <code>&lt;Function-Call&gt;</code> 重复了自身好几次。避免这种重复的一种方法是创建一个临时变量, 但是那可能会变得丑陋。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $assignment-expression = $/&lt;Assignment-Expression&gt;;</div><div class="line">say &apos;my $&apos; ~ $assignment-expression&lt;Variable&gt; ~ &apos; = &apos; ~  $assignment-expression&lt;Number&gt; ~ &apos;;&apos;</div></pre></td></tr></table></figure>
<p>相反, 我们利用 Perl 6 的子例程签名, 并且重用 <code>$/</code> 变量名以使我们能重用上面所写的代码, 然后拿掉 <assignment-expression> 部分。 我会把子例程的名字命名为 rule 的名字, 只是为了直接了当。(你会在之后看到为什么这样做。)</assignment-expression></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub  assignment-expression($/) &#123;</div><div class="line">    &apos;my $&apos; ~ $/&lt;Variable&gt; ~ &apos; = &apos; ~ $/&lt;Number&gt; ~ &apos;;&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say assignment-expression( $/&lt;Assignment-Expression&gt; );</div></pre></td></tr></table></figure>
<p>让我们对 <function-call> 也做同样的事情, 创建一个含有 <code>$/</code> 子例程签名的同名函数。 它现在写在一行里面就很整洁了, 并且只重复 <em><string></string></em> 部分, 因为它不得不重复。</function-call></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub function-call( $/ ) &#123;</div><div class="line">     &apos;say &apos; ~ $/&lt;String&gt;[0] ~ &apos; ~ &apos; ~ $/&lt;Variable&gt; ~ &apos; ~ &apos; ~ $/&lt;String&gt;[1] ~ &apos;;&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say function-call( $/&lt;Function-Call&gt; );</div></pre></td></tr></table></figure>
<h2 id="对象化"><a href="#对象化" class="headerlink" title="对象化"></a>对象化</h2><p>一路上我做了相当多的选择,让我们到达这里。这就是我们上次重构的地方:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">my rule Number                &#123; \d+                                                          &#125;;</div><div class="line">my rule Variable              &#123; \w+                                                          &#125;;</div><div class="line">my rule String                &#123; &apos;&quot;&apos; &lt;-[ &quot; ]&gt;+ &apos;&quot;&apos;                                            &#125;;</div><div class="line">my rule Assignment-Expression &#123; var &lt;Variable&gt; &apos;=&apos; &lt;Number&gt;                                  &#125;;</div><div class="line">my rule Function-Call         &#123; console &apos;.&apos; log &apos;(&apos; &lt;String&gt; &apos;+&apos; &lt;Variable&gt; &apos;+&apos; &lt;String&gt; &apos;)&apos; &#125;;</div><div class="line"></div><div class="line">&apos;var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );&apos; ~~ rule &#123; &lt;Assignment-Expression&gt; &apos;;&apos; &lt;Function-Call&gt; &apos;;&apos; &#125;</div><div class="line"></div><div class="line">sub assignment-expression( $/ ) &#123;</div><div class="line">    &apos;my $&apos; ~ $/&lt;Variable&gt; ~ &apos; = &apos; ~ $/&lt;Number&gt; ~ &apos;;&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub function-call( $/ ) &#123;</div><div class="line">    &apos;say &apos; ~ $/&lt;String&gt;[0] ~ &apos; ~ $&apos; ~ $/&lt;Variable&gt; ~ &apos; ~ &apos; ~ $/&lt;String&gt;[1] ~ &apos;;&apos;;</div><div class="line">&#125;</div><div class="line">say assignment-expression( $/&lt;Assignment-Expression&gt; );</div><div class="line">say function-call( $/&lt;Function-Call&gt; );</div></pre></td></tr></table></figure>
<p>这就是我们的回报。我们先捡起最后那两个 <code>say</code> 语句。 我们还没有给顶层 rule 一个名字, 所以我们就叫它… 好吧, 现在还是叫 ‘top’ 吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub top( $/ ) &#123; assignment-expression( $/ ) ~ function-call( $/ ) &#125;</div></pre></td></tr></table></figure>
<h2 id="收回你的吐槽"><a href="#收回你的吐槽" class="headerlink" title="收回你的吐槽"></a>收回你的吐槽</h2><p>我们暂时还没有对处于文件顶层的 rules 做太多处理, 所以让我们开始工作吧。 在 Perl 6 中, 就一般编程而言, 把你的代码打包复用是不错的注意。而 Perl 6 让我们使用 <code>class</code> 关键字将我们的程序打包, 我们拥有的那些 rules 从任何意义上来说实际上不是 “代码”。而它们能够用于代码中, 并且我们确实使用了它们, 它们自身实际上并没有做出任何决定。</p>
<p>所以我们不应该使用 <code>class</code> 关键字来把它们打包到一块。相反, 有另外一种便捷的类型用于把一堆正则表达式和 rules 打包到一块儿, 它叫做 <code>grammar</code>。<br>它的语法就像声明一个 「rule」 那样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">grammar Javascript &#123;</div><div class="line">    rule Number                &#123; \d+                                                          &#125;;</div><div class="line">    rule Variable              &#123; \w+                                                          &#125;;</div><div class="line">    rule String                &#123; &apos;&quot;&apos; &lt;-[ &quot; ]&gt;+ &apos;&quot;&apos;                                            &#125;;</div><div class="line">    rule Assignment-Expression &#123; var &lt;Variable&gt; &apos;=&apos; &lt;Number&gt;                                  &#125;;</div><div class="line">    rule Function-Call         &#123; console &apos;.&apos; log &apos;(&apos; &lt;String&gt; &apos;+&apos; &lt;Variable&gt; &apos;+&apos; &lt;String&gt; &apos;)&apos; &#125;;      </div><div class="line"></div><div class="line">    rule TOP                   &#123; &lt;Assignment-Expression&gt; &apos;;&apos; &lt;Function-Call&gt; &apos;;&apos;              &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会注意到, 我们给我们的顶层 rule 也起了个名字, 并且暂时把它叫做 「TOP」 吧。 如果你正在家独自玩耍, 你可能已经做出更改并想知道 「’var a = 3;…’ ~~ rule { … }」 是怎么起作用的, 因为键入诸如 「’var a = 3;…’ ~~ JavaScript;」这样的东西可能不会那么有作用。</p>
<p>Grammars 就像类一样, 在里面它们实际上是一块可能的代码。 它们本身不会工作, 它们必须从潜在的转换为动态的代码。我们可以像你在类中做的那样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $JavaScript = JavaScript.new;</div></pre></td></tr></table></figure>
<p>现在我们拥有了一个可以工作的变量。 现在, 让我们来使用它。所有的 grammar 类都有一个内置的 「parse()」 方法, 以使我们能得到 grammar 中的正则表达式。 我们来修改我们的匹配语句以利用 parse() 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$JavaScript.parse(&apos;var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );&apos;);</div></pre></td></tr></table></figure>
<p>我们的代码应该又能工作了。</p>
<h2 id="接收动作"><a href="#接收动作" class="headerlink" title="接收动作"></a>接收动作</h2><p>现在我们已经把我们所有的匹配的东西打包到一个小型的类里面了, 如果我们能对那些子例程做同样的处理将会很棒。 我们在这儿试试, 把我们的子例程放到它们自己的命名空间中, 就像我们对 rule 做的那样。 我们必须从 「sub」 修改为 「method」, 而我们的 「top」 方法将会使用 「self.」 去调用其它方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Actions &#123;</div><div class="line">    method assignment-expression( $/ ) &#123;</div><div class="line">        &apos;my $&apos; ~ $/&lt;Variable&gt; ~ &apos; = &apos; ~ $/&lt;Number&gt; ~ &apos;;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method function-call( $/ ) &#123;</div><div class="line">        &apos;say &apos; ~ $/&lt;String&gt;[0] ~ &apos; ~ $&apos; ~ $/&lt;Variable&gt; ~ &apos; ~ &apos; ~ $/&lt;String&gt;[1] ~ &apos;;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method top( $/ ) &#123;</div><div class="line">        self.assignment-expression( $/&lt;Assignment-Expression&gt; ) ~</div><div class="line">        self.function-call( $/&lt;Function-Call&gt; )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就像之前那样, 我们可以在一行里面创建 Actions 对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $actions = Actions.new;</div></pre></td></tr></table></figure>
<p>并且调用 top 几乎像我们之前做的那样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $actions.top( $/ );</div></pre></td></tr></table></figure>
<p>我们已经修改了很多东西了, 所以我们来看看到哪了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">grammar JavaScript &#123;</div><div class="line">  rule Number                &#123; \d+                                                          &#125;;</div><div class="line">  rule Variable              &#123; \w+                                                          &#125;;</div><div class="line">  rule String                &#123; &apos;&quot;&apos; &lt;-[ &quot; ]&gt;+ &apos;&quot;&apos;                                            &#125;;</div><div class="line">  rule Assignment-Expression &#123; var &lt;Variable&gt; &apos;=&apos; &lt;Number&gt;                                  &#125;;</div><div class="line">  rule Function-Call         &#123; console &apos;.&apos; log &apos;(&apos; &lt;String&gt; &apos;+&apos; &lt;Variable&gt; &apos;+&apos; &lt;String&gt; &apos;)&apos; &#125;;</div><div class="line">  rule TOP                   &#123; &lt;Assignment-Expression&gt; &apos;;&apos; &lt;Function-Call&gt; &apos;;&apos;              &#125;</div><div class="line">&#125;</div><div class="line">my $j = JavaScript.new;</div><div class="line"></div><div class="line">$j.parse(&apos;var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );&apos;);</div><div class="line"></div><div class="line">class Actions &#123;</div><div class="line">    method assignment-expression( $/ ) &#123;</div><div class="line">      &apos;my $&apos; ~ $/&lt;Variable&gt; ~ &apos; = &apos; ~ $/&lt;Number&gt; ~ &apos;;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method function-call( $/ ) &#123;</div><div class="line">      &apos;say &apos; ~ $/&lt;String&gt;[0] ~ &apos; ~ $&apos; ~ $/&lt;Variable&gt; ~ &apos; ~ &apos; ~ $/&lt;String&gt;[1] ~ &apos;;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method top( $/ ) &#123;</div><div class="line">      self.assignment-expression( $/&lt;Assignment-Expression&gt; ) ~</div><div class="line">      self.function-call( $/&lt;Function-Call&gt; )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $actions = Actions.new;</div><div class="line">say $actions.top($/);</div></pre></td></tr></table></figure>
<p>不用担心, 我们快要到了。既然我们有了一个单独的类来处理 Actions, 我们把方法重命名为 grammar 中所匹配的 rule 的名字, 以使我们不会忘记它们是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Actions &#123;</div><div class="line">    method Assignment-Expression( $/ ) &#123;</div><div class="line">        &apos;my $&apos; ~ $/&lt;Variable&gt; ~ &apos; = &apos; ~ $/&lt;Number&gt; ~ &apos;;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method Function-Call( $/ ) &#123;</div><div class="line">        &apos;say &apos; ~ $/&lt;String&gt;[0] ~ &apos; ~$&apos; ~ $/&lt;Variable&gt; ~ &apos; ~ &apos; ~ $/&lt;String&gt;[1] ~ &apos;;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method TOP( $/ ) &#123;</div><div class="line">        self.Assignment-Expression( $/&lt;Assignment-Expression&gt; ) ~</div><div class="line">        self.Function-Call( $/&lt;Function-Call&gt; )</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更进一步, 我们还有最后一点魔法能够利用。 我们将把 $javascript 和 $actions 对象像这样组合在一块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $javascript.parse(&apos;...&apos;, :actions($actions) );</div></pre></td></tr></table></figure>
<p>「:actions(…)」 给 「parse()」方法声明的可选参数。我们正告诉正则表达式引擎, 任何时候, 像 <function-call> 或 <top> 这样的 rule 匹配时, 我们会在我们的类中让它调用对应的同名方法。</top></function-call></p>
<p>这几乎是按原样工作的, 但是如果你运行修改后的代码,  你会发现解析返回了原来的匹配对象, 带着日语引用标记。所以看起来好像我们又回到了原地。不完全是。</p>
<p>继续, 我们在其中之一的方法中添加一个临时的 “say ‘Hello’;” 语句, 仅仅是为了确认它们正被调用。这是正则引擎正在工作并且可能正解析它所going over 的一个重要证据。 你甚至可以使用某些我们上面已经学到的技巧然后写上 「say $/<variable>;」 来查看匹配是否正像你想的那样运行。继续运行并玩玩, 做完的时候再回到这儿。</variable></p>
<h2 id="混合信号-Mixed-Signals"><a href="#混合信号-Mixed-Signals" class="headerlink" title="混合信号(Mixed Signals)"></a>混合信号(Mixed Signals)</h2><p>正发生的是方法正被调用, 但是它们的输出被丢弃。我们来捕获输出然后使用 grammar 的最后一个特性, 抽象语法树。现在,  这可能会勾起坐在教室里看黑板上画出的盒子和线段的场景, 但是也没有那么糟糕了。我们已经看到了一个, 实际上 <strong>say()</strong> 的输出就是一个 AST。</p>
<p>我们来看下其它语法树, 我们在后台创建的那个。在 “$javascript.parse(…)” 调用的末尾添加上 「.ast」, 这会给我们展示我们自己创建的语法树。</p>
<p>如果你这样做了, 你会看到它打印了(Any), 这通常等价于「匹配失败」, 单是我们从之前的测试中知道匹配没有失败。所以这儿发生了什么? 当我们的方法运行的时候, 它们返回输出, 但是 Perl  6 不知道怎么处理这些输出, 或者说它不知道把输出安装到它所创建的 AST中的哪个位置。</p>
<p>关键是一个叫做 「make」的小东西。在方法的开头, 把这个添加到过去我们放置 「say」的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Actions &#123;</div><div class="line">    method Assignment-Expression( $/ ) &#123;</div><div class="line">      make &apos;my $&apos; ~ $/&lt;Variable&gt; ~ &apos; = &apos; ~ $/&lt;Number&gt; ~ &apos;;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method Function-Call( $/ ) &#123;</div><div class="line">      make &apos;say &apos; ~ $/&lt;String&gt;[0] ~ &apos; ~ $&apos; ~ $/&lt;Variable&gt; ~ &apos; ~ &apos; ~ $/&lt;String&gt;[1] ~ &apos;;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method TOP( $/ ) &#123;</div><div class="line">      make $/&lt;Assignment-Expression&gt;.ast ~ $/&lt;Function-Call&gt;.ast</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有, 因为 Perl 6 为我们调用方法, 我们不需要自己来调用 self.Function-Call(…), 我们需要做的全部工作就是查看 Function-Call(…)返回给我们的语法树。 最终我们做到了。一个完整, 虽然微小的编译器。为了防止你在编辑时迷失, 这儿有一个最终的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">grammar JavaScript &#123;</div><div class="line">  rule Number                &#123; \d+                                                          &#125;;</div><div class="line">  rule Variable              &#123; \w+                                                          &#125;;</div><div class="line">  rule String                &#123; &apos;&quot;&apos; &lt;-[ &quot; ]&gt;+ &apos;&quot;&apos;                                            &#125;;</div><div class="line">  rule Assignment-Expression &#123; var &lt;Variable&gt; &apos;=&apos; &lt;Number&gt;                                  &#125;;</div><div class="line">  rule Function-Call         &#123; console &apos;.&apos; log &apos;(&apos; &lt;String&gt; &apos;+&apos; &lt;Variable&gt; &apos;+&apos; &lt;String&gt; &apos;)&apos; &#125;;</div><div class="line">  rule TOP                   &#123; &lt;Assignment-Expression&gt; &apos;;&apos; &lt;Function-Call&gt; &apos;;&apos;              &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Actions &#123;</div><div class="line">  method Assignment-Expression( $/ ) &#123;</div><div class="line">    make &apos;my $&apos; ~ $/&lt;Variable&gt; ~ &apos; = &apos; ~ $/&lt;Number&gt; ~ &apos;;&apos;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  method Function-Call( $/ ) &#123;</div><div class="line">    make &apos;say &apos; ~ $/&lt;String&gt;[0] ~ &apos; ~ $&apos; ~ $/&lt;Variable&gt; ~ &apos; ~ &apos; ~ $/&lt;String&gt;[1] ~ &apos;;&apos;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">  method TOP( $/ ) &#123;</div><div class="line">    make $/&lt;Assignment-Expression&gt;.ast ~ $/&lt;Function-Call&gt;.ast &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">my $j = JavaScript.new;</div><div class="line">my $a = Actions.new;</div><div class="line">say $j.parse(</div><div class="line">   &apos;var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );&apos;,</div><div class="line">   :actions($a)).ast;</div></pre></td></tr></table></figure>
<h2 id="到哪里去"><a href="#到哪里去" class="headerlink" title="到哪里去"></a>到哪里去</h2><p>一个简单但整洁的更改是你可以扩展 Assignment-Expression 来既接收数字又接收字符串。上次我们谈论了 rules 中的轮试,所以这个提示应该足够让你开始了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rule Assignment-Expression &#123; var &lt;Variable&gt; &apos;=&apos; (&lt;Number&gt; | &lt;String&gt;) &#125;</div></pre></td></tr></table></figure>
<p>你必须修改下 Assignment-Expression 方法以使它起作用。或者你可以狡猾一点然后发现( <number> | <string> ) 可以转换为它自己的小的普通的 “Term” rule, “rule Term { <number> | <string> }”, 然后添加一个 action “method Term($/) { make $/<number> or $/<string>}” 而只在 Assignment-Expression 中修改一个东西。</string></number></string></number></string></number></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IO操作]]></title>
      <url>http://ohmycloud.github.io/2015/10/11/IO%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="批量插入文本"><a href="#批量插入文本" class="headerlink" title="批量插入文本"></a>批量插入文本</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @filenames = dir &apos;.&apos;,  test =&gt; any(/\.md$/, /\.markdown/);</div><div class="line"></div><div class="line">for @filenames -&gt; $filePath &#123;</div><div class="line">    my $path = $filePath.path();</div><div class="line">    $path ~~ s/.md//;</div><div class="line">    $path ~~ s/.markdown//;</div><div class="line"></div><div class="line">    my $date = DateTime.new(now);</div><div class="line">    my $head =</div><div class="line">qq:heredoc &apos;EOT&apos;;</div><div class="line">title:  $path.IO.basename()</div><div class="line">date: $date</div><div class="line">tags: Perl6</div><div class="line">categories: Perl 6</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;这城市有太多风景都在提醒那过去！&lt;/blockquote&gt;</div><div class="line"></div><div class="line">[TOC]</div><div class="line"></div><div class="line">EOT</div><div class="line"></div><div class="line">   my @content   = slurp $filePath;</div><div class="line">   spurt($filePath.path, &quot;$head\n@content[]&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在当前目录中查找所有以 <code>.md</code> (.markdown)结尾的文件（即markdown文件）, 并在文件最前面插入一段文本， 形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">title:  Perl6</div><div class="line">date: 2015-08-20T23:19:13Z</div><div class="line">tags: Perl6</div><div class="line">categories: Perl 6</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;我站在天桥上念你, 有点狼狈&lt;/blockquote&gt;</div></pre></td></tr></table></figure>
<p>类 <code>IO::Path</code> 提供了 <code>basename</code>, <code>path</code>, <code>parts</code>, 等方法供使用, 具体用法请看文档:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p6doc IO::Path</div></pre></td></tr></table></figure>
<p>一些例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">say IO::Path.new(&quot;/etc/passwd&quot;).basename;   # passwd</div><div class="line">say IO::Path.new(&quot;docs/README.pod&quot;).extension;   # pod</div><div class="line">say IO::Path.new(&quot;/etc/passwd&quot;).dirname;    # /etc</div><div class="line">say IO::Path::Win32.new(&quot;C:\\Windows\\registry.ini&quot;).volume;    # C:</div><div class="line">say IO::Path.new(&quot;/etc/passwd&quot;).parts.perl # (&quot;dirname&quot; =&gt; &quot;/etc&quot;, &quot;volume&quot;  =&gt; &quot;&quot;, &quot;basename&quot; =&gt; &quot;passwd&quot;).hash</div></pre></td></tr></table></figure>
<p>Examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">    # To iterate over the contents of the current directory: for dir() -&gt; $file</div><div class="line">    &#123;</div><div class="line">        say $file;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    # As before, but include even &apos;.&apos; and &apos;..&apos; which are filtered out by # the</div><div class="line">    default :test matcher: for dir(test =&gt; *) -&gt; $file &#123;</div><div class="line">        say $file;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    # To get the names of all .jpg and .jpeg files in ~/Downloads: my @jpegs =</div><div class="line">    &quot;%*ENV&lt;HOME&gt;/Downloads&quot;.IO.dir(test =&gt; /:i &apos;.&apos; jpe?g $/)».Str;</div><div class="line"></div><div class="line"></div><div class="line"># An example program that lists all files and directories recursively:</div><div class="line"></div><div class="line">    sub MAIN($dir = &apos;.&apos;) &#123;</div><div class="line">        my @todo = $dir.IO; while @todo &#123;</div><div class="line">            for @todo.pop.dir -&gt; $path &#123;</div><div class="line">                say $path.Str; @todo.push: $path if $path.d;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="文件测试操作符"><a href="#文件测试操作符" class="headerlink" title="文件测试操作符"></a>文件测试操作符</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># If you have a string - a path to something in the filesystem:</div><div class="line"></div><div class="line">    if &quot;path/to/file&quot;.IO ~~ :e &#123;</div><div class="line">        say &apos;file exists&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    my $file = &quot;path/to/file&quot;; if $file.IO ~~ :e &#123;</div><div class="line">        say &apos;file exists&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"># Instead of the colonpair syntax, you can use method calls too:</div><div class="line"></div><div class="line">    if &apos;path/to/file&apos;.IO.e &#123;</div><div class="line">        say &apos;file exists&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"># If you already have an IO object in $file, either by creating one yourself, or</div><div class="line"># by getting it from another subroutine, such as dir, you can write this:</div><div class="line"></div><div class="line">    my $file = &quot;path/to/file&quot;.IO; if $file ~~ :e &#123;</div><div class="line">        say &apos;file exists&apos;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="文件时间戳："><a href="#文件时间戳：" class="headerlink" title="文件时间戳："></a>文件时间戳：</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">say &quot;path/to/file&quot;.IO.modified;                # e.g. Instant:1424089165</div><div class="line">say DateTime.new(&quot;path/to/file&quot;.IO.modified);  # e.g. 2015-02-16T12:18:50Z</div><div class="line"></div><div class="line">my $modification_instant = &quot;path/to/file&quot;.IO.modified;</div><div class="line">my $modification_time    = DateTime.new($modification_instant);</div><div class="line">say $modification_time;  # e.g. 2015-02-16T12:18:50Z</div><div class="line"></div><div class="line"></div><div class="line">say &quot;path/to/file&quot;.IO.accessed;                # e.g. Instant:1424353577</div><div class="line">say DateTime.new(&quot;path/to/file&quot;.IO.accessed);  # e.g. 2015-02-19T13:45:42Z</div><div class="line"></div><div class="line">my $access_instant = &quot;path/to/file&quot;.IO.accessed;</div><div class="line">my $access_time    =  DateTime.new($access_instant);</div><div class="line">say $access_time;  # e.g. 2015-02-19T13:45:42Z</div><div class="line"></div><div class="line"></div><div class="line">say &quot;path/to/file&quot;.IO.changed;                # e.g. Instant:1424089165</div><div class="line">say DateTime.new(&quot;path/to/file&quot;.IO.changed);  # e.g. 2015-02-16T12:18:50Z</div><div class="line"></div><div class="line">my $change_instant = &quot;path/to/file&quot;.IO.changed;</div><div class="line">my $change_time    =  DateTime.new($chnge_instant);</div><div class="line">say $change_time;  # e.g. 2015-02-16T12:18:50Z</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[proto]]></title>
      <url>http://ohmycloud.github.io/2015/10/06/proto/</url>
      <content type="html"><![CDATA[<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><hr>
<p>proto 意思为原型。proto 从形式上声明了 <code>multi</code> 候选者之间的<code>共性</code>。 proto 充当作能检查但不会修改参数的包裹。看看这个基本的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">proto congratulate(Str $reason, Str $name, |) &#123;*&#125;</div><div class="line">multi congratulate($reason, $name) &#123;</div><div class="line">   say &quot;Hooray for your $reason, $name&quot;;</div><div class="line">&#125;</div><div class="line">multi congratulate($reason, $name, Int $rank) &#123;</div><div class="line">   say &quot;Hooray for your $reason, $name -- you got rank $rank!&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">congratulate(&apos;being a cool number&apos;, &apos;Fred&apos;);     # OK</div><div class="line">congratulate(&apos;being a cool number&apos;, &apos;Fred&apos;, 42); # OK</div><div class="line">congratulate(&apos;being a cool number&apos;, 42);         # Proto match error</div></pre></td></tr></table></figure>
<p>所有的 <code>multi congratulate</code> 会遵守基本的签名, 这个签名中有两个字符串参数, 后面跟着可选的更多的参数。 <code>|</code> 是一个未命名的 <code>Capture</code> 形参, 这允许 <code>multi</code> 接收额外的参数。第三个 congratulate 调用在编译时失败, 因为第一行的 proto 的签名变成了所有三个 multi congratulate 的共同签名, 而 42 不匹配 <code>Str</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &amp;congratulate.signature #-&gt; (Str $reason, Str $name, | is raw)</div></pre></td></tr></table></figure>
<p>你可以给 <code>proto</code> 一个函数体, 并且在你想执行 dispatch 的地方放上一个 <code>{*}</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># attempts to notify someone -- returns False if unsuccessful</div><div class="line">proto notify(Str $user,Str $msg) &#123;</div><div class="line">   my \hour = DateTime.now.hour;</div><div class="line">   if hour &gt; 8 or hour &lt; 22 &#123;</div><div class="line">      return &#123;*&#125;;</div><div class="line">   &#125; else &#123;</div><div class="line">      # we can&apos;t notify someone when they might be sleeping</div><div class="line">      return False;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>{*}</code> 总是分派给带有参数的候选者。默认参数和类型强制转换会起作用单不会传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">proto mistake-proto(Str() $str, Int $number = 42) &#123;*&#125;</div><div class="line">multi mistake-proto($str,$number) &#123; say $str.WHAT &#125;</div><div class="line">mistake-proto(7,42);   #-&gt; (Int) -- coercions not passed on</div><div class="line">mistake-proto(&apos;test&apos;); #!&gt; fails -- defaults not passed on</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-圣诞月历-(2010)]]></title>
      <url>http://ohmycloud.github.io/2015/10/05/Perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2010/</url>
      <content type="html"><![CDATA[<h1 id="2010"><a href="#2010" class="headerlink" title="2010"></a>2010</h1><hr>
<h2 id="第二天-用main函数控制命令行交互"><a href="#第二天-用main函数控制命令行交互" class="headerlink" title="第二天:用main函数控制命令行交互"></a>第二天:用main函数控制命令行交互</h2><hr>
<p>2010 年 Perl6 圣诞月历(二)用 main 函数控制命令行交互</p>
<p>在 UNIX 环境下，很多脚本都是要从命令行里获取运行参数的。Perl6 上，实现这个相当简单~比如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat add.pl</div><div class="line">sub MAIN ($x, $y) &#123;</div><div class="line">    say $x + $y</div><div class="line">&#125;</div><div class="line">$ perl6 add.pl 3 4</div><div class="line">7</div><div class="line">$ perl6 add.pl too many arguments</div><div class="line">Usage:</div><div class="line">add.pl x y</div></pre></td></tr></table></figure>
<p>只要定义一个带命名变量的 MAIN 函数，你就可以获得一个命令行分析器。然后命令行参数就被自动绑定到 <code>$x</code> 和 <code>$y</code> 上了。如果不匹配，还有温馨的 Usage 提示~~</p>
<p>当然，你可能更喜欢自己定制 Usage 信息。那么自己动手，编写 USAGE 函数好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat add2.pl</div><div class="line">sub MAIN($x, $y) &#123;</div><div class="line">    say $x + $y</div><div class="line">&#125;</div><div class="line">sub USAGE () &#123;</div><div class="line">    say &quot;Usage: add.pl &lt;num1&gt; &lt;num2&gt;&quot;;</div><div class="line">&#125;</div><div class="line">$ perl6 add2.pl too many arguments</div><div class="line">Usage: add.pl &lt;num1&gt; &lt;num2&gt;</div></pre></td></tr></table></figure>
<p>更进一步的，你可以用 <code>multi</code> 指令声明多种 MAIN 函数以完成一种可替代的语法，或者根据某些<strong>常量</strong>做出不同反应，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ cat calc</div><div class="line">#!/usr/bin/env perl6</div><div class="line"></div><div class="line">multi MAIN(&apos;add&apos;, $x, $y)  &#123; say $x + $y &#125;</div><div class="line">multi MAIN(&apos;div&apos;, $x, $y)  &#123; say $x / $y &#125;</div><div class="line">multi MAIN(&apos;mult&apos;, $x, $y) &#123; say $x * $y &#125;</div><div class="line">$ ./calc add 3 5</div><div class="line">8</div><div class="line">$ ./calc mult 3 5</div><div class="line">15</div><div class="line">$ ./calc</div><div class="line">Usage:</div><div class="line">./calc add x y</div><div class="line">or</div><div class="line">./calc div x y</div><div class="line">or</div><div class="line">./calc mult x y</div></pre></td></tr></table></figure>
<p>还有命名参数对应不同的选项的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat copy.pl</div><div class="line">sub MAIN($source, $target, Bool :$verbose) &#123;</div><div class="line">    say &quot;Copying &apos;$source&apos; to &apos;$target&apos;&quot; if $verbose;</div><div class="line">    run &quot;cp $source $target&quot;;</div><div class="line">&#125;</div><div class="line">$ perl6 copy.pl calc calc2</div><div class="line">$ perl6 copy.pl  --verbose calc calc2</div><div class="line">Copying &apos;calc&apos; to &apos;calc2&apos;</div></pre></td></tr></table></figure>
<p>这里申明变量 <code>$verbose</code> 类型为 Bool，也就是不接受赋值。如果没有这个类型约束的话，它是需要赋值的，就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ cat do-nothing.pl</div><div class="line">sub MAIN(:$how = &apos;fast&apos;) &#123;</div><div class="line">    say &quot;Do nothing, but do it $how&quot;;</div><div class="line">&#125;</div><div class="line">$ perl6 do-nothing.pl</div><div class="line">Do nothing, but do it fast</div><div class="line"></div><div class="line">$ perl6 do-nothing.pl --how=well</div><div class="line">Do nothing, but do it well</div><div class="line"></div><div class="line">$ perl6 do-nothing.pl what?</div><div class="line">Usage:</div><div class="line">do-nothing.pl [--how=value-of-how]</div></pre></td></tr></table></figure>
<p>总之，Perl6 提供了内置的命令行解析功能和使用帮助说明，你只要声明好函数就行了。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><hr>
<p>目录<br>不再用 <code>opendir</code> 和其他神马滴，Perl6 中有专门的 <code>dir</code> 函数，用来列出指定目录（默认是当前所在目录）下所有的文件。好了，直接贴代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dir</div><div class="line">dir &apos;t&apos; # t 目录下的文件</div></pre></td></tr></table></figure>
<p>dir 还有一个可选的命名参数 <code>test</code>，用来 <code>grep</code> 结果，这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dir &apos;src/core&apos;, test =&gt; any(/^C/, /^P/)</div></pre></td></tr></table></figure>
<p>创建目录，还是 mkdir 函数没错啦~</p>
<p>文件</p>
<p>最简单的读取文件的办法，是直接使用 <code>slurp</code> 函数，这个函数以标量形式返回文件的内容，这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slurp &apos;VERSION&apos;</div></pre></td></tr></table></figure>
<p>当然原始的文件句柄方式还是有效的，这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my $fh = open &apos;CREDITS&apos;</div><div class="line">$fh.getc #读取一个字符</div><div class="line">$fh.get  #读取一行（译者注：这两看起来好有 C 语言的赶脚啊）</div><div class="line">$fh.close;</div><div class="line"></div><div class="line">$fh = open &apos;new&apos;, :w  # 以可写方式打开</div><div class="line">$fh.print(&apos;foo&apos;)</div><div class="line">$fh.say(&apos;bar&apos;)</div><div class="line">$fh.close;</div><div class="line">say slurp(&apos;new&apos;)</div></pre></td></tr></table></figure>
<p>文件测试<br>如果要测试文件是否存在以及文件的具体类型，直接使用<code>~~</code>操作符就搞定了，还是用代码说话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;LICENSE&apos;.IO ~~ :e     # 文件(广义的)是否存在</div><div class="line">&apos;LICENSE&apos;.IO ~~ :d     # 那么他是目录么？</div><div class="line">&apos;LICENSE&apos;.IO ~~ :f     # 那么是文件么(狭义的)？</div></pre></td></tr></table></figure>
<p>File::Find</p>
<p>如果这些个标准特性还不够，那模块就派上用场了。File::Tools 包里的 File::Find 模块可以递归你指定的目录找你要的东西然后列出来。这个模块应该是跟着 Rakudo Star 一起打包了，如果你只裸装了 Rakudo，那么用 neutro 命令安装也是挺方便的~~<br>额，还是要例子？好吧~很简单的一行 <code>find(:dir, :type, :name(/foo/))</code>，这就会在 <code>t/dir1</code> 目录下，寻找名字匹配 foo 的文件，然后以树的形式列出来~不过要注意的是：这命令的返回可不是文本标量，而是一个个包括他们的完整路径在内的对象，而且还提供文件本身以及文件所在目录的访问器！更多信息，直接看文档吧。<br>有用的示例<br>1、创建新文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open(&apos;new&apos;, :w).close</div></pre></td></tr></table></figure>
<p>2、匿名文件句柄</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">given open(&apos;foo&apos;, :w) &#123;</div><div class="line">    .say(&apos;Hello, world!&apos;);</div><div class="line">    .close</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第四天-–-序列操作符"><a href="#第四天-–-序列操作符" class="headerlink" title="第四天 – 序列操作符"></a>第四天 – 序列操作符</h2><hr>
<p>By Colomon<br>去年，有一个序列操作符的简要梳理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @even-numbers  := 0, 2 ... *;    # 算术序列</div><div class="line">my @odd-numbers   := 1, 3 ... *;</div><div class="line">my @powers-of-two := 1, 2, 4 ... *; # 几何序列</div></pre></td></tr></table></figure>
<p>这些现在在Rakudo里面实现了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; my @powers-of-two := 1, 2, 4 ... *; 1;</div><div class="line">1</div><div class="line">&gt; @powers-of-two[^10]</div><div class="line">1 2 4 8 16 32 64 128 256 512</div></pre></td></tr></table></figure>
<p>(注意：这篇文章中所有的代码例子都已经在Rakudo的 REPL 下面运行过了。因为变量 @powers-of-two 是一个无限惰性列表，我已经在行尾添加了 <code>1;</code> 以至于 REPL 打印出 1 而不是进入到一个无限循环里面。2015.5月份的 REPL 已经不需要加 <code>1;</code> 了。</p>
<p>我们需要削减这个无限列表让Rakudo不会花费无限长的时间来计算它。这种情况下，我使用 [^10] ,这其实是说 “给我前 10 个元素”。（注意，当你把一个惰性列表绑定到一个数组变量上时，被计算过的值是会被记忆的，这是一种快捷的缓存。</p>
<p>序列操作符  … 是一个生成惰性列表的强大工具。上面的例子仅仅暗示了它能做什么。给定一个数字，它就从这个数字开始往下计数（除非序列的终点是一个更小的数字，这种情况下，它会倒数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; 1 ... 10</div><div class="line">1 2 3 4 5 6 7 8 9 10</div><div class="line">&gt; 5 ... 1</div><div class="line">5 4 3 2 1</div></pre></td></tr></table></figure>
<p> 给定两个数字来开始一个序列，它会把这当作一个算术序列，把前两个元素的差异添加到最后一个生成的元素上来产生下一个元素。如果给定三个元素，它会检查它们是否代表一个算术序列的开始或者它是否是一个几何序列，然后继续这个序列。<br>当然，很多有趣的序列既非算术序列也非几何序列，这时，你需要显式地提供一个 sub 来生成序列中的下一个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; my @Fibonacci := 0, 1, -&gt; $a, $b &#123; $a + $b &#125; ... *; 1;</div><div class="line">1</div><div class="line">&gt; @Fibonacci[^10]</div><div class="line">0 1 1 2 3 5 8 13 21 34</div></pre></td></tr></table></figure>
<p>  上面的 <code>-&gt; $a, $b { $a + $b }</code> 是一个 pointy block (或者是一个匿名函数)，它带有 2个参数并返回它们的和。这个序列操作符计算出该block 有多少个参数，然后从当前序列的末尾传递所需的参数来生成序列的下一个数字，以此类推，循环下去。<br>或者也可以中断循环，目前为止，所有的例子都有一个 星号 * 放在右边，它意味着“没有终止条件”。如果你反而在那里放上一个数字，这个列表就会终止在那个数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; 1, 1.1 ... 2</div><div class="line">1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2</div><div class="line">&gt; 1, 1.1 ... 2.01</div><div class="line">... Rakudo spins its wheels, because this is an infinite list ...</div><div class="line">&gt; (1, 1.1 ... 2.01)[^14]</div><div class="line">1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 2.1 2.2 2.3</div></pre></td></tr></table></figure>
<p>第一个列表很自然地终止了，但是第二个列表漏掉了终止数，它会循环下去。结果就是一个无限列表，所以我把它限制到前 14 个元素，以至于我们能明白它正在做什么。<br>那些有做浮点数学背景的人可能会气急败坏地说反复增加0.1直到精确到2 为止很危险。</p>
<p>在Perl6中，没有这个问题，因为它会在可能的地方使用有理数（例如.分数)。如果我想找出所有 10000以下的斐波纳契数，要找到到何处停止的那个精确的数字是很大的问题。幸运的是，就像你能使用块来指定怎样生成序列中的下一个元素一样，你可以使用块来测试序列是否结束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 0, 1, -&gt; $a, $b &#123; $a + $b &#125; ... -&gt; $a &#123; $a &gt; 10000 &#125;;</div><div class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946</div></pre></td></tr></table></figure>
<p>尖头块 <code>-&gt; $a { $a &gt; 10000 }</code> 创建了一个含有一个参数的块，并且当参数大于 10000 时返回真；这就是我们需要的测试。</p>
<p>除了我们所期待的所有斐波那契数小于10000。 我们生成的裴波纳契数有一个大于10000的，当传递一个块作为终止测试时，该序列操作符所有的元素直到那个块返回真为止，然后它返回最后一个元素，然后停止。但是有一种替代形式的操作符能做同样的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 0, 1, -&gt; $a, $b &#123; $a + $b &#125; ...^ -&gt; $a &#123; $a &gt; 10000 &#125;;</div><div class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765</div></pre></td></tr></table></figure>
<p>从 <code>...</code> 转换为 <code>...^</code> 意味着结果列表不包含让终止测试返回真时的第一个元素。<br>有两点旁注. 在Perl6中这真是一种冗长的指定序列的方法。在这里我没有空间解释所谓的闭包，但是去年的文章已经说过它们。使用闭包，你可以将上一个序列写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 0, 1, * + * ...^ * &gt; 10000;</div><div class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765</div></pre></td></tr></table></figure>
<p>这样写是否清晰完全取决于你，条条大路通罗马。<br>并且，序列操作符的左侧可以是任何列表，甚至是惰性的。这意味着你可以很容易的使用一个终止块来得到已存在的惰性列表的有限的一部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; my @Fibonacci := 0, 1, * + * ... *; 1;</div><div class="line">1</div><div class="line">&gt; @Fibonacci ...^ * &gt; 10000</div><div class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765</div><div class="line">&gt; @Fibonacci[30]</div><div class="line">832040</div></pre></td></tr></table></figure>
<p>(我坚持最后的检查只是为了说明@Fibonacci 在超过10000之后依然会继续。<br>这才触及到序列能做什么的皮毛，更多的信息，查看 细则中的 “List infix precedence”，然后下拉到序列操作符（尽管如此，注意这还没有全部实现！它是一个极其复杂的操作符。）</p>
<p>我还要告诉你的是，序列操作符不局限于工作于数字，如果你显式地指定了你自己的生成器，你可以生成任何类型的序列。但是我喜欢将这保留到未来的圣诞节礼物。</p>
<h2 id="第五天-–-为什么Perl语法是你想要的"><a href="#第五天-–-为什么Perl语法是你想要的" class="headerlink" title="第五天 – 为什么Perl语法是你想要的"></a>第五天 – 为什么Perl语法是你想要的</h2><hr>
<p>圣临月第五天，您或许有些失望没能看到 Perl6 酷呆了的新玩法~这次会是直观的解释一些编程语言的运行原理。<br>作为样例，先说下面这两行吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say 6 / 3;</div><div class="line">say &apos;Price: 15 Euro&apos; ~~ /\d+/;</div></pre></td></tr></table></figure>
<p>嗯，两行代码的运行结果分别是 2 和 15。相信这对 perl 程序员来说没什么可奇怪的。但你再细看看，两行都有斜杠<code>/</code>，却为了完全不一样的目的，第一个是数值运算，第二 个是正则匹配。</p>
<p>Perl 怎么知道一个 <code>/</code> 号意味着什么？这当然不是简单的看 <code>/</code> 号后面的文本来决定，因为正则表达式可以看起来跟普通代码一样。<br>答案是：Perl 会持续跟踪他的预期。Perl 预期中最重要的两样东西就是：词和操作符。</p>
<p>一个词可以是像 23 或者 str 这样的文字。当解释器发现这样一个文字，然后后面就会是一个语句的结束（即分号;），或者一个操作符像 <code>+/*</code> 等等。过了这个操作符，解 释器又开始预期下一个词。<br>其实这就是问题的答案了：当解释器预期为词的时候，斜线 / 就代表正则表达式的开始；当预期为操作符的时候，斜线 / 就代表数字的除法运算。</p>
<p>这种做法造成了深远的后果。子函数运行可以不加括号，而在函数名后面，perl 预期一个词开端的参数列表。另一方面，类型名必须跟在操作符后面，所以，所有的类型名必 须在解析时就是已知的。<br>这样，很多字符都可以重复使用在不同的语法环境下了。</p>
<h2 id="第六天-–-X和-Z-元操作符"><a href="#第六天-–-X和-Z-元操作符" class="headerlink" title="第六天 – X和 Z 元操作符"></a>第六天 – X和 Z 元操作符</h2><hr>
<pre><code>-- By Matthew Walton
</code></pre><p>Perl 6中一个新的创意就是元操作符，这种元操作符和普通的操作符结合改变了普通操作符的行为。这种元操作符有很多，但这里我们只关注它们中的两个: <code>X</code> 和 <code>Z</code><br>X 操作符你可能已经见过它作为中缀交叉操作符的普通角色。它将列表联合在一起，每个列表中各取一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; say ((1, 2) X (&apos;a&apos;, &apos;b&apos;)).perl</div><div class="line">((1, &quot;a&quot;), (1, &quot;b&quot;), (2, &quot;a&quot;), (2, &quot;b&quot;))</div></pre></td></tr></table></figure>
<p>然而,这个中缀操作符infix:<x> 其实是 将 X 操作符应用到 列表连接操作符    infix:&lt;,&gt;上的简便形式。事实上，你可以这样写：  </x></p>
<pre><code>&gt; say ((1, 2) X, (10, 11)).perl
((1, 10), (1, 11), (2, 10), (2, 11))
</code></pre><p>如果你喜欢.所以你将 X 应用到不同的中缀操作符上面会发生什么？   应用到  infix:&lt;+&gt; 上呢？</p>
<pre><code>&gt; say ((1, 2) X+ (10, 11)).perl
(11, 12, 12, 13).list
</code></pre><p> 它做了什么？它不是从每个组合中挑出所有的元素列表，这个操作符将中缀操作符 + 应用到元素间，并且结果不是一个列表，而是一个数字，是那个组合中所有元素的和。<br>这对任何中缀操作符都有效。看看 字符串连接 <code>infix:&lt; ~ &gt;</code>：</p>
<pre><code>&gt; say ((1, 2) X~ (10, 11)).perl
(&quot;110&quot;, &quot;111&quot;, &quot;210&quot;, &quot;211&quot;)
</code></pre><p>或者也许数值相等操作符infix:&lt; == &gt;</p>
<pre><code>&gt; say ((1, 2) X== (1, 1)).perl
(Bool::True, Bool::True, Bool::False, Bool::False)
</code></pre><p>但是这篇文章也是关于 Z 元操作符的。我们期望你已经知道他是什么了。如果你遇见过 中缀操作符 Z，它当然是 Z, 的便捷形式。</p>
<pre><code>&gt; say ((1, 2) Z, (3, 4)).perl
((1, 3), (2, 4))
&gt; say ((1, 2) Z+ (3, 4)).perl
(4, 6).list
&gt; say ((1, 2) Z== (1, 1)).perl
(Bool::True, Bool::False)
</code></pre><p>Z,然后,依次操作每个列表的每个元素，同时操作每个列表中的第一个元素，然后同时操作第二对儿，然后第三对儿，不管有多少。当到达列表的结尾时停止。</p>
<p>Z也是惰性的,所以你可以将它用在两个无限列表上，它会尽可能多地生成你需要的结果。X 只能处理左边是无限列表的列表，否则它不会设法得到任何东西。</p>
<p>在写这篇文章的时候，Rakudo 正好出现了一个 bug，就是 <code>infix:&lt;Z&gt;</code> 和 <code>infix:&lt;Z,&gt;</code>不是完全一样的:后者产生一个展开的列表. S03 表明后者的行为是正确的。</p>
<p>These metaoperators, then, become powerful tools for performing operations encompassing the individual elements of multiple lists, whether those elements are associated in some way based on their indexes as with Z, or whether you just want to examine all possible combinations with X.</p>
<p>有一个键和值得列表，你想得到一个散列？ 容易！</p>
<pre><code>my %hash = @keys Z=&gt; @values;
</code></pre><p>或者，也许你想并行遍历两个列表？</p>
<pre><code>for @a Z @b -&gt; $a, $b { ... }
</code></pre><p>或者三个?</p>
<pre><code>for @a Z @b Z @c -&gt; $a, $b, $c { ... }
</code></pre><p>或者你能从扔3次有10个面的骰子的所有数字组合中，得到所有可能的总数：</p>
<pre><code>my @d10 = 1 ... 10;
my @scores = (@d10 X+ @d10) X+ @d10;
</code></pre><p>如果你想看到一些在真实世界这些原操作符的用途，看看 Moritz Lenz’s 写的  Sudoku.pm 数独解算器。</p>
<h2 id="第七天-词法变量"><a href="#第七天-词法变量" class="headerlink" title="第七天 词法变量"></a>第七天 词法变量</h2><hr>
<p>编程总是件很难持续做下去的事情。串几行代码很容易，根据想法做一个原型也是轻松愉快的。但随着程序慢慢变大，维护时间慢慢变长，事情慢慢就棘手起来了……最后，如果不幸的话，我们就得被迫重构——不是因为早先的问题复杂，而是因为程序本身复杂了……在不断的调试中急白了头的程序员们，早就不记得到底要怎么扩展程序以完成目的了……<br>所以我们回溯一下编程史，找找对着复杂性的办法。而答案就在那里，不来不去——<code>限制长度</code>。当你架构一个成百上千模块组成的大型程序的时候，你必须能够让这些组件通过表面上很小的设置进行交互——否则你就等着被乱七八糟的组合干死吧。</p>
<p>在各层次的编程上，我们都可以看到这么一个原则。因为他就只关心这一件事情：分散注意，专一的做一件事情！BCNF 范式、monads (译者注：不知道这东东咋翻译)、单子，例程，类，角色，模块，包等。这些都是在督促和指导我们限制编程的长度。这样我们才不会输在组<br>合学上。而这方面最简单的例子，就是词法变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    my $var;</div><div class="line">    # $var可见</div><div class="line">&#125;</div><div class="line"># $var不可见</div></pre></td></tr></table></figure>
<p>哈哈，这就是今天要介绍的一个非常酷的功能了！非常有趣的说~<br>Perl从第一版开始，在这方面一直不太对。比如Perl5的默认变量作用域是包。而这就是全局变量的一种。我在某个代码块里定义了一个变量，其他地方居然也能看到……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ perl -v</div><div class="line">This is perl 5, version 12, subversion 1 (v5.12.1)</div><div class="line">$ perl -E &apos;&#123; $var = 42 &#125;; say $var&apos;</div><div class="line">42</div><div class="line">$ perl -wE &apos;&#123; my $var= 42 &#125;; say $var&apos;</div><div class="line">Name &quot;main::var&quot; used only once: possible typo at -e line 1.</div><div class="line">Use of uninitialized value $var in say at -e line 1.</div></pre></td></tr></table></figure>
<p>在Perl6里，词法变量变成了默认设置。在 Rakudo 上运行上面的代码，根本无法通过编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;&#123; $var = 42 &#125;; say $var&apos;</div><div class="line">===SORRY!===</div><div class="line">Symbol &apos;$var&apos; not predeclared in &lt;anonymous&gt;</div><div class="line">$ perl6 -e &apos;&#123; my $var = 42 &#125;; say $var&apos;</div><div class="line">===SORRY!===</div><div class="line">Symbol &apos;$var&apos; not predeclared in &lt;anonymous&gt;</div></pre></td></tr></table></figure>
<p>好了，你可能说：“嗯，可以减少点打错字的可能了”。这当然没错，但是更重要的是：这让你认真坦诚的对待<code>变量作用域</code>。这对你控制代码复杂性很有利！</p>
<p>我们可以说出很多很多解释来说明为啥 Perl5 这么做。比如 Perl5 已经建议大家 <code>use warnings;</code> <code>use strict;</code> ，比如 Perl5 承诺的向后兼容，嗯，很伟大的做法，而 Perl1 压根没打算用来写大型程序和管理带来的复杂性；比如全局变量在单行模式下的各种方便……<br>Perl6 内置的强制你从小处着手，帮你在系统扩容的时候，更苛责的关注架构基础。在变量方面，也就是在脚本和模块中，将词法变量作为默认设置。不过在 perl -e 执行的单行命令中，默认依然是全局变量。（ Rakudo 还没有实现这个，目前单行依然是词法变量，期待实现的那天~）<br>继续。好像到这里你感觉词法变量的价值已经说完了？没有！正确设计的结果可是令人惊讶和奖金源源不断啊~考虑一下这个子程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub counter($start_value) &#123;</div><div class="line">    my $count = $start_value;</div><div class="line">    return &#123; $count++ &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里返回的是一个代码块。所以每次我们调用 <code>counter()</code> 的时候，得到的都是一小片断开的代码。然后看看当我创建两片这样的代码后的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my $c1 = counter(5);</div><div class="line">say $c1();           # 5</div><div class="line">say $c1();           # 6</div><div class="line">&amp;nbsp_place_holder;</div><div class="line">my $c2 = counter(42);</div><div class="line">say $c2();           # 42</div><div class="line">say $c1();           # 7</div><div class="line">say $c2();           # 43</div></pre></td></tr></table></figure>
<p>看到了吧， <code>$c1</code> 和 <code>$c2</code> 是完全分开的，他们相互独立互不影响。尽管他们都写成 $count 的样子，看起来真是差不多，但他们都有自己独立的存储单元——因为每次我们运行进入那个代码块的时候，就是一次重新开始。这个小代码块从运行中的计数器里返回，这些计数器里保留了存储单元的对应关系。（他“关闭”这个存储单元，保护它不被 GC 回收掉。这类代码块叫闭包）<br>这个闭包看起来像是个轻量级的对象？gxgx，他们确实就是。闭包背后的原则，即规范对闭包值的访问方式，与面向对象背后的封装和信息的原则是一样的。他们都是尽力限制事情的程度，在事情变得糟糕的时候，帮忙减少其影响和损失。<br>你可以用词法变量做些很有趣的事情，比如闭包；而包变量不行。词法变量最酷啦！吼吼~~</p>
<h2 id="第八天-不同东西用不同名字"><a href="#第八天-不同东西用不同名字" class="headerlink" title="第八天  不同东西用不同名字"></a>第八天  不同东西用不同名字</h2><hr>
<p>Perl5 的新手们，总会很奇怪的说为啥自己没法倒装呢？Perl 里有内置的 reverse 命令，但好像压根不起作用啊：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl -E &quot;say reverse &apos;hello&apos;&quot;</div><div class="line">    hello</div></pre></td></tr></table></figure>
<p>当他们去问一些有经验的 perler 的时候，解决办法很快就有了。因为 reverse 有两种操作模式，分别工作在标量和列表环境下，用来倒装字符串和列表元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl -E &quot;say scalar reverse &apos;hello&apos;&quot;</div><div class="line">    olleh</div></pre></td></tr></table></figure>
<p>比较悲剧的是这个情况和大多数的 perl 语境是不一致的。比方说，绝大多数的操作符和函数由自己决定语境，并在这个语境下分析数据。好比 + 和 * 作用于数字，. 作用于字符串。所以说他们代表一个操作并且提供语境，而 reverse 却不是。<br>在 Perl6 里，我们从过去的错误里吸取教训以摆脱历史的窘境。所以我们把列表倒叙，字符串翻转，哈希反演分开成了三个操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 字符串翻转，改名叫flip</div><div class="line">$ perl6 -e &apos;say flip &quot;hello&quot;&apos;</div><div class="line">olleh</div><div class="line"># 列表倒叙</div><div class="line">$ perl6 -e &apos;say join &quot;, &quot;, reverse &lt;ab cd ef&gt;&apos;</div><div class="line">ef, cd, ab</div><div class="line"># 哈希反转，叫invert</div><div class="line"></div><div class="line">my %capitals = France =&gt; &quot;Paris&quot;, UK =&gt; &quot;London&quot;;</div><div class="line">say %capitals.invert.perl;</div><div class="line">(&quot;Paris&quot; =&gt; &quot;France&quot;, &quot;London&quot; =&gt; &quot;UK&quot;)</div></pre></td></tr></table></figure>
<p>注意哈希的反演和其他两个不同。因为哈希的值不要求是唯一的，所以反演后，哈希结构可能会被改变，或者某些值被覆盖……<br>如果必要的话，使用者可以自己决定返回哈希结构时的操作方式。比如下面就是一种无损的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %inverse;</div><div class="line">   %inverse.push( %original.invert );</div></pre></td></tr></table></figure>
<p>这个方法会在键值对存在的情况下，把新值push在原有值的队尾变成一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my %h;</div><div class="line">%h.push(&apos;foo&apos; =&gt; 1);    # foo =&gt; 1</div><div class="line">%h.push(&apos;foo&apos; =&gt; 2);    # foo =&gt; [1, 2]</div><div class="line">%h.push(&apos;foo&apos; =&gt; 3);    # foo =&gt; [1, 2, 3]</div></pre></td></tr></table></figure>
<p>这三个函数，都会强制转换他们的参数。也就是说，如果你传递一个列表给 flip，这个列表会被强制成字符串后再翻转返回。</p>
<h2 id="第十天-–-Feed-operators"><a href="#第十天-–-Feed-operators" class="headerlink" title="第十天 – Feed operators"></a>第十天 – Feed operators</h2><hr>
<p>By Perlpilot<br> 使用Perl 5 编程一段时间的人可能遇到或写过下面这样相似的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @new = sort &#123; ... &#125; map &#123; ... &#125; grep &#123; ... &#125; @original;</div></pre></td></tr></table></figure>
<p>在这个构造中，数据从 @original 数组流进 grep，然后按顺序，流进 map ，然后流进 sort，最后将结果赋值给 @new 数组。因为它们每个都将列表作为它们最终的参数，仅仅通过位置，数据从一个操作符向左流进下一个操作符。</p>
<p>Perl 6, 从另一方面，通过引入流向操作符让数据从一个操作符流进另一个操作符，让这种思想更明确。上面的Perl 5 代码能使用 Perl 6 重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @new &lt;== sort &#123; ... &#125; &lt;== map &#123; ... &#125; &lt;== grep &#123; ... &#125; &lt;== @original;</div></pre></td></tr></table></figure>
<p>注意条条大路通罗马，这个在Perl 6 中更能体现。你也可以跟Perl 5 的写法相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @new = sort &#123; ... &#125;, map &#123; ... &#125;, grep &#123; ... &#125;, @original;</div></pre></td></tr></table></figure>
<p>唯一不同的是额外的<code>逗号</code>。<br>所以，我们从这些流向操作符得到了什么？通常，当我们阅读代码的时候，你是从左向右读的，在原来的 Perl 5 代码中，你可能从左到右阅读你的代码直到你发现正在处理的结构，其流向是从右向左的，然后你跳到末尾，按照从右往左的方式再读一遍。 在Perl 6 中，现在有一个突出的句法标记，告诉你数据向左流动的性质。</p>
<p>这样写也可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@original ==&gt; grep &#123; ... &#125; ==&gt; map &#123; ... &#125; ==&gt; sort &#123; ... &#125;  ==&gt; my @new;</div></pre></td></tr></table></figure>
<p>下面是一些使用流向操作符的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">my @random-nums = (1..100).pick(*);  # 100个随机数</div><div class="line">my @odds-squared &lt;== sort &lt;== map &#123; $_ ** 2 &#125; &lt;== grep &#123; $_ % 2 &#125; &lt;== @random-nums;</div><div class="line">say ~@odds-squared;</div><div class="line"></div><div class="line">&gt; my @a= (1..100).pick(*);</div><div class="line"></div><div class="line">&gt; @a ==&gt; grep &#123;$_ % 2&#125; ==&gt; map &#123; $_ ** 2&#125; ==&gt; sort &#123;$^a &lt;=&gt; $^b&#125; ==&gt; my @c;</div><div class="line">1 9 25 49 81 121 169 225 289 361 441 529 625 729 841 961 1089 1225 1369 1521 1681 1849 2025 2209 2401 2601 2809 3025 3249 3481 3721 3969 4225 4489 4761 5041 5329 5625 5929 6241 6561 6889 7225 7569 7921 8281 8649 9025 9409 9801</div><div class="line"></div><div class="line"></div><div class="line">&gt; my @odds-squared &lt;== sort &#123;$^b &lt;=&gt; $^a&#125; &lt;== map &#123; $_ ** 2 &#125; &lt;== grep &#123; $_ % 2 &#125; &lt;== @random-nums   # 降序排列</div><div class="line">9801 9409 9025 8649 8281 7921 7569 7225 6889 6561 6241 5929 5625 5329 5041 4761 4489 4225 3969 3721 3481 3249 3025 2809 2601 2401 2209 2025 1849 1681</div><div class="line">1521 1369 1225 1089 961 841 729 625 529 441 361 289 225 169 121 81 49 25 9 1</div><div class="line"></div><div class="line">&gt; my @rakudo-people = &lt;scott patrick carl moritz jonathan jerry stephen&gt;;</div><div class="line">&gt; @rakudo-people ==&gt; grep &#123; /at/ &#125; ==&gt; map &#123; .ucfirst &#125; ==&gt; my @who-it&apos;s-at;</div><div class="line">&gt; say ~@who-it&apos;s-at;    # Patrick Jonathan</div><div class="line"></div><div class="line">&gt; [+](my @a) &lt;== map &#123;$_ **2&#125; &lt;==  1..10   # 385 ， 1 到 10 的平方和</div><div class="line">&gt; [+]() &lt;== map &#123;$_ **2&#125; &lt;==  1..10</div><div class="line">385</div></pre></td></tr></table></figure>
<h2 id="第十二天-–-智能匹配"><a href="#第十二天-–-智能匹配" class="headerlink" title="第十二天 – 智能匹配"></a>第十二天 – 智能匹配</h2><hr>
<p>By Ttjjss<br>还记得<a href="http://perl6advent.wordpress.com/2010/12/04/the-sequence-operator/" target="_blank" rel="external">Perl 6 Advent</a> 序列操作符吗?因为最后一个参数它接受的是一个上限，这让序列的生成停止了，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1, 2, 4 ... 32;         # 1 2 4 8 16 32</div><div class="line">1, 2, 4 ... * &gt; 10;     # 1 2 4 8 16</div><div class="line">&gt; 1,2,4 ... * &gt; 100;</div><div class="line">1 2 4 8 16 32 64 128</div><div class="line">&gt; 1,2,4 ...^ * &gt; 100;</div><div class="line">1 2 4 8 16 32 64</div></pre></td></tr></table></figure>
<p>你能看到，在第一种情况下，使用了数值相等。第二个更有意思： <code>*&gt;10</code> 在内部被重写为一个闭包，像这样 <code>-&gt; $x { $x &gt; 10 }</code> (through currying).</p>
<p>序列操作符做了一些不可思议的比较，根据匹配者的类型。这种比较就叫做智能匹配，并且是在Perl6中重复出现的一个概念，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># after the &apos;when&apos; keyword:</div><div class="line">given $age &#123;</div><div class="line">    when 100    &#123; say &quot;congratulations!&quot;      &#125;</div><div class="line">    when * &lt; 18 &#123; say &quot;You&apos;re not of age yet&quot; &#125;</div><div class="line">&#125;</div><div class="line"># after &apos;where&apos;:</div><div class="line">subset Even of Int where * %% 2;</div><div class="line"># 显式地使用智能匹配操作符:</div><div class="line">if $input ~~ m/^\d+$/ &#123;</div><div class="line">    say &quot;$input is an integer&quot;;</div><div class="line">&#125;</div><div class="line"># arguments to grep(), first() etc.:</div><div class="line">my @even = @numbers.grep: Even;</div></pre></td></tr></table></figure>
<p>在智能操作符 ~~ 的右侧，并且在 when 和 where 的后面，要匹配的值被设置为 主题变量 <code>$_</code>. This allows us to use constructs that operate on $_, like regexes created with m/…/ and .method_call.</p>
<p>下面是一些智能操作符的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$foo ~~ Str             #它的类型是 Str吗?</div><div class="line">$foo ~~ 6               #它等于 6 吗?</div><div class="line">$foo ~~ &quot;bar&quot;           #或者它是 &quot;bar&quot; 吗?</div><div class="line">$foo ~~ / \w+ &apos;-&apos; \d+ / # 它匹配某个模式吗?</div><div class="line">$foo ~~ (15..25)        # 它的值在 15 和 25 之间吗?</div><div class="line">$foo ~~ -&gt; $x &#123; say &apos;ok&apos; if 5 &lt; $x &lt; 25 &#125; # 调用闭包</div><div class="line">$foo ~~ [1, *, 1, *, 1, *] # 含有6个元素的数组，是否其所有的奇数元素的值都为 1?</div></pre></td></tr></table></figure>
<p><a href="http://perlcabal.org/syn/S03.html#Smart_matching" target="_blank" rel="external">智能匹配的全部表现可以在这找到：</a>.</p>
<p>智能匹配没有特殊的操作符，而大部分智能匹配的情况会返回 Bool值，对正则进行匹配会返回一个Match 对象</p>
<p>你可能开始怀疑：一个正确的，内置的类型，我怎么将它用在我自己的类中？你需要为它写一个特别的 ACCEPTS方法。假如我们有一个叫Point 的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">    method ACCEPTS(Positional $p2) &#123;</div><div class="line">        return $.x == $p2[0] and $.y == $p2[1]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一切都清楚了吗?让我们看看它是如何工作的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $a = Point.new(x =&gt; 7, y =&gt; 9);</div><div class="line">say [3, 5] ~~ $a; # Bool::False</div><div class="line">say (7, 9) ~~ $a; # Bool::True</div></pre></td></tr></table></figure>
<p> 现在能恰当地做到你想要的，甚至使用你自己的类。</p>
<h2 id="第-16-天-Perl-6-里的时间"><a href="#第-16-天-Perl-6-里的时间" class="headerlink" title="第 16 天 - Perl 6 里的时间"></a>第 16 天 - Perl 6 里的时间</h2><hr>
<p>今天是圣诞月历的第 0x10 天，是时候学习一下 perl6 里的时间了。S32::Temporal 简介在过去一年中有了大量的修改，今天我们就来介绍一下在 perl6 实现中关于时间的一些基础知识。</p>
<p>time 和 now 是两个可以返回当前时间（至少是你的系统认为的当前时间）的词。简单的展示一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; say time; say now;</div></pre></td></tr></table></figure>
<p>1292460064<br>Instant:2010-12-16T00:41:4.873248Z</p>
<p>第一个明显的区别，前者返回的是 POSIX 格式的数值型的结果；而后者返回的是一个瞬间的对象。如果你想获取秒级以下小数点位或者说闰秒，请用 now ；如果不用，那用 time 获取 POSIX 格式就够了。随你的便。<br>DateTime和他的伙伴<br>大多数时候，你要的不是当前时间。这种时候，你需要的是 DateTime 。比如还是获取当前时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $moment = DateTime.new(now); # 或者DateTime.new(time)</div></pre></td></tr></table></figure>
<p>你有两种方式来创建 DateTime 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $dw = DateTime.new(:year(1963), :month(11), :day(23), :hour(17), :minute(15));</div></pre></td></tr></table></figure>
<p>这是 UTC 时区，如果你要更改时区的话，再加上 :timezone 就好了。这个格式里，只有 :year 是必须的，其他的默认就是1月1号半夜0点0分。<br>上面这种写法确实乏味，你可以采用 ISO8601 格式的输入，来创建一个 DateTime 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $dw = DateTime.new(&quot;1963-11-23T17:15:00Z&quot;);</div></pre></td></tr></table></figure>
<p>其中Z 表示 UTC ，想改变的话，把 Z 替换成 +hhmm 或者 -hhmm 就好了。hh 表示小时，mm 表示分钟。<br>此外，还有一个更简略的 Date 对象。只包括年月日的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $jfk = Date.new(&quot;1963-11-22&quot;); # 你也可以用:year 等的写法</div></pre></td></tr></table></figure>
<p>引入 Date 对象，是吸取了 CPAN 上 DateTime 模块的教训：有时候你压根不关心什么时区啊闰秒啊的。 Date 对象非常容易处理，比如它有内置的 .succ 和 .pred 方法，用来简单的递增和递减。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$jfk++; # 肯尼迪遇刺后的第二天</div></pre></td></tr></table></figure>
<p>最后…<br>以上就是关于 Perl6 里的时间的内容了，想了解更多细节，去看看规范吧；或者去社区里提问</p>
<h2 id="第十九天-假作真时真亦假"><a href="#第十九天-假作真时真亦假" class="headerlink" title="第十九天 - 假作真时真亦假"></a>第十九天 - 假作真时真亦假</h2><hr>
<p>今天的圣临礼物是教大家怎么用混淆完成一个小邪恶滴目的，吼吼~看起来这个功能挺疯狂的，其实有时候蛮有用的。先看下面这个用 but 的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $value = 42 but role &#123; method Bool  &#123; False &#125; &#125;;</div><div class="line">say $value;    # 42</div><div class="line">say ?$value;   # False</div></pre></td></tr></table></figure>
<p>你看，我们改变了 <code>$value</code> 的 <code>.Bool</code> 方法。他不影响程序里其他所有的整数，哪怕别的变量也是 42。一般情况下，对于 Int 型，<code>.Bool</code> 方法（通过?操作符）返回值依据是是否等于 0。但这次它永远都返回 false 了。<br>事实上，我们还可以写的更简单，因为 False 是一个枚举值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $value = 42 but False;</div></pre></td></tr></table></figure>
<p>因为 False 是 Bool 值，所有它会自动重载 .Bool 方法。这是 Perl6 的一种转换方法。其他的值，也会对应的重载。<br>这样在有的时候，这个东西就比较有用了：在 Perl5 里，你用 system 调用 shell 的时候，得牢牢记住在 shell 里，返回 0 才是正常的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ( system($cmd) == 0 ) &#123;  # 或者!system($cmd)</div><div class="line">    # ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而在 Perl6 中，对应的 run 命令返回的是上面说的这种重载过的 Int，当且仅当返回值是 0 的时候，它的 bool 变成了 True，这正是我们想要的额！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if run($cmd) &#123;  #不需要否定了</div><div class="line">    # ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，现在进入最疯狂的部分 —— 我们可以重载布尔值的布尔方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $value = True but False;</div><div class="line">say $value;    # True</div><div class="line">say ?$value;   # False</div></pre></td></tr></table></figure>
<p>没错，Perl6 允许你这样自己踢自己屁股~~虽然我也不知道除了捣乱外怎么会有人愿意这么做，但是我还是很高兴看到 Perl6 保持这种微妙的跟踪和重载类型的心态。我可没有……</p>
<h2 id="Day-21-–-transliteration-and-beyond"><a href="#Day-21-–-transliteration-and-beyond" class="headerlink" title="Day 21 – transliteration and beyond"></a>Day 21 – transliteration and beyond</h2><hr>
<p>By Carl<br>转换听起来像拉丁词根,意味着字母的变化。这就是 Str.trans 方法所做的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;GATTACA&quot;.trans( &quot;TCAG&quot; =&gt; &quot;0123&quot; );  # prints &quot;3200212\n&quot;</div></pre></td></tr></table></figure>
<p>使用过Perl5 的人马上意识到这就是 <code>tr/tcag/0123/</code> .</p>
<p> 下面是一个例子，使用 ROT-13算法加密文本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub rot13($text) &#123; $text.trans( &quot;A..Za..z&quot; =&gt; &quot;N..ZA..Mn..za..m&quot; ) &#125;</div></pre></td></tr></table></figure>
<p>当 <code>.trans</code> 方法看到那些 <code>..</code> 区间时，它会在内部将那些字母展开 (所以 “n..z” 意思是 “nopqrstuvwxyz”). 因此,rot13子例程的最终效果是将ASCII字母表的特定部分映射到其他部分。</p>
<p>在 Perl5 中，两个点跟一个破折号相同，但是在Perl6 中我们让那两个点 .. 代表 范围的概念，在主程序中，在正则中，还有在这里，转换。<br>要注意的是， .trans 方法是不会改变原来的字符串； 它不会噶边 $text ,而是返回一个新的值。这在Perl6中也是一个通用的旋律。要改变原值，请使用  <code>.=trans</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$kabbala.=trans(&quot;A..Ia..i&quot; =&gt; &quot;1..91..9&quot;);</div></pre></td></tr></table></figure>
<p>(并且，它不仅仅适用于 .trans 方法，它对所有方法都适用。)<br>当Perl 6 就是 Perl 6，.trans 方法包含了一个秘密武器：<br>假如我们想转义一些HTML，即，根据下面这个表来替换东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&amp; =&gt; &amp;amp;</div><div class="line">&lt; =&gt; &amp;lt;</div><div class="line">&gt; =&gt; &amp;gt;</div></pre></td></tr></table></figure>
<p>但是我们不想关心替换还要按顺序进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo         =&gt; bar</div><div class="line">foolishness =&gt; folly</div></pre></td></tr></table></figure>
<p>在上面的例子中，如果前面的替换先发生，就不回有后面的替换出现了—这可能不是你想要的。通常，我们想在短的子串之前，尝试并匹配最长的子串。<br>所以，这看起来我们需要一个最长记号的替换匹配，以避免因为偶然的重复替换而产生的无限循环。<br>那就是 Perl 6 的 .trans 方法所提供的。这就是它的秘密武器：嵌入两个数组而非字符串. 对于HTML转义，我们所需要的就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $escaped = $html.trans(</div><div class="line">    [ &apos;&amp;&apos;,     &apos;&lt;&apos;,    &apos;&gt;&apos;    ] =&gt;</div><div class="line">    [ &apos;&amp;amp;&apos;, &apos;&amp;lt;&apos;, &apos;&amp;gt;&apos; ]</div><div class="line">);</div></pre></td></tr></table></figure>
<p>替换的顺序问题和避免循环就不用我们关心了。</p>
<h2 id="第二十二天-Meta-Object-Protocol"><a href="#第二十二天-Meta-Object-Protocol" class="headerlink" title="第二十二天 - Meta-Object Protocol"></a>第二十二天 - Meta-Object Protocol</h2><hr>
<p>你有没有想过用你最爱的编程语言写一个类——但是不是按部就班的写类定义，而是通过几行代码？有些语言提供了 API 来完成这个功能。这些 API 的后面，就是元对象协议( Meta-Object Protocol )，简称 MOP 。<br>Perl6 就有 MOP ，你可以自己创建类、角色、语法，添加方法和属性，并且内省类。比如我们可以调用 MOP 查看 Rakudo 是如何实现 Rat 类型（有理数）的。调用 MOP ，只要把一般的 <code>.</code> 换成 <code>.^</code> 就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ perl6</div><div class="line">&gt; say join &apos;, &apos;, Rat.^attributes</div><div class="line">$!numerator, $!denominator</div><div class="line">&gt; # 列出全部方法比较多，所以随机选几个</div><div class="line">&gt; say join &apos;, &apos;, Rat.^methods(:local).pick(5)</div><div class="line">unpolar, ceiling, reals, Str, round</div><div class="line">&gt; say Rat.^methods(:local).grep(&apos;log&apos;).[0].signature.perl</div><div class="line">:(Numeric $x: Numeric $base = &#123; ... &#125;;; *%_)</div></pre></td></tr></table></figure>
<p>显示出来的这几行信息相信都是不言自明了。Rat 有两个属性，<code>$!numerator</code> 和 <code>$!denominator</code> ；有很多方法，其中 log 方法可接受的第一个变量是数值型 invocant(译者注：不知道怎么翻译，反正就是对象本身的引用 $_[0] )，用冒号标记过；第二个变量参数是可选的，名字是 $base ，它设有一个默认值，不过 Rakudo 不打算告诉你……</p>
<p>Perl6 的数据库接口代码里有一个很不错的使用实例。它有一个选项用来记录对象的调用，但是只是记录一部分特定角色（比如和连接管理或者数据检索有关的）。下面是 dbi 里的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">sub log-calls($obj, Role $r) &#123;</div><div class="line">     my $wrapper = RoleHOW.new;</div><div class="line">     for $r.^methods -&gt; $m &#123;</div><div class="line">         $wrapper.^add_method($m.name, method (|$c) &#123;</div><div class="line">             # 打印日志信息，note() 函数输出到标准错误</div><div class="line">             note &quot;&gt;&gt; $m&quot;;</div><div class="line">             nextsame;</div><div class="line">         &#125;);</div><div class="line">     &#125;</div><div class="line">     $wrapper.^compose();</div><div class="line">     # does 操作符和 but 类似，不过只修改一个对象的拷贝</div><div class="line">     $obj does $wrapper;</div><div class="line">&#125;</div><div class="line">role Greet &#123;</div><div class="line">     method greet($x) &#123;</div><div class="line">         say &quot;hello, $x&quot;;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">class SomeGreeter does Greet &#123;</div><div class="line">     method LOLGREET($x) &#123;</div><div class="line">         say &quot;OH HAI &quot;~ uc $x;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">my $o = log-calls(SomeGreeter.new, Greet);</div><div class="line"># 记录日志啦，因为由 Greet 角色提供了</div><div class="line">$o.greet(&apos;you&apos;);</div><div class="line"># 没记录，因为没角色提供这个</div><div class="line">$o.LOLGREET(&apos;u&apos;);</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<pre><code>&gt;&gt; greet
hello, you
OH HAI U
</code></pre><p>所以说，有了 MOP ，除了指定的语法，你还可以像普通接口一样访问类、角色、语法和属性。这给了面向对象更大的灵活性，可以轻松的内省和修改对象了。</p>
<h2 id="第23天-一些精彩的排序示例"><a href="#第23天-一些精彩的排序示例" class="headerlink" title="第23天 -  一些精彩的排序示例"></a>第23天 -  一些精彩的排序示例</h2><hr>
<p>继续我们的圣临礼物。<br>排序是一个非常非常常见的编程任务。Perl6 加强了它的 <code>.sort</code> 功能来帮助大家更好的排序。<br>最最正常的默认写法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @sorted = @unsorted.sort; # 或者 这样</div><div class="line">sort @unsorted;</div></pre></td></tr></table></figure>
<p>和 Perl5 一样，也是可以自定义函数的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 数值比较</div><div class="line">my @sorted = @unsorted.sort: &#123; $^a &lt;=&gt; $^b &#125;;</div><div class="line"># 或者用函数调用的形式</div><div class="line">my @sorted = sort &#123; $^a &lt;=&gt; $^b &#125;, @unsorted;</div><div class="line"># 字符串比对 ( 跟Perl5的cmp一样 )</div><div class="line">my @sorted = @unsorted.sort: &#123; $^a leg $^b &#125;;</div><div class="line"># 类型依赖比对</div><div class="line">my @sorted = @unsorted.sort: &#123; $^a cmp $^b &#125;;</div></pre></td></tr></table></figure>
<p>你也可以把 <code>:</code> 换成 <code>()</code> ，然后再跟上一些方法进行后续处理，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @topten = @scores.sort( &#123; $^b &lt;=&gt; $^a &#125; ).list.munch(10);</div></pre></td></tr></table></figure>
<p>小提示： $a 和 $b 不再像在 Perl5 中那样有特殊含义了，在 sort 代码块里用别的命名变量 <code>$var</code> 、位置变量 <code>$^var</code> 或者其他任何的都跟在其他代码段里一样。<br>你可以直接在排序的时候直接就做好变换函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @sorted = @unsorted.sort: &#123; foo($^a) cmp foo($^b) &#125;;</div></pre></td></tr></table></figure>
<p>不过 foo() 会在重复执行，如果列表不大也就罢了，如果比较大的话……如果 foo() 还是个计算密集型的……你懂的！<br>在这种情况下，Perl5 里有个习惯就是使用施瓦茨( Schwartzian )变换。施瓦茨变换的做法就是 decorate-sort-undecorate，foo() 函数只用执行一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@sorted =</div><div class="line">    map  &#123; $_-&gt;[0] &#125;</div><div class="line">    sort &#123; $a-&gt;[1] cmp $b-&gt;[1] &#125;</div><div class="line">    map  &#123; [$_, foo($_)] &#125;</div><div class="line">    @unsorted;</div></pre></td></tr></table></figure>
<p>Perl6 里，你一样可以使用施瓦茨变换，不过 Perl6 内置了一些智能方法。如果你有一个函数，它接受的参数个数是 0 或 1 ，Perl6 会自动的替你启用施瓦茨变换。</p>
<p>现在让我们来看一些例子吧。</p>
<ul>
<li>不区分大小写的排序：<br>把每个元素都改成小写，然后把数组按照小写的次序排好返回。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @sorted = @unsorted.sort: &#123; .lc &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>单词长度排序：</li>
</ul>
<p>把每个元素的单词按照从短到长排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @sorted = @unsorted.sort: &#123; .chars &#125;;</div></pre></td></tr></table></figure>
<p>或者从长到短:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @sorted = @unsorted.sort: &#123; -.chars &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>多次排序比较：</li>
</ul>
<p>你可以在 sort 代码块里放多个比较函数，sort 会注意执行直到退出。比如在单词长度的基础上，再按照 ASCII 码的顺序排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.say for @a.sort: &#123; $^a.chars, $^a &#125; ;</div></pre></td></tr></table></figure>
<p>不过，在 Rakudo 里好像运行有点问题……它只会比较长度不会比较数值，也就是说， 10 排在 2 的前面。（没关系，TMTONTDI）<br>perl6 里的 sort 本身是稳定工作的，你可以重复使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.say for @a.sort.sort: &#123; $^a.chars &#125;;</div></pre></td></tr></table></figure>
<p>不过这样 sort 有两次调用，no fashion ！所以你还可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.say for @a.sort: &#123; $^a.chars &lt;=&gt; $^b.chars || $^a leg $^b &#125;;</div></pre></td></tr></table></figure>
<p>不过这下你有两个参数了，perl6 没法自动给你启动施瓦茨变换了。<br>又或者，你可以加上一个给自然数排序的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.say for @a.sort: &#123; $^a.chars.&amp;naturally, $^a &#125;;</div></pre></td></tr></table></figure>
<p>“给自然数排序？”我好像听到你们的哭声了，“哪里有？”<br>很高兴你们这么问，现在继续解决这个问题。</p>
<ul>
<li>自然数排序</li>
</ul>
<p>标准的词法排序是按照 ASCII 次序的。先是自然数，然后是大写字母，最后是小写字母。所以人们在排序的时候经常得到这样的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">100</div><div class="line">11</div><div class="line">144th</div><div class="line">2</div><div class="line">21</div><div class="line">210</div><div class="line">3rd</div><div class="line">33rd</div><div class="line">AND</div><div class="line">ARE</div><div class="line">An</div><div class="line">Bit</div><div class="line">Can</div><div class="line">and</div><div class="line">by</div><div class="line">car</div><div class="line">d1</div><div class="line">d10</div><div class="line">d2</div></pre></td></tr></table></figure>
<p>完全正确，但是没用……尤其是对非程序员来说，更郁闷了就……<br>真正的自然排序，应该是先按数学量级排自然数，然后才是大小写字母。比如上面那个例子，应该排成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3rd</div><div class="line">11</div><div class="line">21</div><div class="line">33rd</div><div class="line">100</div><div class="line">144th</div><div class="line">210</div><div class="line">An</div><div class="line">AND</div><div class="line">and</div><div class="line">ARE</div><div class="line">Bit</div><div class="line">by</div><div class="line">Can</div><div class="line">car</div><div class="line">d1</div><div class="line">d2</div><div class="line">d10</div></pre></td></tr></table></figure>
<p>所以，我们必须的在排序的时候加上一点转换了。<br>我使用 <code>.subst</code> 方法，这是我们所熟悉的 <code>s///</code> 操作符的面向对象形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.subst(/(\d+)/, -&gt; $/ &#123; 0 ~ $0.chars.chr ~ $0 &#125;, :g)</div></pre></td></tr></table></figure>
<p>第一部分，捕获一个连续的数字，然后由 <code>-&gt;$/{}</code> 构成一个尖块，意思是：“传递匹配到 <code>$/</code> 的数组到 <code>{}</code> 代码里”。然后代码里替换成用 0 按照数量级排序的顺序联结的字符串。这个 0 是以 ASCII 字符串出现，联结在原始字符串上的。最后 <code>/g</code> 表示全局替换。<br>如果也不区分大小写，那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.lc.subst(/(\d+)/, -&gt; $/ &#123; 0 ~ $0.chars.chr ~ $0 &#125;, :g)</div></pre></td></tr></table></figure>
<p>改成子例程的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub naturally ($a) &#123;</div><div class="line">    $a.lc.subst(/(\d+)/, -&gt; $/ &#123; 0 ~ $0.chars.chr ~ $0 &#125;, :g)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看起来很不错了，不过还有点小问题，比如 THE 、 The 和 the 会按照他们在列表里的顺序返回，而不是我们预计的顺序。有个简单的解决办法，就是在转换过的元素的结尾，加上一个中断。所以最终结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub naturally ($a) &#123;</div><div class="line">    $a.lc.subst(/(\d+)/, -&gt; $/ &#123; 0 ~ $0.chars.chr ~ $0 &#125;, :g) ~ &quot;\x0&quot; ~ $a</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后你看，这个子例程只有一个参数，所以我们还可以用上施瓦茨变换了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.say for &lt;0 1 100 11 144th 2 21 210 3rd 33rd AND ARE An Bit Can and by car d1 d10 d2&gt;.sort: &#123; .&amp;naturally &#125;;</div></pre></td></tr></table></figure>
<p>或者用来给 ip 排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @ips = ((0..255).roll(4).join(&apos;.&apos;)for 0..99);</div><div class="line">    .say for @ips.sort: &#123; .&amp;naturally &#125;;</div></pre></td></tr></table></figure>
<pre><code>4.108.172.65
5.149.121.70
10.24.201.53
11.10.90.219
12.83.84.206
12.124.106.41
12.162.149.98
14.203.88.93
16.18.0.178
17.68.226.104
21.201.181.225
23.61.166.202
</code></pre><p>以及目录排序啊等等各种数字与字母的混合体~~<br>最后，圣诞快乐，排序快乐，愿施瓦茨与你同在！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[空白格]]></title>
      <url>http://ohmycloud.github.io/2015/09/18/%E7%A9%BA%E7%99%BD%E6%A0%BC/</url>
      <content type="html"><![CDATA[<h2 id="空格最少化"><a href="#空格最少化" class="headerlink" title="空格最少化"></a>空格最少化</h2><hr>
<p>在数组或散列的开括号(即下标左边的那个括号)之前不允许有空格, 参数列表的圆开括号前面也是不能有空格的. 即:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@deadbeef[$x]         # okay</div><div class="line">%monsters&#123;&apos;cookie&apos;&#125;   # okay</div><div class="line">saymewant(&apos;cookie&apos;)   # okay</div><div class="line"></div><div class="line">@a       [$b]         # WRONG</div><div class="line">%people  &#123;&apos;john&apos;&#125;     # WRONG</div><div class="line">mewant   (&apos;cookie&apos;)   # WRONG</div></pre></td></tr></table></figure>
<p>这种限制的的几个副作用之一就是条件控制结构的周围不再需要圆括号了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if $value eq $target &#123;</div><div class="line">        print &quot;Bullseye!&quot;;</div><div class="line">    &#125;</div><div class="line">while $i &lt; 10 &#123; $i++ &#125;</div></pre></td></tr></table></figure>
<p>然而, 显式的使用 <code>unspace</code> 语法仍然能够让你对齐下标和后缀操作符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">%squirrels&#123;&apos;fluffy&apos;&#125; = Squirrel.new;</div><div class="line">%monsters.&#123;&apos;cookie&apos;&#125; = Monster.new;</div><div class="line">%beatles\.&#123;&apos;ringo&apos;&#125;  = Beatle.new;</div><div class="line">%people\ .&#123;&apos;john&apos;&#125;   = Person.new;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的-polymod-方法]]></title>
      <url>http://ohmycloud.github.io/2015/09/17/Perl6%E4%B8%AD%E7%9A%84polymod%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>Perl 6 中的 .polymod 方法 - 把数字分解成分母</p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p><code>.polymod</code> 方法接受几个除数并把它的调用者分解成一份一份的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">my $seconds = 1 * 60*60*24 # days</div><div class="line">            + 3 * 60*60    # hours</div><div class="line">            + 4 * 60       # minutes</div><div class="line">            + 5;           # seconds</div><div class="line"></div><div class="line">say $seconds.polymod: 60, 60;</div><div class="line">say $seconds.polymod: 60, 60, 24;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># (5 4 27)</div><div class="line"># (5 4 3 1)</div></pre></td></tr></table></figure>
<p>这种情况下我们作为参数传递的除数是和时间相关的: 60(每分钟有多少秒)， 60(每小时有多少分钟)，和24(每天有多少小时)。从最小的单位开始， 我们一直前进到最大的单位。</p>
<p>输出和输入的除数是相匹配的 - 从最小的单位到最大的单位： 5 秒，4 分钟，3 小时和 1 天。</p>
<h2 id="手工制作"><a href="#手工制作" class="headerlink" title="手工制作"></a>手工制作</h2><p>不使用 <code>.polymod</code> 而使用一个循环来展示怎么之前的计算:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">my $seconds = 2 * 60*60*24 # days</div><div class="line">            + 3 * 60*60    # hours</div><div class="line">            + 4 * 60       # minutes</div><div class="line">            + 5;           # seconds</div><div class="line"></div><div class="line">my @pieces;</div><div class="line">for 60, 60, 24 -&gt; $divisor &#123;</div><div class="line">    @pieces.push: $seconds mod $divisor;</div><div class="line">    $seconds div= $divisor</div><div class="line">&#125;</div><div class="line">@pieces.push: $seconds;</div><div class="line"></div><div class="line">say @pieces;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># [5 4 3 2]</div></pre></td></tr></table></figure>
<h2 id="超越无限"><a href="#超越无限" class="headerlink" title="超越无限"></a>超越无限</h2><p>当除数是以惰性列表的形式传递给 <code>.polymod</code> 方法时，它会一直运行直到余数为零并不会遍历整个列表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">say 120.polymod:      10¹, 10², 10³, 10⁴, 10⁵;</div><div class="line">say 120.polymod: lazy 10¹, 10², 10³, 10⁴, 10⁵;</div><div class="line">say 120.polymod:      10¹, 10², 10³ … ∞;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># (0 12 0 0 0 0)</div><div class="line"># (0 12)</div><div class="line"># (0 12)</div></pre></td></tr></table></figure>
<p>在第一个调用中， 我们让一系列数字按 10 的幂增长。该调用的输出包含了 4 个尾部的零，因为 <code>.polymod</code> 方法计算了每个除数。在第二个调用中，我们使用 <code>lazy</code> 关键字显式地创建了一个惰性列表， 而现在我们在返回的列表中只有 2 个条目。</p>
<p>第一个除数(10)结果余数为 0，这是返回列表中的第一个条目，对于下一个除数，整除把我们的 120 变成了 12。12 除以 100 的余数为 12， 它是返回列表中的第二个条目。 现在， 12 整除 100 为 0， 它终止了 <code>.polymod</code> 的执行并给了我们两个 条目的结果。</p>
<p>在最后一个调用中，我们使用了省略号，它是一个序列操作符，用来创建一系列按 10 的幂增长的数字，但是这一次序列是无限的。因为它是惰性的，结果再一次只有 2 个元素。</p>
<h2 id="Zip-It-Lock-It-Put-It-In-The-Pocket"><a href="#Zip-It-Lock-It-Put-It-In-The-Pocket" class="headerlink" title="Zip It, Lock It, Put It In The Pocket"></a>Zip It, Lock It, Put It In The Pocket</h2><p>单独的数字很好但是对于它们所代表的单位不够具有描述性。我们来使用 Zip 元操作符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my @units  = &lt;ng μg mg g kg&gt;;</div><div class="line">my @pieces = 42_666_555_444_333.polymod: 10³ xx ∞;</div><div class="line"></div><div class="line">say @pieces Z~ @units;</div><div class="line"># OUTPUT:</div><div class="line"># (333ng 444μg 555mg 666g 42kg)</div></pre></td></tr></table></figure>
<h2 id="快速命名"><a href="#快速命名" class="headerlink" title="快速命名"></a>快速命名</h2><p>对于被调用者和除数，你不仅仅限于使用 Ints，也可以使用其它类型的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">say ⅔.polymod: ⅓;</div><div class="line"></div><div class="line">say 5.Rat.polymod: .3, .2;</div><div class="line">say 3.Rat.polymod: ⅔, ⅓;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># (0 2)</div><div class="line"># (0.2 0 80)</div><div class="line"># (0.333333 0 12)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">say 5.Num.polymod: .3, .2;</div><div class="line">say 3.Num.polymod: ⅔, ⅓;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># (0.2 0.199999999999999 79)</div><div class="line"># (0.333333333333333 2.22044604925031e-16 12)</div></pre></td></tr></table></figure>
<h2 id="使用-Number-Denominate-模块"><a href="#使用-Number-Denominate-模块" class="headerlink" title="使用 Number::Denominate 模块"></a>使用 Number::Denominate 模块</h2><p><a href="http://modules.perl6.org/repo/Number::Denominate" target="_blank" rel="external">Number::Denominate</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">use Number::Denominate;</div><div class="line"></div><div class="line">my $seconds = 1 * 60*60*24 # days</div><div class="line">            + 3 * 60*60    # hours</div><div class="line">            + 4 * 60       # minutes</div><div class="line">            + 5;           # seconds</div><div class="line"></div><div class="line">say denominate $seconds;</div><div class="line">say denominate $seconds, :set&lt;weight&gt;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 1 day, 3 hours, 4 minutes, and 5 seconds</div><div class="line"># 97 kilograms and 445 grams</div></pre></td></tr></table></figure>
<p>你还可以定义自己的单位:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say denominate 449, :units( foo =&gt; 3, &lt;bar boors&gt; =&gt; 32, &apos;ber&apos; );</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 4 foos, 2 boors, and 1 ber</div></pre></td></tr></table></figure>
<p><a href="http://perl6.party/post/Perl6-.polymod-break-up-a-number-into-denominations" target="_blank" rel="external">原文地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[日期难题]]></title>
      <url>http://ohmycloud.github.io/2015/09/15/%E6%97%A5%E6%9C%9F%E9%9A%BE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p><a href="https://www.reddit.com/r/dailyprogrammer/comments/3wshp7/20151214_challenge_245_easy_date_dilemma/" target="_blank" rel="external"> reddit 上使用 Perl 6 处理日期</a></p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><hr>
<p>下面的日期, 有些使用了  M D Y 格式, 有些使用了 Y M D 格式, 还使用了任意分隔符! 请把这些散乱的文本解析成合适的 ISO 8601  (YYYY-MM-DD) 格式化日期。</p>
<p>假设只有以 4  个数字开头的日期使用 Y M D 格式, 其它的使用 M D Y 格式。</p>
<h3 id="输入样本"><a href="#输入样本" class="headerlink" title="输入样本"></a>输入样本</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">2/13/15</div><div class="line">1-31-10</div><div class="line">5 10 2015</div><div class="line">2012 3 17</div><div class="line">2001-01-01</div><div class="line">2008/01/07</div></pre></td></tr></table></figure>
<h3 id="输出样本"><a href="#输出样本" class="headerlink" title="输出样本"></a>输出样本</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">2015-02-13</div><div class="line">2010-01-31</div><div class="line">2015-05-10</div><div class="line">2012-03-17</div><div class="line">2001-01-01</div><div class="line">2008-01-07</div></pre></td></tr></table></figure>
<h3 id="扩展挑战-中级"><a href="#扩展挑战-中级" class="headerlink" title="扩展挑战 [中级]"></a>扩展挑战 [中级]</h3><hr>
<p>使用 2014-12-24 作为相对日期的基准。</p>
<p>当添加 days(天数) 时, 要考虑到每月会有不同的天数, 忽略闰年。</p>
<p>当添加月和年时, 使用整个 units, 以至于:</p>
<p>one month before october 10 is september 10</p>
<p>one year after 2001-04-02 is 2002-04-02</p>
<p>one month after january 30 is february 28 (not march 1)</p>
<h3 id="Sally’s-inputs"><a href="#Sally’s-inputs" class="headerlink" title="Sally’s inputs:"></a>Sally’s inputs:</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">tomorrow</div><div class="line">2010-dec-7</div><div class="line">OCT 23</div><div class="line">1 week ago</div><div class="line">next Monday</div><div class="line">last sunDAY</div><div class="line">1 year ago</div><div class="line">1 month ago</div><div class="line">last week</div><div class="line">LAST MONTH</div><div class="line">10 October 2010</div><div class="line">an year ago</div><div class="line">2 years from tomoRRow</div><div class="line">1 month from 2016-01-31</div><div class="line">4 DAYS FROM today</div><div class="line">9 weeks from yesterday</div></pre></td></tr></table></figure>
<h3 id="Sally’s-expected-outputs"><a href="#Sally’s-expected-outputs" class="headerlink" title="Sally’s expected outputs:"></a>Sally’s expected outputs:</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">2014-12-25</div><div class="line">2010-12-01</div><div class="line">2014-10-23</div><div class="line">2014-12-17</div><div class="line">2014-12-29</div><div class="line">2014-12-21</div><div class="line">2013-12-24</div><div class="line">2014-11-24</div><div class="line">2014-12-15</div><div class="line">2014-11-24</div><div class="line">2010-10-10</div><div class="line">2013-12-24</div><div class="line">2016-12-25</div><div class="line">2016-02-28</div><div class="line">2014-12-28</div><div class="line">2015-02-25</div></pre></td></tr></table></figure>
<p>smls 大神给出了完整的 grammar：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">my $today = Date.new(2014, 12, 24);</div><div class="line"></div><div class="line">grammar MessyDate &#123;</div><div class="line">    rule TOP &#123;</div><div class="line">        |    &lt;date&gt;                 &#123; make $&lt;date&gt;.made &#125; # 跟在 regex 后面的花括号是闭包</div><div class="line">        | :i &lt;duration&gt; ago         &#123; make $today.earlier: |$&lt;duration&gt;.made     &#125;</div><div class="line">        | :i &lt;duration&gt; from &lt;date&gt; &#123; make $&lt;date&gt;.made.later: |$&lt;duration&gt;.made &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    rule date &#123;</div><div class="line">        | [ || &lt;month&gt; (&lt;sep&gt;?) &lt;day&gt;   [$0 &lt;year&gt;]?</div><div class="line">            || &lt;day&gt;   (&lt;sep&gt;?) &lt;month&gt; [$0 &lt;year&gt;]?</div><div class="line">            || &lt;year&gt;  (&lt;sep&gt;?) &lt;month&gt;  $0 &lt;day&gt;    ]</div><div class="line">          &#123; make Date.new: $&lt;year&gt;.made//$today.year, |$&lt;month day&gt;».made &#125;</div><div class="line"></div><div class="line">        | :i today          &#123; make $today     &#125;</div><div class="line">        | :i yesterday      &#123; make $today - 1 &#125;</div><div class="line">        | :i tomorrow       &#123; make $today + 1 &#125;</div><div class="line">        | :i last &lt;weekday&gt; &#123; make $today - ($today.day-of-week - $&lt;weekday&gt;.made) % 7 || 7 &#125;</div><div class="line">        | :i next &lt;weekday&gt; &#123; make $today + ($&lt;weekday&gt;.made - $today.day-of-week) % 7 || 7 &#125;</div><div class="line">        | :i last &lt;unit&gt;    &#123; make $today.earlier: |($&lt;unit&gt;.made =&gt; 1) &#125;</div><div class="line">        | :i next &lt;unit&gt;    &#123; make $today.later:   |($&lt;unit&gt;.made =&gt; 1) &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    rule duration &#123;</div><div class="line">        &lt;count&gt; &lt;unit&gt; &#123; make $&lt;unit&gt;.made =&gt; $&lt;count&gt;.made &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token year &#123;</div><div class="line">        | &lt;number(4)&gt;        &#123; make +$&lt;number&gt;       &#125; # &lt;number(4)&gt; 是扩展的 &lt;...&gt; 语法, 实际是方法调用</div><div class="line">        | &lt;number(2, 0..49)&gt; &#123; make 2000 + $&lt;number&gt; &#125;</div><div class="line">        | &lt;number(2, 50..*)&gt; &#123; make 1900 + $&lt;number&gt; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token month &#123;</div><div class="line">        | &lt;number(1..2, 1..12)&gt; &#123; make +$&lt;number&gt; &#125;</div><div class="line">        | :i Jan[uary]?   &#123; make  1 &#125; # [...] 是非捕获分组</div><div class="line">        | :i Feb[ruary]?  &#123; make  2 &#125;</div><div class="line">        | :i Mar[ch]?     &#123; make  3 &#125;</div><div class="line">        | :i Apr[il]?     &#123; make  4 &#125;</div><div class="line">        | :i May          &#123; make  5 &#125;</div><div class="line">        | :i Jun[e]?      &#123; make  6 &#125;</div><div class="line">        | :i Jul[y]?      &#123; make  7 &#125;</div><div class="line">        | :i Aug[ust]?    &#123; make  8 &#125;</div><div class="line">        | :i Sep[tember]? &#123; make  9 &#125;</div><div class="line">        | :i Oct[ober]?   &#123; make 10 &#125;</div><div class="line">        | :i Nov[ember]?  &#123; make 11 &#125;</div><div class="line">        | :i Dec[ember]?  &#123; make 12 &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token day &#123; &lt;number(1..2, 1..31)&gt; &#123; make +$&lt;number&gt; &#125; &#125;</div><div class="line"></div><div class="line">    token weekday &#123;</div><div class="line">        | :i Mon[day]?    &#123; make 1 &#125;</div><div class="line">        | :i Tue[sday]?   &#123; make 2 &#125;</div><div class="line">        | :i Wed[nesday]? &#123; make 3 &#125;</div><div class="line">        | :i Thu[rsday]?  &#123; make 4 &#125;</div><div class="line">        | :i Fri[day]?    &#123; make 5 &#125;</div><div class="line">        | :i Sat[urday]?  &#123; make 6 &#125;</div><div class="line">        | :i Sun[day]?    &#123; make 7 &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token sep   &#123; &lt;[-/.\h]&gt; &#125; # &lt;[...]&gt; 是 Perl 6 中的字符类</div><div class="line">    token count &#123; (&lt;[0..9]&gt;+) &#123; make +$0 &#125;  |  an? &#123; make 1 &#125; &#125;</div><div class="line">    token unit  &#123; :i (day|week|month|year) s? &#123; make $0.lc &#125; &#125;</div><div class="line"></div><div class="line">    multi token number ($digits)        &#123;  &lt;[0..9]&gt; ** &#123;$digits&#125; &#125;</div><div class="line">    multi token number ($digits, $test) &#123; (&lt;[0..9]&gt; ** &#123;$digits&#125;) &lt;?&#123; +$0 ~~ $test &#125;&gt; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for lines() &#123;</div><div class="line">    say MessyDate.parse($_).made // &quot;failed to parse &apos;$_&apos;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 grammar 中, 有两个 regex 的变体, <code>rule</code> 和 <code>token</code>。rule 默认不会回溯.  rule 与 token 的一个重要区别是, <code>rule</code> 这样的正则采取了 <code>:sigspace</code> 修饰符。 <code>rule</code> 实际上是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">regex :ratchet :sigspace &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>的简写.  ratchet 这个单词的意思是: (防倒转的)棘齿, 意思它是不能回溯的!  而 <code>:sigspace</code> 表明正则中的空白是有意义的, 而 <code>token</code> 实际上是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">regex :ratchet &#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>的简写。 所以在 token 中, 若不是显式的写上 <code>\s</code>、<code>\h</code>、<code>\n</code> 等空白符号, 其它情况下就好像空白隐身了一样, 虽然你写了, 但是编译器却视而不见。</p>
<p><code>//</code> 在左侧匹配失败时会在右侧提供一个默认值。</p>
<p><code>&lt;number(4)&gt;</code>  和 <code>&lt;number(2, 0..49)&gt;</code> 中使用了扩展了的 <code>&lt;...&gt;</code> 元语法。 标识符(例如左面的 number)后面的第一个字符决定了闭合尖括号之前剩余文本的处理。它的底层语义是函数或方法调用, 所以, 如果标识符后面的第一个字符是左圆括号, 那么它要么是方法调用, 要么是函数调用:</p>
<p><code>&lt;number(4)&gt;</code> 等价于 <code>&lt;number=&amp;number(4)&gt;</code></p>
<p><code>&lt;number(2, 0..49)&gt;</code> 等价于 <code>&lt;number=&amp;number(2, 0..49)&gt;</code></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">multi token number ($digits)        &#123;  &lt;[<span class="number">0</span>..<span class="number">9</span>]&gt; ** &#123;$digits&#125; &#125;</div><div class="line">multi token number ($digits, $test) &#123; (&lt;[<span class="number">0</span>..<span class="number">9</span>]&gt; ** &#123;$digits&#125;) &lt;?&#123; +$0 ~~ $test &#125;&gt; &#125;</div></pre></td></tr></table></figure>
<p>在扩展的 <code>&lt;...&gt;</code> 语法中, 一个前置的 <code>?{</code> 或 <code>!{</code> 标示着代码断言:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&lt;[<span class="number">0</span>..<span class="number">9</span>]&gt; ** &#123;$digits&#125;) &lt;?&#123; +$0 ~~ $test &#125;&gt;</div></pre></td></tr></table></figure></p>
<p>等价于：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&lt;[<span class="number">0</span>..<span class="number">9</span>]&gt; ** &#123;$digits&#125;) &#123; +$0 ~~ $test <span class="keyword">or</span> fail &#125;  <span class="comment"># + 强制后面的$0为数值上下文, 以匹配 $test 中的数字</span></div></pre></td></tr></table></figure></p>
<p>上面的两句代码, 具名 <code>regex</code>, <code>token</code>, 或 <code>rule</code> 是一个子例程, 所以可以传递 参数给具名 token。</p>
<p>这从标准输入里读取散乱的日期并把对应的 ISO 日期写到标准输出。</p>
<p>它能解析任务描述中的所有日期（包含扩展）, 还有 - 然而, 在它们中我得到 4 个人不同结果。请弄清它们是否是错误的, 并且为什么是错的:</p>
<hr>
<p>2010-dec-7 –&gt; 我得到  2010-12-07 而不是 2010-12-01</p>
<p>last week –&gt; 我得到 2014-12-17 而不是 2014-12-15</p>
<p>1 month from 2016-01-31 –&gt; 我得到  2016-02-29 而不是 2016-02-28</p>
<p>9 weeks from yesterday –&gt; 我得到  2015-02-24 而不是 2015-02-25</p>
<p>有人在评论中问他 <code>make/made</code> 是类中的方法吗？</p>
<p>是的, 它们是 Match 类的方法。</p>
<h3 id="Match-objects-注意-object-是复数"><a href="#Match-objects-注意-object-是复数" class="headerlink" title="Match objects(注意 object 是复数)"></a>Match objects(注意 object 是复数)</h3><hr>
<p>每个 regex match(并且通过扩展, 每个 grammar token match)的结果被表示为一个 Match 对象。</p>
<p>通过这个对象你能访问各种信息片段:</p>
<ul>
<li><p>匹配到的字符串</p>
</li>
<li><p>关于输入字符串匹配的开始和结束位置</p>
</li>
<li><p>每个位置捕获和具名捕获的sub-matches</p>
</li>
<li><p>与这个匹配有关的 AST 片段, 如果有的话</p>
<h3 id="AST-片段"><a href="#AST-片段" class="headerlink" title="AST 片段"></a>AST 片段</h3></li>
</ul>
<p>Calling make inside a token/rule, sets the “AST fragment” that will be associated with the current match. Then later, you can get at that associated data by calling .made on the resulting Match object.</p>
<p>在 <code>token/rule</code> 里面调用 <code>make</code>, 设置将会与当前匹配关联的 “AST  片段”。然后, 你可以通过在当前结果 Match 对象身上调用 <code>.made</code> 方法来获取那个关联数据。</p>
<p>This is really just a free-form slot that allows you to store anything you want with the Match object and retrieve it later, though of course it is meant for building an AST like I do here.</p>
<p>这正是自由形式的插槽, 允许你使用 Match 对象存储任何你想要的东西并在以后检索它, 尽管显而易见这意味着像我那样创建一个 AST。</p>
<h3 id="在-grammar-中创建-“AST”"><a href="#在-grammar-中创建-“AST”" class="headerlink" title="在 grammar 中创建 “AST”"></a>在 grammar 中创建 “AST”</h3><hr>
<p>Each token/rule in my grammar uses .made to retrieve the pieces of data that its sub-rule matches have made, combines them into a larger piece of data, and make’s it for its own parent rule to retrieve. And so on.</p>
<p>在我的 grammar 中每个 <code>token/rule</code> 使用 <code>.made</code> 来取得它的 sub-rule 匹配构建的数据片段, 把它们组合成一个更大的数据片段, 这是为了让它的 parent rule 能检索。等等。</p>
<p>我在每个 token/rule 里面使用这些语法简写来引用 sub-matches 的 Match 对象:</p>
<ul>
<li>$0 引用 sub-match（由一个 () 捕获组引起） 的第一个位置处的 Match 对象。refers to the Match object of the first positional sub-match (caused by a ( ) capture group).</li>
<li>$<date> 引用一个名字为 “date” 的具名 sub-match 的 Match 对象() refers to the Match object of the named sub-match “date” (通过 <code>&lt;date&gt;</code> 递归引用 名为 date 的 token 引起).</date></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的正则表达式(四)]]></title>
      <url>http://ohmycloud.github.io/2015/09/11/Perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%9B%9B/</url>
      <content type="html"><![CDATA[<h1 id="最长-token-匹配"><a href="#最长-token-匹配" class="headerlink" title="最长 token 匹配"></a>最长 token 匹配</h1><p>注意，下面进入糟糕区域，如果看不懂请查看英文原文!</p>
<p><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/longest-alternative.t#L53-L460" target="_blank" rel="external"><code>S05-metasyntax/longest-alternative.t lines 53–460</code></a></p>
<p>因为 “longest-token matching” 是一个很长的短语, 我们会经常将这个概念叫做 <code>LTM</code>.  这个基本的概念就是人们在头脑中倾向于怎么去解析文本, 所以计算机应该像人一样尝试做同样的事情. 而使用 <code>LTM</code> 解析文本就是关于计算机怎样决定匹配一组备选分支中的哪一个备选分支的.</p>
<p>在 Perl 6 中, <code>|</code> 代表使用声明性的 longest-token 语义的逻辑备选分支.(你现在能使用 <code>||</code> 来标示旧的暂存的备选分支. 就是, <code>|</code> 和 <code>||</code> 现在在正则语法内的运作方式和在正则语法外的运作方式很像,  在正则语法外部, <code>|</code> 和 <code>||</code> 代表 junctional 和 短路的 <code>OR</code>. 这也包括事实上 <code>|</code> 的优先级比 <code>||</code> 的优先级高.)</p>
<p>在过去, Perl 中正则表达式是通过一个能回溯的 NFA 算法来处理的. 这很强大, 但是很多解析器通过并行地处理 rules , 而不是一个接着一个地处理, 工作起来更高效, 至少达到某种程度. 如果你看一下像 yacc grammar 这样的东西, 你会发现很多 pattern/action 声明, 其中的 patterns 被认为是并行的,  并且最终由 grammar 决定触发哪个 action. 虽然默认的Perl 解析角度是从上至下的(或许使用一个中间层的从下至上角度来处理操作符优先级), 这对用户理解 token 处理进行确定性很有用。所以, 为了 regex 匹配的意图, 我们把 tokens 模式定义为那些不含潜在副作用或自引用的能被匹配的模式。(因为空格在行转换时经常有副作用, 所以通常被这样的模式排除, 给予或采取一点向前查看。) 基本上, Perl 自动地从 grammar 中派生出一个词法分析程序, 而不需要你自己写一个。</p>
<p>为此, Perl 6 中的每个 regex 被要求能把它的纯模式和它的 actions 区分开, 并返回它的初始 token 模式的列表(包含由regex 的纯部分调用的 subrule 的 token 模式, 但是不包含多于一次的 subrule, 因为那可能会引起自引用, 这在传统正则表达式中是不被允许的。) 一个使用<code>|</code>的逻辑备选分支接收两个或多个这种列表并分发给匹配最长 token 前缀的备选分支。出现在第一位的可能是也可能不是那个备选分支。</p>
<p>然而, 如果两个备选分支以同样的长度匹配, 绑定首先由特异性打破。 以最长的固定字符串开头的备选分支胜出; 即一个精确的匹配被看作是比使用字符类更接近. 如果它不起作用, 绑定会由两个方法中的一个破坏. 如果备选分支在不同的 grammars 中, 那么标准的 MRO(方法解析顺序)决定首先尝试哪一个. 如果备选分支在同一个 grammar 文件中, 本文出现的更早的备选分支取得优先权. (如果一个 grammar 的 rules 被定义在不止一个文件中, 那么顺序是未定义的, 则必须使用一个显式的断言用于强制失败, 如果首先尝试错误的那个的话)</p>
<p>这个长的标记前缀大致相当于“令牌”在其他分析系统使用一个词法分析器的概念，但对于Perl这很大程度上是自动从语法定义一个偶然现象。然而，尽管是自动计算的，这一套标记可以由用户修改；各种内构造正则表达式的语法来告诉引擎，这是完成图案的部分开始的副作用，所以将这种构建用户控件被认为是象征性的，什么是不。被视为终止一个令牌声明并启动“行动”部分的结构的结构包括：<br>这种最长 token 前缀大致相当于在其它解析系统中使用词法解析程序的 “token” 标记, 但对于 Perl 这很大程度上是从 grammar 定义中派生的附带现象。然而，尽管是自动计算的, 这套 tokens 可以由用户修改; regex 中的各种结构声明性的告诉 grammar 引擎, 模式部分结束, 并开始进入副作用, 所以通过插入这样的结构, 用户控制什么是 token, 什么不是。终止 token 声明并开始模式的 “action” 部分的结构包括:</p>
<ul>
<li>任何 :: 或 ::: 回溯控制 (而不是e : 肯定修饰符).</li>
<li>任何带有节俭匹配(使用 <code>?</code>修饰符)量词化的原子。</li>
<li>任何 <code>{...}</code> action, 但不是含有闭包的断言。(空的闭包 <code>{}</code> 通常用于显式地终止模式的 pure 部分。) 一般的 <code>**{...}</code> 量词形式的闭包也会终止最长 token, 但是无闭包形式的量词不会。</li>
</ul>
<ul>
<li>任何诸如 <code>||</code> 或 <code>&amp;&amp;</code> 按次序的控制流操作符.</li>
<li>作为前一点的结果，因为标准的 grammar 规则使用 <code>||</code> 定义空格, 最长的token 也由那 <em>可能</em> 使用那个规则匹配空格的 regex 或 rule 的任意部分终止, 包括通过 <code>:sigspace</code>隐式匹配的空格。（然而，token 声明明确允许通过在 token 中使用诸如 <code>\h+</code> 或其它字符类这种低级原语来识别空格）</li>
<li>Subpatterns（捕获）不终止token模式，但可能需要重新解析 token以找到Subpatterns的位置。同样地，在确定最长token之后断言可能需要被检查。（或者, 如果以任何一种方式模仿了 DFA 语义, 例如, 使用汤普森的NFA，可能可以知道什么时候触发断言而不使用backchecks。）</li>
</ul>
<p>贪婪量词和字符类不会终止 token 模式。 诸如单词边界的零宽断言也不会。</p>
<p>因为这种断言可以是 token 的一部分, 词法分析程序引擎必须能从这种断言的失败中恢复, 并回溯到下一个最佳 token 候选者, 它可能等长或更短, 但是绝对不会当前候选者更长。</p>
<p>对于含有诸如 <code>&lt;?foo&gt;</code> 或 <code>&lt;?before \s&gt;</code> 这样的正向向前查看的模式, 这种断言会被认为比随后的模式更特殊, 所以向前查看的模式被当作最长 token 的最后一部分; 最长 token 匹配器会足够智能地把额外的 bit 当作是零宽的, 即, 重新匹配任何由向前查看遍历到的文本,当它(如果)继续匹配的时候。(实际上, 如果整个向前查看足够纯粹地参与 LTM, 再匹配可能仅仅优化掉 rematching, 因为向前查看已经在 LTM 引擎中匹配过了)</p>
<p>然而, 对于包含诸如 <code>&lt;!foo&gt;</code> 或 <code>&lt;!before \s&gt;</code> 这种否定向前查看断言的模式, 反面的才是真: 随后的模式被认为比该断言更特殊。所以 LTM 完全忽略了否定向前查看, 并继续从跟在否定向前查看后面的任何东西中查找纯粹模式。你可能会说, 正向向前查看对 LTM 是不透明的, 否地向前查看对 LTM 是透明的。 结论是,如果你想写一个对 LTM 是透明的正向向前查看, 你可以使用两个感叹号的否定: <code>&lt;!!foo&gt;</code> 来标示它。(优化器能自由地移除双否定, 但是不是透明性)。</p>
<p>奇怪的是，这 <code>令牌</code> 关键词具体不确定一个令牌的范围，除了一个令牌模式通常不匹配的空白，而空白是终止令牌的典型方式。<br>很奇怪, <code>token</code> 关键字不确定 token 的作用域, 除了作为一个 token 模式通常不做很多的空格匹配情况之外, 空格是终止 tokens 的原型方式。</p>
<p>初始token匹配器必须把区分大小写考虑在内（或任何其他规范化原语）并做正确的事, 即使传播到不具有相同的规范化的 rules 时。也就是说，它们必须继续代表较低规则能匹配的一组匹配。</p>
<p><code>||</code> 形式有旧的短路语义，而不会试图匹配其右侧, 除非它的左侧耗尽了所有的可能性（包括所有 <code>|</code> 可能性）。regex 中的第一个 <code>||</code> 让它左侧的 token 模式能从外部的最长 token 匹配器中访问,  但从最长 token 匹配隐藏的任何后续的测试。每一个 <code>||</code>建立了一个新的最长 token匹配器。那就是, 如果你在 <code>||</code> 右侧使用 <code>|</code>，那么右侧为最长 token 处理这子表达式和任何被调用的 subrules建立了一个新的顶级作用域处理这个子表达式和任何所谓的规则。右边的最长 token 自动机是对于左侧的 <code>||</code> 或外部的含有 <code>||</code> 的 regex是不可见的。</p>
<p>大西瓜啊，翻译的狗屎一样，惨不忍睹！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-Weekly(一)]]></title>
      <url>http://ohmycloud.github.io/2015/09/11/Perl-6-Weekly-%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>1、<a href="http://stackoverflow.com/questions/30264548/how-do-i-check-file-timestamp-attributes-in-perl-6" target="_blank" rel="external">在 Perl 6 中怎样检查文件的时间戳属性？</a></p>
<p>在 Perl 6 中怎样检查文件的时间戳属性？ 在 Perl 5 中是使用文件测试操作符  <a href="http://perldoc.perl.org/functions/-X.html" target="_blank" rel="external">file test operators </a>, 在 Perl 6 中是使用来自于 <a href="http://doc.perl6.org/type/IO::FileTestable" target="_blank" rel="external"><code>IO::FileTestable</code> role</a> 的方法 (e.g. <code>.modified</code>, <code>.accessed</code> and <code>.changed</code>) 。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $filename = &quot;sample.txt&quot;;</div><div class="line">my $seconds_since_epoch = $filename.IO.accessed;</div><div class="line">my $readable_timestamp  = DateTime.new($filename.IO.accessed);</div><div class="line"></div><div class="line">say &quot;File &apos;$filename&apos; was last accessed at &apos;$readable_timestamp&apos;, which is &#123;$seconds_since_epoch.Num&#125; seconds since the epoch&quot;;</div></pre></td></tr></table></figure>
<p>2、我正尝试生成包含 10 个随机随机序列的 <a href="https://en.wikipedia.org/wiki/FASTQ_format" target="_blank" rel="external">FASTQ 文件</a>， 序列由随机品质分数构成。我原来是使用下面的代码，它工作良好:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">my @seq  = (rand_fa_seq() for ^10);</div><div class="line">my @qual = (rand_qual()   for ^10);</div><div class="line"></div><div class="line">@seq.perl.say;</div><div class="line">@qual.perl.say;</div><div class="line"></div><div class="line">sub rand_fa_seq</div><div class="line">&#123;</div><div class="line">    return join(&quot;&quot;, roll(20,&quot;ACGT&quot;.comb));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">sub rand_qual</div><div class="line">&#123;</div><div class="line">    return join(&quot;&quot;, roll(20,&quot;EFGHIJ&quot;.comb))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub rand-fa-seq($n = 20) &#123; &lt;A C G T&gt;.roll($n).join &#125;</div><div class="line">sub rand-qual($n = 20)   &#123; &lt;E F G H I J&gt;.roll($n).join &#125;</div><div class="line"></div><div class="line">my @seq  = rand-fa-seq() xx 10;</div><div class="line">my @qual = rand-qual() xx 10;</div></pre></td></tr></table></figure>
<p>3、<a href="http://stackoverflow.com/questions/30414206/list-of-non-squares-using-list-comprehension-in-perl-6" target="_blank" rel="external">在 Perl 6 中使用 “列表解析” 生成非平方数列表</a></p>
<p>在 Perl 6 中我怎样使用 “列表解析” 创建一组非平方数? 我在  <a href="http://rosettacode.org/wiki/Sequence_of_Non-squares#Perl_6" target="_blank" rel="external">Rosetta Code</a>  那儿看到了如何打印一组非平方数的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub nth_term (Int $n) &#123; $n + round sqrt $n &#125;</div><div class="line"></div><div class="line">say nth_term $_ for 1 .. 22;</div></pre></td></tr></table></figure>
<p>目前为止我看到的最接近的东西是使用  <code>for</code> 关键字。 但是因为这实际上仅仅是一个内联（inline）循环，我认为这从技术上来讲并不是列表解析，尽管它看起来相似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @y = ($_**2 + 1 for 1 .. 10);</div></pre></td></tr></table></figure>
<p>但是，我真正想知道是否有一种 “列表解析 “ 的方法来创建可在数学上描述的诸如非平方数的列表。这儿有一个我用来创建一组非平方数的方法（直到 30）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @non_squares = grep &#123;sqrt($_) != floor(sqrt($_))&#125;, 1 .. 30;</div></pre></td></tr></table></figure>
<p>我怎样用列表解析来实现它呢？</p>
<p>实际上， 你的例子  <code>my @y = ($_**2 + 1 for 1 .. 10);</code>  是 Perl 6 方式写成的列表解析。你还可以添加一个条件测试， 就像 <a href="http://design.perl6.org/S04.html#Loop_statements" target="_blank" rel="external">Perl 6 design document S04</a> 中建议的那样：</p>
<blockquote>
<p>为了轻松地书写列表解析， 循环语句修饰符允许包含单个条件语句修饰符：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub odd(Int $n) &#123;return $n % 2&#125;</div><div class="line">@evens = ($_ * 2 if .&amp;odd for 0..100);</div></pre></td></tr></table></figure>
<p>这个就是怎样写一个 Perl 6 列表解析的非平方数（直到 30）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @non_squares = ($_ if .sqrt != .sqrt.Int for 1 .. 30);</div></pre></td></tr></table></figure>
<hr>
<p>一丢丢解释：在每次 for 循环迭代中， 从 1 到 30 这个范围中的当前数字会被赋值给默认变量 <code>$_</code>（等价于 it）。没有调用者的方法调用会默认在 “it” 身上调用（例如 <code>.sqrt</code> 等价于 <code>$_.sqrt</code>）。 所以，对于 1到30中的每一个数字，它的平方根被检查以查看它是否有非整数平方根。 如果是真， 那它就被包含在列表中。</p>
<p>4、<a href="http://stackoverflow.com/questions/30982697/print-and-colon-in-perl-6" target="_blank" rel="external">Perl 6 中的 Print 函数和冒号</a></p>
<p>我想知道在 Perl 6 中冒号与方法和函数调用有什么关系。</p>
<p>我在 <a href="https://github.com/perl6/roast/blob/master/S32-io/copy.t" target="_blank" rel="external">Perl6 spec test (S32-io)</a> 中看到了这个(我添加了注释):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fh.print: &quot;0123456789A&quot;;   # prints &apos;0123456789A&apos; to the file</div></pre></td></tr></table></figure>
<p>据我所知，这等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fh.print(&quot;0123456789A&quot;);   # prints &apos;0123456789A&apos; to the file</div></pre></td></tr></table></figure>
<p>这两种方式看起来都接收多个参数而且展平列表也没问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$fh.print: &quot;012&quot;, &quot;345&quot;, &quot;6789A&quot;;   # prints &apos;0123456789A&apos; to the file</div><div class="line">$fh.print(&quot;012&quot;, &quot;345&quot;, &quot;6789A&quot;);   # prints &apos;0123456789A&apos; to the file</div><div class="line"></div><div class="line">my @a = &lt;012 345 6789A&gt;;</div><div class="line"></div><div class="line">$fh.print(@a);   # prints &apos;0123456789A&apos; to the file</div><div class="line">$fh.print: @a;   # prints &apos;0123456789A&apos; to the file</div></pre></td></tr></table></figure>
<p>存在这两种语法一定有某种原因。 使用这种或另一种语法有某种理由吗？</p>
<p>我还注意到，当作为方法使用时， 我们不得不使用带有 <code>:</code> 或 <code>()</code>的 print：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$fh.print(@a);   # Works</div><div class="line">$fh.print: @a;   # Works!</div><div class="line">$fh.print @a;    # ERROR!</div></pre></td></tr></table></figure>
<p>当使用带冒号的 print 函数时，还有一些有意思的行为。 在这种情况下, ： 和 () 不等价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">print @a;  # Prints &apos;0123456789A&apos; (no newline, just like Perl 5)</div><div class="line">print(@a); # Ditto</div><div class="line">print: @a; # Prints &apos;012 345 6789A&apos; followed by a newline (at least in REPL)</div><div class="line"></div><div class="line">print  @a, @a; # Error (Two terms in a row)</div><div class="line">print: @a, @a; # Prints &apos;012 345 6789A 012 345 6789A&apos; followed by a newline (in REPL)</div></pre></td></tr></table></figure>
<p>然后我尝试在脚本文件中使用print。这对于打印到标准输出有效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print @a;</div></pre></td></tr></table></figure>
<p>然而， 这不会打印到标准输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print: @a, @a;</div></pre></td></tr></table></figure>
<p>但是方法版本的工作良好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fh.print: @a, @a; # Prints &apos;0123456789A0123456789A&apos; to the file</div></pre></td></tr></table></figure>
<p>我感觉我已经理解了这个， 但是不能用语言表达出来。有人可以解释下使用 print 的这些变化吗。 还有， 这些行为会因为  Great List Refactor 而改变吗？</p>
<hr>
<p>Answer：</p>
<p>使用冒号代替圆括号的一个主要原因是通过移除一组圆括号，它能使代码更清晰。在其它方面它们真的一样。</p>
<p>当你使用 <code>print: @a</code> ， 那你真正在做的就是在行上放置一个标签， 并让 @a 落进去（fall-through）。这在 REPL 中会调用带有值的 say 方法。</p>
<p>如果你没有在方法调用中使用括号或冒号，， 那么方法会以无参数方式调用。</p>
<hr>
<p>你可以交换方法的顺序，还有调用者，如果你使用冒号的话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $*ERR: &apos;hello world&apos;; # $*ERR.say(&apos;hello world&apos;)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>我刚刚确认了， 就像你说的， <code>print: @a</code> 就是 <code>label: @a</code>,   <code>label</code> 可以是任何东西. – <a href="http://stackoverflow.com/users/215487/christopher-bottoms" target="_blank" rel="external">Christopher Bottoms</a> <a href="http://stackoverflow.com/questions/30982697/print-and-colon-in-perl-6#comment50169331_30988281" target="_blank" rel="external">Jun 26 at 14:12</a></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>换句话说，冒号能代替方法调用的圆括号，但不能代替子例程调用。 – <a href="http://stackoverflow.com/users/215487/christopher-bottoms" target="_blank" rel="external">Christopher Bottoms</a> <a href="http://stackoverflow.com/questions/30982697/print-and-colon-in-perl-6#comment50169347_30988281" target="_blank" rel="external">Jun 26 at 14:12</a></td>
</tr>
</tbody>
</table>
<p>5、<a href="http://stackoverflow.com/questions/31745631/sorting-hash-kv-pairs" target="_blank" rel="external">排序散列键值对儿</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my %hash =</div><div class="line">    two   =&gt; 2,</div><div class="line">    three =&gt; 3,</div><div class="line">    one   =&gt; 1,</div><div class="line">;</div><div class="line"></div><div class="line">for %hash.sort(*.key)».kv -&gt; ($key, $value) &#123;</div><div class="line">    say &quot;&apos;$key&apos; =&gt; &apos;$value&apos;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>%hash.sort({.key})».kv</code> 和上面的  <code>sort</code> 等价吗?</p>
<p>为什么这个 sort 没有 hyper <code>»</code>  提示就不会工作?</p>
<hr>
<p>这个 <a href="http://doc.perl6.org/routine/sort" target="_blank" rel="external"><code>sort</code></a>方法返回一个 <a href="http://doc.perl6.org/type/Pair" target="_blank" rel="external">Pairs</a> 的列表。</p>
<p>因为在列表身上调用  <a href="http://doc.perl6.org/routine/kv" target="_blank" rel="external"><code>.kv</code></a> 会返回一个索引, Pair 列表, 这不是你想要的; 你不能单单在列表身上调用   <a href="http://doc.perl6.org/routine/kv" target="_blank" rel="external"><code>.kv</code></a> 。所以你必须通过在每个 Pair 身上调用 .kv 方法分别从列表中的   <a href="http://doc.perl6.org/type/Pair" target="_blank" rel="external">Pair</a> 中取出键和值, 这正是 ».kv 所做的。</p>
<p>你还可以使用 <a href="http://doc.perl6.org/routine/map" target="_blank" rel="external"><code>.map(*.kv)</code></a> 代替。</p>
<p><code>».kv</code> 语法允许把工作展开到多个线程中执行, 如果那样做有意义的话。</p>
<p>(当前的 Rakudo仅以半随机的顺序工， 以防止人们错误地使用该特性 )</p>
<hr>
<p>通过在签名中使用副词以提取属性， 这是另一种 loop 写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for %hash.sort -&gt; (:$key, :$value) &#123;</div><div class="line">  say &quot;&apos;$key&apos; =&gt; &apos;$value&apos;&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for %hash.sort -&gt; $pair (:$key, :$value) &#123;</div><div class="line">  say $pair;</div><div class="line">  say $key === $pair.key and $value === $pair.value; # True␤</div><div class="line">&#125;</div><div class="line"></div><div class="line"># :$key is short for :key($key)</div><div class="line">for %hash.sort -&gt; (:key($k), :value($v)) &#123;</div><div class="line">  say &quot;&apos;$k&apos; =&gt; &apos;$v&apos;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这对其它没有方法创建一组它们公用属性的对象有用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class C &#123; has $.a; has $.b; has $.c; has $!private-value &#125;</div><div class="line">my $c = 5;</div><div class="line">my $obj = C.new(:a&lt;A&gt;,:b(1),:$c);</div><div class="line"></div><div class="line">given $obj -&gt; ( :$a, :b($b), :$c) ) &#123;</div><div class="line">  say &quot;$a $b $c&quot;;   # A 1 5</div><div class="line">&#125;</div><div class="line"></div><div class="line"># ignore $.a by using an unnamed scalar</div><div class="line">given $obj -&gt; ( :a($), :$b, :$c ) &#123; ... &#125;</div><div class="line"></div><div class="line"># places any unspecified public attributes in %others</div><div class="line">given $obj -&gt; ( :$a, :$b, *%others ) &#123;</div><div class="line">  .say for keys %others; # c␤</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 忽略任何未指定的属性</div><div class="line"># useful to allow subclasses to add more attributes</div><div class="line"># 或仅仅丢弃掉任何你不关心的值</div><div class="line">given $obj -&gt; ( :$a, :$b, *% ) &#123; ... &#125;</div><div class="line"></div><div class="line"># 失败，因为它没有处理公用的 c 属性</div><div class="line"># in the sub-signature</div><div class="line">given $obj -&gt; ( :$a, :$b ) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>关于签名能做什么，那只是开始。</p>
<p>所有下面的，在子例程和方法签名中都是被允许的，非强制性的， 对于这个例子杀伤力过大。这在 multi subs 和 multi methods 中对于限制可能的候选者真的很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">for &apos;one&apos; =&gt; 1, 1/3</div><div class="line">-&gt;</div><div class="line">  # Type is an alias to the object type</div><div class="line">  ::Type Any $_ # Any is the default type requirement</div><div class="line"></div><div class="line">  # the public attributes of the object</div><div class="line">  (</div><div class="line">    ::A-Type Any :key(   :numerator(   $a ) ),</div><div class="line">    ::B-Type Any :value( :denominator( $b ) ) where $b &gt;= 1,</div><div class="line">  )</div><div class="line">&#123;</div><div class="line">  my Type $obj = $_; # new variable declared as having the same type</div><div class="line">  my A-Type $new-a = $a;</div><div class="line">  my B-Type $new-b = $b;</div><div class="line"></div><div class="line">  # could have used $_.^name or .^name instead of Type.^name</div><div class="line">  # so you don&apos;t actually have to add the alias to the signature</div><div class="line">  # to get the name of the arguments type</div><div class="line">  say Type.^name, &apos; &apos;, $_;</div><div class="line">  say &apos;  &apos;, A-Type.^name, &apos; &apos;, $a;</div><div class="line">  say &apos;  &apos;, B-Type.^name, &apos; &apos;, $b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Pair one =&gt; 1</div><div class="line">  Str one</div><div class="line">  Int 1</div><div class="line">Rat 0.333333</div><div class="line">  Int 1</div><div class="line">  Int 3</div></pre></td></tr></table></figure>
<hr>
<p>至于使用  <a href="http://doc.perl6.org/routine/sort" target="_blank" rel="external"><code>.sort({.key})</code></a>, 恩, 那从根本上来说是同一个东西, 因为 <a href="http://doc.perl6.org/routine/sort" target="_blank" rel="external"><code>sort</code></a>  在那儿接受任何 <a href="http://doc.perl6.org/type/Callable" target="_blank" rel="external">Callable</a> </p>
<p>我要指出, 你甚至不需要为 <a href="http://doc.perl6.org/routine/sort" target="_blank" rel="external"><code>sort</code></a>  提供参数, 因为它默认比你给它的东西智能。</p>
<p>Perl 6 有很多创建和访问 <a href="http://doc.perl6.org/type/Callable" target="_blank" rel="external">Callable</a>  东西的方式。所以任何下面一种都可以工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">*.key</div><div class="line">&#123; .key &#125; # &#123; $_.key &#125;</div><div class="line">-&gt; $_ &#123; .key &#125; # basically what the previous line turns into</div><div class="line">&#123; $^placeholder-var.key &#125;</div><div class="line">sub ($_) &#123; .key &#125;</div><div class="line">&amp;a-subroutine-reference # you would have to create the subroutine though</div></pre></td></tr></table></figure>
<p>还有， 因为所有普通的操作符实际上都是子例程，你可以在需要  <a href="http://doc.perl6.org/type/Callable" target="_blank" rel="external">Callable</a> 的其它地方使用它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&amp;infix:&lt;+&gt; # the subroutines responsible for the numeric addition operator</div><div class="line">&amp;[+] # ditto</div><div class="line"></div><div class="line">&amp;prefix:&lt;++&gt;</div><div class="line">&amp;postfix:&lt;++&gt;</div><div class="line"></div><div class="line"># etc</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的操作符(一)]]></title>
      <url>http://ohmycloud.github.io/2015/08/31/Perl6%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6-%E4%B8%80/</url>
      <content type="html"><![CDATA[<h1 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h1><p><a href="https://github.com/perl6/roast/blob/master/S03-operators/arith.t#L46-L342" target="_blank" rel="external">S03-operators/arith.t lines 46–342</a></p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-operators/precedence.t#L5-L200" target="_blank" rel="external">S03-operators/precedence.t  lines 5–200</a></p>
<p>Perl 6 拥有和 Perl 5 同等数量的优先级级别，但是它们散布在不同的地方。这儿，我们列出了从最紧凑到最松散的级别，每一级别还有几个例子：</p>
<p>最高优先级到最低优先级：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">A  Level             Examples</div><div class="line">=  =====             ========</div><div class="line">N  Terms             42 3.14 &quot;eek&quot; qq[&quot;foo&quot;] $x :!verbose @$array</div><div class="line">L  Method postfix    .meth .+ .? .* .() .[] .&#123;&#125; .&lt;&gt; .«» .:: .= .^ .:</div><div class="line">N  Autoincrement     ++ --</div><div class="line">R  Exponentiation    **</div><div class="line">L  Symbolic unary    ! + - ~ ? | || +^ ~^ ?^ ^</div><div class="line">L  Multiplicative    * / % %% +&amp; +&lt; +&gt; ~&amp; ~&lt; ~&gt; ?&amp; div mod gcd lcm</div><div class="line">L  Additive          + - +| +^ ~| ~^ ?| ?^</div><div class="line">L  Replication       x xx</div><div class="line">X  Concatenation     ~</div><div class="line">X  Junctive and      &amp; (&amp;) ∩</div><div class="line">X  Junctive or       | ^ (|) (^) ∪ (-)</div><div class="line">L  Named unary       temp let</div><div class="line">N  Structural infix  but does &lt;=&gt; leg cmp .. ..^ ^.. ^..^</div><div class="line">C  Chaining infix    != == &lt; &lt;= &gt; &gt;= eq ne lt le gt ge ~~ === eqv !eqv (&lt;) (elem)</div><div class="line">X  Tight and         &amp;&amp;</div><div class="line">X  Tight or          || ^^ // min max</div><div class="line">R  Conditional       ?? !! ff fff</div><div class="line">R  Item assignment   = =&gt; += -= **= xx= .=</div><div class="line">L  Loose unary       so not</div><div class="line">X  Comma operator    , :</div><div class="line">X  List infix        Z minmax X X~ X* Xeqv ...</div><div class="line">R  List prefix       print push say die map substr ... [+] [*] any Z=</div><div class="line">X  Loose and         and andthen</div><div class="line">X  Loose or          or xor orelse</div><div class="line">X  Sequencer         &lt;== ==&gt; &lt;&lt;== ==&gt;&gt;</div><div class="line">N  Terminator        ; &#123;...&#125; unless extra ) ] &#125;</div></pre></td></tr></table></figure>
<p>下面使用的两个 <code>!</code> 符号通常表示任意一对儿拥有相同优先级的操作符， 上表指定的二元操作符的结合性解释如下(其中 A 代表<strong>结合性</strong>， associativities )：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    结合性     Meaning of $a ! $b ! $c</div><div class="line">    =====     =========================</div><div class="line">L   left      ($a ! $b) ! $c</div><div class="line">R   right     $a ! ($b ! $c)</div><div class="line">N   non       ILLEGAL</div><div class="line">C   chain     ($a ! $b) and ($b ! $c)</div><div class="line">X   list      infix:&lt;!&gt;($a; $b; $c)</div></pre></td></tr></table></figure>
<p>对于一元操作符， 这解释为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    结合性     Meaning of !$a!</div><div class="line">    =====     =========================</div><div class="line">L   left      (!$a)!</div><div class="line">R   right     !($a!)</div><div class="line">N   non       ILLEGAL</div></pre></td></tr></table></figure>
<p>(在标准 Perl 中没有能利用结合性的一元操作符，因为在每一优先级级别中， 标准操作符要么一贯地是前缀，要么是后缀。)</p>
<p>注意列表结合性（X）只在同一操作符之间有效。如果两个拥有不同列表结合性的操作符拥有相同的优先级，它们彼此间就会被认为是非结合性的，必须使用圆括号来消除歧义。</p>
<p><a href="https://github.com/perl6/roast/blob/master/S03-operators/precedence.t#L211-L245" target="_blank" rel="external">S03-operators/precedence.t lines 211–245</a></p>
<p>例如， <code>X</code> 交叉操作符和 <code>Z</code> <strong>拉链操作符</strong> 都有 “list infix” 优先级，但是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@a X @b Z @c</div></pre></td></tr></table></figure>
<p>是非法的，它必须写成下面的任意一种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(@a X @b) Z @c</div><div class="line">@a X (@b Z @c)</div></pre></td></tr></table></figure>
<p>如果仅有的列表结合性操作符的实现是二进制的, 那么它会被当作是右结合性的。<br>标准的优先级层级尝试和它们的结合性相一致, 但是用户定义的操作符和优先级级别可以在同一优先级级别上混合右结合性和左结合性操作符。如果在同一个表达式中不小心使用了有冲突的操作符, 那么操作符彼此之间会被认为是非结合性的, 并且必须使用圆括号来消除歧义。</p>
<p>如果你没有在上面看见你喜欢的操作符, 下面的章节会包含所有按优先级排列的操作符。这儿描述了基本的操作符。</p>
<h4 id="Term-precedence"><a href="#Term-precedence" class="headerlink" title="Term precedence"></a>Term precedence</h4><p>这实际上不真的是优先级, 但是它在这里是因为没有操作符的优先级比 term 高. 查看 S02 获取各种 terms 的更详尽的描述. 这里有一些例子:</p>
<ul>
<li>Int 字面量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">42</div></pre></td></tr></table></figure>
<ul>
<li>Num 字面量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.14</div></pre></td></tr></table></figure>
<ul>
<li>不能插值的 Str 字面量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;$100&apos;</div></pre></td></tr></table></figure>
<ul>
<li>能插值的 Str 字面量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;Answer = $answer\n&quot;</div></pre></td></tr></table></figure>
<ul>
<li>通用的 Str 字面量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">q[&quot;$100&quot;]</div><div class="line">qq[&quot;$answer&quot;]</div></pre></td></tr></table></figure>
<ul>
<li>Heredoc</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">qq:to/END/</div><div class="line">    Dear $recipient:</div><div class="line">    Thanks!</div><div class="line">    Sincerely,</div><div class="line">    $me</div><div class="line">    END</div></pre></td></tr></table></figure>
<ul>
<li>数组构造器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[1,2,3]</div></pre></td></tr></table></figure>
<p> <code>[ ]</code> 里面提供了列表上下文. 技术上讲, 它实际上提供了一个  <code>semilist</code> 上下文, 即一系列分号分割的语句, 每条语句都在列表上下文中解释, 然后被连接成最终的列表.</p>
<ul>
<li>散列构造器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123; &#125;</div><div class="line">&#123; a =&gt; 42 &#125;</div></pre></td></tr></table></figure>
<p><code>{ }</code> 里面要么是空的, 要么是以 pair 或 散列 开头的单个列表, 否则你必须使用 <code>hash( )</code> 或 <code>%( )</code> 代替.</p>
<ul>
<li>Closure</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>如果出现在语句那儿, 会立即执行。 否则会延迟内部作用域的求值。</p>
<ul>
<li>捕获构造器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\(@a,$b,%c)</div></pre></td></tr></table></figure>
<p>代表还不知道它的上下文的参数列表的抽取,</p>
<ul>
<li>符号化变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$x</div><div class="line">@y</div><div class="line">%z</div><div class="line">$^a</div><div class="line">$?FILE</div><div class="line">&amp;func</div><div class="line">&amp;div:(Int, Int --&gt; Int)</div></pre></td></tr></table></figure>
<ul>
<li>符号作为上下文化函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$()</div><div class="line">@()</div><div class="line">%()</div><div class="line">&amp;()</div></pre></td></tr></table></figure>
<ul>
<li>quote-like 记号中的 Regexes</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/abc/</div><div class="line">rx:i[abc]</div><div class="line">s/foo/bar/</div></pre></td></tr></table></figure>
<ul>
<li>转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tr/a..z/A..Z/</div></pre></td></tr></table></figure>
<p>注意范围使用 <code>..</code> 而非 <code>-</code>.</p>
<ul>
<li>类型名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Num</div><div class="line">::Some::Package</div></pre></td></tr></table></figure>
<ul>
<li>由圆括号环绕的子表达式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(1+2)</div></pre></td></tr></table></figure>
<ul>
<li>带括号的函数调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a(1)</div></pre></td></tr></table></figure>
<p>一个项后面立即跟着一个圆括号化的表达式总是被当作函数调用，　即使那个标识符也含有前缀意义，　所以那种情况下你从来不用担心优先级。因此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">not($x) + 1         # means (not $x) + 1</div></pre></td></tr></table></figure>
<ul>
<li>Pair 构造器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:limit(5)</div><div class="line">:!verbose</div></pre></td></tr></table></figure>
<ul>
<li>签名字面量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:(Dog $self:)</div></pre></td></tr></table></figure>
<ul>
<li>使用隐式调用者的方法调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.meth       # call on $_</div><div class="line">.=meth      # modify $_</div></pre></td></tr></table></figure>
<p>注意这只能出现在需要项(term)的地方。需要后缀的地方它就是后缀。如果需要中缀操作符（即, 在项后面, 之间是空格）, .meth 就是语法错误。(.meth 形式在那儿是被允许的因为有一个和方法调用形式在语义上等价但是允许在 = 号和方法名之间于空格存在的特殊 .= 中缀赋值操作符)。</p>
<ul>
<li>Listop (leftward)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4,3, sort 2,1       # 4,3,1,2</div></pre></td></tr></table></figure>
<p>就像 Perl 5 中一样, 列表操作符对于它左侧的表达式看起来像一个项(term), 所以它比左侧的逗号绑定的紧凑点, 比右侧的逗号绑定的松散点。– 查看下面的列表前缀优先级。</p>
<h4 id="方法后缀优先级"><a href="#方法后缀优先级" class="headerlink" title="方法后缀优先级"></a>方法后缀优先级</h4><p>所有的方法后缀都以一个点开头, 尽管对于下标来说, 点号是可选的. 因为这些是最紧密的操作符,  你可以看到一系列方法调用作为单独的项, 这个项仅仅要表达一个复杂的名字.</p>
<ul>
<li>标准的单个分发方法调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$obj.meth</div></pre></td></tr></table></figure>
<ul>
<li>标准单个分发方法调用的变体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$obj.+meth</div><div class="line">$obj.?meth</div><div class="line">$obj.*meth</div></pre></td></tr></table></figure>
<p>除了普通的 <code>.</code> 方法调用之外, 还有 <code>.*</code>, <code>.?</code>, 和 <code>.+</code> 变体来控制如何处理多个同名的相关方法.</p>
<ul>
<li>类限定的方法调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$obj.::Class::meth</div><div class="line">$obj.Class::meth    # same thing, 假设预先定义了 Class</div></pre></td></tr></table></figure>
<p>就跟 Perl 5 一样, 告诉分发器(dispatcher)从哪个类开始搜索, 而不正好是那个被调用的方法。</p>
<ul>
<li>可变方法调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$obj.=meth</div></pre></td></tr></table></figure>
<p>.= 操作符执行了对左侧对象的就地修改。</p>
<ul>
<li>元方法调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$obj.^meth</div></pre></td></tr></table></figure>
<p><code>.^</code> 操作符调用了类的元方法(class metamethod); <strong>foo.^bar</strong> 是 <code>foo.HOW.bar</code> 的简写。</p>
<ul>
<li>像方法一样的后环缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$routine.()</div><div class="line">$array.[]</div><div class="line">$hash.&#123;&#125;</div><div class="line">$hash.&lt;&gt;</div><div class="line">$hash.«»</div></pre></td></tr></table></figure>
<p>不带点的这些形式有同样的优先级.</p>
<ul>
<li>带点形式的其它后缀操作符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$x.++         # postfix:&lt;++&gt;($x)</div></pre></td></tr></table></figure>
<ul>
<li>带点形式的其它前缀操作符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$x.:&lt;++&gt;       # prefix:&lt;++&gt;($x)</div></pre></td></tr></table></figure>
<ul>
<li>有一个特殊的非中缀操作符 infix:&lt;.&gt; 所以</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$foo . $bar</div></pre></td></tr></table></figure>
<p>总是会返回编译时错误来标示用户应该使用中缀操作符 infix&lt;~&gt; 代替。这用于捕获正在学习 Perl 6 的 Perl 5 程序员可能会犯的错误。</p>
<h4 id="自增优先级"><a href="#自增优先级" class="headerlink" title="自增优先级"></a>自增优先级</h4><p>就像在 C 中一样，这些操作符增加或减少正在谈论的那个对象的值，根据操作符在前面还是在后面。还是像 C 中一样，在同一个表达式中多个对单个可变对象的引用可能导致未定义行为除非显式地插入了某些序列操作符。请查看 “Sequence points”。</p>
<p>至于 Perl 6 中得所有后缀操作符，项(term) 和它的后缀之间不允许有空格。请查看 S02 来了解为什么，还有怎么使用 “unspace” 来应急这个约束。</p>
<p>和可变方法一样，所有这些操作符被分派为操作符数的类型并返回一个同类型的结果，但是只有（不可变的）值存储在可变容器中时，它们在值类型上才是合法的。然而，为了支持通用的习语，一个裸的未定义值（在一个合适的标量容器中）是被允许把自身修改成 Int 类型的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $x unless %seen&#123;$x&#125;++;</div></pre></td></tr></table></figure>
<p>Str (在一个合适的容器中)的增加和 Perl 5 类似，但是被稍微推广了一点。Perl 6 会扫描前面不是 ‘.’ 字符的字符串中得最后的字母数字序列。不像 Perl 5 那样，这个字母数字序列不需要锚定到字符串的开头，也不需要以字母数字符开头；字符串中匹配 <code>&lt;!after &#39;.&#39;&gt; &lt;rangechar&gt;+</code> 字母数字的最后的序列被增加而不管它前面是什么。</p>
<p><code>&lt;rangechar&gt;</code> 字符类被定义为那种字符的子集(subset)，Perl 知道怎么在范围(range)中增加它，就像下面定义的那样：<br>额外的匹配增加了两个好处：对于典型的增长文件名的用法，你不必担心路径名或扩展名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$file = &quot;/tmp/pix000.jpg&quot;;</div><div class="line">$file++;                 # /tmp/pix001.jpg, 不是 /tmp/pix000.jph</div></pre></td></tr></table></figure>
<p>也许更重要的是, 如果你恰好增长了一个以小数结尾的字符串，Perl 6 也能应对自如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$num = &quot;123.456&quot;;</div><div class="line">$num++;             # 124.456, not 123.457</div></pre></td></tr></table></figure>
<p>字符位置增加自然范围内任何Unicode范围被认为代表了数字0 . .9或被认为是一个完整的周期性字母的(一例)(Unicode)脚本。只在codepoints脚本,代表他们的字母表,形成一个周期独立于其他字母可能使用。(此规范延缓这种脚本的用户,以确定适当的周期的信件)。我们任意定义ASCII字母不相交与其他脚本,使用范围的字符,但是字母点缀ASCII字母是不允许的。</p>
<p>如果在这样一个范围中当前字符是字符串位置中最后的字符,它包装的第一个字符范围和发送一个“携带”的位置了,然后那个位置是增加的范围。当且仅当最左边的位置是筋疲力尽的范围,一个额外的字符相同的范围是插入到持有套利以相同的方式作为Perl 5,所以递增(zz99)“变成”(aaa00)zz和递增(99)“变成”(100 aa)”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; my $a = &quot;99zz&quot;</div><div class="line">&gt; $a++           # 99zz</div><div class="line">&gt; $a++           # 100aa</div><div class="line"></div><div class="line">&gt; my $b = &apos;zz99&apos;</div><div class="line">&gt; $b++           # zz99</div><div class="line">&gt; $b++           # aaa00</div></pre></td></tr></table></figure>
<p>下面的 Unicode  范围是某些可能的 rangechar 范围。对于字母我们有这样的范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">A..Z        # ASCII uc</div><div class="line">a..z        # ASCII lc</div><div class="line">&apos;Α&apos;..&apos;Ω&apos;    # Greek uc</div><div class="line">α..ω        # Greek lc (presumably skipping C&lt;U+03C2&gt;, final sigma)</div><div class="line">א..ת        # 希伯来</div><div class="line">  etc.      # (XXX out of my depth here)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; my @a =  &apos;Α&apos;..&apos;Ω&apos;  # Α Β Γ Δ Ε Ζ Η Θ Ι Κ Λ Μ Ν Ξ Ο Π Ρ ΢ Σ Τ Υ Φ Χ Ψ Ω</div></pre></td></tr></table></figure>
<p>对于数字我们有这样的范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0..9         # ASCII</div><div class="line">٠..٩         # 阿拉伯语-印度语</div><div class="line">०..९         # 天城文</div><div class="line">০..৯         # 孟加拉语</div><div class="line">&apos;੦&apos;..&apos;੯&apos;    # 古木基文</div><div class="line">૦..૯        # 古吉拉特文</div><div class="line">୦..୯        # 奥里亚语</div></pre></td></tr></table></figure>
<p>等等.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; my @b =    &apos;੦&apos;..&apos;੯&apos;   #  ੦ ੧ ੨ ੩ ੪ ੫ ੬ ੭ ੮ ੯</div></pre></td></tr></table></figure>
<p>某些其它非书写用的 0..9 范围也可以被增长，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">⁰..⁹        # 上标 (note, cycle includes latin-1 chars)</div><div class="line">&apos;₀&apos;..&apos;₉&apos;    # 下标</div><div class="line">０..９      # 全角数字</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; my @f = &apos;₀&apos;..&apos;₉&apos; # ₀ ₁ ₂ ₃ ₄ ₅ ₆ ₇ ₈ ₉</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ⅰ..Ⅻ        # clock roman numerals uc</div><div class="line">ⅰ..ⅻ        # clock roman numerals lc</div><div class="line">⓪..㊿       # circled digits/numbers 0..50</div><div class="line">⒜..⒵        # parenthesized lc</div><div class="line">⚀..⚅        # die faces 1..6</div><div class="line">&apos;❶&apos;..&apos;❿&apos;        # dingbat negative circled 1..10</div></pre></td></tr></table></figure>
<p>etc.</p>
<p>注意: 对于 Perl 中实际的范围， 你需要把上面的字符用引号括起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;⓪&apos;..&apos;㊿&apos;   # circled digits/numbers 0..50</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @d = &apos;⓪&apos;..&apos;⓾&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @e = &apos;❶&apos;..&apos;❿&apos; # ❶ ❷ ❸ ❹ ❺ ❻ ❼ ❽ ❾ ❿</div></pre></td></tr></table></figure>
<p>If you want to future-proof the top end of your range against further Unicode additions, you may specify it as “whatever”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;⓪&apos;..*      # circled digits/numbers up to current known Unicode max</div></pre></td></tr></table></figure>
<p>prefix:&lt;|&gt;,  将对象展开为参数列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| $capture</div></pre></td></tr></table></figure>
<p>把Capture 值的内容(或 Capture-like)插值进当前的参数列表中, 就像它们被字面地指定那样。</p>
<p>prefix:&lt;||&gt;,  将对象展开为分号列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|| $parcel</div></pre></td></tr></table></figure>
<p>把 Parcel(或其它有顺序的值)的元素插值到当前参数列表中就像它们被字面地指定一样, 由分号分割, 即, 以多维级别。在列表中的列表上下文之外使用该操作符是错误的; 换句话说, 它必须被绑定到 <code>**</code>(slice)参数上而非吞噬参数<code>*</code>上。</p>
<p>infix:<div>, 整除</div></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$numerator div $denominator</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">3</span> div <span class="number">2</span>     <span class="comment"># 1</span></div><div class="line">&gt; <span class="number">13</span> div <span class="number">2</span>    <span class="comment"># 6</span></div></pre></td></tr></table></figure>
<p>而</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">13</span> div <span class="number">2.4</span></div></pre></td></tr></table></figure>
<p>报错：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cannot call infix:&lt;div&gt;(Int, Rat); none of these signatures match:</div><div class="line">    (Int:D \a, Int:D \b)</div><div class="line">    (<span class="keyword">int</span> $a, <span class="keyword">int</span> $b --&gt; <span class="keyword">int</span>)</div><div class="line">  in block &lt;unit&gt; at &lt;unknown file&gt;:<span class="number">1</span></div></pre></td></tr></table></figure>
<p>infix:&lt;%&gt;, modulo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$x % $y</div></pre></td></tr></table></figure>
<h2 id="重复操作符"><a href="#重复操作符" class="headerlink" title="重复操作符"></a>重复操作符</h2><p>infix:<x>, 字符串/缓冲区 复制(或者重复/拷贝)</x></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$string x $count</div></pre></td></tr></table></figure>
<p>在字符串上下文中计算左边的参数，重复结果字符串值由右侧参数指定的倍数次，然后不管上下文，把结果作为单个连接好的字符串返回。</p>
<p>如果重复次数小于 1，则返回空字符串。重复次数不可以是 <code>*</code>，因为 Perl 6 不支持无穷字符串。（至少，还没有…）然而注意，有一天无穷字符串可能使用 cat(<code>$string xx *</code>) 来模仿，在这种情况下，<code>$string x *</code>  可能是它的简写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&apos;a&apos; x *;              # WhateverCode.new()</div><div class="line">my $a = &apos;a&apos; x *;      # WhateverCode.new()</div><div class="line">say $a;               # WhateverCode.new()</div><div class="line">say $a(12);           # 可以传递参数！, 结果为 aaaaaaaaaaaa</div></pre></td></tr></table></figure>
<p>infix:<xx>, 表达式重复操作符</xx></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@list xx $count  # 如果 $count  是 * ，则返回一个无限列表 （懒惰的，因为列表默认是懒惰的 ）</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rand xx *;                # infinite supply of random numbers</div><div class="line">[ 0 xx $cols ] xx $rows   # distinct arrays, not the same row replicated</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span> @random= <span class="keyword">rand</span> xx *;</div><div class="line">&gt; @random[<span class="number">0</span>]                <span class="comment"># 0.510689533871727</span></div><div class="line">&gt; @random[<span class="number">0</span>]                <span class="comment"># 0.510689533871727</span></div><div class="line">&gt; @random[<span class="number">1</span>]                <span class="comment"># 0.993102039714483</span></div><div class="line">&gt; @random[<span class="number">2</span>]                <span class="comment"># 0.177400471499773</span></div><div class="line">&gt; @random[<span class="number">12</span>]</div></pre></td></tr></table></figure>
<h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>infix:&lt;~&gt;, 字符串 /缓冲 连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$x ~ $y</div></pre></td></tr></table></figure>
<h2 id="范围对象创建"><a href="#范围对象创建" class="headerlink" title="范围对象创建"></a>范围对象创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$min .. $max</div><div class="line">$min ^.. $max</div><div class="line">$min ..^ $max</div><div class="line">$min ^..^ $max</div></pre></td></tr></table></figure>
<h2 id="逗号操作符优先级"><a href="#逗号操作符优先级" class="headerlink" title="逗号操作符优先级"></a><a href="https://desgin.perl6.org/S03.html#Comma_operator_precedence" target="_blank" rel="external">逗号操作符优先级</a></h2><ul>
<li>infix:&lt;,&gt;  参数分隔符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1, 2, 3, @many</div></pre></td></tr></table></figure>
<p>不像 Perl5 ，逗号操作符从来不返回最后一个值（在标量上下文中它返回一个列表）</p>
<ul>
<li>infix:&lt;:&gt;, 调用者标记</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> $*OUT: <span class="string">"howdy, world"</span>  <span class="comment"># howdy, world</span></div><div class="line"><span class="keyword">say</span>($*OUT: <span class="string">"howdy, world"</span>) <span class="comment"># howdy, world</span></div><div class="line"><span class="keyword">push</span> @array: <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></div><div class="line"><span class="keyword">push</span>(@array: <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">\($object: <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, :foo, :!bar)</div></pre></td></tr></table></figure>
<p>冒号操作符就像逗号那样解析，但是它把左边的参数标记为调用者，这会把函数调用转换为方法调用。它只能在参数列表或捕获的第一个参数身上使用，用在其它地方会解析失败。当用在捕获中时，尚不知道捕获会被绑定到哪个签名上；如果绑定到一个非方法的签名身上，调用者仅仅转换成第一个位置参数，就像冒号是一个逗号一样。</p>
<p>为了避免和其它的冒号形式混淆，冒号中缀操作符后面必须跟上空格或终止符。它前面可以有空格也可以没有空格。</p>
<p>注意：在下面把中缀操作符和冒号区别开:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@array.push: 1,2,3</div><div class="line">@array.push(1,2,3): 4,5,6</div><div class="line">push(@array, 1,2,3): 4,5,6</div></pre></td></tr></table></figure>
<p>这是把普通函数或方法转换为列表操作符的特殊形式。 这种特殊形式只在点语法形式的方法调用后被识别， 或者在方法或函数调用的右圆括号之后被识别。这种特殊形式不允许其间有空格，但是下一个参数的前面要有空格。如果可能的话在所有其它情况下，冒号会被解析为副词的开始，否则会被解析为调用者标记（上面描述的中缀操作符。）</p>
<p>这种特殊形式不允许介于中间的空格， 但是允许在下一个参数之前有空格。 在所有情况下， 冒号会被尽可能地解析为副词的开头，或者调用者标记者（上面描述的中缀）</p>
<p>冒号的另一种特殊方式是, 允许正好在参数列表的右侧圆括号之后为圆括号括住的参数列表添加 listop 参数，附带条件是你被允许把 <code>.foo(): 1,2,3</code> 缩短为 <code>.foo: 1,2,3</code>.(但是仅限于方法调用， 因为普通的函数不需要把处于第一个位置的冒号转换为 listop， 空格就够了。 如果你尝试使用冒号扩展函数名最好把它看作标签。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">foo $obj.bar: 1,2,3     # special, means foo($obj.bar(1,2,3))</div><div class="line">foo $obj.bar(): 1,2,3   # special, means foo($obj.bar(1,2,3))</div><div class="line">foo $obj.bar(1): 2,3    # special, means foo($obj.bar(1,2,3))</div><div class="line">foo $obj.bar(1,2): 3    # special, means foo($obj.bar(1,2,3))</div><div class="line">foo($obj.bar): 1,2,3    # special, means foo($obj.bar, 1,2,3)</div><div class="line">foo($obj.bar, 1): 2,3   # special, means foo($obj.bar, 1,2,3)</div><div class="line">foo($obj.bar, 1,2): 3   # special, means foo($obj.bar, 1,2,3)</div><div class="line">foo $obj.bar : 1,2,3    # infix:&lt;:&gt;, means $obj.bar.foo(1,2,3)</div><div class="line">foo ($obj.bar): 1,2,3   # infix:&lt;:&gt;, means $obj.bar.foo(1,2,3)</div><div class="line">foo $obj.bar:1,2,3      # 语法错误</div><div class="line">foo $obj.bar :1,2,3     # 语法错误</div><div class="line">foo $obj.bar :baz       # 副词, means foo($obj.bar(:baz))</div><div class="line">foo ($obj.bar) :baz     # 副词, means foo($obj.bar, :baz)</div><div class="line">foo $obj.bar:baz        # extended identifier, foo( $obj.&apos;bar:baz&apos; )</div><div class="line">foo $obj.infix:&lt;+&gt;      # extended identifier, foo( $obj.&apos;infix:&lt;+&gt;&apos; )</div><div class="line">foo: 1,2,3              # label at statement start, else infix</div></pre></td></tr></table></figure>
<p>这个故事的寓意是：如果你不知道冒号是怎样结合的，就使用空格或圆括号让它清晰。</p>
<ul>
<li>List infix precedence 列表中缀优先级</li>
</ul>
<p>列表中缀操作符都有列表结合性，这意味着，同一个中缀操作符是同步起作用的，而不是一个接着一个。不同的操作符被认为是非结合性的，为了明确，必须用括号括起来。</p>
<ul>
<li>infix:<z>,  the zip operator</z></li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,<span class="number">2</span> Z <span class="number">3</span>,<span class="number">4</span>   <span class="comment"># (1,3),(2,4)</span></div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span> [Zmin] <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>     <span class="comment"># 两两比较, 2 4 5</span></div><div class="line">&gt; <span class="keyword">my</span> @a=<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>            <span class="comment"># 3 6 9</span></div><div class="line">&gt; <span class="keyword">my</span> @b=<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>           <span class="comment"># 4 5 10</span></div><div class="line">&gt; @a [Zmin] @b           <span class="comment"># 3 5 9</span></div><div class="line">&gt; <span class="keyword">my</span> @a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>)    <span class="comment"># 1 2 9 3 5</span></div><div class="line">&gt; <span class="keyword">my</span> @b = (<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>)    <span class="comment"># 2 3 5 1 9</span></div><div class="line">&gt; <span class="keyword">my</span> @c = (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>)    <span class="comment"># 2 3 4 5 1</span></div><div class="line">&gt; @a [Zmin] @b [Zmin] @c <span class="comment"># 1 2 4 1 1</span></div><div class="line">&gt; @a [Zmax] @b [Zmax] @c <span class="comment"># 2 3 9 5 9</span></div></pre></td></tr></table></figure>
<ul>
<li>infix:<minmax>,  minmax 操作符</minmax></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@a minmax @b</div></pre></td></tr></table></figure>
<p>返回@a和@b中最小值和最大值的一个范围。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span> @a = <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>;</div><div class="line">&gt; <span class="keyword">my</span> @b = <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>;</div><div class="line">&gt; @a minmax @b         <span class="comment"># 1..9</span></div></pre></td></tr></table></figure>
<ul>
<li>infix:<x>,  交叉操作符</x></li>
</ul>
<p>S03-metaops/cross.t lines 6–19  </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,<span class="number">2</span> X <span class="number">3</span>,<span class="number">4</span>          <span class="comment"># (1,3), (1,4), (2,3), (2,4)</span></div></pre></td></tr></table></figure>
<p>和 zip 操作符相比， X 操作符返回元素交叉后的列表。例如，如果只有 2 个列表，第一个列表中取一个元素和第二个列表中取一个元素组成 pair 对儿，第二个元素变化的最迅速。</p>
<p>最右边的列表先遍历完。因此， 你写：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a b&gt; X &lt;<span class="number">1</span> <span class="number">2</span>&gt;</div></pre></td></tr></table></figure>
<p>你会得到：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="string">'a'</span>, <span class="string">'1'</span>), (<span class="string">'a'</span>, <span class="string">'2'</span>), (<span class="string">'b'</span>, <span class="string">'1'</span>), (<span class="string">'b'</span>, <span class="string">'2'</span>)</div></pre></td></tr></table></figure>
<p>这在平的上下文会变成一个展平的列表，在 list of list 上下文中会变成列表中的列表</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> flat(&lt;a b&gt; X &lt;<span class="number">1</span> <span class="number">2</span>&gt;).perl    <span class="comment">#  ("a", "1", "a", "2", "b", "1", "b", "2").list</span></div><div class="line"><span class="keyword">say</span> lol(&lt;a b&gt; X &lt;<span class="number">1</span> <span class="number">2</span>&gt;).perl     <span class="comment"># (("a", "1"), ("a", "2"), ("b", "1"), ("b", "2"))</span></div></pre></td></tr></table></figure>
<p>这个操作符是列表结合性的，所以：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,<span class="number">2</span> X <span class="number">3</span>,<span class="number">4</span> X <span class="number">5</span>,<span class="number">6</span></div></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>),(<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>)</div></pre></td></tr></table></figure>
<p>另一方面，如果任一列表为空，你会得到一个空列表。</p>
<p>尽管X两边的列表可能是无限的，在操作符 X的右边使用无限列表可能会产生意想不到的结果，例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a b&gt; X <span class="number">0</span>..*</div></pre></td></tr></table></figure>
<p>会产生</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="string">'a'</span>,<span class="number">0</span>), (<span class="string">'a'</span>,<span class="number">1</span>), (<span class="string">'a'</span>,<span class="number">2</span>), (<span class="string">'a'</span>,<span class="number">3</span>), (<span class="string">'a'</span>,<span class="number">4</span>), (<span class="string">'a'</span>,<span class="number">5</span>), ...</div></pre></td></tr></table></figure>
<p>并且你绝对不会到达 ‘b’。如果你左侧的列表只包含单个元素，然而，这可能有用，尤其是如果 X 用作元操作符时。看下面。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> lol(&lt;a b&gt; X &lt;<span class="number">1</span> <span class="number">2</span>&gt;).perl    <span class="comment"># ("a", "1", "a", "2", "b", "1", "b", "2")</span></div></pre></td></tr></table></figure>
<p>Cross metaoperators 交叉操作符</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@files X~ <span class="string">'.'</span> X~ @extensions</div><div class="line"><span class="number">1</span>..<span class="number">10</span> X* <span class="number">1</span>..<span class="number">10</span></div><div class="line">@x Xeqv @y</div></pre></td></tr></table></figure>
<p>等等</p>
<p>一个常见的用法是让一个列表只含有单个元素在操作符 X 的一边或另一边：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@vector X* 2;                 # 每个元素都乘以 2</div><div class="line">$prefix X~ @infinitelist;     # 在无限列表的每个元素前面前置一个元素</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">my</span> $prefix = <span class="string">' - '</span></div><div class="line">&gt; <span class="keyword">my</span> @a =&lt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>&gt;</div><div class="line">&gt; $prefix X~ @a       <span class="comment">#  - 1  - 2  - 3  - 4  - 5</span></div></pre></td></tr></table></figure>
<p>这时右边有一个无限列表是可以的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[探索Perl6的Signatures,第二部分]]></title>
      <url>http://ohmycloud.github.io/2015/08/29/%E6%8E%A2%E7%B4%A2Perl6%E7%9A%84Signatures-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>在我们探索 Perl 6 签名的<a href="http://friedo.com/blog/2016/01/exploring-perl-6-signatures-part-1" target="_blank" rel="external">第一部分</a>中, 我们了解了怎么使用 Perl 6 强大而灵活的类型系统来约束具名参数和位置参数是如何被传递给子例程和方法的。我们还涉及了怎么使用 <em>slurp</em> 签名来创建能接收任意具名和位置参数列表的可变函数。</p>
<p>Perl 6 的签名系统提供了更多。在这篇文章中我们将验证其中更高级的特性, 它们让 Perl 6 的调用语义更强大。</p>
<h2 id="Class-约束"><a href="#Class-约束" class="headerlink" title="Class 约束"></a>Class 约束</h2><hr>
<p>你可以使用签名来指定传递进函数中的参数的类型约束。你使用的类型可以是任意类名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub foo( Numeric $foo, Str $bar) &#123;</div><div class="line">    say &quot;my string is $bar and my number is $foo&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个签名要求我们传递 <strong>Numeric</strong> 和 <strong>Str</strong> 类型的参数。但是因为 Perl 6 的内置类型实际上就是类(classes), 并且因为 <strong>Numeric</strong> 拥有几个子类型, 我们可以传递进任何数字类型, 它都能工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">foo(42, &quot;blah&quot;);</div><div class="line">foo(42.99, &quot;yoohoo&quot;);</div><div class="line">foo(3+9i, &quot;hellooooooo&quot;);</div><div class="line"># etc</div></pre></td></tr></table></figure>
<p>我们自己定义的类中签名的工作原理也一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Foo &#123;</div><div class="line">    has $.prop is rw;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub inspect-a-foo( Foo $my-foo ) &#123;</div><div class="line">    say &quot;this foo&apos;s property is &quot; ~ $my-foo.prop;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $f = Foo.new( prop =&gt; 42 );</div><div class="line">inspect-a-foo($f);</div><div class="line"># this foo&apos;s property is 42</div></pre></td></tr></table></figure>
<p>在上面的例子中,  子例程 <em>inspect-a-foo</em> 只会接收 <strong>Foo</strong> 类型的参数, 或者 <strong>Foo</strong> 的子类。</p>
<h2 id="带有-where-block-的特异性"><a href="#带有-where-block-的特异性" class="headerlink" title="带有 where block 的特异性"></a>带有 <strong>where</strong> block 的特异性</h2><hr>
<p>通过在签名中使用 <em>where</em> 子句, Perl 6 允许我们更进一步的限制子例程的参数。<em>where</em> 子句接收任何 code block, 这个 <code>code block</code> 必须返回一个 true 值以使类型约束通过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub foo(Int $positive where &#123; $positive &gt; 0 &#125; ) &#123;</div><div class="line">    say &quot;我很确信 $positive 是正的!&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub bar( Foo $foo where &#123; $foo.prop.isa( Int ) and $foo.prop &gt; 40 &#125; ) &#123;</div><div class="line">    say &quot;这个 Foo 的属性是一个大于 40 的整数&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以指定多个 <em>where</em> 子句来约束多个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub quadrant2( Real $x where &#123; $x &lt; 0 &#125;, Real $y where &#123; $y &gt; 0 &#125; ) &#123;</div><div class="line">    say &quot;at the point ($x, $y)&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">quadrant2( 1, 1 );</div><div class="line"># Constraint type check failed for parameter &apos;$x&apos;</div><div class="line">quadrant2( -1, -1 );</div><div class="line"># Constraint type check failed for parameter &apos;$y&apos;</div><div class="line">quadrant2( -1, 1 );</div><div class="line"># at the point (-1, 1)</div></pre></td></tr></table></figure>
<p>约束块儿(Constraint blocks)甚至不需要是 <em>blocks</em>。事实上, 任何 <strong>Callable</strong> 类都可以。因此, 你可以很容易地获得功能函数的约束检测, 它们能在多个不同的子例程之间循环利用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub is-positive( Real $n ) &#123; $n &gt; 0  &#125;</div><div class="line">sub is-negative( Real $n ) &#123; $n &lt; 0  &#125;</div><div class="line">sub is-zero( Real $n )     &#123; $n == 0 &#125;</div><div class="line"></div><div class="line">sub quadrant1( Real $x where is-positive( $x ), Real $y where is-positive( $y ) ) &#123; ... &#125;</div><div class="line">sub quadrant2( Real $x where is-negative( $x ), Real $y where is-positive( $y ) ) &#123; ... &#125;</div><div class="line">sub quadrant3( Real $x where is-negative( $x ), Real $y where is-negative( $y ) ) &#123; ... &#125;</div><div class="line">sub quadrant4( Real $x where is-positive( $x ), Real $y where is-negative( $y ) ) &#123; ... &#125;</div><div class="line">sub x-axis( Real $x, Real $y where is-zero( $y ) ) &#123; ... &#125;</div><div class="line">sub y-axis( Real $x where is-zero( $x ), Real $y ) &#123; ... &#125;</div><div class="line">sub origin( Real $x where is-zero( $x ), Real $y where is-zero( $y ) ) &#123; ... &#125;</div></pre></td></tr></table></figure>
<h2 id="Return-Types"><a href="#Return-Types" class="headerlink" title="Return Types"></a>Return Types</h2><hr>
<p>每个 Perl 6 子例程也能指定它自己的返回值类型作为签名的一部分。这可以使用 <em>returns</em> 关键字来显式地指定, 但是我更喜欢用快捷形式的 <code>--&gt;</code> 操作符, 它在签名自身之内。下面声明的两个子例程是等价的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub are-they-equal( Str $foo, Str $bar ) returns Bool &#123;</div><div class="line">    $foo eq $bar</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub are-they-equal( Str $foo, Str $bar --&gt; Bool ) &#123;</div><div class="line">    $foo eq $bar</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>毫无疑问地, 如果返回错误的类型 Perl 6 会抛出错误。</p>
<h2 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h2><hr>
<p>Perl 6 中子例程是一等对象。但是 Perl 6 带来了一大堆新的内省工具, 包含询问子例程的签名信息的能力。每个子例程的签名实际上就是 <strong>Signature</strong> 类的一个对象。我们能找出子例程的元数和返回值类型。我们甚至能够在签名中抓取一个 <strong>Parameter</strong> 对象的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub are-they-equal( Str $foo, Str $bar ) returns Bool &#123;</div><div class="line">    $foo eq $bar</div><div class="line">&#125;</div><div class="line"></div><div class="line">say &amp;are-they-equal.signature.arity;    # 2</div><div class="line">say &amp;are-they-equal.signature.returns;  # (Bool)</div><div class="line"></div><div class="line">my @params = &amp;are-they-equal.signature.params;</div><div class="line">say @params[0].name;      # $foo</div><div class="line">say @params[0].type;      # (Str)</div><div class="line">say @params[0].sigil;     # $</div></pre></td></tr></table></figure>
<p>总之, Perl 6 的签名很好很强壮。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-单行程序]]></title>
      <url>http://ohmycloud.github.io/2015/08/25/Perl-6-%E5%8D%95%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="Perl-6-单行程序"><a href="#Perl-6-单行程序" class="headerlink" title="Perl 6 单行程序"></a><a href="https://github.com/dnmfarrell/Perl6-One-Liners" target="_blank" rel="external">Perl 6 单行程序</a></h1><p>这本书在进行之中。我希望你能觉得它有趣，甚至可能有用！如果你想贡献反馈的话，那么很欢迎提问题还有新的或有提升的正则表达式。</p>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>戴维法瑞尔 <a href="PerlTricks.com">PerlTricks.com</a></p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>版本 0.01</p>
<h2 id="许可"><a href="#许可" class="headerlink" title="许可"></a>许可</h2><p>FreeBSD</p>
<h2 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h2><ul>
<li>Alexander Moquin</li>
<li>Bruce Gray</li>
<li>Carl Mäsak</li>
<li>David H. Adler</li>
<li>FROGGS</li>
<li>Helmut Wollmersdorfer</li>
<li>japhb</li>
<li>Larry Wall</li>
<li>Matt Oates</li>
<li>Moritz Lenz</li>
<li>Mouq</li>
<li>Salve J Nilsen</li>
<li>Sam S</li>
<li>Skids</li>
<li>timotimo</li>
</ul>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>启发于 Peteris Krumins 的 Perl 5 example <a href="http://www.catonmat.net/download/perl1line.txt" target="_blank" rel="external">文件</a>。他逐字逐句地写了一本关于 Perl 5 单行 的<a href="http://www.nostarch.com/perloneliners" target="_blank" rel="external">书</a>。</p>
<p><a href="http://webchat.freenode.net/?channels=perl6&amp;nick=" target="_blank" rel="external">irc</a>上有很好地 folks。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ol>
<li>介绍</li>
<li>教程</li>
<li>文件间距</li>
<li>行号</li>
<li>计算</li>
<li>创建字符串和创建数组</li>
<li>文本转换和替换</li>
<li>文本分析</li>
<li>选择性的行打印</li>
<li>使用管道转换数据(进行中)</li>
<li>WWW(进行中)</li>
<li>转换到 Windows</li>
</ol>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>把 Perl 和其它语言区别开的一件事情是在单行代码中写小程序的能力，即人们所熟知的”单行”。在终端里直接键入一个程序比写一个废弃的脚本往往更快。并且单行程序也很强大；它们是羽翼丰满的程序，能够加载外部库，但是也能集成到终端中。你可以在单行程序中输入或输出数据。</p>
<p>像 Perl 5 一样， Perl 6支持单行程序。还有就像 Perl 6 到处清理着 Perl 5 的毒瘤一样，Perl 6 的单行语法也更好了。它拥有更少的特殊变量和选项因此更容易记忆。这本书提供了很多有用的 Perl 6 单行例子，从找出文件中得重复行到运行一个 web 服务器，它几乎能做所有事情。尽管 Perl 6 拥有更少的特殊变量，但是由于它高级的面向对象的语法，Perl 6 中的大部分单行程序比等价的 Perl 5 单行程序更短。</p>
<p>这本书可以以多种方式阅读。如果你是单行程序的新手，从教程开始。它带领你掌握单行程序的核心概念；不要担心，一旦你理解了它会很容易。如果你精通 Perl，Bash，或 Sed/Awk，你可以立马开始工作。随意跳过和浏览你所感兴趣的东西。如果有些代码你不理解，那么在终端中试试！这个仓库中包含的无处不在的文件是 example.txt，它会在很多单行程序中用到。</p>
<p>使用单行编程仅仅是 Perl 6 擅长的一个范例。这样的代码小而美，但是同时你正学习的是一种生产力技能，记住你正在学的是一种新的编程语言。检查 <a href="perl6.org">perl6.org</a>网站获取官方文档。</p>
<h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>要开始单行程序，所有你要掌握的是 <strong>-e</strong> 选项。这告诉 Perl 把它后面所跟的东西作为一个程序去执行。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -e &apos;say &quot;Hello, World!&quot;&apos;</div></pre></td></tr></table></figure>
<p>我们来一步步剖析这段代码。 <code>perl6</code> 引用了 Perl 6 程序， <code>-e</code> 告诉 Perl 6 去执行，而 <code>&#39;say &quot;Hello, World!&quot;&#39;</code>是要执行的程序。每个程序都必须被包围在单引号中（除了在 Windows 上，查看 <a href="https://github.com/dnmfarrell/Perl6-One-Liners#converting-for-windows" target="_blank" rel="external">转换到 Windows</a>）。要运行单行程序，就把它键入到终端中好了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; perl6 <span class="_">-e</span> <span class="string">'say "Hello, World!"'</span></div><div class="line">Hello, World!</div></pre></td></tr></table></figure>
<p>如果你想加载一个文件，就把文件路径添加到程序代码的后面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'for (lines) &#123;say $_&#125;'</span> /path/to/file.txt</div></pre></td></tr></table></figure>
<p>这个程序打印出了 <code>path/to/file.txt</code> 的每一行。你可能知道 <code>$_</code> 是默认变量，它在这儿是指正被循环的当前行。<code>lines</code> 是一个列表，当你传递一个文件路径给单行程序的时候会自动为你创建这个列表。现在我们来重写那个单行程序，一步一步。它们都是等价的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'for (lines) &#123; say $_ &#125;'</span> /path/to/file.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'for (lines) &#123; $_.say &#125;'</span> /path/to/file.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'for (lines) &#123; .say &#125;'</span> /path/to/file.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'.say for (lines)'</span> /path/to/file.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'.say for lines'</span> /path/to/file.txt</div></pre></td></tr></table></figure>
<p>就像 <code>$_</code> 是默认变量一样，在默认变量身上调用的方法可以省略掉变量引用。它们变成了默认方法。所以 <code>$_.say</code> 变成 <code>.say</code>。回报给写单行程序的人的东西是 - 更少的键入！</p>
<p><code>-n</code> 选项改变了程序的行为：它为文件中的每一行执行一次代码。所以，大写并打印 <code>path/to/file.txt</code> 的每一行你会键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.uc.say'</span> /path/to/file.txt</div><div class="line">``` </div><div class="line"></div><div class="line">`-p` 选项就像 `-n`, 除了它会自动打印 `<span class="variable">$_</span>` 之外。所以大写文件中的所有行的另外一种方法是：</div><div class="line"></div><div class="line">```Bash</div><div class="line">perl6 -pe <span class="string">'$_ = .uc'</span> /path/to/file.txt</div></pre></td></tr></table></figure>
<p>或者两个做同样事情的更短的版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'.=uc'</span> /path/to/file.txt</div><div class="line">perl6 -pe .=uc   /path/to/file.txt</div></pre></td></tr></table></figure>
<p>在第二个例子中，我们可以完全移除周围的单引号。这种场景很少遇到，但是如果你的单行程序中没有空格并且没有符号或引号，那么你通常可以移除外部的引号。</p>
<p><code>-n</code> 和 <code>-p</code> 选项真的很有用。本书中也有很多使用它们的单行例子。</p>
<p>最后一件你要知道的事情是怎么加载模块。 <code>-M</code> 开关代表着加载模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -M URI::Encode <span class="_">-e</span> <span class="string">'say encode_uri("example.com/10 ways to crush it with Perl 6")'</span></div></pre></td></tr></table></figure>
<p><code>-M URI::Encode</code> 加载了 <code>URI::Encode</code> 模块，它导入了 <em>encode_uri</em> 子例程。 你可以多次使用 <code>-M</code> 来加载多个模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -M URI::Encode -M URI <span class="_">-e</span> <span class="string">'&lt;your code here&gt;'</span></div></pre></td></tr></table></figure>
<p>如果你有一个还没有安装的本地模块呢？ 简单， 仅仅传递一个 <code>-I</code> 开关来包含那个目录好了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -I lib -M URI::Encode <span class="_">-e</span> <span class="string">'&lt;your code here&gt;'</span></div></pre></td></tr></table></figure>
<p>现在 Perl 6 会在 <code>lib</code> 目录中搜索 <code>URI::Encode</code> 模块，和标准的安装位置一样。</p>
<p>要查看 Perl 6 命令行开关有哪些， 使用 <code>-h</code> 选项查看帮助：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -h</div></pre></td></tr></table></figure>
<p>这打印可获得的不错的统计。</p>
<h3 id="文件间距"><a href="#文件间距" class="headerlink" title="文件间距"></a>文件间距</h3><p>Double space a file</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'$_ ~= "\n"'</span> example.txt</div></pre></td></tr></table></figure>
<p>N-space a file (例如. 4倍空白)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'$_ ~= "\n" x 4'</span> example.txt</div></pre></td></tr></table></figure>
<p>在每一行前面添加一个空行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'say ""'</span> example.txt</div></pre></td></tr></table></figure>
<p>移除所有空行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 -ne &apos;.say if /\S/&apos;   example.txt</div><div class="line">perl6 -ne &apos;.say if .chars&apos; example.txt</div></pre></td></tr></table></figure>
<p>移除所有的连续空白行，只保留一行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'$*ARGFILES.slurp.subst(/\n+/, "\n\n", :g).say'</span> example.txt</div></pre></td></tr></table></figure>
<h3 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h3><p>给文件中的所有行编号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say "&#123;++$&#125; $_"'</span> example.txt</div><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say $*ARGFILES.ins ~ " $_ "'</span> example.txt</div></pre></td></tr></table></figure>
<p>只给文件中得非空行编号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'$_ = "&#123;++$&#125; $_" if /\S/'</span> example.txt</div></pre></td></tr></table></figure>
<p>给所有行编号但是只打印非空行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'$_ = $*ARGFILES.ins ~ " $_ " if /\S/'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印文件中行数的总数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say lines.elems'</span> example.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'say lines.Int'</span>   example.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'lines.Int.say'</span>   example.txt</div></pre></td></tr></table></figure>
<p>打印出文件中非空行的总数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'lines.grep(/\S/.elems.say)'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印文件中空行的数量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'lines.grep(/^\s*$/).elems.say'</span> example.txt</div></pre></td></tr></table></figure>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>检查一个数是否是质数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say "7 is prime" if 7.is-prime'</span></div></pre></td></tr></table></figure>
<p>打印一行中所有字段的和：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say [+] .split("\t")'</span></div></pre></td></tr></table></figure>
<p>打印所有行的所有字段的和：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say [+] lines.split("\t")'</span></div></pre></td></tr></table></figure>
<p>打乱行中的所有字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.split("\t").pick(*).join("\t").say'</span></div></pre></td></tr></table></figure>
<p>找出一行中最小的元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.split("\t").min.say'</span></div></pre></td></tr></table></figure>
<p>找出所有行的最小的元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'lines.split("\t").min.say'</span></div></pre></td></tr></table></figure>
<p>找出一行中最大的元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.split("\t").max.say'</span></div></pre></td></tr></table></figure>
<p>找出所有行的最大的元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'lines.split("\t").max.say'</span></div></pre></td></tr></table></figure>
<p>找出一行中得数值化最小元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.split("\t")».Numeric.min.say'</span></div></pre></td></tr></table></figure>
<p>找出一行中得数值化最大元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.split("\t")».Numeric.max.say'</span></div></pre></td></tr></table></figure>
<p>使用字段的绝对值替换每个字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.split("\t").map(*.abs).join("\t")'</span></div></pre></td></tr></table></figure>
<p>找出每行中字符的总数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.chars.say'</span> example.txt</div></pre></td></tr></table></figure>
<p>找出每行中单词的总数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.words.elems.say'</span> example.txt</div></pre></td></tr></table></figure>
<p>找出每行中由逗号分隔的元素的总数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.split(",").elems.say'</span> example.txt</div></pre></td></tr></table></figure>
<p>找出所有行的字段（单词）的总数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say lines.split("\t").elems'</span> example.txt  <span class="comment"># fields</span></div><div class="line">perl6 <span class="_">-e</span> <span class="string">'say lines.words.elems'</span> example.txt        <span class="comment"># words</span></div></pre></td></tr></table></figure>
<p>打印匹配某个模式的字段的总数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say lines.split("\t").comb(/pattern/).elems'</span> example.txt <span class="comment"># fields</span></div><div class="line">perl6 <span class="_">-e</span> <span class="string">'say lines.words.comb(/pattern/).elems'</span> example.txt       <span class="comment"># words</span></div></pre></td></tr></table></figure>
<p>打印匹配某个模式的行的总数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say lines.grep(/in/.elems)'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印数字 PI 到 n 位小数点(例如. 10位)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say pi.fmt("%.10f");'</span></div></pre></td></tr></table></figure>
<p>打印数字 PI 到 15 位小数点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say π'</span></div></pre></td></tr></table></figure>
<p>打印数字 E 到 n 位小数点(例如. 10位)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say e.fmt("%.10f");'</span></div></pre></td></tr></table></figure>
<p>打印数字 E 到 15 位小数点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say e'</span></div></pre></td></tr></table></figure>
<p>打印 UNIX 时间 (seconds since Jan 1, 1970, 00:00:00 UTC)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say time'</span></div></pre></td></tr></table></figure>
<p>打印 GMT (格林威治标准时间)和地方计算机时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 -MDateTime::TimeZone <span class="_">-e</span> <span class="string">'say to-timezone("GMT",DateTime.now)'</span></div><div class="line">perl6 <span class="_">-e</span> <span class="string">'say DateTime.now'</span></div></pre></td></tr></table></figure>
<p>以 H:M:S 格式打印当地计算机时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say DateTime.now.map(&#123;$_.hour, $_.minute, $_.second.round&#125;).join(":")'</span></div></pre></td></tr></table></figure>
<p>打印昨天的日期：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say DateTime.now.earlier(:1day)'</span></div></pre></td></tr></table></figure>
<p>打印日期： 14 个月, 9 天，和 7 秒之前</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say DateTime.now.earlier(:14months).earlier(:9days).earlier(:7seconds)'</span></div></pre></td></tr></table></figure>
<p>在标准输出前加上时间戳（GMT，地方时间）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tail <span class="_">-f</span> logfile | perl6 -MDateTime::TimeZone <span class="_">-ne</span> <span class="string">'say to-timezone("GMT",DateTime.now) ~ "\t$_"'</span></div><div class="line">tail <span class="_">-f</span> logfile | perl6 <span class="_">-ne</span> <span class="string">'say DateTime.now ~ "\t$_"'</span></div></pre></td></tr></table></figure>
<p>计算 5 的阶乘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say [*] 1..5'</span></div></pre></td></tr></table></figure>
<p>计算最大公约数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say [gcd] @list_of_numbers'</span></div></pre></td></tr></table></figure>
<p>使用欧几里得算法计算数字 20 和 35 的最大公约数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say (20, 35, *%* ... 0)[*-2]'</span></div></pre></td></tr></table></figure>
<p>计算 20 和 35 的最小公倍数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say 20 lcm 35'</span></div></pre></td></tr></table></figure>
<p>使用欧几里得算法: n*m/gcd(n,m) 计算数字 20 和 35 的最小公倍数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say 20 * 35 / (20 gcd 35)'</span></div></pre></td></tr></table></figure>
<p>生成 10 个 5 到 15（不包括 15）之间的随机数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'.say for (5..^15).roll(10)'</span></div></pre></td></tr></table></figure>
<p>找出并打印列表的全排列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say .join for [1..5].permutations'</span></div></pre></td></tr></table></figure>
<p>生成幂集</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'.say for &lt;1 2 3&gt;.combinations'</span></div></pre></td></tr></table></figure>
<p>把 IP 地址转换为无符号整数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say :256["127.0.0.1".comb(/\d+/)]'</span></div><div class="line">perl6 <span class="_">-e</span> <span class="string">'say +":256[&#123;q/127.0.0.1/.subst(:g,/\./,q/,/)&#125;]"'</span></div><div class="line">perl6 <span class="_">-e</span> <span class="string">'say Buf.new(+«"127.0.0.1".split(".")).unpack("N")'</span></div></pre></td></tr></table></figure>
<p>把无符号整数转换为 IP 地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say join ".", @(pack "N", 2130706433)'</span></div><div class="line">perl6 <span class="_">-e</span> <span class="string">'say join ".", map &#123; ((2130706433+&gt;(8*$_))+&amp;0xFF) &#125;, (3...0)'</span></div></pre></td></tr></table></figure>
<h3 id="创建字符串和创建数组"><a href="#创建字符串和创建数组" class="headerlink" title="创建字符串和创建数组"></a>创建字符串和创建数组</h3><p>生成并打印字母表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'.say for "a".."z"'</span></div></pre></td></tr></table></figure>
<p>生成并打印所有从 “a” 到 “zz” 的字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'.say for "a".."zz"'</span></div></pre></td></tr></table></figure>
<p>把整数转换为十六进制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say 255.base(16)'</span></div><div class="line">perl6 <span class="_">-e</span> <span class="string">'say sprintf("%x", 255)'</span></div></pre></td></tr></table></figure>
<p>把整数打印为十六进制转换表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say sprintf("%3i =&gt; %2x", $_, $_) for 0..255'</span></div></pre></td></tr></table></figure>
<p>把整数编码为百分数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say sprintf("%%%x", 255)'</span></div></pre></td></tr></table></figure>
<p>生成一个随机的 10 个 a-z 字符长度的字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'print roll 10, "a".."z"'</span></div><div class="line">perl6 <span class="_">-e</span> <span class="string">'print roll "a".."z": 10'</span></div></pre></td></tr></table></figure>
<p>生成一个随机的 15 个 ASCII 字符长度的密码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'print roll 15, "0".."z"'</span></div><div class="line">perl6 <span class="_">-e</span> <span class="string">'print roll "0".."z": 15'</span></div></pre></td></tr></table></figure>
<p>创建一个指定长度的字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'print "a" x 50'</span></div></pre></td></tr></table></figure>
<p>生成并打印从 1 到 100 数字为偶数的数组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'(1..100).grep(* %% 2).say'</span></div></pre></td></tr></table></figure>
<p>找出字符串的长度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'"storm in a teacup".chars.say'</span></div></pre></td></tr></table></figure>
<p>找出数组的元素个数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'my @letters = "a".."z"; @letters.Int.say'</span></div></pre></td></tr></table></figure>
<h3 id="文本转换和替换"><a href="#文本转换和替换" class="headerlink" title="文本转换和替换"></a>文本转换和替换</h3><p>对文件进行 ROT 13 加密：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'tr/A..Za..z/N..ZA..Mn..za..m/'</span> example.txt</div></pre></td></tr></table></figure>
<p>对字符串进行 Base64 编码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -MMIME::Base64 <span class="_">-ne</span> <span class="string">'print MIME::Base64.encode-str($_)'</span> example.txt</div></pre></td></tr></table></figure>
<p>对字符串进行 Base64 解码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -MMIME::Base64 <span class="_">-ne</span> <span class="string">'print MIME::Base64.decode-str($_)'</span> base64.txt</div></pre></td></tr></table></figure>
<p>对字符串进行 URL 转义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -MURI::Encode -le <span class="string">'say uri_encode($string)'</span></div></pre></td></tr></table></figure>
<p>URL-unescape a string</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -MURI::Encode -le <span class="string">'say uri_decode($string)'</span></div></pre></td></tr></table></figure>
<p>HTML-encode a string</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -MHTML::Entity <span class="_">-e</span> <span class="string">'print encode-entities($string)'</span></div></pre></td></tr></table></figure>
<p>HTML-decode a string</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -MHTML::Entity <span class="_">-e</span> <span class="string">'print decode-entities($string)'</span></div></pre></td></tr></table></figure>
<p>把所有文本转换为大写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'.=uc'</span>    example.txt</div><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say .uc'</span> example.txt</div></pre></td></tr></table></figure>
<p>把所有文本转换为小写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'.=lc'</span>    example.txt</div><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say .lc'</span> example.txt</div></pre></td></tr></table></figure>
<p>只把每行的第一个单词转换为大写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say s/(\w+)&#123;&#125;/&#123;$0.uc&#125;/'</span> example.txt</div></pre></td></tr></table></figure>
<p>颠倒字母的大小写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'tr/a..zA..Z/A..Za..z/'</span>           example.txt</div><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say tr/a..zA..Z/A..Za..z/.after'</span> example.txt</div></pre></td></tr></table></figure>
<p>对每行进行驼峰式大小写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say .wordcase'</span> example.txt</div></pre></td></tr></table></figure>
<p>在每行的开头去掉前置空白（空格、tabs）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say .trim-leading'</span> example.txt</div></pre></td></tr></table></figure>
<p>从每行的末尾去掉结尾的空白（空格、tabs）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say .trim-trailing'</span> example.txt</div></pre></td></tr></table></figure>
<p>从每行中去除行首和行尾的空白：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say .trim'</span> example.txt</div></pre></td></tr></table></figure>
<p>把 UNIX 换行符转换为 DOS/Windows 换行符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'print .subst(/\n/, "\r\n")'</span> example.txt</div></pre></td></tr></table></figure>
<p>把 DOS/Windows  换行符转换为 UNIX 换行符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'print .subst(/\r\n/, "\n")'</span> example.txt</div></pre></td></tr></table></figure>
<p>把每行中所有的 “ut” 实体用 “foo” 替换掉：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'s:g/ut/foo/'</span> example.txt</div></pre></td></tr></table></figure>
<p>把包含 “lorem” 的每行中所有的 “ut” 实体用 “foo” 替换掉：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'s:g/ut/foo/ if /Lorem/'</span> example.txt</div></pre></td></tr></table></figure>
<p>把文件转换为 JSON 格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -M JSON::Tiny <span class="_">-e</span> <span class="string">'say to-json(lines)'</span> example.txt</div></pre></td></tr></table></figure>
<p>从文件的每一行中随机挑选 5 个单词：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'say .words.pick(5)'</span> example.txt</div></pre></td></tr></table></figure>
<h3 id="文本分析"><a href="#文本分析" class="headerlink" title="文本分析"></a>文本分析</h3><p>Print n-grams of a string</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'my $n=2; say "banana".comb.rotor($n,$n-1).map(&#123;[~] @$_&#125;)'</span></div><div class="line"></div><div class="line">打印唯一的 n-grams</div><div class="line"></div><div class="line">```Bash</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'my $n=2; say "banana".comb.rotor($n,$n-1).map(&#123;[~] @$_&#125;).Set.sort'</span></div></pre></td></tr></table></figure>
<p>打印 n-grams 的出现次数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'my $n=2; say "banana".comb.rotor($n,$n-1).map(&#123;[~] @$_&#125;).Bag.sort.join("\n")'</span></div></pre></td></tr></table></figure>
<p>打印单词的出现次数(1-grams)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say lines[0].words.map(&#123;[~] @$_&#125;).Bag.sort.join("\n")'</span> example.txt</div></pre></td></tr></table></figure>
<p>基于一组 1-grams 打印 Dice 相似系数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'my $a="banana".comb;my $b="anna".comb;say ($a (&amp;) $b)/($a.Set + $b.Set)'</span></div></pre></td></tr></table></figure>
<p>基于 1-grams 打印卡得杰相似系数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'my $a="banana".comb;my $b="anna".comb;say ($a (&amp;) $b) / ($a (|) $b)'</span></div></pre></td></tr></table></figure>
<p>基于 1-grams 打印重叠系数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'my $a="banana".comb;my $b="anna".comb;say ($a (&amp;) $b)/($a.Set.elems,$b.Set.elems).min'</span></div></pre></td></tr></table></figure>
<p>基于 1-grams 打印类似的余弦：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'my $a="banana".comb;my $b="anna".comb;say ($a (&amp;) $b)/($a.Set.elems.sqrt*$b.Set.elems.sqrt)'</span></div><div class="line"></div><div class="line"><span class="comment"># 上面的命令提示 Seq 已经被消费</span></div><div class="line">perl6 <span class="_">-e</span> <span class="string">'my $a="banana".comb;my $b="anna".comb;say ($a.cache (&amp;) $b.cache)/($a.cache.Set.elems.sqrt*$b.cache.Set.elems.sqrt)'</span></div></pre></td></tr></table></figure>
<p>创建字符串中字符的索引并打印出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say &#123;&#125;.push: %("banana".comb.pairs).invert'</span></div></pre></td></tr></table></figure>
<p>创建一行中单词的所以并打印出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'(&#123;&#125;.push: %(lines[0].words.pairs).invert).sort.join("\n").say'</span> example.txt</div></pre></td></tr></table></figure>
<h3 id="选择性的行打印"><a href="#选择性的行打印" class="headerlink" title="选择性的行打印"></a>选择性的行打印</h3><p>打印文件的第一行（模仿 head -1）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.say;exit'</span>      example.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'lines[0].say'</span>    example.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'lines.shift.say'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印文件的前 10 行（模仿 head -10）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'exit if ++$ &gt; 10'</span> example.txt</div><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.say if ++$ &lt; 11'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印文件的最后一行（模仿 tail -1）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'lines.pop.say'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印文件的最后 5 行（模仿 tail -5）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'.say for lines[*-5..*]'</span> example.txt</div></pre></td></tr></table></figure>
<p>只打印包含元音的行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'/&lt;[aeiou]&gt;/ &amp;&amp; .print'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印包含所有元音的行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.say if .comb (&gt;=) &lt;a e i o u&gt;'</span> example.txt</div><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.say if .comb ⊇ &lt;a e i o u&gt;'</span>    example.txt</div></pre></td></tr></table></figure>
<p>打印字符数大于或等于 80 的行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.print if .chars &gt;= 80'</span> example.txt</div><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.chars &gt;= 80 &amp;&amp; .print'</span> example.txt</div></pre></td></tr></table></figure>
<p>只打印第二行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.print if ++$ == 2'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印除了第二行的所有行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'next if ++$ == 2'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印第一行到第三行之间的所有行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.print if (1..3).any == ++$'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印两个正则表达式之间（包含匹配那个正则表达式的行）的所有行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.print if /^Lorem/../laborum\.$/'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印最长的行的长度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say lines.max.chars'</span> example.txt</div><div class="line">perl6 <span class="_">-ne</span> <span class="string">'state $l=0; $l = .chars if .chars &gt; $l;END &#123; $l.say &#125;'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印长度最长的行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say lines.max'</span> example.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'my $l=""; for (lines) &#123;$l = $_ if .chars &gt; $l.chars&#125;;END &#123; $l.say &#125;'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印包含数字的所有行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.say if /\d/'</span>             example.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'.say for lines.grep(/\d/)'</span> example.txt</div><div class="line">perl6 <span class="_">-ne</span> <span class="string">'/\d/ &amp;&amp; .say'</span>             example.txt</div><div class="line">perl6 -pe <span class="string">'next if ! $_.match(/\d/)'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印只包含数字的所有行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.say if /^\d+$/'</span>             example.txt</div><div class="line">perl6 <span class="_">-e</span> <span class="string">'.say for lines.grep(/^\d+$/)'</span> example.txt</div><div class="line">perl6 <span class="_">-ne</span> <span class="string">'/^\d+$/ &amp;&amp; .say'</span>             example.txt</div><div class="line">perl6 -pe <span class="string">'next if ! $_.match(/^\d+$/)'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印每个奇数行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.say if ++$ % 2'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印每个偶数行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.say if ! (++$ % 2)'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印所有重复的行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'state %l;.say if ++%l&#123;$_&#125;==2'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印唯一的行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'state %l;.say if ++%l&#123;$_&#125;==1'</span> example.txt</div></pre></td></tr></table></figure>
<p>打印每一行中的第一个字段（单词）（模仿 cut -f 1 -d ‘ ‘）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.words[0].say'</span> example.txt</div></pre></td></tr></table></figure>
<h3 id="使用管道转换数据"><a href="#使用管道转换数据" class="headerlink" title="使用管道转换数据"></a>使用管道转换数据</h3><p>Perl 6程序直接集成到了命令行中。你可以使用 | 管道符号从单行程序中输出数据和输入数据到单行程序中。为了 从管道中输入数据， Perl 6 自动地把 STDIN 设置为 <code>$*IN</code>。就像对文件那样，从管道输入的数据在单行中也能使用 <code>-n</code> 来进行循环迭代。从单行程序中输出数据就使用 print 或 say 好了。</p>
<p>在当前目录中对所有文件进行 JSON 编码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls | perl6 -M JSON::Tiny <span class="_">-e</span> <span class="string">'say to-json(lines)'</span></div></pre></td></tr></table></figure>
<p>打印文件中的大约 5% 的随机样本行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-ne</span> <span class="string">'.say if 1.rand &lt;= 0.05'</span> /usr/share/dict/words</div></pre></td></tr></table></figure>
<p>颜色转换， 从 HTML 到 RGB</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"#ffff00"</span> | perl6 <span class="_">-ne</span> <span class="string">'.comb(/\w\w/).map(&#123;:16($_)&#125;).say'</span></div></pre></td></tr></table></figure>
<p>颜色转换， 从 RGB 到 HTML</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"#ffff00"</span> | perl6 <span class="_">-ne</span> <span class="string">'.comb(/\w\w/).map(&#123;:16($_)&#125;).say'</span></div></pre></td></tr></table></figure>
<h3 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h3><p>下载一个页面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -M HTTP::UserAgent <span class="_">-e</span> <span class="string">'say HTTP::UserAgent.new.get("google.com").content'</span></div></pre></td></tr></table></figure>
<p>下载一个页面并剥离 HTML：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -O - <span class="string">"http://perl6.org"</span> | perl6 <span class="_">-ne</span> <span class="string">'s:g/\&lt;.+?\&gt;//.say'</span></div></pre></td></tr></table></figure>
<p>下载一个页面并剥离并解码 HTML：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -O - <span class="string">"http://perl6.org"</span> | perl6 -MHTML::Strip <span class="_">-ne</span> <span class="string">'strip_html($_).say'</span></div></pre></td></tr></table></figure>
<p>开启一个简单地 web 服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -M HTTP::Server::Simple <span class="_">-e</span> <span class="string">'HTTP::Server::Simple.new.run'</span></div></pre></td></tr></table></figure>
<h3 id="转换到-Windows"><a href="#转换到-Windows" class="headerlink" title="转换到 Windows"></a>转换到 Windows</h3><p>一旦你知道了里面的门道之后那么在 Windows 上运行单行程序就是小草一碟。单行程序既可以在 cmd.exe 中运行，又可以在 Powershell 中运行。主要的规则是：用双引号替换掉外部的单引号，在单行程序的内部使用插值引用操作符 <code>qq//</code> 来把字符串括起来。对于非插值的引起，你可以使用单引号。我们来看几个例子。</p>
<p>这儿有一个打印时间的单行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say DateTime.now'</span></div></pre></td></tr></table></figure>
<p>要在 Windows 上运行，我们仅仅用双引号替换掉单引号好了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">"say DateTime.now"</span></div></pre></td></tr></table></figure>
<p>这个单行程序给文件中每一行添加了一个换行符，使用了插值字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">'$_ ~= "\n"'</span> example.txt</div></pre></td></tr></table></figure>
<p>在 Windows 上这应该写为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 -pe <span class="string">"<span class="variable">$_</span> ~= qq/\n/"</span> example.txt</div></pre></td></tr></table></figure>
<p>这种情况下，我们想对换行符进行插值，并且不为该行字面地添加反斜线和字符”n”，所以我们必须使用 qq。但是你通常也可以像这样在单行程序中使用单引号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">'say "Hello, World!"'</span></div></pre></td></tr></table></figure>
<p>在 Windows 上这应该写为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">"say 'hello, World!'"</span></div></pre></td></tr></table></figure>
<p>简单地输出重定向工作起来像基于 Unix 系统那样。 这个单行程序使用 <code>&gt;</code> 把 ASCII 字符索引表打印到一个文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl6 <span class="_">-e</span> <span class="string">"say .chr ~ ' ' ~ <span class="variable">$_</span> for 0..255"</span> &gt; ascii_codes.txt</div></pre></td></tr></table></figure>
<p>在使用 <code>&gt;</code> 的时候，如果文件不存在就会创建一个。如果文件确实存在，它会被重写。你可能更想追加到文件，使用 <code>&gt;&gt;</code> 代替。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cookbook]]></title>
      <url>http://ohmycloud.github.io/2015/08/25/cookbook/</url>
      <content type="html"><![CDATA[<h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><hr>
<blockquote>
<p>将每行从第二列到最后一列数值为0的且数目多于6个的行删除</p>
</blockquote>
<p>数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">OG004240:    1       3     1       1       9     0       4       5       1     1       6    1     2</div><div class="line">OG004241:    1       2     1       4       7     2       1       3       1     2       9    1     1</div><div class="line">OG004242:    1       2     1       2       4     1       3       9       2     2       4    2     2</div><div class="line">OG004243:    0       4     1       2       9     2       4       5       1     2       3    1     1</div><div class="line">OG004244:    0       2     1       3       8     3       3       2       2     3       4    2     2</div><div class="line">OG004245:    0       3     1       2       7     3       3       0       3     2       7    2     2</div><div class="line">OG004246:    0       0     2       0       1     15      0       15      0     0       1    0     1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @lines = &quot;a.txt&quot;.IO.lines;</div><div class="line">for @lines -&gt; $line &#123;</div><div class="line">    my @words = $line.split(/\s+/);</div><div class="line">    say $line unless @words[1..*].grep(* eq 0).elems &gt; 6;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 <code>p6doc -f Str.split</code> 查看 split 的帮助文档。</p>
<p>合并相同行：</p>
<p>文件一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1###ENSMMUP00000017866###-###27582-27683</div><div class="line">1###ENSMMUP00000017866###-###27508-27576</div><div class="line">1###ENSMMUP00000017866###-###27290-27503</div><div class="line">1###ENSMMUP00000040736###-###199515-200498</div><div class="line">1###ENSMMUP00000040736###-###198582-198818</div><div class="line">1###ENSMMUP00000030409###+###395728-395934</div><div class="line">1###ENSMMUP00000030409###+###403004-403148</div></pre></td></tr></table></figure>
<p>想合并相同的，生成文件格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1###ENSMMUP00000017866###-###27582-27683  27508-27576  27290-27503  </div><div class="line">1###ENSMMUP00000040736###-###199515-200498  198582-198818</div><div class="line">1###ENSMMUP00000030409###+###395728-395934  403004-403148</div></pre></td></tr></table></figure>
<p>一种方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @lines = &quot;a.txt&quot;.IO.lines;</div><div class="line">my %hash;</div><div class="line">for @lines -&gt; $line &#123;</div><div class="line">    $line.match(/^(.*?)(\d+&apos;-&apos;\d+)/);</div><div class="line">    %hash&#123;$0&#125; ~= $1 ~ &quot; &quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for %hash.kv -&gt; $key, $value &#123;</div><div class="line">    say $key, $value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下数据，想去掉第3列重复的行且保留的行要使第四列最小, 原始数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">326        0.00        0.00        ( 0 )</div><div class="line">63        0.00        2.43        ( 0.0082 )</div><div class="line">64        0.00        2.43        ( 0.0082 )</div><div class="line">120        0.00        2.43        ( 0 )</div><div class="line">340        0.00        4.03        ( 0 )</div><div class="line">99        0.00        9.14        ( 0.0229 )</div><div class="line">441        0.00        9.14        ( 0.0232 )</div><div class="line">142        0.00        10.77        ( 0.0569 )</div><div class="line">292        0.00        10.77        ( 0.0393 )</div><div class="line">266        0.00        10.77        ( 0.0233 )</div></pre></td></tr></table></figure>
<p>想要的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">326        0.00        0.00        ( 0 )</div><div class="line">120        0.00        2.43        ( 0 )</div><div class="line">340        0.00        4.03        ( 0 )</div><div class="line">99        0.00        9.14        ( 0.0229 )</div><div class="line">266        0.00        10.77        ( 0.0233 )</div></pre></td></tr></table></figure>
<p>一种方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @lines = &quot;a.txt&quot;.IO.lines;</div><div class="line">my %hash;</div><div class="line">for @lines -&gt; $line &#123;</div><div class="line">    $line.match(/(\d+\.\d+)\s+\(\s+(\S+)/);</div><div class="line">    %hash&#123;$0&#125; ~= $1 ~ &quot; &quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for @lines -&gt; $line &#123;</div><div class="line">    $line.match(/(\d+\.\d+)\s+\(\s+(\S+)/);</div><div class="line"></div><div class="line">    for %hash.kv -&gt; $key, $value &#123;</div><div class="line">        say $line if $0 ~~ $key &amp;&amp; $1 ~~ $value.words.min;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有 gene.txt 和 in.txt 两个文件, 文件内容如下:</p>
<p>gene.txt:（2000多行)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">chr1        ABCA4        94458582        94586799</div><div class="line">chr1        ACADM        76190031        76229363</div><div class="line">chr16        BBS2        56518258        56554008</div><div class="line">chr17        G6PC        41052813        41066450</div><div class="line">chr17        GAA        78078244        78093271</div></pre></td></tr></table></figure>
<p>in.txt:(5万多行)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1        94505603        rs368951547        C        T        NA        NA</div><div class="line">1        94505604        rs61750126         A        C        0.02066    NA</div><div class="line">1        94505611        rs137853898        G        A        NA        not-provided</div><div class="line">1        94505620        rs370967816        T        A        NA        NA</div><div class="line">1        94505621        rs149503495        T        C        NA        NA</div><div class="line">1        94505627        rs374610040        A        G        NA        NA</div><div class="line">22        18901263        rs377148163       C        A        NA        NA</div><div class="line">22        18901290        rs381848          G        A        0.07989   NA</div><div class="line">22        18901322        rs62232347        C        A        NA        NA</div><div class="line">22        18901326        rs201353896       TCC      T        0.05005   NA</div><div class="line">22        18901327        rs10537001        CCT      C        0.0528    NA</div><div class="line">16        18901326        rs201353896       TCC      T        0.05005   NA</div><div class="line">17        18901327        rs10537001        CCT      C        0.0528    NA</div></pre></td></tr></table></figure>
<p>gene.txt 和 in.txt 的第一列的数字部分相同，并且 In 的第二列在gene 的三四列范围之间，就输出 in.txt 中的那一行。</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @lines   = &quot;a.txt&quot;.IO.lines;</div><div class="line">my @inlines = &quot;in.txt&quot;.IO.lines;</div><div class="line">my %hash;</div><div class="line">for @lines -&gt; $line &#123;</div><div class="line">    $line.match(/^chr(\d+)\s+(\w+)\s+(\d+)\s+(\d+)/);</div><div class="line">    %hash&#123;$0~$1~$2~$3&#125; = $0 ~ &quot; &quot; ~ $2 ~ &quot; &quot; ~ $3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for @inlines -&gt; $line &#123;</div><div class="line">    $line.match(/^(\d+)\s+(\d+)/);</div><div class="line"></div><div class="line">    for %hash.values -&gt; $value &#123;</div><div class="line">        say $line</div><div class="line">        if $0 ~~ $value.words[0]</div><div class="line">        &amp;&amp; $1 &lt;= $value.words[1].Num</div><div class="line">        &amp;&amp; $1 &lt;= $value.words[2].Num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例如我现在数组中的值是 <code>@project = (&#39;NX11&#39;,&#39;NX12&#39;,&#39;NX13’)</code></p>
<p>另外一个数组是 <code>@get = (&#39;ss&#39;,&#39;ssfd&#39;,&#39;NX12&#39;,&#39;sed&#39;,&#39;NX11’)</code></p>
<p>现在把第一个数组中出现过的值，如果第二个数组中也有的话删除掉，然后保留第二个数组剩下的值。</p>
<p>使用差集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@get (-) @project</div></pre></td></tr></table></figure>
<p>有如下数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">PL -0.00 5.50</div><div class="line">PL -0.25 3.50</div><div class="line">PL -0.50 0.00</div><div class="line">PL -0.75 4.50</div><div class="line">-0.25 -0.00 1.00</div><div class="line">-0.25 -0.25 4.50</div><div class="line">-0.25 -0.50 1.00</div><div class="line">-0.75 -0.75 1.00</div><div class="line">-0.75 -1.00 0.00</div><div class="line">-1.00 -0.25 3.50</div><div class="line">-1.00 -0.50 0.00</div><div class="line">-1.00 -1.25 3.40</div><div class="line">-1.00 -1.75 4.00</div></pre></td></tr></table></figure>
<p>将第一列值相同的行合并， 分使合并第二列和第三列：</p>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PL -0.00 -0.25 -0.50 -0.75</div><div class="line">PL 5.50 3.50 0.00 4.50</div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><hr>
<p>Fluent interface (流接口)</p>
<p>在软件工程中，一个流接口（fluent Interface）是指实现一种实现面向对象的能提高代码可读性的API的方法。<br>在 Perl 6 中有很多种方法, 但是最简单的一种是声明属性为可读写并使用 given 关键字。类型注释是可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Employee &#123;</div><div class="line">    subset Salary         of Real where * &gt; 0;</div><div class="line">    subset NonEmptyString of Str  where * ~~ /\S/; # 至少一个非空白符号</div><div class="line"></div><div class="line">    has NonEmptyString $.name    is rw;</div><div class="line">    has NonEmptyString $.surname is rw;</div><div class="line">    has Salary         $.salary  is rw;</div><div class="line"></div><div class="line">    method gist &#123;</div><div class="line">        return qq:to[END];</div><div class="line">        Name:    $.name</div><div class="line">        Surname: $.surname</div><div class="line">        Salary:  $.salary</div><div class="line">        END</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">my $employee = Employee.new();</div><div class="line"></div><div class="line">given $employee &#123;</div><div class="line">    .name    = &apos;Sally&apos;;</div><div class="line">    .surname = &apos;Ride&apos;;</div><div class="line">    .salary  = 200;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say $employee;</div><div class="line"></div><div class="line"># Output:</div><div class="line"># Name:    Sally</div><div class="line"># Surname: Ride</div><div class="line"># Salary:  200</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的变量]]></title>
      <url>http://ohmycloud.github.io/2015/08/25/Perl6%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<p>变量名以一个叫做魔符 sigil 的特殊字符开头, 后面跟着一个可选的第二个叫做 <code>twigil</code> 的特殊字符, 然后是一个标识符.</p>
<h2 id="Sigils"><a href="#Sigils" class="headerlink" title="Sigils"></a>Sigils</h2><hr>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">符号	   类型约束	                      默认类型     Flattens      Assignment</div><div class="line">$	     Mu (<span class="keyword">no</span> type constraint)      Any          No           item</div><div class="line">&amp;        Callable	                  Callable     No           item</div><div class="line">@	     Positional                   Array        Yes          list</div><div class="line">%	     Associative	              Hash         Yes          list</div></pre></td></tr></table></figure>
<p>Examples:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $square = <span class="number">9</span> ** <span class="number">2</span>;</div><div class="line"><span class="keyword">my</span> @array  = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;   <span class="comment"># Array variable with three elements</span></div><div class="line"><span class="keyword">my</span> %hash   = <span class="string">London =&gt;</span> <span class="string">'UK'</span>, <span class="string">Berlin =&gt;</span> <span class="string">'Germany'</span>;</div></pre></td></tr></table></figure>
<p>不带符号的变量也是可行的, 查看 <a href="http://doc.perl6.org/language/variables#Sigilless_variables" target="_blank" rel="external">无符号变量</a>.</p>
<h2 id="项和列表赋值"><a href="#项和列表赋值" class="headerlink" title="项和列表赋值"></a>项和列表赋值</h2><hr>
<p>有两种类型的赋值, item 赋值和 list 赋值. 两者都使用 = 号操作符. 根据 = 号左边的语法来区别 = 是 item 赋值还是 list 赋值.</p>
<p>Item 赋值把等号右侧的值放到左侧的变量(容器)中.</p>
<p>例如, 数组变量(@符号)在列表赋值时清空数组自身, 然后把等号右侧的值都放进数组自身中. 跟 Item 赋值相比, 这意味着等号左侧的变量类型始终是 Array, 不管右侧是什么类型.</p>
<p>赋值类型(item 或 list)取决于当前表达式或声明符看到的第一个上下文:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $foo = <span class="number">5</span>;            <span class="comment"># item assignment</span></div><div class="line"><span class="keyword">say</span> $foo.perl;          <span class="comment"># 5</span></div><div class="line"></div><div class="line"><span class="keyword">my</span> @bar = <span class="number">7</span>, <span class="number">9</span>;         <span class="comment"># list assignment</span></div><div class="line"><span class="keyword">say</span> @bar.WHAT;          <span class="comment"># Array</span></div><div class="line"><span class="keyword">say</span> @bar.perl;          <span class="comment"># [7, 9]&lt;&gt;</span></div><div class="line"></div><div class="line">(<span class="keyword">my</span> $baz) = <span class="number">11</span>, <span class="number">13</span>;     <span class="comment"># list assignment</span></div><div class="line"><span class="keyword">say</span> $baz.WHAT;          <span class="comment"># Parcel</span></div><div class="line"><span class="keyword">say</span> $baz.perl;          <span class="comment"># (11, 13)</span></div></pre></td></tr></table></figure>
<p>如果内部赋值是一个声明符(例如 my), 就使用 item 赋值, 它比逗号和列表赋值的优先级更高:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @array;</div><div class="line">@array = <span class="keyword">my</span> $num = <span class="number">42</span>, <span class="string">"str"</span>;   <span class="comment"># item assignment: uses declarator</span></div><div class="line"><span class="keyword">say</span> @array.perl;                <span class="comment"># [42, "str"]&lt;&gt; (an Array)</span></div><div class="line"><span class="keyword">say</span> $num.perl;                  <span class="comment"># 42 (a Num)</span></div></pre></td></tr></table></figure>
<p>类似地, 如果内部赋值是一个用于声明符初始化的表达式, 则内部表达式的上下文决定赋值的类型:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $num;</div><div class="line"><span class="keyword">my</span> @array = $num = <span class="number">42</span>, <span class="string">"str"</span>;    <span class="comment"># item assignment: uses expression</span></div><div class="line"><span class="keyword">say</span> @array.perl;                 <span class="comment"># [42, "str"]&lt;&gt; (an Array)</span></div><div class="line"><span class="keyword">say</span> $num.perl;                   <span class="comment"># 42 (a Num)</span></div><div class="line"></div><div class="line"><span class="keyword">my</span> ( @foo, $bar );</div><div class="line">@foo = ($bar) = <span class="number">42</span>, <span class="string">"str"</span>;       <span class="comment"># list assignment: uses parens</span></div><div class="line"><span class="keyword">say</span> @foo.perl;                   <span class="comment"># [42, "str"]&lt;&gt; (an Array)</span></div><div class="line"><span class="keyword">say</span> $bar.perl;                   <span class="comment"># $(42, "str")  (a Parcel)</span></div></pre></td></tr></table></figure>
<p>然而, 如果内部赋值既不是声明符又不是表达式, 而是更大的表达式的一部分, 更大的表达式的上下文决定赋值的类型:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> ( @array, $num );</div><div class="line">@array = $num = <span class="number">42</span>, <span class="string">"str"</span>;    <span class="comment"># list assignment</span></div><div class="line"><span class="keyword">say</span> @array.perl;              <span class="comment"># [42, "str"]&lt;&gt; (an Array)</span></div><div class="line"><span class="keyword">say</span> $num.perl;                <span class="comment"># [42, "str"]&lt;&gt; (an Array)</span></div></pre></td></tr></table></figure>
<p>这是因为整个表达式是 <code>@array = $num = 42, &quot;str&quot;</code>, 而 <code>$num = 42</code> 不是单独的表达式.</p>
<h2 id="无符号变量"><a href="#无符号变量" class="headerlink" title="无符号变量"></a>无符号变量</h2><hr>
<p>在 Perl 6 中创建不带符号的变量也是可能的:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> \degrees = pi / <span class="number">180</span>;</div><div class="line"><span class="keyword">my</span> \θ       = <span class="number">15</span> * degrees;</div></pre></td></tr></table></figure>
<p>然而, 这些无符号变量并不创建容器. 那意味着上面的 <code>degrees</code> 和 <code>θ</code> 实际上直接代表 <code>Nums</code>. 为了说明, 我们定义一个无符号变量后再赋值:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">θ = <span class="number">3</span>; <span class="comment"># Dies with the error "Cannot modify an immutable Num"</span></div></pre></td></tr></table></figure>
<h2 id="Twigils"><a href="#Twigils" class="headerlink" title="Twigils"></a>Twigils</h2><hr>
<p><code>Twigils</code> 影响变量的<code>作用域</code>。请记住 twigils 对基本的魔符插值没有影响，那就是，如果  <code>$a</code> 内插， <code>$^a</code>, <code>$*a</code>, <code>$=a</code>, <code>$?a</code>, <code>$.a</code>, 等等也会内插. 它仅仅取决于 <code>$</code>.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* 动态</div><div class="line">! 属性(类成员)</div><div class="line">? 编译时变量</div><div class="line">. 方法(并非真正的变量)</div><div class="line">&lt; 匹配对象索引(并非真正的变量)</div><div class="line">^ 自我声明的形式位置参数</div><div class="line">: 自我声明的形式命名参数</div><div class="line">= Pod 变量</div><div class="line">~ 子语言</div></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title="*"></a>*</h2><hr>
<p>动态变量</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $lexical   = <span class="number">1</span>;</div><div class="line"><span class="keyword">my</span> $*dynamic1 = <span class="number">10</span>;</div><div class="line"><span class="keyword">my</span> $*dynamic2 = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">say</span>-<span class="title">all</span>() </span>&#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"$lexical, $*dynamic1, $*dynamic2"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># prints 1, 10, 100</span></div><div class="line"><span class="keyword">say</span>-all();</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">my</span> $lexical   = <span class="number">2</span>;</div><div class="line">    <span class="keyword">my</span> $*dynamic1 = <span class="number">11</span>;</div><div class="line">    $*dynamic2    = <span class="number">101</span>; <span class="comment"># 注意,这儿没有使用 my 来声明</span></div><div class="line"></div><div class="line">    <span class="comment"># prints 1, 11, 101</span></div><div class="line">    <span class="keyword">say</span>-all();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># prints 1, 10, 101</span></div><div class="line"><span class="keyword">say</span>-all();</div></pre></td></tr></table></figure>
<p><code>$lexical</code> 不是在调用者的作用域内被查找, 而是在 <code>&amp;say-all</code> 被定义的作用域那儿<br>也就是第一行的 <code>$lexical = 1</code> 了. 另外两个动态作用域变量在调用者的作用域内被查找, 所以值为 11 和 101<br>第三个 <code>&amp;say-all</code> 被调用后,  <code>$*dynamic1</code> 不再是 11 了. 但是 <code>$*dynamic2</code> 仍然是 101.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="!"></a>!</h2><hr>
<p>属性是变量, 存在于每个类的实例中. 通过 <code>!</code> 符号它们可以从类的里面直接被访问到:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    has $.<span class="keyword">x</span>;</div><div class="line">    has $.<span class="keyword">y</span>;</div><div class="line"></div><div class="line">    method Str() &#123;</div><div class="line">        <span class="string">"($!x, $!y)"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意属性是怎样被声明为 <code>$.x</code> 和 <code>$.y</code> 的, 但是仍然能够通过 <code>$!x</code> 和 <code>$!y</code> 访问到属性. 这是因为 在 Perl 6 中, 所有的属性都是<code>私有的</code>, 并且在类中能使用 <code>$!attribute-name</code> 直接访问这些属性. Perl 6 能自动为你生成访问方法.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title="?"></a>?</h2><hr>
<p>编译时”常量”, 可通过 <code>?</code> twigil 访问. 编译器对它们很熟悉, 并且编译后不能被修改. 常用的一个例子如下:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> <span class="string">"$?FILE: $?LINE"</span>; <span class="comment"># prints "hello.pl: 23" if this is the 23 line of a</span></div><div class="line">                      <span class="comment"># file named "hello.pl".</span></div></pre></td></tr></table></figure>
<p>尽管不能在运行时改变它们, 用户可以(重新)定义这种常量.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">constant $?TABSTOP = <span class="number">4</span>; <span class="comment"># this causes leading tabs in a heredoc or in a POD</span></div><div class="line">                        <span class="comment"># block's virtual margin to be counted as 4 spaces.</span></div></pre></td></tr></table></figure>
<h2 id="-3"><a href="#-3" class="headerlink" title="."></a>.</h2><hr>
<p><code>.</code> twigil 真的不是用于变量的. 实际上, 看下面的代码:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    has $.<span class="keyword">x</span>;</div><div class="line">    has $.<span class="keyword">y</span>;</div><div class="line"></div><div class="line">    method Str() &#123;</div><div class="line">        <span class="string">"($.x, $.y)"</span> <span class="comment"># 注意我们这次使用 . 而不是 !</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对自身调用了方法 x 和 方法 y, 这是自动为你生成的, 因为在你声明你的属性的时候, 你使用的是 <code>.</code> twigil 。 注意,  子类可能会覆盖那些方法. 如果你不想这个发生, 请使用 <code>$!x</code> 和 <code>$!y</code> 代替。</p>
<p><code>.</code> twigil 只是调用了一个方法也表明下面是可能的</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class SaySomething &#123;</div><div class="line">    method a() &#123; <span class="keyword">say</span> <span class="string">"a"</span>; &#125;</div><div class="line">    method b() &#123; $.a; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SaySomething.a; <span class="comment"># prints "a"</span></div></pre></td></tr></table></figure>
<h2 id="lt"><a href="#lt" class="headerlink" title="&lt;"></a>&lt;</h2><hr>
<p> <code>&lt;</code> twigil 是 <code>$/&lt;...&gt;</code> 的别名,  <code>$/</code> 是匹配变量.</p>
<h2 id="-4"><a href="#-4" class="headerlink" title="^"></a>^</h2><hr>
<p><code>^</code> twigil 为 block 块 或 子例程 声明了一个形式位置参数.  形如 <code>$^variable</code> 的变量是一种占位变量. 它们可用在裸代码块中来声明代码块的形式参数. 看下面代码中的块:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ^<span class="number">4</span> &#123;</div><div class="line">    <span class="keyword">say</span> <span class="string">"$^seconds follows $^first"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>which prints</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> follows <span class="number">0</span></div><div class="line"><span class="number">3</span> follows <span class="number">2</span></div></pre></td></tr></table></figure>
<p>有两个形式参数，就是 <code>$first</code> 和 <code>$second</code>.  注意, 尽管 <code>$^second</code> 在代码中出现的比 <code>$^first</code> 早,  <code>$^first</code> 依然是代码块中的第一个形式参数. 这是因为占位符变量是以 Unicode 顺序排序的.</p>
<p>子例程也能使用占位符变量, 但是只有在子例程没有显式的参数列表时才行. 这对普通的块也适用</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">say</span>-<span class="title">it</span>    </span>&#123; <span class="keyword">say</span> $^a; &#125; <span class="comment"># valid</span></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">say</span>-<span class="title">it</span>()  </span>&#123; <span class="keyword">say</span> $^a; &#125; <span class="comment"># invalid</span></div><div class="line">              &#123; <span class="keyword">say</span> $^a; &#125; <span class="comment"># valid</span></div><div class="line">-&gt; $x, $y, $x &#123; <span class="keyword">say</span> $^a; &#125; <span class="comment"># 非法, 已经有参数列表 $x,$y,$x 了</span></div></pre></td></tr></table></figure>
<p>占位符变量语法上不能有类型限制. 也注意, 也不能使用单个大写字母的占位符变量, 如 <code>$^A</code></p>
<h2 id="-5"><a href="#-5" class="headerlink" title=":"></a>:</h2><hr>
<p>声明命名参数</p>
<h2 id="-6"><a href="#-6" class="headerlink" title="="></a>=</h2><hr>
<p>访问 Pod 变量</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">=begin Foo</span></div><div class="line">...</div><div class="line">=end Foo</div><div class="line"></div><div class="line">#after that, $=Foo gives you all Foo-Pod-blocks</div></pre></td></tr></table></figure>
<h2 id="-7"><a href="#-7" class="headerlink" title="~"></a>~</h2><hr>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$~MAIN       the current main language (e.g. Perl statements)</div><div class="line">$~Quote      the current root of quoting language</div><div class="line">$~Quasi      the current root of quasiquoting language</div><div class="line">$~Regex      the current root of regex language</div><div class="line">$~Trans      the current root of transliteration language</div><div class="line">$~P5Regex    the current root of the Perl <span class="number">5</span> regex language</div></pre></td></tr></table></figure>
<p>You may supersede or augment those languages in your current lexical scope by doing</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">augment slang Regex &#123;  <span class="comment"># derive from $~Regex and then modify $~Regex</span></div><div class="line">    token backslash:std&lt;\Y&gt; &#123; YY &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">supersede slang Regex &#123; <span class="comment"># completely substitute $~Regex</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="变量声明符和作用域"><a href="#变量声明符和作用域" class="headerlink" title="变量声明符和作用域"></a>变量声明符和作用域</h2><hr>
<p>通常, 使用 <code>my</code> 关键字创建一个新的变量就足够了:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $amazing-variable = <span class="string">"World"</span>;</div><div class="line"><span class="keyword">say</span> <span class="string">"Hello $amazing-variable!"</span>; <span class="comment"># Hello World!</span></div></pre></td></tr></table></figure>
<p>然而, 有很多声明符能改变作用域的细节</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">声明符 作用</div><div class="line"><span class="keyword">my</span>    作为词法作用域名字的开头</div><div class="line"><span class="keyword">our</span>   作为包作用域名字的开头</div><div class="line">has   作为属性名的开头</div><div class="line">anon  作为私有名字的开头</div><div class="line"><span class="keyword">state</span> 作为词法作用域但是持久名字的开头</div><div class="line">augment 给已存在的名字添加定义</div><div class="line">supersede 替换已存在名字的定义</div></pre></td></tr></table></figure>
<p>还有两个类似于声明符的前缀, 但是作用于预定义变量:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">前缀  作用</div><div class="line">temp  在作用域的最后恢复变量的值</div><div class="line">let   如果 block 成功退出就恢复变量的值</div></pre></td></tr></table></figure>
<h3 id="my-声明符"><a href="#my-声明符" class="headerlink" title="my 声明符"></a>my 声明符</h3><hr>
<p>使用 <code>my</code> 声明一个变量给变量一个词法作用域. 这意味着变量只在当前块中存在.例如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="keyword">my</span> $foo = <span class="string">"bar"</span>;</div><div class="line"><span class="keyword">say</span> $foo; <span class="comment"># -&gt; "bar"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">say</span> $foo; <span class="comment"># !!! "Variable '$foo' is not declared"</span></div></pre></td></tr></table></figure>
<p>它抛出异常,因为只要我们在同一个作用域内 <code>$foo</code> 才被定义. 此外, 词法作用域意味着变量能在新的作用域内被临时地重新定义:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">my</span> $location = <span class="string">"outside"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">outer</span>-<span class="title">location</span> </span>&#123;</div><div class="line">    <span class="comment"># Not redefined:</span></div><div class="line">    <span class="keyword">say</span> $location;</div><div class="line">&#125;</div><div class="line"></div><div class="line">outer-location; <span class="comment"># -&gt; "outside"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">in</span>-<span class="title">building</span> </span>&#123;</div><div class="line">    <span class="keyword">my</span> $location = <span class="string">"inside"</span>;</div><div class="line">    <span class="keyword">say</span> $location;</div><div class="line">&#125;</div><div class="line"></div><div class="line">in-building;    <span class="comment"># -&gt; "inside"</span></div><div class="line">outer-location; <span class="comment"># -&gt; "outside"</span></div></pre></td></tr></table></figure>
<p>如果变量被重新定义了, 任何引用外部变量的代码会继续引用外部变量.<br>所以, 在这儿, <code>&amp;outer-location</code> 仍然打印外部的 <code>$location</code>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">new</span>-<span class="title">location</span> </span>&#123;</div><div class="line">    <span class="keyword">my</span> $location = <span class="string">"nowhere"</span></div><div class="line">    outer-location;</div><div class="line">&#125;</div><div class="line"></div><div class="line">new-location; <span class="comment"># -&gt; "outside"</span></div></pre></td></tr></table></figure>
<p>为了让 <code>new-location</code> 能打印 nowwhere, 需要使用 <code>*</code> twigil 让 $location 变为动态变量.<br>对于子例程来说, <code>my</code> 是默认作用域, 所以 <code>my sub x( ) { }</code> 和 <code>sub x( ) { }</code> 是一样的.</p>
<h3 id="our-声明符"><a href="#our-声明符" class="headerlink" title="our 声明符"></a>our 声明符</h3><hr>
<p>our 跟 my 的作用类似, 除了把别名引入到符号表之外:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module M &#123;</div><div class="line">    <span class="keyword">our</span> $Var;</div><div class="line">    <span class="comment"># $Var available here</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Available as $M::Var here.</span></div></pre></td></tr></table></figure>
<h3 id="has-声明符"><a href="#has-声明符" class="headerlink" title="has 声明符"></a>has 声明符</h3><hr>
<p>has 作用域在类的实例或 role 的属性上, 还有类或 roles 的方法上. has 隐式作用于方法上, 所以</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">has method <span class="keyword">x</span>( ) &#123; &#125;</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method <span class="keyword">x</span>( ) &#123; &#125;</div></pre></td></tr></table></figure>
<h3 id="anon-声明符"><a href="#anon-声明符" class="headerlink" title="anon 声明符"></a>anon 声明符</h3><hr>
<p><code>anon</code> 声明符阻止符号本安装在词法作用域内, 还有方法表中, 和其它任何地方.<br>例如, 你可以使用 <code>anon</code> 声明一个知道自己名字的子例程, 但是仍然不会被安装到作用域内:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> %operations =</div><div class="line">    <span class="string">half   =&gt;</span> anon <span class="function"><span class="keyword">sub</span> <span class="title">half</span>($<span class="title">x</span>)   </span>&#123; $x / <span class="number">2</span>  &#125;,</div><div class="line">    <span class="string">square =&gt;</span> anon <span class="function"><span class="keyword">sub</span> <span class="title">square</span>($<span class="title">x</span>) </span>&#123; $x * $x &#125;,</div><div class="line">    ;</div><div class="line"><span class="keyword">say</span> %operations&lt;square&gt;.name;       <span class="comment"># square</span></div><div class="line"><span class="keyword">say</span> %operations&lt;square&gt;(<span class="number">8</span>);         <span class="comment"># 64</span></div></pre></td></tr></table></figure>
<h3 id="state-声明符"><a href="#state-声明符" class="headerlink" title="state 声明符"></a>state 声明符</h3><hr>
<h3 id="augment-声明符"><a href="#augment-声明符" class="headerlink" title="augment 声明符"></a>augment 声明符</h3><hr>
<p>使用 <code>augment</code>, 你可以给已经存在的类或 grammars 增加属性和方法.</p>
<p>因为类通常使用 our 作用域, 因此是全局的, 这意味着修改全局状态, 这是强烈不鼓励的, 对于大部分情况, 有更好的方法.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># don't do this</span></div><div class="line"><span class="keyword">use</span> MONKEY-TYPING;</div><div class="line">augment class Int &#123;</div><div class="line">    method is-answer &#123; self == <span class="number">42</span> &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">say</span> <span class="number">42</span>.is-answer;       <span class="comment"># True</span></div></pre></td></tr></table></figure>
<h3 id="supersede-声明符"><a href="#supersede-声明符" class="headerlink" title="supersede 声明符"></a>supersede 声明符</h3><hr>
<h3 id="temp-前缀"><a href="#temp-前缀" class="headerlink" title="temp 前缀"></a>temp 前缀</h3><hr>
<p>像 my 一样, temp 在作用域的末尾恢复旧的变量值. 然而, temp 不创建新的变量.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $cookies = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">buy</span>-<span class="title">cookie</span> </span>&#123; $cookies++ &#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">my</span> $cookies = <span class="number">42</span>;</div><div class="line">    buy-cookie;   <span class="comment"># Increments the outer $cookies variable</span></div><div class="line">    <span class="keyword">say</span> $cookies; <span class="comment"># 42</span></div><div class="line">                  <span class="comment"># the outer $cookies variable is 6 now</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    temp $cookies = <span class="number">42</span>;</div><div class="line">    <span class="comment"># Still the same $cookies, but a new value:</span></div><div class="line">    buy-cookie;</div><div class="line">    <span class="keyword">say</span> $cookies; <span class="comment"># -&gt; 43</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Old value is restored</span></div><div class="line"><span class="keyword">say</span> $cookies; <span class="comment"># -&gt; 6</span></div></pre></td></tr></table></figure>
<h3 id="let-前缀"><a href="#let-前缀" class="headerlink" title="let 前缀"></a>let 前缀</h3><hr>
<p>跟 temp 类似, 但是只在 block 退出成功时才恢复变量值.</p>
<h2 id="类型约束和初始化"><a href="#类型约束和初始化" class="headerlink" title="类型约束和初始化"></a>类型约束和初始化</h2><hr>
<p>变量可以有类型约束, 约束在声明符和变量名之间:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> Int $x = <span class="number">42</span>;</div><div class="line">$x = <span class="string">'a string'</span>; <span class="comment"># throws an X::TypeCheck::Assignment error</span></div></pre></td></tr></table></figure>
<p>如果一个标量有类型约束但是没有初始值, 它会使用类型约束的类型对象来初始化.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> Int $x;</div><div class="line"><span class="keyword">say</span> $x.^name;    <span class="comment"># Int</span></div><div class="line"><span class="keyword">say</span> $x.defined;  <span class="comment"># False</span></div></pre></td></tr></table></figure>
<p>没有显式类型约束的标量的类型为 Mu, 但是默认会是 Any 类型的对象.</p>
<p>带有 @ 符号的变量会被初始化为空的数组; 带有 % 符号的变量会被初始化为空的散列.</p>
<p>变量的默认值可以使用 <code>is default</code> 特性设置, 通过把 Nil 赋值给变量来重新应用默认值:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> Real $product is default(<span class="number">1</span>);</div><div class="line"><span class="keyword">say</span> $product;                       <span class="comment"># 1</span></div><div class="line">$produce *= <span class="number">5</span>;</div><div class="line"><span class="keyword">say</span> $product;                       <span class="comment"># 5</span></div><div class="line">$product = Nil;</div><div class="line"><span class="keyword">say</span> $product;                       <span class="comment"># 1</span></div></pre></td></tr></table></figure>
<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><hr>
<p>经常使用的变量</p>
<p>每个代码块中都有3个特别的变量:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">变量	意义</div><div class="line">$_	  特殊变量</div><div class="line">$/	  正则匹配</div><div class="line">$!	  异常</div></pre></td></tr></table></figure>
<h3 id="-8"><a href="#-8" class="headerlink" title="$_"></a>$_</h3><hr>
<p><code>$_</code> 是特殊变量，在没有显式标识的代码块中，它是默认参数。所以诸如 <code>for @array { ... }</code> 和 <code>given $var { ... }</code> 之类的结构会将变量绑定给 <code>$_</code>.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &lt;a b c&gt; &#123; <span class="keyword">say</span> $_ &#125;  <span class="comment"># sets $_ to 'a', 'b' and 'c' in turn</span></div><div class="line"><span class="keyword">say</span> $_ <span class="keyword">for</span> &lt;a b c&gt;;     <span class="comment"># same, even though it's not a block</span></div><div class="line"><span class="keyword">given</span> <span class="string">'a'</span>   &#123; <span class="keyword">say</span> $_ &#125;  <span class="comment"># sets $_ to 'a'</span></div><div class="line"><span class="keyword">say</span> $_ <span class="keyword">given</span> <span class="string">'a'</span>;       <span class="comment"># same, 尽管这不是一个块</span></div></pre></td></tr></table></figure>
<p>CATCH 块将 <code>$_</code> 设置为捕获到的异常。 <code>~~</code> 智能匹配操作符。<br>对 <code>$_</code> 调用一个方法可以省略特殊变量 <code>$_</code> 的名字，从而写的更短：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.say;                   <span class="comment"># 与 $_.say 相同</span></div></pre></td></tr></table></figure>
<p><code>m/regex/</code> 和 <code>/regex/</code> 正则匹配 和 <code>s/regex/subst/</code> 替换是作用于 <code>$_</code> 上的.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> <span class="string">"Looking for strings with non-alphabetic characters..."</span>;</div><div class="line"><span class="keyword">for</span> &lt;ab:c d$e fgh ij*&gt; &#123;</div><div class="line">    .say <span class="keyword">if</span> <span class="keyword">m</span>/&lt;!alpha&gt;<span class="regexp">/;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Looking <span class="keyword">for</span> strings with non-alphabetic characters...</div><div class="line">ab:c</div><div class="line">d$e</div><div class="line">ij*</div></pre></td></tr></table></figure>
<h3 id="-9"><a href="#-9" class="headerlink" title="$/"></a>$/</h3><hr>
<p><code>$/</code> 是匹配变量。它存储着最近一次正则匹配的结果，通常包含 <code>Match</code> 类型的对象。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'abc 12'</span> ~~ <span class="regexp">/\w+/</span>;  <span class="comment"># 设置 $/ 为一个Match 对象</span></div><div class="line"><span class="keyword">say</span> $/;             <span class="comment"># abc</span></div></pre></td></tr></table></figure>
<p>Grammar的 parse 方法会把调用者的 <code>$/</code> 设置为 <code>Match object</code> 的结果。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> XML;</div><div class="line">XML.parse(slurp <span class="string">"filename.xml"</span>);</div><div class="line"><span class="keyword">say</span> $/;</div></pre></td></tr></table></figure>
<p>其他匹配变量是 <code>$/</code> 元素的别名：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$0          <span class="comment"># same as $/[0]</span></div><div class="line">$1          <span class="comment"># same as $/[1]</span></div><div class="line">$&lt;named&gt;    <span class="comment"># same as $/&lt;named&gt;</span></div></pre></td></tr></table></figure>
<h3 id="位置属性"><a href="#位置属性" class="headerlink" title="位置属性"></a>位置属性</h3><hr>
<p>如果正则中有捕获分组, <code>$/</code> 中会有位置属性. 它们由圆括号组成.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'abbbbbcdddddeffg'</span> ~~ <span class="regexp">/ a (b+) c (d+ef+) g /</span>;</div><div class="line"><span class="keyword">say</span> $/[<span class="number">0</span>]; <span class="comment"># ｢bbbbb｣</span></div><div class="line"><span class="keyword">say</span> $/[<span class="number">1</span>]; <span class="comment"># ｢dddddeff｣</span></div></pre></td></tr></table></figure>
<p>这些捕获分组也能使用 <code>$0</code>,<code>$1</code>,<code>$2</code> 等便捷形式取得:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> $0; <span class="comment"># ｢bbbbb｣</span></div><div class="line"><span class="keyword">say</span> $1; <span class="comment"># ｢dddddeff｣</span></div></pre></td></tr></table></figure>
<p>要获取所有的位置属性, 使用 <code>$/.list</code>, <code>@$/</code>,<code>@( )</code> 中的任意一个都可以:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> @().join; <span class="comment"># bbbbbdddddeff</span></div></pre></td></tr></table></figure>
<h3 id="命名属性"><a href="#命名属性" class="headerlink" title="命名属性"></a>命名属性</h3><hr>
<p>如果正则中有命名捕获分组, <code>$/</code> 可以有命名属性, 或者正则调用了另一个正则:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'I.... see?'</span> ~~ <span class="regexp">/ \w+ $&lt;punctuation&gt;=[ &lt;-[\w\s]&gt;+ ] \s* $&lt;final-word&gt; = [ \w+ . ] /</span>;</div><div class="line"><span class="keyword">say</span> $/&lt;punctuation&gt;; <span class="comment"># ｢....｣</span></div><div class="line"><span class="keyword">say</span> $/&lt;final-word&gt;;  <span class="comment"># ｢see?｣</span></div></pre></td></tr></table></figure>
<p>这些命名捕获分组也能使用便捷形式获取:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> $&lt;punctuation&gt;; <span class="comment"># ｢....｣</span></div><div class="line"><span class="keyword">say</span> $&lt;final-word&gt;;  <span class="comment"># ｢see?｣</span></div></pre></td></tr></table></figure>
<p>要获取所有的命名属性, 使用 <code>$/.hash</code>,  <code>%$/</code>, <code>%()</code>中的任何一个:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> %().join;  <span class="comment"># "punctuation     ....final-word  see?"</span></div></pre></td></tr></table></figure>
<h3 id="-10"><a href="#-10" class="headerlink" title="$!"></a>$!</h3><hr>
<p><code>$!</code> 是错误变量.</p>
<h2 id="编译时-“常量”"><a href="#编译时-“常量”" class="headerlink" title="编译时 “常量”"></a>编译时 “常量”</h2><hr>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$?FILE      所在文件</div><div class="line">$?LINE      所在行</div><div class="line">&amp;?ROUTINE   所在子例程</div><div class="line">&amp;?BLOCK     所在块</div><div class="line">%?LANG      What is the current set of interwoven languages?</div></pre></td></tr></table></figure>
<p>其它编译时常量：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$?KERNEL    Which kernel am I compiled <span class="keyword">for</span>?</div><div class="line">$?DISTRO    Which OS distribution am I compiling under</div><div class="line">$?VM        Which virtual machine am I compiling under</div><div class="line">$?XVM       Which virtual machine am I cross-compiling <span class="keyword">for</span></div><div class="line">$?PERL      Which Perl am I compiled <span class="keyword">for</span>?</div><div class="line">$?SCOPE     Which lexical scope am I in?</div><div class="line">$?PACKAGE   Which <span class="keyword">package</span> am I in?</div><div class="line">$?MODULE    Which module am I in?</div><div class="line">$?CLASS     Which class am I in? (as variable)</div><div class="line">$?ROLE      Which role am I in? (as variable)</div><div class="line">$?GRAMMAR   Which grammar am I in?</div><div class="line">$?TABSTOP   How many spaces is a tab in a heredoc <span class="keyword">or</span> virtual margin?</div><div class="line">$?USAGE     The usage message generated from the signatures of MAIN subs.</div><div class="line">$?ENC       Default encoding of Str.encode/Buf.decode/various IO methods.</div></pre></td></tr></table></figure>
<h2 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h2><hr>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$*ARGFILES  神奇的命令行输入句柄</div><div class="line">@*ARGS      来自命令行的参数</div><div class="line">$*IN        标准输入文件句柄</div><div class="line">$*OUT       标准输出文件句柄</div><div class="line">$*ERR       标准错误文件句柄</div><div class="line">$*TZ        系统的本地时区</div><div class="line">$*CWD       当前工作目录</div></pre></td></tr></table></figure>
<p>其他变量</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$*PROGRAM_NAME     Path to the current executable as it was typed in on the</div><div class="line">                   command line, <span class="keyword">or</span> C&lt;-e&gt; <span class="keyword">if</span> perl was invoked with the -e flag.</div><div class="line">$*PID              当前进程的进程ID</div><div class="line">$*OS               在哪种操作系统下被编译(e.g. Linux).</div><div class="line">$*OSVER            当前操作系统的版本.</div><div class="line">$*EXECUTABLE_NAME  当前运行的可执行perl 的名字</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的引号]]></title>
      <url>http://ohmycloud.github.io/2015/08/24/Perl6%E4%B8%AD%E7%9A%84%E5%BC%95%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>除了 q 和 qq 之外，现在还有一种基本形式的 Q，它不会进行插值，除非显式地修改它那样做。所以，q 实际上是 Q:q 的简称，qq 实际上是 Q:qq 的简称。实际上所有的 quote-like 形式都派生自带有副词的 Q 形式：</p>
<p><a href="https://github.com/perl6/roast/blob/master/S02-literals/quoting.t#L95-L116" target="_blank" rel="external">S02-literals/quoting.t lines 95–116</a><br><a href="https://github.com/perl6/roast/blob/master/S02-literals/quoting.t#L132-L139" target="_blank" rel="external">S02-literals/quoting.t lines 132–139</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">q//         Q :q //</div><div class="line">qq//        Q :qq //</div><div class="line">rx//        Q :regex //</div><div class="line">s///        Q :subst ///</div><div class="line">tr///       Q :trans ///</div></pre></td></tr></table></figure>
<p>诸如 <code>:regex</code> 的副词通过转换到不同的解析器改变了语言的解析。这能完全改变任何之后的副词还有所引起的东西自身的解释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">q:s//       Q :q :scalar //</div><div class="line">rx:s//      Q :regex :scalar //</div></pre></td></tr></table></figure>
<p>就像 <code>q[...]</code> 拥有简写形式的 ‘…’, 并且 <code>qq[...]</code> 拥有简写形式的 “…” 一样，完整的 <code>Q[...]</code> 引用也有一种使用半角括号 ｢…｣ 的短形式。</p>
<h2 id="引号上的副词"><a href="#引号上的副词" class="headerlink" title="引号上的副词"></a>引号上的副词</h2><p>广义上的引号现在可以接收副词了：<br><a href="https://github.com/perl6/roast/blob/master/S02-literals/quoting.t#L210-L223" target="_blank" rel="external">S02-literals/quoting.t lines 210–223</a><br>  <a href="https://github.com/perl6/roast/blob/master/S02-literals/quoting.t#L55-L69" target="_blank" rel="external">S02-literals/quoting.t lines 55–69</a><br> <a href="https://github.com/perl6/roast/blob/master/S02-literals/quoting.t#L427-L501" target="_blank" rel="external">S02-literals/quoting.t lines 427–501</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Short       Long            Meaning</div><div class="line">=====       ====            =======</div><div class="line">:x          :exec           作为命令执行并返回结果</div><div class="line">:w          :words          按单词分割结果(没有引号保护)</div><div class="line">                                     </div><div class="line"></div><div class="line">:ww         :quotewords     按单词分割结果 (带有引号保护)</div><div class="line">:v          :val            Evaluate word or words for value literals</div><div class="line">:q          :single         插值 \\, \q 和 \&apos; (or whatever)</div><div class="line">                                    </div><div class="line"></div><div class="line">:qq         :double         使用 :s, :a, :h, :f, :c, :b 进行插值</div><div class="line">:s          :scalar         插值 $ vars</div><div class="line">:a          :array          插值 @ vars</div><div class="line">:h          :hash           插值 % vars</div><div class="line"></div><div class="line">                        </div><div class="line">:f          :function       插值 &amp; 调用</div><div class="line">:c          :closure        插值 &#123;...&#125; 表达式</div><div class="line">:b          :backslash      插值 \n, \t, 等. (至少暗示了 :q )</div><div class="line">:to         :heredoc        把结果解析为 heredoc 终止符</div><div class="line">            :regex          解析为正则表达式</div><div class="line">            :subst          解析为置换 (substitution)</div><div class="line">            :trans          解析为转换 (transliteration)</div><div class="line">            :code           Quasiquoting</div><div class="line">:p          :path           返回一个 Path 对象 (查看 S16 获取更多选项)</div></pre></td></tr></table></figure>
<p>通过在开头加入一个带有短形式的单个副词的 Q，q，或 qq，你可以省略掉第一个冒号，这产生了如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">qw /a b c/;                         # P5-esque qw// meaning q:w</div><div class="line">Qc &apos;...&#123;$x&#125;...&apos;;                    # Q:c//, interpolate only closures</div><div class="line">qqx/$cmd @args[]/                   # equivalent to P5&apos;s qx//</div></pre></td></tr></table></figure>
<p>(注意 qx// 不插值)</p>
<p>如果你想进一步缩写，那么定义一个宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">macro qx &#123; &apos;qq:x &apos; &#125;          # equivalent to P5&apos;s qx//</div><div class="line">macro qTO &#123; &apos;qq:x:w:to &apos; &#125;    # qq:x:w:to//</div><div class="line">macro quote:&lt;❰ ❱&gt; ($text) &#123; quasi &#123; &#123;&#123;&#123;$text&#125;&#125;&#125;.quoteharder &#125; &#125;</div></pre></td></tr></table></figure>
<p>所有大写的副词被保留用作用户定义的引号。所有在 Latin-1 上面的 Unicode 分隔符被保留用作用户定义的引号。<br><a href="https://github.com/perl6/roast/blob/master/S02-literals/quoting.t#L352-L426" target="_blank" rel="external">S02-literals/quoting.t lines 352–426</a></p>
<p>关于上面我们现在有了一个推论，我们现在能说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%hash = qw:c/a b c d &#123;@array&#125; &#123;%hash&#125;/;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%hash = qq:w/a b c d &#123;@array&#125; &#123;%hash&#125;/;</div></pre></td></tr></table></figure>
<p>把东西(items)插值到 qw 中。默认地，数组和散列在插值时只带有空格分隔符，所以之后的按空格分割仍旧能工作。（但是内置的  «…»  引号自动进行了等价于 <code>qq:ww:v/.../</code> 的插值）。 内置的 <code>&lt;...&gt;</code> 等价于 <code>q:w:v/.../</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl6Weekly(第二期)]]></title>
      <url>http://ohmycloud.github.io/2015/08/22/Perl6Weekly-%E7%AC%AC%E4%BA%8C%E6%9C%9F/</url>
      <content type="html"><![CDATA[<h2 id="my-foo-的作用域和用途"><a href="#my-foo-的作用域和用途" class="headerlink" title=":my $foo 的作用域和用途"></a><code>:my $foo</code> 的作用域和用途</h2><p>在 <em>regex</em>、<em>token</em> 或 <em>rule</em> 中, 定义像下面这样的变量是可能的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">token directive &#123;</div><div class="line">    :my $foo = &quot;in command&quot;;</div><div class="line">    &lt;command&gt; &lt;subject&gt; &lt;value&gt;?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在中提到了一点有关该变量的东西, 我引用过来:</p>
<blockquote>
<p>任何 grammar regex 实际上是一种<code>方法</code>, 并且你可以在这样一个子例程中使用一个冒号跟着任何作用域声明符来声明一个变量, 这些声明符包括 <code>my</code>, <code>our</code>, <code>state</code> 和 <code>constant</code> (作为类似的声明符, temp 和 let 也能被识别). 单个语句(直到结尾的分号或行末尾的闭括号为止) 被解析为普通的 Perl 6 代码:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">token prove-nondeterministic-parsing &#123;</div><div class="line">    :my $threshold = rand;</div><div class="line">    &apos;maybe&apos; \s+ &lt;it($threshold)&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有谁能解释下这段代码的应用场景吗？</p>
<h3 id="what-scope-does-my-foo-have"><a href="#what-scope-does-my-foo-have" class="headerlink" title="what scope does :my $foo; have?"></a>what scope does <code>:my $foo;</code> have?</h3><p><code>:my $foo</code> 在它所出现的 rule/token/regex 中拥有词法作用域(lexical scope)。你所得到的作用域要么很大要么很小:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">grammar g &#123;</div><div class="line">    regex r1 &#123;</div><div class="line">        &#123; my $foo; ...&#125; # `$foo` 在该 block 的结尾超出作用域。</div><div class="line">        ...</div><div class="line">        &#123; say $foo;   &#125; # `$foo` 不在作用域中。</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">grammar i &#123;</div><div class="line">    my $foo;</div><div class="line">    regex r1   &#123; ... &#125; # 在 `r1` 内部, `$foo` 被识别出。</div><div class="line">    ...</div><div class="line">    regex r999 &#123; ... &#125; # 但是在 r999 中也是。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="它的用途"><a href="#它的用途" class="headerlink" title="它的用途?"></a>它的用途?</h3><p>使用 <code>:my $foo;</code> 形式的变量声明以在 rule/token/regex 中声明本地作用域的变量, 如果没有进一步的声明, 那么这些变量能在 rule/token/regex 中的任何地方通过所声明的名字来引用。举个例子, 你可以看看 Rakudo 的 Grammar.nqp 源代码中的 <a href="http://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.nqp#L108" target="_blank" rel="external"><code>token babble</code></a> 中声明的 <code>@extra_tweaks</code> 变量的用法。</p>
<p>使用 <code>:my $*foo;</code> 形式的变量声明来声明动态的词法变量。动态变量能够, 在没有进一步声明的情况下, 在闭合词法作用域和闭合动态作用域中通过它们声明的名字来引用。作为说明, 请查看 <a href="http://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.nqp#L4861" target="_blank" rel="external">the declaration of <code>@*nibbles</code> in Rakudo’s Grammar module</a> 和 <a href="http://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L8943" target="_blank" rel="external">its use in Rakudo’s Actions module</a> 。</p>
<h3 id="一般的使用场景"><a href="#一般的使用场景" class="headerlink" title="一般的使用场景"></a>一般的使用场景</h3><p>在 <a href="https://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="external">regular expressions</a> 中一般不使用 <code>:…</code> 风格的声明。<code>:...;</code> 结构通常用在特别复杂和庞大的 grammars 中。对于这些使用场景, 依靠 Perl 6 的正则表达式和闭包的一致性是合适的。正是这使得 rule/token/regex 级别的 <code>:...;</code> 变量声明变得正当。</p>
<h3 id="Regexes-和-closures-的一致性"><a href="#Regexes-和-closures-的一致性" class="headerlink" title="Regexes 和 closures 的一致性"></a>Regexes 和 closures 的一致性</h3><p>很多 grammars 都是<a href="http://trevorjim.com/python-is-not-context-free/" target="_blank" rel="external">上下文有关的</a>.</p>
<p>Perl 6 使 regexes 和 closures 统一了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say Regex.^mro; (Regex) (Method) (Routine) (Block) (Code) ...</div></pre></td></tr></table></figure>
<p>mro 是方法解析顺序, 这足以说明 regex 实际上是一种特殊类型的方法(就像方法是一种特殊类型的子例程一样)。</p>
<h2 id="Perl6-is-there-a-phaser-that-runs-only-when-you-fall-out-of-a-loop"><a href="#Perl6-is-there-a-phaser-that-runs-only-when-you-fall-out-of-a-loop" class="headerlink" title="Perl6: is there a phaser that runs only when you fall out of a loop?"></a><a href="http://stackoverflow.com/questions/36117329/perl6-is-there-a-phaser-that-runs-only-when-you-fall-out-of-a-loop" target="_blank" rel="external">Perl6: is there a phaser that runs only when you fall out of a loop?</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line"></div><div class="line">use v6.c;</div><div class="line"></div><div class="line">ROLL:</div><div class="line">for 1..10 -&gt; $r &#123;</div><div class="line">    given (1..6).roll &#123;</div><div class="line">        when 6 &#123;</div><div class="line">            say &quot;Roll $r: you win!&quot;;</div><div class="line">            last ROLL;</div><div class="line">        &#125;</div><div class="line">        default &#123;</div><div class="line">            say &quot;Roll $r: sorry...&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    LAST &#123;</div><div class="line">        say &quot;You either won or lost - this runs either way&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更优雅的写法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">constant N = 5;</div><div class="line">for flat (1..6).roll xx * Z 1..N -&gt; $_, $n &#123;</div><div class="line">    print &quot;roll $n: $_ &quot;;</div><div class="line"></div><div class="line">    when 6 &#123;</div><div class="line">        put &quot;(won)&quot;;</div><div class="line">        last;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    default &#123;</div><div class="line">        put &quot;(lost)&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    LAST &#123;</div><div class="line">        print &quot;result: &quot;;</div><div class="line">        when 6 &#123; put &quot;winner :)&quot; &#125;</div><div class="line">        default &#123; put &quot;loser :(&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="怎么从命令行传递一个复数给-sub-MAIN"><a href="#怎么从命令行传递一个复数给-sub-MAIN" class="headerlink" title="怎么从命令行传递一个复数给 sub MAIN?"></a><a href="http://stackoverflow.com/questions/35872082/how-do-i-pass-a-complex-number-from-the-command-line-to-sub-main" target="_blank" rel="external">怎么从命令行传递一个复数给 sub MAIN?</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line"></div><div class="line">use v6.c;</div><div class="line"></div><div class="line">sub MAIN($x)</div><div class="line">&#123;</div><div class="line">    say &quot;$x squared is &#123; $x*$x &#125;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我要在命令行中传递一个复数给 MAIN:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; % ./square i</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Cannot convert string to number: base-10 number must begin with valid digits or &apos;.&apos; in &apos;⏏i&apos; (indicated by ⏏)</div><div class="line">  in sub MAIN at ./square line 7</div><div class="line">  in block &lt;unit&gt; at ./square line 5</div><div class="line"></div><div class="line">Actually thrown at:</div><div class="line">  in sub MAIN at ./square line 7</div><div class="line">  in block &lt;unit&gt; at ./square line 5</div></pre></td></tr></table></figure>
<p>当我把脚本变为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line"></div><div class="line">use v6.c;</div><div class="line"></div><div class="line">sub MAIN(Complex $x)</div><div class="line">&#123;</div><div class="line">    say &quot;$x squared is &#123; $x*$x &#125;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它竟然彻底罢工了:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">% ./square i</div><div class="line">Usage:</div><div class="line">  square &lt;<span class="keyword">x</span>&gt;</div><div class="line"></div><div class="line">% ./square <span class="number">1</span></div><div class="line">Usage:</div><div class="line">  square &lt;<span class="keyword">x</span>&gt;</div></pre></td></tr></table></figure>
<p>一种方法是使用 <a href="http://design.perl6.org/S02.html#Coercive_type_declarations" target="_blank" rel="external">Coercive type declaration</a> (强制类型声明), 从 Str 到 Complex:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub MAIN(Complex(Str) $x) &#123;</div><div class="line">    say &quot;$x 的平方为 &#123; $x * $x &#125;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">% ./squared.pl 1</div><div class="line">1+0i 的平方为 1+0i</div><div class="line">% ./squared.pl 1+2i</div><div class="line">1+2i 的平方为 -3+4i</div></pre></td></tr></table></figure>
<p>但是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ./test.pl6 2</div><div class="line">Usage:</div><div class="line">  ./test.p6 &lt;x&gt;</div></pre></td></tr></table></figure>
<p>所以你真正需要的是把其它 Numeric 类型强转为 Complex 类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line"></div><div class="line">use v6.c;</div><div class="line"></div><div class="line">sub MAIN ( Complex(Real) $x ) &#123;</div><div class="line">    say &quot;$x squared is &#123; $x*$x &#125;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我使用 Real 而非 Numeric, 因为 Complex 已经涵盖了其它的了。</p>
<h2 id="Blessing-a-Hash-into-an-object"><a href="#Blessing-a-Hash-into-an-object" class="headerlink" title="Blessing a Hash into an object"></a><a href="https://www.reddit.com/r/perl6/comments/4aoi82/blessing_a_hash_into_an_object/" target="_blank" rel="external">Blessing a Hash into an object</a></h2><p>为什么我写的这段代码不对呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class WordCount &#123;</div><div class="line">  has %!words; # Tried with both . and !</div><div class="line">  method new($string) &#123;</div><div class="line">    my %words;</div><div class="line">    my @sentence = split(/\s+/, $string);</div><div class="line">    for @sentence -&gt; $word &#123;</div><div class="line">      %words&#123;$word&#125;++;</div><div class="line">    &#125;</div><div class="line">    return self.bless(:%words);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  method sayCounts() &#123;</div><div class="line">    my @keys = keys(%!words);</div><div class="line">    for @keys -&gt; $key &#123;</div><div class="line">      say $key ~ &quot; &quot; ~ %!words&#123;$key&#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub MAIN &#123;</div><div class="line">  my $sentence = &quot;the boy jumped over the dog&quot;;</div><div class="line">  my $wordCount = WordCount.new($sentence);</div><div class="line">  $wordCount.sayCounts();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Perl6-ify:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">class WordCount &#123;</div><div class="line">  has Int %.words is default(0);</div><div class="line"></div><div class="line">  method new($string) &#123;</div><div class="line">    my Int %words;</div><div class="line">    for $string.split(/\s+/) -&gt; $word &#123;</div><div class="line">      %words&#123;$word&#125;++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    self.bless(:%words)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  method gist &#123;</div><div class="line">    %.words.map(&#123;.value ~ &quot; &quot; ~ .key&#125;).join(&quot;\n&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $word-count = WordCount.new(&apos;the boy jumped over the dog&apos;);</div><div class="line">say $word-count;</div></pre></td></tr></table></figure>
<p>散列中的每一项都是一个 <strong>Pair</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %w = a =&gt; 1;</div><div class="line">%w.map(&#123; say $_.^name &#125;) # OUTPUT«Pair␤»</div></pre></td></tr></table></figure>
<p>所以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%.words.map(&#123;.value ~ &quot; &quot; ~ .key&#125;).join(&quot;\n&quot;)</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%.words.kv.map( -&gt; $word, $count &#123; &quot;$word $count&quot; &#125; ).join(&quot;\n&quot;)</div></pre></td></tr></table></figure>
<p>你还可以使用 sub-signature(子签名)来解构 <code>.map</code> 提供的 <code>Pair</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%.words.map( -&gt; (:key($word), :value($count)) &#123; &quot;$word $count&quot; &#125; ).join(&quot;\n&quot;)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Perl6中为自定义的类添加下标(subscripts)]]></title>
      <url>http://ohmycloud.github.io/2015/08/18/%E5%9C%A8Perl6%E4%B8%AD%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%A0%87-subscripts/</url>
      <content type="html"><![CDATA[<h3 id="为自定义的类添加下标-subscripts"><a href="#为自定义的类添加下标-subscripts" class="headerlink" title="为自定义的类添加下标(subscripts)"></a>为自定义的类添加下标(subscripts)</h3><p>假如你定义了一个类，你想把类的实例用作散列那样，可以索引其中的元素， 那么你需要让你得自定义遵守 Associative 接口，并重写<br><code>AT-KEY</code> 、<code>EXISTS-KEY</code> 、<code>DELETE-KEY</code> 、<code>push</code> 等跟散列有关的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">class HTTPHeader &#123; ... &#125;</div><div class="line"></div><div class="line">class HTTPHeader does Associative  &#123;</div><div class="line">    </div><div class="line">    has %!fields  handles &lt;self.AT-KEY self.EXISTS-KEY self.DELETE-KEY self.push  list kv keys values&gt;;</div><div class="line">    method Str &#123; say self.hash.fmt; &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    multi method EXISTS-KEY ($key)       &#123; %!fields&#123;normalize-key $key&#125;:exists &#125;</div><div class="line">    multi method DELETE-KEY ($key)       &#123; %!fields&#123;normalize-key $key&#125;:delete &#125;</div><div class="line">    multi method push (*@_)              &#123; %!fields.push: @_                   &#125;</div><div class="line"></div><div class="line">    sub normalize-key ($key) &#123; $key.subst(/\w+/, *.tc, :g) &#125; # titileCase 驼峰式的键</div><div class="line"></div><div class="line">    method AT-KEY (::?CLASS:D: $key) is rw &#123;</div><div class="line">        my $element := %!fields&#123;normalize-key $key&#125;;</div><div class="line">        </div><div class="line">        Proxy.new(</div><div class="line">            FETCH =&gt; method () &#123; $element &#125;,</div><div class="line">            </div><div class="line">            STORE =&gt; method ($value) &#123;</div><div class="line">                $element = do given $value».split(/&apos;,&apos; \s+/).flat &#123;</div><div class="line">                    when 1  &#123; .[0] &#125;    # a single value is stored as a string</div><div class="line">                    default &#123; .Array &#125;  # multiple values are stored as an array</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">my $header = HTTPHeader.new;</div><div class="line">say $header.WHAT;  #-&gt; (HTTPHeader)</div><div class="line">&quot;&quot;.say;</div><div class="line"></div><div class="line">$header&lt;Accept&gt; = &quot;text/plain&quot;;</div><div class="line">$header&#123;&apos;Accept-&apos; X~ &lt;Charset Encoding Language&gt;&#125; = &lt;utf-8 gzip en&gt;;</div><div class="line">$header.push(&apos;Accept-Language&apos; =&gt; &quot;fr&quot;);  # like .push on a Hash</div><div class="line"></div><div class="line">say $header.hash.fmt;</div><div class="line">&quot;&quot;.say;</div><div class="line"># say $header.Str; # 同上</div><div class="line"></div><div class="line">say $header&lt;Accept-Language&gt;.values; </div><div class="line">say $header&lt;Accept-Charset&gt;;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(HTTPHeader)</div><div class="line"></div><div class="line">Accept	text/plain</div><div class="line">Accept-Charset	utf-8</div><div class="line">Accept-Encoding	gzip</div><div class="line">Accept-Language	en fr</div><div class="line"></div><div class="line">(en fr)</div><div class="line">utf-8</div></pre></td></tr></table></figure>
<p>同样，你也可以使用数组下标，只要你重写相应地方法。</p>
<p>关于为自定义的类添加下标这个问题， stackoverflow 上的回答是不需要在 handles 后面所跟的方法中添加 <code>self</code>。 他的解释如下:</p>
<h2 id="为自定义的类添加下标-subscripts-1"><a href="#为自定义的类添加下标-subscripts-1" class="headerlink" title="为自定义的类添加下标(subscripts)"></a><a href="http://stackoverflow.com/questions/36773986/how-to-add-subscripts-to-my-custom-class-in-perl-6" target="_blank" rel="external">为自定义的类添加下标(subscripts)</a></h2><p>在自定义类上实现关联式下标(associative subscripting)。</p>
<h3 id="通过代理实现"><a href="#通过代理实现" class="headerlink" title="通过代理实现"></a>通过代理实现</h3><p>Perl 6 通过在实现了集合类型的对象身上调用良定义的方法来实现关联式下标和位置下标（对于内置类型）。通过在 <code>%!fields</code> 属性后面添加 <code>handles</code> 特性(trait)， 你就把这些方法调用传递给了 <code>%!fields</code> – 它作为一个散列，会知道怎么来处理那些方法。</p>
<h3 id="灵活的键"><a href="#灵活的键" class="headerlink" title="灵活的键"></a>灵活的键</h3><blockquote>
<p>However, HTTP header field names are supposed to be case-insensitive (and preferred in camel-case). We can accommodate this by taking the *-KEY and push methods out of the handles list, and implementing them separately…</p>
</blockquote>
<p>把所有的键处理方法代理给内部的散列意味着你的键得到了散列那样的插值 – 意味着它们将是大小写无关的因为散列的键是大小写无关的。为了避免那，你把所有跟键有关的方法从 <em>handles</em> 子句中拿出并自己实现那些方法。在例子中，键在被索引到 <code>%!fields</code> 让键变成大小写无关之前先进行了键的「标准化」。</p>
<h3 id="灵活的值"><a href="#灵活的值" class="headerlink" title="灵活的值"></a>灵活的值</h3><p>例子中的最后一部分展示了当值存入到散列那样的容器中时你如何控制值的插值。到目前为止，通过赋值给这个自定义容器的实例提供的值要么是一个字符串，要么是一个字符串的数组。额外的控制是通过移除定义在灵活的键中的  <strong>AT-KEY</strong> 方法来达成的并提供一个 <strong><a href="https://doc.perl6.org/type/Proxy" target="_blank" rel="external">Proxy</a></strong> 对象来代替它。如果你给容器赋值，那么代理人对象的 <strong>STORE</strong> 方法会被调用并且那个方法会扫描所提供的字符串值中的 <code>&quot;, &quot;</code>（注意空格是必要的）。如果找到会接收那个字符串值作为几个字符串值的说明书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">class HTTPHeader &#123; ... &#125;</div><div class="line"></div><div class="line">class HTTPHeader does Associative  &#123;</div><div class="line">    </div><div class="line">    has %!fields  handles &lt;list kv keys values&gt;;</div><div class="line">    method Str &#123; say self.hash.fmt; &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    multi method EXISTS-KEY ($key)       &#123; %!fields&#123;normalize-key $key&#125;:exists &#125;</div><div class="line">    multi method DELETE-KEY ($key)       &#123; %!fields&#123;normalize-key $key&#125;:delete &#125;</div><div class="line">    multi method push (*@_)              &#123; %!fields.push: @_                   &#125;</div><div class="line"></div><div class="line">    sub normalize-key ($key) &#123; $key.subst(/\w+/, *.tc, :g) &#125;</div><div class="line"></div><div class="line">    method AT-KEY (::?CLASS:D: $key) is rw &#123;</div><div class="line">        my $element := %!fields&#123;normalize-key $key&#125;;</div><div class="line">        </div><div class="line">        Proxy.new(</div><div class="line">            FETCH =&gt; method () &#123; $element &#125;,</div><div class="line">            </div><div class="line">            STORE =&gt; method ($value) &#123;</div><div class="line">                $element = do given $value».split(/&apos;,&apos; \s+/).flat &#123;</div><div class="line">                    when 1  &#123; .[0] &#125;    # a single value is stored as a string</div><div class="line">                    default &#123; .Array &#125;  # multiple values are stored as an array</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">my $header = HTTPHeader.new;</div><div class="line">say $header.WHAT;  #-&gt; (HTTPHeader)</div><div class="line">&quot;&quot;.say;</div><div class="line"></div><div class="line">$header&lt;Accept&gt; = &quot;text/plain&quot;;</div><div class="line">$header&#123;&apos;Accept-&apos; X~ &lt;Charset Encoding Language&gt;&#125; = &lt;utf-8 gzip en&gt;;</div><div class="line">$header.push(&apos;Accept-Language&apos; =&gt; &quot;fr&quot;);  # like .push on a Hash</div><div class="line"></div><div class="line">say $header.hash.fmt;</div><div class="line">&quot;&quot;.say;</div><div class="line"># say $header.Str; # 同上</div><div class="line"></div><div class="line">say $header&lt;Accept-Language&gt;.values; </div><div class="line">say $header&lt;Accept-Charset&gt;;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(HTTPHeader)</div><div class="line"></div><div class="line">Accept	text/plain</div><div class="line">Accept-Charset	utf-8</div><div class="line">Accept-Encoding	gzip</div><div class="line">Accept-Language	en fr</div><div class="line"></div><div class="line">(en fr)</div><div class="line">utf-8</div></pre></td></tr></table></figure>
<p>同样，你也可以使用数组下标，只要你重写相应地方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Using-Perl-6(一)]]></title>
      <url>http://ohmycloud.github.io/2015/08/13/Using-Perl-6-%E4%B8%80/</url>
      <content type="html"><![CDATA[<hr>
<p>title: Using Perl 6<br>date: 2015-03-14 13:14<br>categories: Perl 6<br>tags:</p>
<ul>
<li>入门</li>
<li>基础<br>comments: true</li>
</ul>
<hr>
<h2 id="第一章-概要"><a href="#第一章-概要" class="headerlink" title="第一章 概要"></a>第一章 概要</h2><hr>
<p> Comming soon!</p>
<h2 id="第二章-基础"><a href="#第二章-基础" class="headerlink" title="第二章 基础"></a>第二章 基础</h2><hr>
<p>假设有一场乒乓球比赛，比赛结果以这种格式记录：<br>Player1 Player2 | 3:2<br>这意味着选手1与选手2的比分为3:2, 你需要一个脚本算出每位选手赢了几场比赛并且胜了几局。<br>输入数据（存储在一个叫做scores的文件中）像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Beth Ana Charlie Dave</div><div class="line">Ana Dave        | 3:0</div><div class="line">Charlie Beth    | 3:1</div><div class="line">Ana Beth        | 2:3</div><div class="line">Dave Charlie    | 3:0</div><div class="line">Ana Charlie     | 3:1</div><div class="line">Beth Dave       | 0:3</div></pre></td></tr></table></figure></p>
<p> 第一行是选手清单。随后每一行记录着比赛结果。</p>
<p>这里使用Perl6给出一种解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $file = open &apos;scores&apos;;</div><div class="line">my @names = $file.get.words ;  #get方法读入一行，每调用一次get，读取一行</div><div class="line"># &gt; @names.perl   #  Array.new(&quot;1&quot;, &quot;Beth&quot;, &quot;Ana&quot;, &quot;Charlie&quot;, &quot;Dave&quot;)</div><div class="line">my %matches;      # 赢得比赛次数</div><div class="line">my %sets;         # 赢得比赛局数</div><div class="line"></div><div class="line">for $file.lines -&gt; $line &#123;                       # .lines 是惰性的</div><div class="line">    my ($pairing, $result) = $line.split(&apos; | &apos;); # 对剩下的每一行调用split操作</div><div class="line">    my ($p1, $p2)          = $pairing.words;     # 提取选手1和选手2的名字</div><div class="line">    my ($r1, $r2)          = $result.split(&apos;:&apos;); # 提取比赛比分</div><div class="line"></div><div class="line">    %sets&#123;$p1&#125; += $r1;  # 选手1赢得的比赛局数</div><div class="line">    %sets&#123;$p2&#125; += $r2;  # 选手2赢得的比赛局数</div><div class="line"></div><div class="line">    if $r1 &gt; $r2 &#123; # 如果每场比赛中，选手1赢的局数多于选手2，则选手1赢得的比赛数+1，反之选手2的+1</div><div class="line">        %matches&#123;$p1&#125;++;</div><div class="line">    &#125; else &#123;</div><div class="line">        %matches&#123;$p2&#125;++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @sorted = @names.sort( &#123; %sets&#123;$_&#125; &#125; ).sort(&#123; %matches&#123;$_&#125; &#125; ).reverse;</div><div class="line"></div><div class="line">for @sorted -&gt; $n &#123;</div><div class="line">    say &quot;$n has won %matches&#123;$n&#125; matches and %sets&#123;$n&#125; sets&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Ana has won 2 matches and 8 sets</div><div class="line">Dave has won 2 matches and 6 sets</div><div class="line">Charlie has won 1 matches and 4 sets</div><div class="line">Beth has won 1 matches and 4 sets</div></pre></td></tr></table></figure>
<p>每个 Perl 6程序应该以 use v6;作为开始，它告诉编译器程序期望的是哪个版本的Perl。</p>
<p>在Perl6中，一个变量名以一个魔符打头，这个魔符是一个非字母数字符号，诸如$,@,%或者 &amp;,还有更少见的双冒号 ::<br>内置函数 open 打开了一个名叫 scores 的文件，并返回一个文件句柄，即一个代表该文件的对象。赋值符号=将句柄赋值给左边的变量，这意味着 $file 现在存储着该文件句柄。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @names = $file.get.words;</div></pre></td></tr></table></figure>
<p> 上边这句的右侧对存储在 $file 中的文件句柄调用了 get 方法， get 方法从文件中读取并返回一行，并去掉行的末尾。. words  也是一个方法，用于从get 方法返回的字符串上。.words 方法将它的组件–它操作的字符串，分解成一组单词，这里即意味着不含空格的字符串。它把单个字符串 ‘Beth Ana Charlie Dave’ 转换成一组字符串 ‘Beth’, ‘Ana’, ‘Charlie’, ‘Dave’.最后，这组字符串存储在数组@names中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %matches;</div><div class="line">my %sets;</div></pre></td></tr></table></figure>
<p>在比分计数程序中，%matches 存储每位选手赢得的比赛数。 %sets 存储每位选手赢得的比赛局数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for $file.lines -&gt; $line &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>for循环中 $file.lines 产生一组从文件 scores 读取的行，从上次 $file.lines 离开的地方开始，一直到文件末尾结束。<br>在第一次循环中， $line 会包含字符串 <code>Ana Dave | 3:0;</code> 在第二次循环中，$line 会包含 <code>Charlie Beth | 3:1</code>,以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my ($pairing, $result) = $line.split(&apos; | &apos;);</div></pre></td></tr></table></figure>
<p>split此处是一个方法，字符串 ‘|’ 是它的参数。</p>
<p>第一次循环结束：</p>
<pre><code>Variable       Contents
$line           &apos;Ana Dave | 3:0&apos;
$pairing        &apos;Ana Dave&apos;
$result         &apos;3:0&apos;
$p1             &apos;Ana&apos;
$p2             &apos;Dave&apos;
$r1              &apos;3&apos;
$r2              &apos;0&apos;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @sorted = @names.sort(&#123; %sets&#123;$_&#125; &#125;).sort(&#123; %matches&#123;$_&#125; &#125;).reverse;</div></pre></td></tr></table></figure>
<p>这一句是排序，先按比赛局数多少排序，再按赢得的比赛数排序，然后反转。<br>打印选手名字的时候以胜负次序排序，代码必须使用选手的分数，而非他们的名字来进行排序。sort 方法的参数是一个代码块，用于将数组元素（选手的名字）转换成用于排序的数据。数组的元素通过变量 $_ 传递到代码块中。</p>
<p>最简单的使用分数排序选手的方法应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@names.sort( &#123; %matches&#123;$_&#125; &#125; )</div></pre></td></tr></table></figure>
<p>这是通过使用赢得比赛的次数来进行排序。然而，Ana和Dave都赢了两场比赛。还需要比较谁赢的的比赛局数多，才能决定比赛的排名。</p>
<p>在双引号括起的字符串中，标量和花括号中的变量能进行变量插值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $names = &apos;things&apos;;</div><div class="line">say &apos;Do not call me $names&apos;;   # Do not call me $names</div><div class="line">say &quot;Do not call me $names&quot;; # Do not call me things</div></pre></td></tr></table></figure>
<p>花括号中的数组进行插值后会变成用空格分隔的条目。花括号中的散列插值后每个散列键值对单独成为一行，每行包含一个健，随后是一个tab符号，然后是键值，最后是一个新行符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">TODO: explain &lt;...&gt; quote-words</div><div class="line"> say &quot;Math: &#123; 1 + 2 &#125;&quot;     # Math: 3</div><div class="line"> my @people = &lt;Luke Matthew Mark&gt;;</div><div class="line"> say &quot;The synoptics are: &#123;@people&#125;&quot; # The synoptics are: Luke Matthew Mark</div><div class="line"></div><div class="line"> say &quot;&#123;%sets&#125;&quot;; # From the table tennis tournament</div><div class="line"></div><div class="line"> # Charlie 4</div><div class="line"> # Dave 6</div><div class="line"> # Ana 8</div><div class="line"> # Beth 4</div></pre></td></tr></table></figure>
<p>当数组和散列变量直接出现在双引号字符串中（并且不在花括号{}里），它们只在它们的名字后跟着一个 postcircumfix —-一对括号，后面跟着语句时才会进行插值。在变量名和后置环缀之间进行方法调用也是可以的（ 例如  @flavours.sort() ）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">my @flavours = &lt;vanilla peach&gt;;</div><div class="line"></div><div class="line">say &quot;we have @flavours&quot;;    # we have @flavours ，这里没进行插值</div><div class="line">say &quot;we have @flavours[0]&quot;; # we have vanilla，后置环缀，变量名字后面跟着一对儿括号</div><div class="line"># so-called &quot;Zen slice&quot;</div><div class="line">say &quot;we have @flavours[]&quot;;  # we have vanilla peach</div><div class="line"></div><div class="line"># 以后置环缀结尾的方法调用</div><div class="line">say &quot;we have @flavours.sort()&quot;; # we have peach vanilla</div><div class="line"></div><div class="line"># 链式方法调用:</div><div class="line">say &quot;we have @flavours.sort.join(&apos;, &apos;)&quot;;</div><div class="line"># we have peach, vanilla</div></pre></td></tr></table></figure>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><hr>
<p>例子中的第一行选手的名字是多余的，你可以在参加比赛的选手中找出所有选手的名字！ 如果例子中的第一行被省略了，你如何更改程序？提示：%hash.keys 返回散列 %hash中的所有键。</p>
<p>答案: 移除此行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @names = $file.get.words;</div></pre></td></tr></table></figure>
<p>并且将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @sorted = @names.sort(&#123; %sets&#123;$_&#125; &#125;).sort(&#123; %matches&#123;$_&#125; &#125;).reverse;</div></pre></td></tr></table></figure>
<p>变成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @sorted = %sets.keys.sort(&#123; %sets&#123;$_&#125; &#125;).sort(&#123; %matches&#123;$_&#125; &#125;).reverse;</div></pre></td></tr></table></figure>
<p>. 除了移除冗余，你也可以用它来提醒我们，如果一个选手没有在第一行的名字清单中被提到，例如因为输入错误，你该怎样修改你的程序？</p>
<p>答案:引入另外一个散列，合法选手的名字作为键，当读取选手名字的时候查找该散列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my @names = $file.get.split(&apos; &apos;);</div><div class="line">my %legitimate-players;</div><div class="line">for @names -&gt; $n &#123;      #  -&gt; 两侧要有空格</div><div class="line">    %legitimate-players&#123;$n&#125; = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> …</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">for $file.lines -&gt; $line &#123;</div><div class="line">my ($pairing, $result) = $line.split(&apos; | &apos;);</div><div class="line">my ($p1, $p2)          = $pairing.split(&apos; &apos;);</div><div class="line">   for $p1, $p2 -&gt; $p &#123;</div><div class="line">       if !%legitimate-players&#123;$p&#125; &#123;</div><div class="line">           say &quot;Warning: &apos;$p&apos; is not on our list!&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第三章-操作符"><a href="#第三章-操作符" class="headerlink" title="第三章 操作符"></a>第三章 操作符</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @scores = &apos;Ana&apos; =&gt; 8, &apos;Dave&apos; =&gt; 6, &apos;Charlie&apos; =&gt; 4, &apos;Beth&apos; =&gt; 4;</div><div class="line">my $screen-width = 30;</div><div class="line"></div><div class="line">my $label-area-width = 1 + [max] @scores».key».chars;</div><div class="line">my $max-score = [max] @scores».value;</div><div class="line">my $unit = ($screen-width - $label-area-width) / $max-score;</div><div class="line">my $format = &apos;%- &apos; ~ $label-area-width ~ &quot;s%s\n&quot;;</div><div class="line"></div><div class="line">for @scores &#123;</div><div class="line">    printf $format, .key, &apos;X&apos; x ($unit * .value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们计算一下每位选手在竞标赛中赢得比赛的局数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @scores = &apos;Ana&apos; =&gt; 8, &apos;Dave&apos; =&gt; 6, &apos;Charlie&apos; =&gt; 4, &apos;Beth&apos; =&gt; 4;</div></pre></td></tr></table></figure>
<p>这一句局包含了三个不同的操作符=和 =&gt;和 ,<br>以字符串连接操作符~为例， $string ~= “text” 等价于 $string = $string ~”text”.</p>
<p>=&gt; 操作符（大键号）创建了一个键值对对象，一个键值对存储着键和值；键在 =&gt; 操作符的左侧，值在右侧。这个操作符有一个特殊的特性：编译器会把 =&gt;操作符左侧的任何裸标识符解释为一个字符串。你也可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @scores = Ana =&gt; 8, Dave =&gt; 6, Charlie =&gt; 4, Beth =&gt; 4;</div></pre></td></tr></table></figure>
<p>最后逗号操作符 , 构建了一个对象序列，在该情况下，所谓的对象就是键值对。</p>
<p>这三个操作符都是中缀操作符，这意味着它在两个条目之间。</p>
<p>一个项前面可以有0个或多个前缀操作符，所以你可以写比如 4 + -5。+ 号（一个中缀操作符）的后面，编译器期望一个项，为了将 - 号解释为项 5 的一个前缀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $label-area-width = 1 + [max] @scores».key».chars;</div></pre></td></tr></table></figure>
<p>» 是一个特殊的符号，打印不出来可以用两个大于号&gt;&gt;代替。<br>中缀操作符 max 返回两个值中的较大者，所以 2 max 3 返回 3。方括号包裹着一个中缀操作符让Perl将该中缀操作符应用到列表中的元素之间。[max] 1,5,3,7 和 1 max 5 max 3 max 7 一样，结果都为7.</p>
<p>同样地，[+]用来计算列表元素的和，[*]用来计算列表元素的积，[&lt;=]用来检查一个列表的值是否按递增排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@scores».key».chars</div><div class="line">my @scores = Ana =&gt; 8, Dave =&gt; 6, Charlie =&gt; 4, Beth =&gt; 4;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ana     8 Dave  6 Charlie       4 Beth  4</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@scores.key</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Method &apos;key&apos; not found for invocant of class &apos;Array&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@scores&gt;&gt;.key</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ana Dave Charlie Beth</div></pre></td></tr></table></figure>
<p>就像@variable.method 在@variable上调用一个方法一样，@array».method 对@array中的每一项调用method方法，并且返回一个返回值的列表。即@scores&gt;&gt;.key返回一个列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@scores&gt;&gt;.key&gt;&gt;.chars  #每个名字含有几个字符</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4 7 4</div></pre></td></tr></table></figure>
<p>表达式 [max] @scores».key».chars 给出(3,4,7,4)中的最大值。它与下面的表达式相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@scores[0].key.chars</div><div class="line">max @scores[1].key.chars</div><div class="line">max @scores[2].key.chars</div><div class="line">max ...</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@scores[0]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;Ana&quot; =&gt; 8</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@scores[0].key</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ana</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $format = &apos;%- &apos; ~ $label-area-width ~ &quot;s%s\n&quot;;</div><div class="line">for @scores &#123;</div><div class="line">    printf $format, .key, &apos;X&apos; x ($unit * .value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义一个格式，%-表示左对齐，~是字符串连接操作符.for循环中，@scores中的每一项被绑定给特殊变量$_, .key是每项的键，即名字， .value是每项的键值，即得分。小 x 是字符串重复操作符。</p>
<h3 id="关于优先级的的一句话"><a href="#关于优先级的的一句话" class="headerlink" title="关于优先级的的一句话"></a>关于优先级的的一句话</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @scores = &apos;Ana&apos; =&gt; 8, &apos;Dave&apos; =&gt; 6, &apos;Charlie&apos; =&gt; 4, &apos;Beth&apos; =&gt; 4;</div></pre></td></tr></table></figure>
<p>等号右侧产生一个列表（因为逗号，操作符），这个列表由对儿组成（因为 =&gt;）,并且结果赋值给数组变量。<br>在Perl5中会这样解释:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(my @scores = &apos;Ana&apos;) =&gt; 8, &apos;Dave&apos; =&gt; 6, &apos;Charlie&apos; =&gt; 4, &apos;Beth&apos; =&gt; 4;</div></pre></td></tr></table></figure>
<p>以至于数组@scores中只有一个项，表达式的其余部分被计算后丢弃。</p>
<p>优先级规则控制着编译器如何解释这一行。Perl 6的优先级规则申明 中缀操作符 =&gt; 比 , 中缀操作符对于参数的绑定更紧，而逗号操作符比 等号赋值操作符绑定的更紧。</p>
<p>实际上有两种不同优先级的赋值操作符。当赋值操作符右侧是一个标量时，使用较紧优先级的项赋值操作符，否则使用较松优先级的列表赋值操作符。（如同螺丝的松紧）<br>比较 $a = 1, $b = 2 和@a = 1, 2，前者是在一个列表中赋值给两个变量，后者是将含有两个项的一个列表赋值给一个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say 5 - 7 / 2; # 5 - 3.5 = 1.5</div><div class="line">say (5 - 7) / 2; # (-2) / 2 = -1</div></pre></td></tr></table></figure>
<p>Perl 6 中的优先级可以用圆括号改变，但是如果圆括号直接跟在标识符的后面而不加空格的话，则会被解释为参数列表。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say(5 - 7) / 2; # -2</div></pre></td></tr></table></figure>
<p>只打印出了 5-7 的值。</p>
<pre><code>          优先级表
Example             Name
(), 42.5            (tightest precedence)
42.rand                term
$x++                method calls and postcircumĕxes
$x**2                autoincrement and autodecrement
?$x, !$x            exponentiation operator
+$x, ~$x            boolean preĕx
2*3, 7/5            preĕx context operators
1+2, 7-5            multiplicative inĕx operators
$a x 3                additive inĕx operators
$x ~&quot;.nn&quot;            replication operators
1&amp;2                    string concatenation
1|2                    junctive AND
abs $x                junctive OR
$x cmp 3            named unary preĕx
$x == 3                non-chaining binary operators
$x &amp;&amp; $y            chaining binary operators
$x || $y            tight AND inĕx
$x &gt; 0 ?? 1 !! -1    tight OR inĕx
$x = 1                conditional operator
not $x                item assignment
1, 2                loose unary preĕx
1, 2 Z @a            comma
@a = 1, 2            list inĕx
$x and say &quot;Yes&quot;    list preĕx, list assignment
$x or die &quot;No&quot;        loose AND inĕx
;                    loose OR inĕx
                    statement terminator
                    (loosest precedence)
</code></pre><h3 id="比较和智能匹配"><a href="#比较和智能匹配" class="headerlink" title="比较和智能匹配"></a>比较和智能匹配</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">my @a = 1, 2, 3;</div><div class="line">my @b = 1, 2, 3;</div><div class="line">say @a === @a; # Bool::True</div><div class="line">say @a === @b; # Bool::False</div><div class="line"># these use identity for value</div><div class="line">say 3 === 3 # Bool::True</div><div class="line">say &apos;a&apos; === &apos;a&apos;; # Bool::True</div><div class="line">my $a = &apos;a&apos;;</div><div class="line">say $a === &apos;a&apos;; # Bool::True</div></pre></td></tr></table></figure>
<pre><code>@b===@a
</code></pre><p>False<br>    @a eqv @b</p>
<p>True<br>    ‘2’ eqv 2</p>
<p>False</p>
<p>只有当两个对象有相同的类型和相同的结构时， eqv 操作符才返回 True。在前面定义的例子中，@a  eqv  @b 结果为 True， 因为 @a 和 @b 各自包含相同的值，另一方面， ‘2’ eqv 2 返回 ‘False’ ,因为一个参数是字符串，另一个是整数，类型不相同。</p>
<h4 id="数字比较"><a href="#数字比较" class="headerlink" title="数字比较"></a>数字比较</h4><hr>
<p>使用 == 中缀操作符查看两个对象是否有相同的数字值。如果某个对象不是数字，Perl 会在比较之前尽力使其数字化。如果没有更好的方式将对象转换为数字，Perl 会使用默认的数字 0 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say 1 == 1.0;  # Bool::True</div><div class="line">say 1 == &apos;1&apos;;  # Bool::True</div><div class="line">say 1 == &apos;2&apos;;  # Bool::False</div><div class="line">say 3 == &apos;3b&apos;; # fails</div></pre></td></tr></table></figure>
<p>跟数字比较相关的还有 &lt;,&lt;=,&gt;,&gt;= 。如果两个对象的数字值不同，使用 != 会返回 True 。</p>
<p>如果你将数组或列表作为数字，它会计算列表中项的个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my @colors = &lt;red blue green&gt;;</div><div class="line"> if @colors == 3 &#123;</div><div class="line">     say &quot;It&apos;s true, @colors contains 3 items&quot;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><hr>
<p>Perl 6 中使用 eq 比较字符串，必要时会将其参数转换为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if $greeting eq &apos;hello&apos; &#123;</div><div class="line">   say &apos;welcome&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Table 3.2: Operators and Comparisons</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">数字比较	字符串比较	意思</div><div class="line">------------------------------------------</div><div class="line">==	      eq	        等于</div><div class="line">!=	      ne	        不等于</div><div class="line">!==	  !eq	        不等于</div><div class="line">&lt;	      lt	        小于</div><div class="line">&lt;=	      le	        小于或等于</div><div class="line">&gt;	      gt	        大于</div><div class="line">&gt;=	      ge	        大于或等于</div></pre></td></tr></table></figure>
<p>例如，’a’ lt ‘b’ 为 true，’a’ lt ‘aa’ 也为 true。 != 是 !==的便捷形式，它实际是 ! 元操作符加在 中缀操作符 ==之前。同样地， ne 和 !eq 是一样的。</p>
<p>三路操作符</p>
<p>三路操作符有两个操作数，如果左侧较小，返回 Order::Increase ，两侧相等则返回 Order::Same，如果右侧较小则返回 Order::Decrease。对于数字使用 三路操作符 &lt;=&gt; ,对于字符串，使用三路操作符 leg （取自 lesser，equal，greater）。中缀操作符 cmp 是一个对类型敏感的三路操作符，它像 &lt;=&gt; 一样比较数字，像 leg 一样比较字符串，（举例来说）并且比较键值对儿时，先比较键，如果键相同再比较键值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say 10 &lt;=&gt; 5;     # +1</div><div class="line">say 10 leg 5;     # because &apos;1&apos; lt &apos;5&apos;</div><div class="line">say &apos;ab&apos; leg &apos;a&apos;; # +1, lexicographic comparison</div></pre></td></tr></table></figure>
<p>三路操作符的典型用处就是用在排序中。列表中的.sort 方法能使用一个含有两个值的块或一个函数，比较它们，并返回一个小于，等于或大于 0 的值。 sort  方法根据该返回值进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">say ~&lt;abstract Concrete&gt;.sort;</div><div class="line"># output: Concrete abstract</div><div class="line"></div><div class="line">say ~&lt;abstract Concrete&gt;.sort:  -&gt; $a, $b &#123; uc($a) leg uc($b) &#125;;</div><div class="line"># output: abstract Concrete</div></pre></td></tr></table></figure>
<p>默认的，比较是大小写敏感的，通过比较它们的大写变形，而不是比较它们的值，这个例子使用了大小写敏感排序。</p>
<h4 id="智能匹配"><a href="#智能匹配" class="headerlink" title="智能匹配"></a>智能匹配</h4><hr>
<p>使用 ~~ 做正确的事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if $pints-drunk ~~ 8 &#123;</div><div class="line">   say &quot;Go home, you&apos;ve had enough!&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if $country ~~ &apos;Sweden&apos; &#123;</div><div class="line">    say &quot;Meatballs with lingonberries and potato moose, please.&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">unless $group-size ~~ 2..4 &#123;</div><div class="line">    say &quot;You must have between 2 and 4 people to book this tour.&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>智能匹配总是根据 ~~右侧值的类型来决定使用哪种比较。上个例子中，比较的是数字、字符串和范围。<br>智能匹配的工作方式 $answer ~~ 42 等价于 42.ACCPETS( $answer ).对 ~~ 操作符右侧的操作数调用 ACCEPTS 方法，并将左操作数作为参数传入。</p>
<h2 id="第四章-子例程和签名"><a href="#第四章-子例程和签名" class="headerlink" title="第四章 子例程和签名"></a>第四章 子例程和签名</h2><hr>
<p>一个子例程就是一段执行特殊任务的代码片段。它可以对提供的数据（<code>实参</code>）操作，并产生结果（返回值）。子例程的签名是它<code>所含的参数</code>和它产生的<code>返回值</code>的描述。从某一意义上来说，第三章描述的操作符也是Perl 6用特殊方式解释的子例程。</p>
<h3 id="申明子例程"><a href="#申明子例程" class="headerlink" title="申明子例程"></a>申明子例程</h3><hr>
<p> 一个子例程申明由几部分组成。首先， <code>sub</code>表明你在申明一个子例程，然后是可选的子例程的名称和<code>可选的签名</code>。子例程的主体是一个用花括号扩起来的代码块。<br>默认的，子例程是本地作用域的，就像任何使用 <code>my</code> 申明的变量一样。这意味着，一个子例程只能在它被申明的作用域内被调用。使用 <code>our</code> 来申明子例程可以使其在<code>当前包</code>中可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">our sub eat() &#123;</div><div class="line">    say &quot;om nom nom&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub drink() &#123;</div><div class="line">    say &quot;glug glug&quot;;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">our &amp;eat; # makes the package-scoped sub eat available in this lexical scope</div><div class="line"></div><div class="line">eat(); # om nom nom</div><div class="line">drink(); # 失败, can&apos;t drink outside of the block</div></pre></td></tr></table></figure>
<p>our 也能让子例程从包或模块的外部是可见的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module EatAndDrink &#123;</div><div class="line">    our sub eat() &#123;</div><div class="line">    say &quot;om nom nom&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub drink() &#123;</div><div class="line">    say &quot;glug glug&quot;;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">EatAndDrink::eat(); # om nom nom</div><div class="line">EatAndDrink::drink(); # fails, not declared with &quot;our&quot;</div></pre></td></tr></table></figure>
<p>你也可以<code>导出</code>一个子例程，让它在另外的作用域内可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># in file Math/Trivial.pm</div><div class="line"># TODO: find a better example</div><div class="line"># TODO: explain modules, search paths</div><div class="line">module Math::Trivial &#123;</div><div class="line">    sub double($x) is export &#123;</div><div class="line">    return 2 * $x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在其它程序或模块中你可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use Math::Trivial; # imports sub double</div><div class="line">say double(21); # 21 is only half the truth</div></pre></td></tr></table></figure>
<p>Perl 6的子例程都是对象。你可以将它们随意传递并存储在数据结构中。编程语言设计者常常将它们称之为first-class 子例程；它们就像数组和散列一样作为语言的基础。</p>
<p>First-class 子例程能帮助你解决复杂的问题。例如，为了做出一个微型的ASCII艺术舞蹈图，你可能要建立一个散列，键是舞蹈动作的名称，键值是匿名散列。假使使用者能键入一系列舞蹈动作（可能是站在舞蹈平台上或其它外部输入设备）。 你怎么保持一个变量清单中都是合法的行为，允许使用者输入，并限制输入是一系列安全的行为呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">my %moves =</div><div class="line">hands-over-head       =&gt; sub &#123; say &apos;/o\ &apos;  &#125;,</div><div class="line">bird-arms             =&gt; sub &#123; say &apos;|/o\| &apos;&#125;,</div><div class="line">left                  =&gt; sub &#123; say &apos;&gt;o &apos;   &#125;,</div><div class="line">right                 =&gt; sub &#123; say &apos;o&lt; &apos;   &#125;,</div><div class="line">arms-up               =&gt; sub &#123; say &apos;\o/ &apos;  &#125;;</div><div class="line"></div><div class="line">my @awesome-dance = &lt;arms-up bird-arms right hands-over-head&gt;;</div><div class="line"></div><div class="line">for @awesome-dance -&gt; $move &#123;</div><div class="line">    %moves&#123;$move&#125;.();  # 在散列上调用方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>outputs:
 \o/
|/o\|
  o&lt;
 /o\.
</code></pre><h3 id="Adding-Signatures"><a href="#Adding-Signatures" class="headerlink" title="Adding Signatures"></a>Adding Signatures</h3><hr>
<p><strong>添加签名</strong></p>
<p>子例程的签名执行两个任务。首先，它申明哪个调用者可能或必须将参数传递给子例程。第二，它申明子例程中的变量被绑定到哪些参数上。这些变量叫做参数。Perl 6的签名更深入，它们允许你<code>限制参数的类型</code>，值和参数的定义，并准确匹配复杂数据结构的某一部分。此外，它们也允许你显式地指定子例程返回值的类型。</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><hr>
<p>签名最简单的形式是，绑定到输入参数上的用逗号分隔的一列变量的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub order-beer($type, $pints) &#123;</div><div class="line">   say ($pints == 1 ?? &apos;A pint&apos; !! &quot;$pints pints&quot;) ~ &quot; of $type, please.&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">order-beer(&apos;Hobgoblin&apos;, 1);    # A pint of Hobgoblin, please.</div><div class="line">order-beer(&apos;Zlatý Bažant&apos;, 3);  # 3 pints of Zlatý Bažant, please.</div></pre></td></tr></table></figure>
<p>这里使用的关系绑定而非赋值就是签名。默认地，在Perl6 中，子例程中引用到传入参数的签名的变量是<code>只读</code>的。这意味着你<code>不能</code>从子例程内部<code>修改</code>它们。<br>如果只读绑定太受限制了，你可以将 <code>is rw</code> (rw是read/write的缩写) 特性应用到参数上以降低这种限制。这个特性说明参数是可读可写的，这允许你从子例程内部修改参数。使用的时候必须小心，因为它会<code>修改</code>传入的原始对象。如果你试图传入一个字面值，一个常量，或其它类型的不可变对象到一个有 <code>is rw</code>  特性的参数中，绑定会在调用时失败并抛出异常:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sub make-it-more-so($it is rw) &#123;</div><div class="line">    $it ~= substr($it, $it.chars - 1) x 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $happy = &quot;yay!&quot;;</div><div class="line">make-it-more-so($happy);</div><div class="line">say $happy; # yay!!!!!!   # 原始传入对象被修改了</div><div class="line">make-it-more-so(&quot;uh-oh&quot;); # 失败，不能修改一个常量</div></pre></td></tr></table></figure></p>
<p>如果你想将参数的本地副本用在子例程内部而不改变调用者的变量，—-使用 <code>is copy</code> 特性：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub say-it-one-higher($it is copy) &#123;</div><div class="line">    $it++;</div><div class="line">    say $it;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $unanswer = 41;</div><div class="line">say-it-one-higher($unanswer); # 42</div><div class="line">say-it-one-higher(41); # 42</div><div class="line">$unanswer;  #41</div></pre></td></tr></table></figure></p>
<p>在诸如C/C++ and Scheme等其它类型的编程语言中,这种广为人知的求值策略就是“按值传递”。当使用 <code>is copy</code>特性时，只有本地副本被赋值。其它任何传递给子例程的参数在调用者的作用域内保持不变。（一个不可变对象是当这个对象被创建后，它的状态不会改变，作为比较，一个可变对象的状态在创建后是会被改变的）</p>
<h4 id="传递数组、散列和代码"><a href="#传递数组、散列和代码" class="headerlink" title="传递数组、散列和代码"></a>传递数组、散列和代码</h4><hr>
<p>一个变量的魔符表明它的本意用途。在签名中，变量的魔符也起着限制传入的参数类型的作用。例如， @ 符号检查传入的对象行使位置角色（一个角色包含像数组和列表的类型）。如果传递的东西不能匹配这样的限制，会引起调用失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sub shout-them(@words) &#123;</div><div class="line">    for @words -&gt; $w &#123;</div><div class="line">        print uc(&quot;$w &quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @last_words = &lt;do not want&gt;;</div><div class="line"></div><div class="line">shout-them(@last_words); # DO NOT WANT</div><div class="line">shout-them(&apos;help&apos;); # Fails; a string is not Positional  字符串不是位置参数</div></pre></td></tr></table></figure>
<p>类似地， % 符号表明调用者必须传递一个行使关系角色的对象；即允许通过&lt;…&gt;或{…} 进行索引的东西。 &amp; 符号要求调用者传递一个诸如匿名散列之类的行使能调用的角色的对象。在那种情况下，你也可以不用 &amp; 符号调用可调用的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sub do-it-lots(&amp;it, $how-many-times) &#123;</div><div class="line">    for 1..$how-many-times &#123;</div><div class="line">        it();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">do-it-lots(sub &#123; say &quot;Eating a stroopwafel&quot; &#125;, 10);   #此处是一个匿名子例程</div></pre></td></tr></table></figure>
<p>标量使用 $ 符号，并表明没有限制。什么都可以绑定在它上面，即使它使用另外的符号绑定到一个对象上。</p>
<h4 id="插值、数组和散列"><a href="#插值、数组和散列" class="headerlink" title="插值、数组和散列"></a>插值、数组和散列</h4><hr>
<p>有时你想从数组中填充占位参数。你可以通过在数组前添加一个垂直竖条或管道字符 ( <code>|</code> ): eat(|@food)    而不是写作eat(@food[0],@food[1], @food[2], …) 等将它们吸进参数列表( | 像不像一个吸管, ^_^)。</p>
<p>同样地，你可以将散列插值进具名参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sub order-shrimps($count, :$from) &#123;</div><div class="line">    say &quot;I&apos;d like $count pieces of shrimp from the $from, please&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my %user-preferences = from =&gt; &apos;Northern Sea&apos;;</div><div class="line"></div><div class="line">order-shrimps(3, |%user-preferences);</div><div class="line"># I&apos;d like 3 pieces of shrimp from the Northern Sea, please</div></pre></td></tr></table></figure>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><hr>
<p>为使参数可选，要么给签名的参数赋值为默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub order-steak($how = &apos;medium&apos;) &#123;</div><div class="line">    say &quot;I&apos;d like a steak, $how&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">order-steak();</div><div class="line">order-steak(&apos;well done&apos;);</div></pre></td></tr></table></figure>
<p>或者在参数名字的后面添加一个问号(?):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub order-burger($type, $side?) &#123;</div><div class="line">    say &quot;I&apos;d like a $type burger&quot; ~</div><div class="line">    ( defined($side) ?? &quot; with a side of $side&quot; !! &quot;&quot; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">order-burger(&quot;triple bacon&quot;, &quot;deep fried onion rings&quot;);</div></pre></td></tr></table></figure>
<p>如果没有参数被传递，参数会被绑定成一个未定义的值。 defined(…) 函数用来检查是否有值。</p>
<h4 id="强制参数"><a href="#强制参数" class="headerlink" title="强制参数"></a>强制参数</h4><hr>
<p>默认地，位置参数是必不可少的。然而，你可以通过在参数后面追加一个感叹号来显式地指定该参数是必须的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub order-drink($size, $flavor!) &#123;</div><div class="line">    say &quot;$size $flavor, coming right up!&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">order-drink(&apos;Large&apos;, &apos;Mountain Dew&apos;); # OK</div><div class="line">order-drink(&apos;Small&apos;); # Error</div></pre></td></tr></table></figure>
<h4 id="具名实参和形参"><a href="#具名实参和形参" class="headerlink" title="具名实参和形参"></a>具名实参和形参</h4><hr>
<ul>
<li>arguments  实参</li>
<li>parameters 形参</li>
</ul>
<p>当一个子例程有很多参数时，调用者很难记清传递参数的顺序。这种情况下，通过<code>名字</code>传递参数往往更容易。这样，参数出现的顺序就无关紧要了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub order-beer($type, $pints) &#123;</div><div class="line">    say ($pints == 1 ?? &apos;A pint&apos; !! &quot;$pints pints&quot;) ~ &quot; of $type, please.&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">order-beer(type =&gt; &apos;Hobgoblin&apos;, pints =&gt; 1);</div><div class="line"># A pint of Hobgoblin, please.</div><div class="line"></div><div class="line">order-beer(pints =&gt; 3, type =&gt; &apos;Zlatý Bažant&apos;);</div><div class="line"># 3 pints of Zlatý Bažant, please.</div></pre></td></tr></table></figure>
<p>你也可以指定参数只能按名字被传递（这意味着它不允许按位置传递）。这样的话，在参数名字前加一个<code>冒号</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sub order-shrimps($count, :$from = &apos;Northern Sea&apos;) &#123;</div><div class="line">    say &quot;I&apos;d like $count pieces of shrimp from the $from, please&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">order-shrimps(6);    # takes &apos;Northern Sea&apos;</div><div class="line">order-shrimps(4, from =&gt; &apos;Atlantic Ocean&apos;);</div><div class="line">order-shrimps(22, &apos;Mediterranean Sea&apos;);   # 不允许, :$from is named only</div></pre></td></tr></table></figure>
<p>不像位置参数，命名参数默认是可选的。在命名参数后面追加一个 ! 号使命名参数强制性存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub design-ice-cream-mixture($base = &apos;Vanilla&apos;, :$name!) &#123;</div><div class="line">    say &quot;Creating a new recipe named $name!&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">design-ice-cream-mixture(name =&gt; &apos;Plain&apos;);</div><div class="line">design-ice-cream-mixture(base =&gt; &apos;Strawberry chip&apos;); # 错误,没有指定 $name</div></pre></td></tr></table></figure>
<p><strong>重命名参数</strong></p>
<p>因为按名字传递实参给形参是合理的, 形参的名字应该应该作为子例程公共 API 的一部分被考虑在内. 小心地挑选它们吧! 有时候, 使用一个名字暴露形参而使用另外一个名字绑定到变量会很方便:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub announce-time(:dinner($supper) = &apos;8pm&apos;) &#123;</div><div class="line">    say &quot;We eat dinner at $supper&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">announce-time(dinner =&gt; &apos;9pm&apos;); # We eat dinner at 9pm</div></pre></td></tr></table></figure>
<p>参数可以有多个名字，如果你的用户有些是英国人，有些是美国人，你可能这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sub paint-rectangle(</div><div class="line">    :$x = 0,</div><div class="line">    :$y = 0,</div><div class="line">    :$width = 100,</div><div class="line">    :$height = 50,</div><div class="line">    :color(:colour($c))) &#123;</div><div class="line"></div><div class="line">    # print a piece of SVG that represents a rectangle</div><div class="line">    say qq[&lt;rect x=&quot;$x&quot; y=&quot;$y&quot; width=&quot;$width&quot; height=&quot;$height&quot; &gt;]</div><div class="line">&#125;</div><div class="line"></div><div class="line"># both calls work the same</div><div class="line">paint-rectangle :color&lt;Blue&gt;;</div><div class="line">paint-rectangle :colour&lt;Blue&gt;;</div><div class="line"></div><div class="line"># of course you can still fill the other options</div><div class="line">paint-rectangle :width(30), :height(10), :colour&lt;Blue&gt;;</div></pre></td></tr></table></figure>
<p><strong>可选的命名参数语法</strong></p>
<p>命名变量通常是成对的（键值对）。写一个 <code>Pairs</code> 有多种方式。各种方法的不同之处就是清晰性，因为每种选择提供不同的引述机制。下面的三种调用是一样的意思：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">announce-time(dinner =&gt; &apos;9pm&apos;);</div><div class="line">announce-time(:dinner(&apos;9pm&apos;));</div><div class="line">announce-time(:dinner&lt;9pm&gt;);</div></pre></td></tr></table></figure>
<p>如果传递的是布尔值，你可以省略键值对的键值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">toggle-blender( :enabled); # enables the blender 开启果汁机</div><div class="line">toggle-blender(:!enabled); # disables the blender 关闭果汁机</div></pre></td></tr></table></figure>
<p>形如 <code>:name</code> 但不带值的命名参数有一个隐式的布尔真值 <code>Bool::True</code>. 它的对立形式是 <code>:!name</code> , 其值是隐式的布尔假值 <code>Bool::false</code>. 如果你使用变量创建了一个 <code>pair</code>, 你可以将变量名作为 <code>pair</code> 的键复用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $dinner = &apos;9pm&apos;;</div><div class="line">announce-dinner :$dinner; # same as dinner =&gt; $dinner;</div></pre></td></tr></table></figure>
<pre><code>                        Pair forms and their meanings.

    Shorthand      Long form                          Description
:allowed           allowed =&gt; Bool::True               Boolean flag
:!allowed          allowed =&gt; Bool::False              Boolean flag
:bev&lt;tea coffee&gt;   bev =&gt; (&apos;tea&apos;, &apos;coffee&apos;)            List
:times[1, 3]       times =&gt; [1, 3]                     Array
:opts{ a =&gt; 2 }    opts =&gt; { a =&gt; 2 }                  Hash
:$var              var =&gt; $var Scalar                  variable
:@var              var =&gt; @var Array                   variable
:%var              var =&gt; %var Hash                    variable
:&amp;var              vaf =&gt; &amp;var Callable/ Subroutine    variable
</code></pre><p>你可以使用在任何可以使用 Pair 对象的上下文使用表中的任意一种形式. 例如, 生成散列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># TODO: better example</div><div class="line">my $black = 12;</div><div class="line">my %color-popularities = :$black, :blue(8), red =&gt; 18, :white&lt;0&gt;;</div><div class="line"></div><div class="line"># 与此相同：</div><div class="line"># my %color-popularities =</div><div class="line"># black =&gt; 12,</div><div class="line"># blue =&gt; 8,</div><div class="line"># red =&gt; 18,</div><div class="line"># white =&gt; 0;</div></pre></td></tr></table></figure>
<p>最后, 通过位置而非名字传递一个已存在的 Pair 对象到子例程中, 要么把它放在圆括号中 ( 就像 (:$thing) ), 或者使用 =&gt; 操作符引起左侧的字符串: “thing” =&gt; $thing.</p>
<p><strong>参数的顺序</strong></p>
<p>当位置参数和命名参数都出现在签名中时，所有的位置参数都要出现在命名参数之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub mix(@ingredients, :$name)    &#123; ... &#125; # OK</div><div class="line">sub notmix(:$name, @ingredients) &#123; ... &#125; # Error</div></pre></td></tr></table></figure>
<p>必须的位置参数要在可选的位置参数之前。然而，命名参数没有这种限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sub copy-machine($amount, $size = &apos;A4&apos;, :$color!, :$quality) &#123; ... &#125; # OK</div><div class="line">sub fax-machine($amount = 1, $number) &#123; ... &#125; # Error</div></pre></td></tr></table></figure>
<h4 id="Slurpy-参数"><a href="#Slurpy-参数" class="headerlink" title="Slurpy 参数"></a>Slurpy 参数</h4><hr>
<p>有时候，你会希望让子例程接受任何数量的参数，并且将所有这些参数收集到一个数组中。为了达到这个目的，给签名添加一个数组参数，就是在数组前添加一个 * 号前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub shout-them(*@words) &#123;</div><div class="line">    for @words -&gt; $w &#123;</div><div class="line">        print uc(&quot;$w &quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> #现在你可以传递项</div><div class="line">shout-them(&apos;go&apos;); # GO</div><div class="line">shout-them(&apos;go&apos;, &apos;home&apos;); # GO HOME</div></pre></td></tr></table></figure>
<p>除了集合所有的值之外，slurpy 参数会展平任何它接收到的数组，最后你只会得到一个展平的列表，因此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @words = (&apos;go&apos;, &apos;home&apos;);</div><div class="line">shout-them(@words);</div></pre></td></tr></table></figure>
<p>会导致 <code>*@words</code> 参数有两个字符串元素，而非只有单个数组元素。</p>
<p>你可以选择将某些参数捕获到位置参数中，并让其它参数被吸进数组参数里。这种情况下， <code>slupy</code> 应该放到最后。相似地， <code>*%hash</code> slurps 所有剩下的未绑定的命名参数到散列 %hash中。<code>Slurpy</code> 数组和散列允许你传递所有的位置参数和命名参数到另一个子例程中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub debug-wrapper(&amp;code, *@positional, *%named) &#123;</div><div class="line">    warn &quot;Calling &apos;&amp;code.name()&apos; with arguments &quot;</div><div class="line">    ~ &quot;@positional.perl(), %named.perl()\n&quot;;</div><div class="line">    code(|@positional, |%named);</div><div class="line">    warn &quot;... back from &apos;&amp;code.name()&apos;\n&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">debug-wrapper(&amp;order-shrimps, 4, from =&gt; &apos;Atlantic Ocean&apos;);</div></pre></td></tr></table></figure>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><hr>
<p>子例程也能返回值。之前本章中的 ASCII 艺术舞蹈例子会更简单当每个子例程返回一个新字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my %moves =</div><div class="line">hands-over-head =&gt; sub &#123; return &apos;/o\ &apos;   &#125;,</div><div class="line">bird-arms       =&gt; sub &#123; return &apos;|/o\| &apos; &#125;,</div><div class="line">left            =&gt; sub &#123; return &apos;&gt;o &apos;    &#125;,</div><div class="line">right           =&gt; sub &#123; return &apos;o&lt; &apos;    &#125;,</div><div class="line">arms-up         =&gt; sub &#123; return &apos;\o/ &apos;   &#125;;</div><div class="line"></div><div class="line">my @awesome-dance = &lt;arms-up bird-arms right hands-over-head&gt;;</div><div class="line"></div><div class="line">for @awesome-dance -&gt; $move &#123;</div><div class="line">    print %moves&#123;$move&#125;.();</div><div class="line">&#125;</div><div class="line"></div><div class="line">print &quot;\n&quot;;</div></pre></td></tr></table></figure>
<p>子例程也能返回多个值（译者注：那不就是返回一个列表嘛）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub menu &#123;</div><div class="line">    if rand &lt; 0.5 &#123;</div><div class="line">        return (&apos;fish&apos;, &apos;white wine&apos;)</div><div class="line">    &#125; else &#123;</div><div class="line">        return (&apos;steak&apos;, &apos;red wine&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my ($food, $beverage) = menu();</div></pre></td></tr></table></figure>
<p> 如果你把 return 语句排除在外，则在子例程内部运行的最后一个语句产生的值被返回。这意味着前一个例子可以简化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub menu &#123;</div><div class="line">    if rand &lt; 0.5 &#123;</div><div class="line">        &apos;fish&apos;, &apos;white wine&apos;</div><div class="line">    &#125; else &#123;</div><div class="line">        &apos;steak&apos;, &apos;red wine&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my ($food, $beverage) = menu();</div></pre></td></tr></table></figure>
<p>记得：当子例程中的控制流极其复杂时，添加一个显式的 return 会让代码更清晰，所以 return 还是加上的好。<br>return 另外的副作用就是执行后立即退出子例程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub create-world(*%characteristics) &#123;</div><div class="line">    my $world = World.new(%characteristics);</div><div class="line">    return $world if %characteristics&lt;temporary&gt;;</div><div class="line"></div><div class="line">    save-world($world);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>…并且你最好别放错你的新单词 $word 如果它是临时的。因为这是你要获取的仅有的一个。</p>
<h3 id="返回值的类型"><a href="#返回值的类型" class="headerlink" title="返回值的类型"></a>返回值的类型</h3><hr>
<p>像其它现代语言一样，Perl 6 允许你显式地指定子例程返回值的类型。这允许你限制从子例程中返回的值的类型。使用 returns 特性可以做到这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub double-up($i) returns Int &#123;</div><div class="line">    return $i * 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my Int $ultimate-answer = double-up(21);  # 42</div></pre></td></tr></table></figure>
<p> 当然，使用这个 <code>returns</code> 特性是可选的</p>
<h3 id="Working-With-Types"><a href="#Working-With-Types" class="headerlink" title="Working With Types"></a>Working With Types</h3><hr>
<p>很多子例程不能完整意义上使用任意参数工作，但是要求参数支持确定的方法或有其它属性。这种情况下，限制参数类型就有意义了，诸如传递不正确值作为参数，当调用子例程时，这会引起Perl 发出错误，或者甚至在编译时，如果编译器足够聪明来捕捉错误。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><hr>
<p>最简单的限制子例程接收可能的值的方法是在参数前写上类型名。例如，一个子例程对其参数执行数值计算，这要求它的参数类型是 Numeric：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub mean(Numeric $a, Numeric $b) &#123;</div><div class="line">   return ($a + $b) / 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say mean 2.5, 1.5;</div><div class="line">say mean &apos;some&apos;, &apos;strings&apos;;</div></pre></td></tr></table></figure>
<p> 产生输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Nominal type check failed for parameter &apos;$a&apos;;</div><div class="line">expected Numeric but got Str instead</div></pre></td></tr></table></figure>
<p>nominal 类型是一个人实际类型的名字，这里是 Numeric。<br>如果多个参数有类型限制，每个参数必须填充它绑定的参数限制的类型</p>
<h4 id="添加限制"><a href="#添加限制" class="headerlink" title="添加限制"></a>添加限制</h4><hr>
<p>有时，类型的名字不足以描述参数的要求。这种情况下，你可能使用 where 代码块添加一个额外的限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub circle-radius-from-area(Real $area where &#123; $area &gt;= 0 &#125;) &#123;</div><div class="line">    ($area / pi).sqrt</div><div class="line">&#125;</div><div class="line"></div><div class="line">say circle-radius-from-area(3); # OK</div><div class="line">say circle-radius-from-area(-3); # Error</div></pre></td></tr></table></figure>
<p> 因为这种计算只对非负面积值有意义，该子例程的参数包含了一个限制，对于非负值它会返回真。如果这个限制返回一个假的值，类型检查会失败，当有些东西调用该子例程时。</p>
<p>where 之后的代码块是可选的。Perl 通过通过智能匹配 where 后面的参数来执行检查。<br>例如，它可能接受在某一确定范围中的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub set-volume(Numeric $volume where 0..11) &#123;</div><div class="line">    say &quot;Turning it up to $volume&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者你可以将参数限制为散列的键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my %in-stock = &apos;Staropramen&apos; =&gt; 8, &apos;Mori&apos; =&gt; 5, &apos;La Trappe&apos; =&gt; 9;</div><div class="line"></div><div class="line">sub order-beer(Str $name where %in-stock) &#123;</div><div class="line">      say &quot;Here&apos;s your $name&quot;;</div><div class="line">      %in-stock&#123;$name&#125;--;</div><div class="line">      if %in-stock&#123;$name&#125; == 0 &#123;</div><div class="line">          say &quot;OH NO! That was the last $name, folks! :&apos;(&quot;;</div><div class="line">          %in-stock.delete($name);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="抽象参数和具体参数"><a href="#抽象参数和具体参数" class="headerlink" title="抽象参数和具体参数"></a>抽象参数和具体参数</h3><hr>
<p>下面检测变量是否定义。<br>例如，下面是Perl5 代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub foo &#123;</div><div class="line">    my $arg = shift;</div><div class="line">    die &quot;Argument is undefined&quot; unless defined $arg;</div><div class="line"></div><div class="line">    # Do something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Perl 6 中这样写:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">foo</span>(<span class="title">Int</span>:<span class="title">D</span> $<span class="title">arg</span>) </span>&#123;</div><div class="line">    <span class="comment"># Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>留意附加在参数类型后面的 :D 笑脸。这个动词表明给定的参数必须被绑定到一个具体的对象上。如果不是的话，会抛出一个运行时异常。这就是为什么它那么高兴！作为对比， 动词 :U 用于表明该参数需要一个未定义的或抽象的对象。此外， 动词:<em> 允许定义或未定义的值。实际上，使用 :</em> 有点多余。</p>
<p>最后，动词 :T 能用于表明参数只能是类型对象，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub say-foobar(Int:T $arg) &#123;</div><div class="line">    say &apos;FOOBAR!&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say-foobar(Int);</div><div class="line"># FOOBAR!</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[S12-Objects]]></title>
      <url>http://ohmycloud.github.io/2015/08/09/S12-Objects/</url>
      <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><hr>
<p>大纲 12： 对象(Objects)</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><hr>
<p>创建于： 2004-08-27</p>
<p>上次修改时间： 2014-8-26</p>
<p>版本：134</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr>
<p>这个大纲总结了第12个启示录, 它探讨关于面向对象的编程。</p>
<h2 id="类-Classes"><a href="#类-Classes" class="headerlink" title="类 (Classes)"></a>类 (Classes)</h2><hr>
<p><a href="https://github.com/perl6/roast/blob/master/S12-class/lexical.t#L12-L61" target="_blank" rel="external">S12-class/lexical.t lines 12–61</a></p>
<p><a href="https://github.com/perl6/roast/blob/master/S12-class/basic.t#L13-L50" target="_blank" rel="external">S12-class/basic.t lines 13–50</a></p>
<p><a href="https://github.com/perl6/roast/blob/master/S14-roles/lexical.t#L12-L47" target="_blank" rel="external">S14-roles/lexical.t lines 12–47</a></p>
<p>类是使用关键字 <code>class</code> 声明的模块。 至于模块, 即公共存储, 接口, 并且类的名字通过包和它的名字来表示, 这总是(但不必须)一个全局的名字。 类是一个模块, 因此能导出东西, 但是类添加了更多的行为来支持 Perl 6 的标准的基于类的 OO。</p>
<p>作为类型对象(type object), 类名代表了它的类型的所有可能值, 因此在计算那种类型的普通对象能做什么时, 类型对象能用作任何属于该类型的”真实”对象的代理。 类对象是一个对象, 但是它不是一个类(<code>Class</code>), 因为 Perl 6 中没有强制性的 <code>Class</code> 类, 还因为在Perl 6 中类型对象被认为是未定义的。 我们想基于类的和基于原型的 OO 编程这两个都支持。所以, 所有的元编程是通过当前对象的 <code>HOW</code> 对象来完成的, 这可以把元编程代理给任何它喜欢的元模型上。 然而, 默认地, 从 <code>Mu</code> 派生的对象支持相当标准的基于类的模型。</p>
<p>有两种基本的类声明语法:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">unit class Foo; <span class="comment"># 文件的剩余部分是类的定义</span></div><div class="line">has $.foo</div><div class="line"></div><div class="line">class Bar &#123; has $.bar &#125; <span class="comment"># block 是类的定义</span></div></pre></td></tr></table></figure>
<p>第一种形式只有当第一种声明是在一个编译单元(即文件或 EVAL 字符串)中时被允许。</p>
<p>如果类的主体以一个主操作符为单个<code>prefix:&lt;...&gt;</code>（yada）listop 开始的语句, 那么只引入类名而不定义, 并且在同一个作用域中第二次声明那个类不会抱怨重新定义。（语句修饰符允许在这样的 <code>...</code> 操作符上。）因此你可以向前声明你的类:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">calss A &#123; ... &#125; <span class="comment"># 引入 A 作为类名而不定义</span></div><div class="line">class B &#123; ... &#125; <span class="comment"># 引入 B 作为类名而不定义</span></div><div class="line"></div><div class="line"><span class="keyword">my</span> A $root .= new(:a(B));</div><div class="line"></div><div class="line">class A &#123;</div><div class="line">    has B $.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B &#123;</div><div class="line">    has A $.b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就像这个例子展示的那样, 这允许互相递归类的定义(但是它不允许递归继承)。</p>
<p>通过 <code>augment</code> 声明符来扩展类也是可以的, 但是那被认为有点不符合常规并且不应用于向前声明。</p>
<p>一个具名的类声明能作为表达式的一部分出现, 就像具名子例程声明那样。</p>
<p>类主要用于实例管理, 而非代码复用。 当你只是想提取共有的代码时考虑使用 roles。</p>
<p>Perl 6 支持多重继承, 匿名类和自动装箱。</p>
<p><a href="https://github.com/perl6/roast/blob/master/S12-class/anonymous.t#L5-L81" target="_blank" rel="external">S12-class/anonymous.t lines 5–81</a></p>
<p>所有的 public 方法调用在 C++ 里就是虚的。</p>
<p>你可能派生自任何内置类型, 但是像<code>Int</code>这样的低级别派生可能只增加行为, 而不改变表示。使用构成 and/or 代理来改变表示。</p>
<p>因为 Perl 6 中没有裸字, 裸的类名必须被预先声明好。你可以预先声明一个 stub 类并在之后填充它就像你在子例程中的那样。</p>
<p><a href="https://github.com/perl6/roast/blob/master/S12-class/declaration-order.t#L14-L21" target="_blank" rel="external">S12-class/declaration-order.t lines 14–21</a></p>
<p><a href="https://github.com/perl6/roast/blob/master/S12-class/stubs.t#L4-L40" target="_blank" rel="external">S12-class/stubs.t lines 4–40</a></p>
<p>你可以使用 <code>::</code> 前缀来强制一个名字解释为类名或类型名。 在左值上下文中, <code>::</code> 前缀是一个 no-op, 但是在声明式的上下文中, 它在声明的作用域中绑定了一个新的类型名, 伴随着任何其它通过声明声明的东西。</p>
<p><a href="https://github.com/perl6/roast/blob/master/S12-class/literal.t#L7-L25" target="_blank" rel="external">S12-class/literal.t lines 7–25</a></p>
<p>如果没有 <code>my</code> 或其它作用域声明符, 那么一个裸的 <code>class</code> 声明符声明了一个 <code>our</code>声明符, 即一个在当前包中的名字。 因为类文件开始解析于 <code>GLOBAL</code> 包中, 文件中第一个声明的类把它自己安装为一个全局的名字, 之后的声明随后把它们自己安装在当前类中而不是全局的包中。</p>
<p>因此, 要在当前的包(或模块, 或类)中声明一个内部的类, 那使用 <code>our class</code> 或仅仅 <code>class</code>。  要声明一个本地作用域的类, 使用 <code>my class</code>。 类的名字总是从最内的作用域开始搜索, 直到最外层的作用域。 至于起始的 <code>::</code>, 类名中出现的 <code>::</code> 不是暗示全局性(不像 Perl 5)。 所以外层的搜索能查看搜索过的名字空间的孩子。</p>
<p>内部的 class 或 role 在一般的上下文中必须被本地作用域化, 如果它依赖于任何一般的参数或类型的话; 并且这样的内部类或 role 也叫做泛型。</p>
<h3 id="类的特性-Class-traits"><a href="#类的特性-Class-traits" class="headerlink" title="类的特性(Class traits)"></a>类的特性(Class traits)</h3><hr>
<p>类的特性使用 <code>is</code> 来设置:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class MyStruct is rw &#123; ... &#125;</div></pre></td></tr></table></figure>
<h4 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h4><hr>
<p><code>isa</code> 也仅仅是一个特性, 碰巧是另一个类:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Dog is Mammal &#123; ... &#125;</div></pre></td></tr></table></figure>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><hr>
<p>多重继承使用多个     <code>is</code> 来指定：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Dog is Mammal is Pet &#123; ... &#125;</div><div class="line">​<span class="string">``</span><span class="string">`	</span></div><div class="line">#### 合成</div><div class="line">Roles 使用 `does<span class="string">` 代替 `</span>is<span class="string">`:</span></div><div class="line">​`<span class="string">``</span>perl</div><div class="line">class Dog is Mammal does Pet &#123; ... &#125;</div></pre></td></tr></table></figure>
<h4 id="also-声明符"><a href="#also-声明符" class="headerlink" title="also 声明符"></a>also 声明符</h4><hr>
<p>你也可以使用 <code>also</code> 声明符把这些都放在里面:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Dog &#123;</div><div class="line">    also is Mammal;</div><div class="line">    also does Pet;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（然而, also 声明符主要用在 roles 中）</p>
<h3 id="元类-Metaclasses"><a href="#元类-Metaclasses" class="headerlink" title="元类(Metaclasses)"></a>元类(Metaclasses)</h3><hr>
<p>每个对象（包括任何基于类的对象）代理给它的元类的一个实例上。你能通过 <code>HOW</code> 方法来获取元类的任何对象, HOW 方法返回那个元类的实例。 在 Perl 6 中, 一个”类”对象仅仅被认为是一个”空的”实例, 更合适的叫法是 “原型” 或 “泛型” 对象, 或仅仅叫 “类型对象”。 Perl 6 真的没有任何名为 <code>Class</code> 的类。 各种各样的类型是通过这些未定义的类型对象来命名的, 这被认为是和他们自己的实例化版本拥有相同的类型。但是这样的类型对象是惰性的, 并且不能管理类实例的状态。</p>
<p>管理实例的实际对象是通过 HOW 语法所指向的元类对象。 所以当你说 “Dog”的时候, 你指的即是一个包又是一个类型对象, 后者指的是通过 HOW 来表示类的对象。 类型对象区别实例对象不是通过拥有不同的类型, 而是就谁被定义而言的。有些对象可能告诉你它们被定义了, 而其它对象可能告诉你它们没有被定义。 那归结于对象, 并取决于元对象如何选择去分发 <code>.defined</code> 方法。</p>
<h3 id="闭合类-Closed-classes"><a href="#闭合类-Closed-classes" class="headerlink" title="闭合类(Closed classes)"></a>闭合类(Closed classes)</h3><hr>
<p>类默认是开放和非最终(non-final) 的, 但是它们能很容易地被整个程序闭合或定型, 而非被它们自己。 然而使用动态加载或子程序的平台可能不想批量闭合或定型类。(这特么都是什么?)</p>
<h3 id="私有类"><a href="#私有类" class="headerlink" title="私有类"></a>私有类</h3><hr>
<p>私有类能使用 <code>my</code> 来声明; 在 Perl 6 中, 大部分隐私问题是使用词法作用域(my)来处理的。词法默认很重要的事实也意味着类导入的任何名字默认也是私有的。</p>
<p>在 grammars 中, 不能使用 grammars 属性, 所以你能从一个不相关的 grammar 中调用一个 grammar。这能通过在闭包中创建一个本地作用域的 grammars 来模仿那种行为。闭包捕获的词法变量就能用在像 grammars 属性那样的地方了。</p>
<h3 id="类的成分"><a href="#类的成分" class="headerlink" title="类的成分"></a>类的成分</h3><hr>
<p><code>class</code>声明(特别地, role 合成)是严格的编译时语句。特别地, 如果类声明出现在嵌套作用域里面, 那么类声明被约束为, 构成和任何可能的实现一样。所有的 roles 和 超类必须被限制为非重新装订的只读值; 任何 traits 的参数会只在非拷贝上下文中被求值。类声明限定的名字是非重新装订的并且是只读的, 所以它们能被用作超类。</p>
<h3 id="匿名的类声明"><a href="#匿名的类声明" class="headerlink" title="匿名的类声明"></a>匿名的类声明</h3><hr>
<p>在匿名的类声明中, 如果需要 <code>::</code> 本身就代表了匿名类的名字:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class &#123; ... &#125;                    <span class="comment"># ok</span></div><div class="line">class is Mammal &#123; ... &#125;          <span class="comment"># 错误</span></div><div class="line">class :: is Mammal &#123; ... &#125;       <span class="comment"># ok</span></div><div class="line">class &#123; also is Mammal; ... &#125;    <span class="comment"># also ok</span></div></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><hr>
<p>方法是类中使用 <code>method</code> 关键字声明的子例程:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">method doit ($a, $b, $c) &#123; ... &#125;</div><div class="line">meyhod doit ($self: $a, $b, $c) &#123; ... &#125;</div><div class="line">method doit (MyName $self: $a, $b, $c) &#123; ... &#125;</div><div class="line">method doit (::?CLASS $self: $a, $b, $c) &#123; ... &#125;</div></pre></td></tr></table></figure>
<h3 id="调用者"><a href="#调用者" class="headerlink" title="调用者"></a>调用者</h3><hr>
<p>调用者的声明是可选的。你总是使用关键字 <code>self</code>来访问当前调用者。你不需要声明调用者的类型, 因为调用者的词法类是被任何事件知晓的, 因为方法必须声明在调用者的类中, 尽管真实的(虚拟的)类型可能是词法类型派生出来的类型。你可以声明一个限制性更强的类类型, 但是那对于多态可能是坏事儿。你可以显式地使用词法类型来type 调用者, 但是任何为此做的检查会被优化掉，(当前的词法导向的类总是可以命名为 <code>::?CLASS</code> 即使在匿名类中或 roles 中)</p>
<p><a href="https://github.com/perl6/roast/blob/master/S12-attributes/recursive.t#L46-L97" target="_blank" rel="external">S12-attributes/recursive.t lines 46–97</a></p>
<p>要标记一个显式的调用者, 在它后面放上一个冒号就好了:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method doit ($x: $a, $b, $c) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>如果你使用数组变量为 Array 类型声明一个显式的调用者, 你可以在列表上下文中直接使用它来生成它的元素</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method push3 (@x: $a, $b, $c) &#123; ... any(@x) ... &#125;</div></pre></td></tr></table></figure>
<p>注意 <code>self</code>项直接指向了方法所调用的对象上, 因此:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class A is Array &#123;</div><div class="line">    method <span class="keyword">m</span>() &#123; .say <span class="keyword">for</span> self &#125;</div><div class="line">&#125;</div><div class="line">A.new(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).m; <span class="comment"># 1\n2\n\3</span></div></pre></td></tr></table></figure>
<p>会打印3行输出。</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><hr>
<p>私有方法是使用 <code>!</code> 声明的:</p>
<p>[<a href="https://github.com/perl6/roast/blob/master/S12-methods/private.t#L6-L44" target="_blank" rel="external">S12-methods/private.t lines 6–44</a>]</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method !think (Brain $self: $thought)</div></pre></td></tr></table></figure>
<p>(这样的方法对普通方法调用是完全不可见的, 实际上是使用不同的语法, 即使用 <code>!</code> 代替 <code>.</code> 字符。 看下面。)</p>
<h3 id="方法作用域"><a href="#方法作用域" class="headerlink" title="方法作用域"></a>方法作用域</h3><hr>
<p>不像大部分的其它声明符, <code>method</code>声明符不是默认为 <code>our</code>语义, 或者甚至 <code>my</code> 语义, 而是 <code>has</code>语义。所以, 不是安装一个符号到词法的或包的符号表中, 它们只是在当前类或 role 中通过调用它的元对象来安装一个公共的或私有的方法。（同样适用于 <code>submethod</code> 声明符 — 查看下面的 “Submethod”）.</p>
<p>使用一个显式的 <code>has</code>声明符对声明没有影响。你可以在本地作用域中使用<code>my</code>或在当前包中使用 <code>our</code>来给方法安装额外的别名。这些别名使用 <code>&amp;foo</code>别名来命名, 并返回一个能叫做子例程的 <code>Routine</code>对象, 这时你必须提供期望的调用者作为第一个参数。</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><hr>
<p>要使用普通的方法分发语义来调用普通的方法, 使用点语法记法或间接对象记法:</p>
<p><a href="https://github.com/perl6/roast/blob/master/S12-methods/instance.t#L13-L243" target="_blank" rel="external">S12-methods/instance.t lines 13–243</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$obj.doit(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">doit $obj: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div></pre></td></tr></table></figure>
<p>间接对象记法现在要求调用者后面要有一个冒号, 即使冒号后面没有参数:</p>
<p><a href="https://github.com/perl6/roast/blob/master/S12-methods/indirect_notation.t#L5-L57" target="_blank" rel="external">S12-methods/indirect_notation.t lines 5–57</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$handle.close;</div><div class="line"><span class="keyword">close</span> $handle:;</div></pre></td></tr></table></figure>
<p>要拒绝方法调用并且只考虑 subs, 仅仅从调用行那儿省略冒号即可：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">close</span>($handle);</div><div class="line"><span class="keyword">close</span> $handle;</div></pre></td></tr></table></figure>
<p>然而, 这儿内置<code>IO</code>类定义的方法 <code>close （）</code>是导出的, 它默认把 <code>multi sub close (IO)</code> 放在作用域中。因此, 如果 <code>$handle</code>对象是一个 IO 对象的话, 那么上面的两个子例程调用仍旧被转换成方法调用。</p>
<p>点调用记法可以省略调用者, 如果调用者是 <code>$_</code>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.doit(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>方法调用使用的是 C3 方法解析顺序。</p>
<h4 id="花哨的方法调用"><a href="#花哨的方法调用" class="headerlink" title="花哨的方法调用"></a>花哨的方法调用</h4><hr>
<p>注意对于私有方法没有对应的记法。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">!doit(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)     <span class="comment"># 错, 会被解析为 not(doit(1,2,3))</span></div><div class="line">self!doit(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># ok</span></div></pre></td></tr></table></figure>
<p>对于方法名有几种间接的形式。你可以使用引起的字符串替换标识符, 它会被求值为引起, 引起的结果用作方法名。</p>
<p><a href="https://github.com/perl6/roast/blob/master/S12-methods/indirect_notation.t#L58-L76" target="_blank" rel="external">S12-methods/indirect_notation.t lines 58–76</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$obj.<span class="string">"$methodname"</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 使用 $methodname 的内容作为方法名</span></div><div class="line">$obj.<span class="string">'$methodname'</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 没有插值; 调用名字中带有 $ 符号的方法</span></div><div class="line"></div><div class="line">$obj!<span class="string">"$methodname"</span>() <span class="comment"># 间接调用私有方法名</span></div></pre></td></tr></table></figure>
<p>在插值中, 双引号形式不可以包含空白。这在双引号中以点结尾的字符串中达到用户期望的那样:</p>
<p><a href="https://github.com/perl6/roast/blob/master/S02-literals/misc-interpolation.t#L96-L120" target="_blank" rel="external">S02-literals/misc-interpolation.t lines 96–120</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> <span class="string">"Foo = $foo."</span>;</div></pre></td></tr></table></figure>
<p>如果你真的想调用带有空格的方法, 那你使用一个闭包插值来进行约束:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> <span class="string">"Foo = &#123;$foo."</span>a method<span class="string">"()&#125;"</span>; <span class="comment"># OK</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[rotor]]></title>
      <url>http://ohmycloud.github.io/2015/08/08/rotor/</url>
      <content type="html"><![CDATA[<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method rotor(*@cycle, Bool() :$partial)</div></pre></td></tr></table></figure>
<p>rotor 返回一个 list, 这个 list 的元素也是 list,  其中每个子列表由调用者中的元素组成.  在最简单的情况下, @cycle 只包含一个整数, 这时调用者列表被分割为多个子列表, 每个子列表中的元素尽可能多的为那个整数指定的个数. 如果 <code>:$partial</code> 为 True, 不够分的最后那部分也会被包括进去, 即使它不满足长度的要求:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor(<span class="number">3</span>).join(<span class="string">'|'</span>); <span class="comment"># a b c|d e f</span></div><div class="line"><span class="keyword">say</span> (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor(<span class="number">3</span>, :partial).join(<span class="string">'|'</span>); <span class="comment"># a b c|d e f|g h</span></div></pre></td></tr></table></figure></p>
<p>如果 @cycle 的元素是一个  <a href="file:///type/Pair" target="_blank" rel="external">/type/Pair</a>, 则 pair 的键指定了所返回子列表的长度(即每个子列表中含有的元素数), pair 的键值指定两个列表之间的间隙; 负的间隙会产生<code>重叠</code>:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor(<span class="string">2 =&gt;</span> <span class="number">1</span>).join(<span class="string">'|'</span>); <span class="comment"># a b|d e|g h</span></div><div class="line"><span class="keyword">say</span> (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor(<span class="string">3 =&gt;</span> -<span class="number">1</span>).join(<span class="string">'|'</span>); <span class="comment"># a b c|c d e|e f g</span></div><div class="line">&gt; <span class="keyword">my</span> $pair  = <span class="string">2 =&gt;</span> <span class="number">1</span>;&gt; <span class="keyword">my</span> $key   = $pair.key;&gt; <span class="keyword">my</span> $value = $pair.value;</div><div class="line">&gt; <span class="keyword">say</span> (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor($key =&gt; $value).join(<span class="string">'|'</span>) <span class="comment"># a b|d e|g h</span></div></pre></td></tr></table></figure></p>
<p>如果 @cycle 的元素个数大于 1 时,  rotor 会按 @cycle 中的元素依次循环调用者列表, 得到每个子列表:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor(<span class="number">2</span>, <span class="number">3</span>).join(<span class="string">'|'</span>); <span class="comment"># a b|c d e|f g</span></div><div class="line"><span class="keyword">say</span> (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor(<span class="string">1 =&gt;</span> <span class="number">1</span>, <span class="number">3</span>).join(<span class="string">'|'</span>); <span class="comment"># a|c d e|f</span></div></pre></td></tr></table></figure></p>
<p>组合多个循环周期 和 :partial 也有效:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor(<span class="string">1 =&gt;</span> <span class="number">1</span>, <span class="string">3 =&gt;</span> -<span class="number">1</span>, :partial).join(<span class="string">'|'</span>); <span class="comment"># a|c d e|e|g h</span></div></pre></td></tr></table></figure></p>
<p>注意, 从 rotor 函数返回的一列列表们赋值给一个变量时会展开为一个数组:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @maybe_lol = (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor(<span class="string">2 =&gt;</span> <span class="number">1</span>);@maybe_lol.perl.say;   <span class="comment">#  ["a", "b", "d", "e", "g", "h"]&lt;&gt;</span></div></pre></td></tr></table></figure></p>
<p>这可能不是你想要的, 因为 rotor 之后的输出看起来是这样的:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor(<span class="string">2 =&gt;</span> <span class="number">1</span>).perl; <span class="comment"># (("a", "b"), ("d", "e"), ("g", "h"))</span></div></pre></td></tr></table></figure></p>
<p>要强制返回列表的列表, 使用绑定而非赋值:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> @really_lol := (<span class="string">'a'</span>..<span class="string">'h'</span>).rotor(<span class="string">2 =&gt;</span> <span class="number">1</span>);@really_lol.perl.say;   <span class="comment"># (("a", "b"), ("d", "e"), ("g", "h"))</span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6圣诞月历-(2015)]]></title>
      <url>http://ohmycloud.github.io/2015/08/05/Perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2015/</url>
      <content type="html"><![CDATA[<p>Comming Soon!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Introspection]]></title>
      <url>http://ohmycloud.github.io/2015/07/25/Introspection/</url>
      <content type="html"><![CDATA[<p>Perl 6 支持”泛型, roles 和 多重分发”, 它们都是很好的特点, 并且已经在其它 advent calendar 中发布过了。</p>
<p>但是今天我们要看的是 <strong>MOP</strong>。 “MOP”代表着元对象协议(“Meta-Object Protocol”)。那意味着, 它们实际上是你能从用户那边改变的一部分, 而不是对象、类等定义语言的东西。</p>
<p>实际上, 在 Perl 6中, 你可以为类型添加方法, 移除某个方法, 包裹方法, 使用更多能力增强类(<a href="https://github.com/jnthn/oo-actors" target="_blank" rel="external">OO::Actors</a>  和 <a href="https://github.com/jnthn/oo-monitors" target="_blank" rel="external">OO::Monitors</a> 就是两个这样的例子), 或者你可以完全重定义它(并且, 例如, 使用 Ruby-like 的对象系统。<a href="https://github.com/edumentab/rakudo-and-nqp-internals-course" target="_blank" rel="external">这儿有个例子</a>)。</p>
<p>但是今天, 我们首先看一下第一部分: 自省。在类型创建完之后查看它的类型, 了解它, 并使用这些信息。</p>
<p>我们将要创建的模块是基于 <a href="https://github.com/vendethiel/sixcheck" target="_blank" rel="external">Sixcheck</a> 模块(一个 <a href="https://en.wikipedia.org/wiki/QuickCheck" target="_blank" rel="external">QuickCheck-like</a> 模块)的需求: 为某个类型生成一些随机数据, 然后把数据喂给我们正测试的函数, 并检查某些后置条件(post-condition)。</p>
<p>所以, 我们先写出第一个版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my %special-cases&#123;Mu&#125; = </div><div class="line">  (Int) =&gt; -&gt; &#123; (1..50).pick &#125;,</div><div class="line">  (Str) =&gt; -&gt; &#123; (&apos;a&apos;..&apos;z&apos;).pick(50).join(&apos;&apos;) &#125;,</div><div class="line">;</div><div class="line"></div><div class="line">sub generate-data(Mu:U \t) &#123;</div><div class="line">    %special-cases&#123;t&#125; ?? %special-cases&#123;t&#125;() !! t.new;</div><div class="line">&#125;</div><div class="line"></div><div class="line">generate-data(Int);</div></pre></td></tr></table></figure>
<p>注意以下几点:</p>
<ul>
<li>我们给 %special-cases 指定了键的类型。那是因为默认地, 键的类型为 <strong>Str</strong>。显然地, 我们不想让我们的类型字符串化。我们实际上做的是指定它们为”Mu”的子类(这在类型”食物链”的顶端)。</li>
<li>我们在 <strong>Int</strong> 和 <strong>Str</strong> 周围放上圆括号, 以避免字符串化。</li>
<li>我们在函数参数类型中使用了 <code>:U</code>。那意味着那个值必须是未定义的(undefined)。类型对象(就像 Int、Str 等等)是未定义的, 所以它能满足我们(你可能见过一个叫 Nil 的不同的未知值)。</li>
<li>类型对象实际上是对象, 就像其它任何对象一样。这就是为什么我们在类型对象上调用 <code>.new</code>方法, 例如, 它和直接调用 <code>Int.new</code>相同(那对一致性和 <a href="https://design.perl6.org/S09.html#Autovivification" target="_blank" rel="external">autovivification</a> 很有用)。</li>
<li>我们为 <em>Int</em> 和 <em>Str</em> 提供了fallback, 因为调用 <em>Int.new</em> 和 <em>Str.new</em> ( 0 和 “” )不会在我们创建的数据中给我们任何随机化。</li>
<li>Perl 6 在函数中自动返回最后一个表达式。所以不需要在那儿放上一个 <em>return</em>。</li>
</ul>
<p>我们用代码生成数据, 公平且公正。但是我们需要生成更多那样简单的数据。</p>
<p>我们至少需要支持带有属性的类: 我们想查看属性列表, 为它们的类型生成数据, 并把它们喂给构造器。</p>
<p>我们要能够看到类的内部。用 Perl 6 的术语来说, 我们将要到达的是元对象协议(<a href="https://perl6advent.wordpress.com/2010/12/22/day-22-the-meta-object-protocol/" target="_blank" rel="external">Meta-Object Protocol</a>)。首先我们定义一个类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Article &#123;</div><div class="line">    has Str $.title;</div><div class="line">    has Str $.content;</div><div class="line">    has Int $.view-count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 我们可以这样手动创建一个实例</div><div class="line">Article.new(title      =&gt; &quot;Perl 6 Advent, 第 19 天&quot;,</div><div class="line">            content    =&gt; &quot;Magic!&quot;,</div><div class="line">            view-count =&gt; 0</div><div class="line">            );</div></pre></td></tr></table></figure>
<p>但是我们不想亲手创建那个文章 (article)。我们想把那个 <strong>class</strong> Article 传递给我们的 <em>generate-data</em> 函数, 并返回一个 Article(里面带有随机数据)。让我们回到我们的 <em>REPL</em>…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say Article.^attributes;         # (Str $!title Str $!content Int $!view-count)</div><div class="line">say Article.^attributes[0].WHAT; # (Attribute)</div></pre></td></tr></table></figure>
<p>如果你点击了 MOP 链接, 你不会对我们得到一个含有 3 个元素的数组感到惊讶。如果你仍旧对该语法感到惊讶, 那么 <code>.^</code>是元方法调用。意思是 <code>a.^b</code>会被转换为 <code>a.HOW.b(a)</code>。</p>
<p>如果我们想知道我们可以访问到什么, 我们问它就是了(移除了匿名的那些):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Attribute.^methods.grep(*.name ne &apos;&lt;anon&gt;&apos;); </div><div class="line"># (compose apply_handles get_value set_value </div><div class="line">#      container readonly package inlined WHY set_why Str gist)</div><div class="line"></div><div class="line">Attribute.^attributes # Method &apos;gist&apos; not found for invocant of class &apos;BOOTSTRAPATTR&apos;</div></pre></td></tr></table></figure>
<p>哎吆… 看起来这有点太 meta 了。幸好, 我们能使用 Rakudo 的一个非常好的属性: 它的大部分都是用 Perl 6写的! 要查看我们可以得到什么, 我们查看<a href="https://github.com/rakudo/rakudo/blob/nom/src/core/Attribute.pm" target="_blank" rel="external">源代码</a>就好了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># has Str $!name;</div><div class="line">...</div><div class="line"># has Mu $!type;</div></pre></td></tr></table></figure>
<p>我们得到了键的名字, 还有去生成值的类型。让我们看看…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; say Article.^attributes.map(*.name)</div><div class="line">($!title $!content $!view-count)</div><div class="line">&gt; say Article.^attributes.map(*.type)</div><div class="line">((Str) (Str) (Int))</div></pre></td></tr></table></figure>
<p>天才! 看起来是正确的。(如果你想知道为什么我们得到 <code>$!</code>（私有的） twigils, 那是因为 <code>$.</code>只意味着将会生成的一个 getter 方法)。属性本身仍然是私有的, 并且在类中是可访问的。</p>
<p>现在, 我们唯一要做的事情就是创建一个循环…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my %args;</div><div class="line"></div><div class="line">for Article.^attributes -&gt; $attr &#123;</div><div class="line">    %args&#123;$attr.name.substr(2)&#125; = generate-data($attr.type);</div><div class="line">&#125;</div><div class="line">say %args.perl;</div></pre></td></tr></table></figure>
<p>这是一个将会打印什么的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;:content(&quot;muenglhaxrvykfdjzopqbtwisc&quot;), :title(&quot;rfpjndgohmasuwkyzebixqtvcl&quot;), :view-count(45)&#125;</div></pre></td></tr></table></figure>
<p>每次你运行你的代码你都会得到不同的结果(然而我不认为它会创建一篇值得阅读的文章…)。剩下唯一要做的就是把它们传递给 Article 的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say Article.new(|%args);</div></pre></td></tr></table></figure>
<p>(前缀 <code>|</code>允许我们把 <em>%args</em> 作为具名参数传递, 而不是单个位置参数)。再次, 你应该会打印这些东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Article.new(title =&gt; &quot;kyvphxqmejtuicrbsnfoldgzaw&quot;, content =&gt; &quot;jqbtcyovxlngpwikdszfmeuahr&quot;, view-count =&gt; 26)</div></pre></td></tr></table></figure>
<p>呀! 我们设法在不了解 Article 的情况下胡乱地(blindly)创建了一个 Article 实例。 我们的代码能够用于为任何期望传递它的类属性的构造函数生成数据。好了!</p>
<p>PS: 留个作业! 移动到 generate-data 函数, 以至于我们能给 Article 添加一个 User $.author 属性, 并且构建好这个函数。祝你好运!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[when和where]]></title>
      <url>http://ohmycloud.github.io/2015/07/18/when%E5%92%8Cwhere/</url>
      <content type="html"><![CDATA[<hr>
<p>title: When and Where<br>date: 2015-03-15 13:15<br>categories: Perl 6</p>
<h2 id="comments-true"><a href="#comments-true" class="headerlink" title="comments: true"></a>comments: true</h2><h2 id="When-可以用在主题化-的语句中"><a href="#When-可以用在主题化-的语句中" class="headerlink" title="When 可以用在主题化($_)的语句中"></a>When 可以用在主题化($_)的语句中</h2><p>Perl 里面有个特殊的变量叫 <code>$_</code>, 即主题化变量, the variable in question. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; for (&apos;Swift&apos;, &apos;PHP&apos;, &apos;Python&apos;, &apos;Perl&apos;) -&gt; $item  &#123; say $item when $item ~~ /^P/ &#125;    </div><div class="line">PHP                                                                                  </div><div class="line">Python                                                                               </div><div class="line">Perl</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; for (12, 24, 56, 42) &#123;.say when *&gt;40 &#125;</div><div class="line">56</div><div class="line">42</div></pre></td></tr></table></figure>
<p>而 <em>where</em> 用于对类型进行约束.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; for (&apos;Swift&apos;, &apos;PHP&apos;, &apos;Python&apos;, &apos;Perl&apos;, 42) -&gt; $item  where $item ~~ Str  &#123;say $item&#125;   </div><div class="line">Swift                                                                                    </div><div class="line">PHP                                                                                      </div><div class="line">Python                                                                                   </div><div class="line">Perl                                                                                     </div><div class="line">Constraint type check failed for parameter &apos;$item&apos;</div></pre></td></tr></table></figure>
<p>未完待续.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[元对象协议]]></title>
      <url>http://ohmycloud.github.io/2015/07/16/%E5%85%83%E5%AF%B9%E8%B1%A1%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h1 id="自省和-Perl-6-的对象系统"><a href="#自省和-Perl-6-的对象系统" class="headerlink" title="自省和 Perl 6 的对象系统"></a>自省和 Perl 6 的对象系统</h1><hr>
<p>Perl 6 是构建在元对象层上面的。那意味着有些对象(元对象)控制着各种面向对象结构(例如类、roles、方法、属性、枚举,…)怎样去表现。</p>
<p>要感受类的元对象, 这儿有一个同样的例子出现2次: 一次一种 Perl 6中的普通声明, 一次通过元模型来表达:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">    method x() &#123; say 42 &#125;</div><div class="line">&#125;</div><div class="line">A.x(); # 42</div></pre></td></tr></table></figure>
<p>对应于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">constant A := Metamodel::ClassHOW.new_type( name =&gt; &apos;A&apos; );  # class A &#123;</div><div class="line">A.^add_method(&apos;x&apos;, my method x(A:) &#123; say 42 &#125;);             # method x() .. .</div><div class="line">A.^compose;                                                 # &#125;</div><div class="line"></div><div class="line">A.x(); # 42</div></pre></td></tr></table></figure>
<p>(除了声明形式的运行在编译时, 后面这种形式不是)</p>
<p>对象后面的元对象能使用 <code>$obj.HOW</code>获取, 这儿的 HOW 代表着 <strong>Higher Order Workings</strong>(或者 HOW the *%@$ does this work?)。</p>
<p>这儿, 带有 <code>.^</code>的调用是元对象的调用, 所以 <code>A.^compose</code>是 <code>A.HOW.compose(A)</code>的简写。调用者也被传递到参数列表中, 以使它能够支持原型类型风格的类型系统, 那儿只有一个元对象。</p>
<p>就像上面的例子展示的那样, 所有的面向对象特性对使用者都是可获得的, 而不仅仅是编译器。实际上编译器就是使用元对象的这样的调用的。</p>
<h2 id="元对象-MetaObjects"><a href="#元对象-MetaObjects" class="headerlink" title="元对象(MetaObjects)"></a>元对象(MetaObjects)</h2><hr>
<p>这些是内省的宏, 类似于方法调用。</p>
<p>元对象通常以 ALLCAPS(全大写)命名, 并且避免使用你自己的带有全大写名字的方法被认为是一个好的风格。这会避免和可能出现在未来版本中的任何元对象发生冲突。注意, 如果你必须使用带有全大写名字的方法的话, 把你的这个方法名字用引号引起来来间接安全地调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#| THIS IS A CLASS FOR SHOUTING THINGS</div><div class="line">class MY-CLASSES-ARE-ALL-CAPS &#123;</div><div class="line">    method WHY &#123; &quot;I DON&apos;T KNOW&quot; &#125;</div><div class="line">&#125;</div><div class="line">my $c = MY-CLASSES-ARE-ALL-CAPS.new;</div><div class="line">say $c.WHY      # &quot;THIS IS A CLASS FOR SHOUTING THINGS&quot;? 显示这？你在逗我!</div><div class="line">say $c.&quot;WHY&quot;()  # &quot;I DON&apos;T KNOW&quot;</div></pre></td></tr></table></figure>
<h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h2><hr>
<p>类型的类型对象。例如 <code>42.WHAT</code> 返回 <code>Int</code>类型对象。</p>
<h2 id="WHICH"><a href="#WHICH" class="headerlink" title="WHICH"></a>WHICH</h2><hr>
<p>对象的同一值。这能用于哈希和同一比较, 并且这是 <code>===</code>中缀操作符的实现方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &quot;a&quot;.WHICH</div><div class="line">Str|a</div></pre></td></tr></table></figure>
<h2 id="WHO"><a href="#WHO" class="headerlink" title="WHO"></a>WHO</h2><hr>
<p>支持对象的包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &quot;a&quot;.WHO</div><div class="line">Str</div></pre></td></tr></table></figure>
<h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><hr>
<p>对象的内存地址。注意这在移动的/紧凑的垃圾回收实现中是不稳定的。 在稳定的同一指示器中使用 <code>WHERE</code>。</p>
<h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h2><hr>
<p>元类对象(the metaclass object)：“Higher Order Workings”。</p>
<h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><hr>
<p>附加的 Pod 值。</p>
<h2 id="DEFINITE"><a href="#DEFINITE" class="headerlink" title="DEFINITE"></a>DEFINITE</h2><hr>
<p>对象有一个有效的强制表现。</p>
<p>对于实例返回 <code>True</code>, 对于类型对象返回 <code>False</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; 42.DEFINITE</div><div class="line">True</div><div class="line">&gt; Int.DEFINITE</div><div class="line">False</div></pre></td></tr></table></figure>
<h2 id="VAR"><a href="#VAR" class="headerlink" title="VAR"></a>VAR</h2><hr>
<p>返回底层的 Scalar 对象, 如果有的话。</p>
<h2 id="元对象系统的结构"><a href="#元对象系统的结构" class="headerlink" title="元对象系统的结构"></a>元对象系统的结构</h2><hr>
<p>对于每个类型声明符关键字, 例如 <code>class</code>、<code>role</code> 、<code>enum</code>、<code>module</code>、<code>package</code>、<code>grammar</code> 或<code>subset</code>, 就有一个独立的元类在 <code>Matamodel::</code>命名空间中。(Rakudo 在 <code>Perl6::Metamodel::</code>命名空间中实现了它们, 然后把 <code>Perl6::Metamodel</code>映射到 <code>Metamodel</code>)。</p>
<p>这些元类(meta classes)中的很多都共享公共的功能。例如 roles、grammars和 classes(类)都能包括方法和属性, 还能遵守 roles。这个共享的功能是在 roles 中实现的, 它被组合进合适的元类中。例如 <a href="http://doc.perl6.org/type/Metamodel::RoleContainer" target="_blank" rel="external">role Metamodel::RoleContainer</a>实现了类型能处理 roles 和 <code>Metamodel::ClassHOW</code>的功能, 它是在 <code>class</code>关键字后面的元类, 遵守了这个 role。</p>
<h2 id="Bootstrapping-concerns"><a href="#Bootstrapping-concerns" class="headerlink" title="Bootstrapping concerns"></a><a href="http://doc.perl6.org/language/mop#___top" target="_blank" rel="external">Bootstrapping concerns</a></h2><hr>
<p>你可能想知道为什么 <code>Metamodel::ClassHOW</code>可以是一个类, 当按照<code>Metamodel::ClassHOW</code>作为一个类被定义时, 或者 roles 负责 role 处理的怎么能是 roles。答案是通过魔法。</p>
<p>开玩笑啦。自举是特别实现的。Rakudo 使用语言的对象系统来实现自举, 它恰好(几乎)就是 Perl 6 的一个子集: NQP, Not Quite Perl。 NQP 有原始的, class-like 叫做 <code>konwhow</code> 的性质, 它用于自举它自己的类和 roles 实现。<code>konwhow</code>建立在NQP 提供的虚拟机的原始基础上。</p>
<p>因为元对象是根据低级(low-level)类型引导的, 自省有时能返回低级(low-level)类型而非你期望的那个类型, 例如返回一个 NQP-level 的子例程而非普通的 <code>Routine</code>对象, 或返回一个引导的属性而非<a href="http://doc.perl6.org/type/Attribute" target="_blank" rel="external">Attribute</a>。</p>
<h2 id="组合和静态推理"><a href="#组合和静态推理" class="headerlink" title="组合和静态推理"></a>组合和静态推理</h2><hr>
<p>在 Perl 6中, 类型是在解析时被构造的, 所以在开始, 它必须是可变的。然而, 如果所有类型一直是可变的, 那么关于类型的所有推断会在任何类型的修改时变得无效。例如父类的列表因此类型检测的结果能在那个时候改变。</p>
<p>所以为了获得这两个世界中最好的东西, 当类型从可变转为不可变时是好时机。这就叫做组合, 并且对于从句法构成上声明的类型, 它发生在类型声明被完全解析时(所以总是在闭合花括号被解析时)。</p>
<p>如果你通过元对象系统直接创建类型, 你必须要在它们身上调用 <code>.^compose</code>, 在它们变得完全起作用之前。</p>
<p>很多元类也使用组合时来计算一些诸如方法解析顺序这样的属性, 发布一个方法缓存, 和其它清扫任务。在它们被组合之后干预类型有时是可能的, 但通常是造成灾难的因素。 不要那样做。</p>
<h2 id="能力和责任"><a href="#能力和责任" class="headerlink" title="能力和责任"></a>能力和责任</h2><hr>
<p>元对象协议提供了很多常规 Perl 6 代码故意限制了的能力, 例如调用类中不信任你的私有方法, 窥探私有属性, 和其它通常不能完成的东西。</p>
<p>常规的 Perl 6 代码有很多就地的安全检测; 元模型中不是这样，它靠近底层的虚拟机, 违反和虚拟机的约定可以导致所有奇怪的行为, 而在正常代码中, 显而易见的会是 bugs。</p>
<p>所以, 在写元类型的时候要格外小心和思考。</p>
<h2 id="能力、便利和陷阱"><a href="#能力、便利和陷阱" class="headerlink" title="能力、便利和陷阱"></a>能力、便利和陷阱</h2><hr>
<p>元对象协议被设计的强大到实现 Perl 6 的对象系统。这种能力间或花费了便利的代价。</p>
<p>例如, 当你写了 <code>my $x = 42</code>并在 <code>$x</code>上调用方法时, 大部分方法会在整数 42 上起作用, 而不是在存储 42 的标量容器上。这是 Perl 6中设立的一块便利。元对象协议中的大部分不能提供自动忽略标量容器的便利性, 因为它们也用于实现那些标量容器。 所以, 如果你写了 <code>my $t = MyType; ... $t.^compose</code>, 那么你正组合那个<code>$</code>变量表明的标量, 而不是 <code>MyType</code>。</p>
<p>结果就是你需要很详尽的理解 Perl 6 的底层以避免陷阱, 当使用 MOP 时, 并且不能期望得到和普通 Perl 6 代码提供的 “do what I mean” 的便利。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的-Role]]></title>
      <url>http://ohmycloud.github.io/2015/07/15/Perl6%E4%B8%AD%E7%9A%84Role/</url>
      <content type="html"><![CDATA[<ul>
<li>Composition and mix-ins</li>
<li>Sigils</li>
<li>Typed data structures</li>
<li>Traits</li>
</ul>
<p>所以到底什么是 <code>role</code> 呢？ role 是零个或多个方法和属性的集合。</p>
<p>role 不像 class，它不能被实例化（如果你尝试了，会生成一个 class）。Perl 6 中 Classes 是可变的，而 roles 是不可变的。</p>
<h2 id="申明-Roles-就像申明-Class-一样："><a href="#申明-Roles-就像申明-Class-一样：" class="headerlink" title="申明 Roles 就像申明 Class 一样："></a>申明 Roles 就像申明 Class 一样：</h2><hr>
<p>使用关键字 <code>role</code>来引入 role, 在 role 中声明属性和方法就像在 Perl 6 的类中声明属性和方法那样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">role DebugLog &#123;</div><div class="line">    has @.log_lines;</div><div class="line">    has $.log_size is rw = 100;</div><div class="line">    method log_message($message) &#123;</div><div class="line">        @!log_lines.shift if</div><div class="line">        @!log_lines.elems &gt;= $!log_size;</div><div class="line">        @!log_lines.push($message);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Role-Composition"><a href="#Role-Composition" class="headerlink" title="Role Composition"></a>Role Composition</h2><hr>
<ul>
<li>使用 <code>does</code> trait 将 role 组合到 Class 中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class WebCrawler does DebugLog &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这会把方法和属性添加到 class WebCrawler 里面去。</li>
<li>结果就像它们起初被写到 class 中一样。</li>
</ul>
<h2 id="Mix-ins"><a href="#Mix-ins" class="headerlink" title="Mix-ins"></a>Mix-ins</h2><hr>
<ul>
<li>允许 role 的功能被添加到每个对象的根基上</li>
<li>不影响其它的类实例</li>
<li>role 中的方法总是覆盖对象中已经存在的方法</li>
</ul>
<h2 id="Mix-ins-Example"><a href="#Mix-ins-Example" class="headerlink" title="Mix-ins Example"></a>Mix-ins Example</h2><hr>
<ul>
<li>假设我们想跟踪某个对象发生了什么</li>
<li>Mix in the DebugLog role</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$acount does DebugLog;</div></pre></td></tr></table></figure>
<ul>
<li>然后, 我们可以输出被登记的行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$account.log_lines».say;</div></pre></td></tr></table></figure>
<ul>
<li>现在我们只需给<code>log_message</code>方法添加调用</li>
<li>我们可以使用<code>.?</code>操作符, 这会调用某个方法, 如果方法存在的话</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Account &#123;</div><div class="line">    method change_password($new) &#123;</div><div class="line">        self.?log_message(</div><div class="line">            &quot;changing password to $new&quot;;</div><div class="line">        )</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Sigil-接口协定"><a href="#Sigil-接口协定" class="headerlink" title="Sigil = 接口协定"></a>Sigil = 接口协定</h2><hr>
<ul>
<li>在 Perl 6 中, 符号表明接口协定</li>
<li>这个接口协定由 role 定义</li>
<li>你可以只把东西放在带有符号的变量中, 如果该变量遵守(<code>does</code>)了要求的 role 的话</li>
<li>例外: 带有 <code>$</code>的变量可以存储任何东西(如果没有使用类型约束的话)</li>
</ul>
<h2 id="Positional"><a href="#Positional" class="headerlink" title="@ = Positional"></a>@ = Positional</h2><hr>
<ul>
<li><code>@</code>符号表明它是一个 <code>Positional</code>role</li>
<li>保证会有一个方法后环缀让你能调用</li>
<li>This is that gets called when you do an index positionally into something</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say @fact[1];</div><div class="line">say @fact.postcircumfix:&lt;[ ]&gt;(1);</div></pre></td></tr></table></figure>
<ul>
<li>注意: 优化器(如果有的话)可能发出更轻量级的东西</li>
</ul>
<h2 id="Associative"><a href="#Associative" class="headerlink" title="% = Associative"></a>% = Associative</h2><hr>
<ul>
<li><code>%</code> 表明它是一个关联型(Associative)的 role</li>
<li>要有一个方法后环缀 <code>postcircumfix:&lt;{}&gt;</code>让你调用</li>
<li>This is that gets called when you do an index associatively into something</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say %price&lt;Cheese&gt;;</div><div class="line">say %price.postcircumfix:&lt;&#123; &#125;&gt;(&apos;Cheese&apos;);</div></pre></td></tr></table></figure>
<h2 id="amp-Callable"><a href="#amp-Callable" class="headerlink" title="&amp; = Callable"></a>&amp; = Callable</h2><hr>
<ul>
<li><code>&amp;</code>表明它是一个 Callable 的 role</li>
<li>东西要能被调用</li>
<li>这个 role 被诸如 <code>Block</code>、<code>Sub</code>、<code>Method</code>之类的东西遵守</li>
<li>要求实现后环缀 <code>postcircumfix:&lt;()&gt;</code></li>
</ul>
<p>使用带有 block 的 class 关键字引入一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Puppy &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 或使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Puppy;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">1;</div></pre></td></tr></table></figure>
<p>把类相关的东西单独写进一个文件</p>
<h2 id="Role-也可以被初始化"><a href="#Role-也可以被初始化" class="headerlink" title="Role 也可以被初始化"></a>Role 也可以被初始化</h2><hr>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">role BarChart &#123;</div><div class="line">    has Int @.bar-<span class="keyword">values</span>;</div><div class="line">    has $.b is rw;</div><div class="line">    method plot &#123;</div><div class="line">        <span class="keyword">say</span> @.bar-<span class="keyword">values</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $chart = BarChart.new(bar<span class="string">-values =&gt;</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="string">b =&gt;</span> <span class="string">"Camelia"</span>);</div><div class="line"><span class="keyword">say</span> $chart.b;</div><div class="line"><span class="keyword">say</span> $chart.bar-<span class="keyword">values</span>;</div><div class="line">$chart.b = <span class="string">"Rakudo"</span>;</div><div class="line"><span class="keyword">say</span> $chart.b;</div><div class="line"><span class="keyword">say</span> BarChart.^methods;</div></pre></td></tr></table></figure>
<p>如果你初始化了 role, 那么它就变为类了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-rotor--列表操作之王]]></title>
      <url>http://ohmycloud.github.io/2015/07/14/Perl-6-rotor-%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%8E%8B/</url>
      <content type="html"><![CDATA[<p>Perl 6 .rotor - The King of List Manipulation</p>
<p>对于 Perl 6 程序员, <code>.rotor</code>是一个强大的列表操作工具。</p>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><hr>
<p>最简单的, <code>.rotor</code>接收一个整数<strong>$number</strong>并把列表分成多个子列表, 每个子列表含有 <strong>$number</strong> 个元素:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say &lt;a b c d e f  g h&gt;.rotor: 3</div><div class="line"># ((a b c) (d e f))</div></pre></td></tr></table></figure>
<p>我们有一个含有 8 个元素的列表, 我们在该列表上调用接收参数 3 的 <code>.rotor</code>方法, 它返回 2 个列表, 每个列表中含有 3 个元素。不包括原列表中的最后 2 个元素, 因为它们没有组成一个完整的3个元素的列表。然而它们可以被包含进来, 使用 <code>:partial</code>具名参数设置为 <strong>True</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">say &lt;a b c  d e f  g h&gt;.rotor: 3, :partial</div><div class="line"># ((a b c) (d e f) (g h))</div><div class="line"></div><div class="line">say &lt;a b c  d e f  g h&gt;.rotor: 3, :partial(True)</div><div class="line"># ((a b c) (d e f) (g h))</div><div class="line"></div><div class="line">say &lt;a b c  d e f  g h&gt;.rotor: 3, :partial(False)</div><div class="line"># ((a b c) (d e f))</div></pre></td></tr></table></figure>
<p>下面应用一下我们刚刚学到的。把字符串分成列宽相等的几段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;foobarberboorboozebazmeow&quot;.comb.rotor(10, :partial)».join».say</div><div class="line"># foobarberb</div><div class="line"># oorboozeba</div><div class="line"># zmeow</div></pre></td></tr></table></figure>
<p>分行然后每行前面添加 4 个空格:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;foobarberboorboozebazmeow&quot;.comb.rotor(10, :partial)&gt;&gt;.join&gt;&gt;.indent(4)&gt;&gt;.say</div><div class="line">#    foobarberb</div><div class="line">#    oorboozeba</div><div class="line">#    zmeow</div></pre></td></tr></table></figure>
<p>但是这最好被写为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;foobarberboorboozebazmeow&quot;.comb(10)».say</div></pre></td></tr></table></figure>
<h4 id="注意缝隙"><a href="#注意缝隙" class="headerlink" title="注意缝隙"></a>注意缝隙</h4><hr>
<p>假设你正在接受输入: 你得到一个单词, 它的法语翻译和它的西班牙语翻译, 等一堆单词。你只想输出特定语言, 所以我们需要在我们的列表中跳过某些项。 <code>.rotor</code>来拯救来了!</p>
<p>指定一对儿(Pair)整数作为 rotor 的参数会让每个列表中含有 <strong>$key</strong> 个元素, 每个列表之间有 <strong>$value</strong> 个空隙。看例子更简单一些:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say ^10 .rotor: 3 =&gt; 1, :partial</div><div class="line">&gt;&gt;&gt;OUTPUT: ((0 1 2) (4 5 6) (8 9))</div><div class="line">say ^10 .rotor: 2 =&gt; 2, :partial</div><div class="line">&gt;&gt;&gt;OUTPUT: ((0 1) (4 5) (8 9))</div></pre></td></tr></table></figure>
<p>第一个例子我们把缝隙设置为 1, 第二个例子我们把缝隙增加为 2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum &lt;English French Spanish&gt;;</div><div class="line">say join &quot; &quot;, &lt;Good Bon Buenos morning matin días&gt;[French..*].rotor: 1 =&gt; 2;</div><div class="line">&gt;&gt;&gt;OUTPUT: Bon matin</div></pre></td></tr></table></figure>
<p>其中 <code>[French..*]</code>意思为 <code>[1..*]</code>, 例子中 French 被枚举化为整数 1。</p>
<h4 id="重叠"><a href="#重叠" class="headerlink" title="重叠"></a>重叠</h4><hr>
<p>当我们让缝隙变为负数的时候, 分段的列表中就会有元素重叠:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say &lt;a a b c c c d&gt;.rotor: 2 =&gt; -1</div><div class="line">&gt;&gt;&gt;OUTPUT: ((a a) (a b) (b c) (c c) (c c) (c d))</div><div class="line">say &lt;a a b c c c d&gt;.rotor(2 =&gt; -1).map: &#123;$_[0] eq $_[1] ?? &quot;same&quot; !! &quot;different&quot;&#125;</div><div class="line">&gt;&gt;&gt;OUTPUT: (same different different same same different)</div></pre></td></tr></table></figure>
<h4 id="全力以赴"><a href="#全力以赴" class="headerlink" title="全力以赴"></a>全力以赴</h4><hr>
<p><code>.rotor</code>不单单只能接受单个 <strong>Int</strong> 值或 <strong>Pair</strong>, 你可以指定额外的 <strong>Int</strong> 或 <strong>Pairs</strong> 位置参数来把列表分成不同尺寸大小的子列表, 列表之间的缝隙也不同。下面以一个日志文件为例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">IP: 198.0.1.22</div><div class="line">Login: suser</div><div class="line">Time: 1454017107</div><div class="line">Resource: /report/accounting/x23gs</div><div class="line">Input: x=42,y=32</div><div class="line">Output: success</div><div class="line">===================================================</div><div class="line">IP: 198.0.1.23</div><div class="line">Login: nanom</div><div class="line">Time: 1454027106</div><div class="line">Resource: /report/systems/boot</div><div class="line">Input: mode=standard</div><div class="line">Output: success</div></pre></td></tr></table></figure>
<p>每段之间有一行双划线。</p>
<p>我们想这样输出: <strong>Header</strong> 里包含 IP, Login, Time, Resource; <strong>Operation</strong> 里包含 Resource, Input, Output。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">for &apos;report.txt&apos;.IO.lines».indent(4).rotor( 4 =&gt; -1, 3 =&gt; 1 ) -&gt; $head, $op &#123;</div><div class="line">    .say for &quot;Header:&quot;,    |$head,</div><div class="line">             &quot;Operation:&quot;, |$op, &apos;&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&gt;&gt;&gt;OUTPUT:</div><div class="line">    Header:</div><div class="line">        IP: 198.0.1.22</div><div class="line">        Login: suser</div><div class="line">        Time: 1454017107</div><div class="line">        Resource: /report/accounting/x23gs</div><div class="line">    Operation:</div><div class="line">        Resource: /report/accounting/x23gs</div><div class="line">        Input: x=42,y=32</div><div class="line">        Output: success</div><div class="line"></div><div class="line">    Header:</div><div class="line">        IP: 198.0.1.23</div><div class="line">        Login: nanom</div><div class="line">        Time: 1454027106</div><div class="line">        Resource: /report/systems/boot</div><div class="line">    Operation:</div><div class="line">        Resource: /report/systems/boot</div><div class="line">        Input: mode=standard</div><div class="line">        Output: success</div></pre></td></tr></table></figure>
<p>先是 4 个元素一块, 缝隙为 -1(有重叠), 然后是 3 个元素一块, 缝隙为 1。这就在每个分段的列表中包含了 Resource 字段。因为 <code>$op</code> 和 <code>$head</code>是列表, 我们使用管道符号 <code>|</code>来展平列表。</p>
<p>记住, 你提供给 <code>.rotor</code>方法的模式可以动态地生成! 这儿我们使用 sine 函数来生成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">say ^92 .rotor(</div><div class="line">    (0.2, 0.4 ... 3).map: (10 * *.sin).Int # pattern we supply to .rotor</div><div class="line">).join: &quot;\n&quot;&apos;</div><div class="line">&gt;&gt;&gt;OUTPUT:</div><div class="line">    0</div><div class="line">    1 2 3</div><div class="line">    4 5 6 7 8</div><div class="line">    9 10 11 12 13 14 15</div><div class="line">    16 17 18 19 20 21 22 23</div><div class="line">    24 25 26 27 28 29 30 31 32</div><div class="line">    33 34 35 36 37 38 39 40 41</div><div class="line">    42 43 44 45 46 47 48 49 50</div><div class="line">    51 52 53 54 55 56 57 58 59</div><div class="line">    60 61 62 63 64 65 66 67 68</div><div class="line">    69 70 71 72 73 74 75 76</div><div class="line">    77 78 79 80 81 82</div><div class="line">    83 84 85 86 87</div><div class="line">    88 89 90</div><div class="line">    91</div></pre></td></tr></table></figure>
<p>再举个例子:</p>
<p>我现在想要将同类的序列（字符串）进行合并，比如有这样一个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;seq-1A</div><div class="line">GACACAGTCACCCGAGCCT</div><div class="line">&gt;seq-1B</div><div class="line">TCAATCAATACTGAAGCGA</div><div class="line">&gt;seq-1C</div><div class="line">AAAACTAGTCGAGAAGAGAG</div><div class="line">&gt;seq-1D</div><div class="line">CGTGGAAAACTCCAG</div><div class="line">&gt;seq-2A</div><div class="line">TAAAAGGCGTTCATTGGATATTTC</div><div class="line">&gt;seq-2B</div><div class="line">ACTGGCAGTGCATCC</div></pre></td></tr></table></figure>
<p>我想要进行合并 得到这样的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;seq-1</div><div class="line">GACACAGTCACCCGAGCCTTCAATCAATACTGAAGCGAAAAACTAGTCGAGAAGAGAGCGTGGAAAACTCCAG</div><div class="line">&gt;seq-2</div><div class="line">TAAAAGGCGTTCATTGGATATTTCACTGGCAGTGCATCC</div></pre></td></tr></table></figure>
<p>使用 rotor 来实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my %re;</div><div class="line">for &apos;input.txt&apos;.IO.lines».rotor(2, :partial) -&gt; $header, $data &#123;</div><div class="line">    my $key = $header;</div><div class="line">    $key ~~ s/&lt;upper&gt;$//;</div><div class="line">    %re&#123;$key&#125; ~= $data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for %re.kv -&gt; $key, $value &#123;</div><div class="line">    say &quot;$key\n$value&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Grammar笔记]]></title>
      <url>http://ohmycloud.github.io/2015/07/11/Grammar%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>一个 Grammar 调了很久, 先分解下：</p>
<ul>
<li>解析<code>[ ]</code> 里面的数据：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use Grammar::Debugger;</div><div class="line"></div><div class="line">grammar Lines &#123;</div><div class="line">    token TOP &#123;</div><div class="line">        ^ &lt;line&gt;+ $</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token line &#123;</div><div class="line">        \[</div><div class="line">        &lt;student&gt;+ % &lt;semicolon&gt;</div><div class="line">        \]</div><div class="line">        \n                   # 换行 \n 是最容易被忽略的地方, 坑了很多次了！</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token student &#123;</div><div class="line">       &lt;myname&gt;+ % &lt;comma&gt;   # 分隔符也可以是一个 subrule</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token myname &#123;</div><div class="line">        &lt;[A..Za..z-]&gt;+       # 字符类的写法 &lt;[...]&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token comma &#123;</div><div class="line">        &apos;,&apos; \s+              # 逗号, 分号 不能裸露出现在 token 中</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token semicolon &#123;</div><div class="line">        &apos;;&apos; \s+</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">my $parse = Lines.parsefile(&apos;test.txt&apos;);</div><div class="line">say $parse;</div></pre></td></tr></table></figure>
<p>test.txt 的内容如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[Lue, Fan]</div><div class="line">[Lou, Man-Li]</div><div class="line">[Tian, Mijie; Zhou, Lin; Zou, Xiao; Zheng, Qiaoji; Luo, Lingling; Jiang, Na; Lin, Dunmin]</div></pre></td></tr></table></figure>
<p>下面的 Grammar 用于解析一个字符串, 由于 tokens 不能回溯, 所以当解析 <code>$str</code> 时使用了 Grammar 的继承, 重写了 university 这个 token:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> v6;</div><div class="line"><span class="keyword">use</span> Grammar::Debugger;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $string = <span class="string">"[Wang, Zhiguo; Zhao, Zhiguo] Hangzhou Normal Univ, Ctr Cognit &amp; Brain Disorders, Hangzhou, Zhejiang, Peoples R China; [Wang, Zhiguo; Theeuwes, Jan] Vrije Univ Amsterdam, Dept Cognit Psychol, Amsterdam, Netherlands"</span>;</div><div class="line"></div><div class="line">grammar University::Grammar &#123;</div><div class="line">    token TOP             &#123; ^ &lt;university&gt; $             &#125;</div><div class="line">    token university      &#123; [ &lt;bracket&gt; &lt;info&gt; ]+ % <span class="string">'; '</span> &#125;</div><div class="line">    token bracket         &#123; <span class="string">'['</span> &lt;studentname&gt;  <span class="string">'] '</span>      &#125;</div><div class="line">    token studentname     &#123; &lt;stdname=.info&gt;+ % <span class="string">'; '</span>      &#125;</div><div class="line">    token info            &#123; &lt;field&gt;+ % <span class="string">', '</span>              &#125;</div><div class="line">    token field           &#123; &lt;-[,\]\[;\n]&gt;+               &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># grammar 像类一样可以继承, 里面的 token 可以被重写</span></div><div class="line">grammar MyUniversity  is University::Grammar &#123;</div><div class="line">    token university      &#123; &lt;info&gt;+ % <span class="string">'; '</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $str = <span class="string">"Zhejiang Univ, Coll Environm &amp; Resources Sci, Dept Resource Sci, Hangzhou 310029, Peoples R China; La Trobe Univ, Dept Agr Sci, Bundoora, Vic 3083, Australia; Hangzhou Normal Coll, Fac Life Sci, Hangzhou, Peoples R China"</span>;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $parsed = University::Grammar.parse($string);</div><div class="line"><span class="comment"># my $parsed = MyUniversity.parse($str);</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> @($parsed&lt;university&gt;&lt;info&gt;) -&gt; $f &#123;</div><div class="line">    <span class="keyword">say</span> $f&lt;field&gt;[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MAIN-中的冒号]]></title>
      <url>http://ohmycloud.github.io/2015/07/05/MAIN-%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>假如我有多个文本文件, 我要写一段脚本来进行替换操作。在命令行中提供一些列选项供配置。文本格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Perl 6 很灵活</div><div class="line">Perl 6 很强大</div><div class="line">Perl 6 很复杂</div><div class="line"></div><div class="line">I 123 Love Perl Six</div><div class="line">尽管它456还很稚嫩789</div><div class="line">对了, 它的 logo 是一个可爱的456花蝴蝶。</div></pre></td></tr></table></figure>
<p>我想把每行中第一次出现的 3 位数字替换为 “在木星”。</p>
<p>@蘑菇 的脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use MONKEY-SEE-NO-EVAL;</div><div class="line"></div><div class="line">sub MAIN(Str :$regex, Str :$substr, Str :$ext = &apos;.out&apos;, Int :$ignore-line = 0, *@files) &#123;</div><div class="line">    for @files -&gt; $file &#123;</div><div class="line">        my $out = open $file ~ &quot;.out&quot;, :w; # 写入文件</div><div class="line"></div><div class="line">        for $file.IO.lines.kv -&gt; $index, $line is copy &#123;</div><div class="line">            next if $index &lt;= $ignore-line; # 忽略前 $ignore-line几行</div><div class="line">            $line ~~ EVAL &quot;s/&quot; ~ $regex ~ &quot;/&quot; ~ $substr ~ &quot;/&quot;; # 根据正则表达式进行替换</div><div class="line">            say $/;</div><div class="line">            $out.say($line);</div><div class="line">        &#125;</div><div class="line">        $out.close;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看本脚本的用法</p>
<blockquote>
<p>perl6 colon_in_signature.p6 –help</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">colon_in_signature.p6 [-r|--regex=&lt;Str&gt;] [-s|--substr=&lt;Str&gt;] [-e|--ext=&lt;Str&gt;] [-i|--ignore-line=&lt;Int&gt;] [&lt;files&gt; ...]</div></pre></td></tr></table></figure>
<p>可以看出命令行选项有<strong>短名称</strong>(如 -r)和<strong>长名称</strong>(如 –regex)。我们使用的时候可以使用短名称:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; perl6 colon_in_signature.p6  -r=&quot;\d ** 3&quot; -s=&quot;在木星&quot; -i=2 1.txt 2.txt 3.txt</div></pre></td></tr></table></figure>
<p>也可以使用长名称:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; perl6 colon_in_signature.p6  --regex=&quot;\d ** 3&quot; --substr=&quot;在木星&quot; --ignore-line=2 1.txt 2.txt 3.txt</div></pre></td></tr></table></figure>
<p> 也可以只使用长名称, 但是我们需要修改下 <strong>MAIN</strong> 函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub MAIN(Str :$regex, Str :$substr, Str :$ext = &apos;.out&apos;, Int :$ignore-line = 0, *@files)</div></pre></td></tr></table></figure>
<p>再次查看帮助:</p>
<blockquote>
<p> perl6 colon_in_signature.p6  –help</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">colon_in_signature.p6 [--regex=&lt;Str&gt;] [--substr=&lt;Str&gt;] [--ext=&lt;Str&gt;] [--ignore-line=&lt;Int&gt;] [&lt;files&gt; ...]</div></pre></td></tr></table></figure>
<p>方括号表示该选项是可选的。但是现在只有长名称:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; perl6 colon_in_signature.p6 --regex=&quot;\d ** 3&quot; --substr=&quot;在木星&quot; 1.txt 2.txt 3.txt</div></pre></td></tr></table></figure>
<p>也能既有长名又有短名:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub MAIN(Str :r(:$regex), Str :$substr, Str :$ext = &apos;.out&apos;, Int :$ignore-line = 0, *@files)</div></pre></td></tr></table></figure>
<p>这其中的原理是什么呢? <strong>MAIN</strong> 在处理命令行参数时, 是把选项当作散列来用的:</p>
<ul>
<li>带短名称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; my $regex = &apos;\d ** 3&apos; #-&gt;  \d ** 3</div><div class="line">&gt; :r(:$regex)           #-&gt;  r =&gt; regex =&gt; \d ** 3</div></pre></td></tr></table></figure>
<ul>
<li>不带短名称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; (:$regex)            #-&gt;   regex =&gt; \d ** 3</div></pre></td></tr></table></figure>
<p><code>:r(:$regex)</code> 拥有一长一短两个键, <code>(:$regex)</code> 只拥有一个长键。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[散列也是容器]]></title>
      <url>http://ohmycloud.github.io/2015/06/28/%E6%95%A3%E5%88%97%E4%B9%9F%E6%98%AF%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="散列也是容器"><a href="#散列也是容器" class="headerlink" title="散列也是容器"></a>散列也是容器</h2><p>假设我们想计算某个东西的出现次数, 我们通常的做法是弄一个 “seen-hash” 散列。有时候我们有一组待查询的键, 其中有些键可能不在我们所扫描的数据中。那是一种特殊情况, 但是 Perl 6 能够完美地解决, 因为散列也是容器, 因此我们能够拥有默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $words = &lt;Hashes are containers too&gt;.lc;</div><div class="line">constant alphabet = &apos;a&apos; .. &apos;z&apos;;</div><div class="line"></div><div class="line">my %seen of Int is default(0);</div><div class="line"></div><div class="line">%seen&#123;$_&#125;++ for $words.comb;</div><div class="line">put &quot;$_: %seen&#123;$_&#125;&quot; for alphabet;</div></pre></td></tr></table></figure>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">a: 3</div><div class="line">b: 0</div><div class="line">c: 1</div><div class="line">d: 0</div><div class="line">e: 3</div><div class="line">f: 0</div><div class="line">g: 0</div><div class="line">h: 2</div><div class="line">i: 1</div><div class="line">j: 0</div><div class="line">k: 0</div><div class="line">l: 0</div><div class="line">m: 0</div><div class="line">n: 2</div><div class="line">o: 3</div><div class="line">p: 0</div><div class="line">q: 0</div><div class="line">r: 2</div><div class="line">s: 3</div><div class="line">t: 2</div><div class="line">u: 0</div><div class="line">v: 0</div><div class="line">w: 0</div><div class="line">x: 0</div><div class="line">y: 0</div><div class="line">z: 0</div></pre></td></tr></table></figure></p>
<p><code>$words</code> 中没有出现的特殊字符由 <code>is default(0)</code> 处理了。<br>默认值可以被精心设计。我们来弄一个在数值上下文中为默认值为 0 但是在字符串上下文中为默认值为 NULL 并且总是被定义的一个散列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %seen of Int is default(0 but role :: &#123; method Str() &#123;&apos;NULL&apos;&#125; &#125;);</div><div class="line">say %seen&lt;not-there&gt;, %seen&lt;not-there&gt;.defined, Int.new(%seen&lt;not-there&gt;);</div><div class="line"></div><div class="line"># OUTPUT</div><div class="line"># «NULLTrue0␤»</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[找到两个文件中共有的行]]></title>
      <url>http://ohmycloud.github.io/2015/06/18/%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E5%85%B1%E6%9C%89%E7%9A%84%E8%A1%8C/</url>
      <content type="html"><![CDATA[<h3 id="找出两个文件中共有的行-顺序无关紧要"><a href="#找出两个文件中共有的行-顺序无关紧要" class="headerlink" title="找出两个文件中共有的行, 顺序无关紧要"></a>找出两个文件中共有的行, 顺序无关紧要</h3><hr>
<p>在 Perl 5 里, 你可以这样:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env perl</span></div><div class="line"><span class="keyword">use</span> <span class="number">5.010</span>; <span class="keyword">use</span> warnings; <span class="keyword">use</span> strict;</div><div class="line"></div><div class="line"><span class="keyword">my</span> %filea = <span class="keyword">map</span> &#123; $_ =&gt; <span class="number">1</span> &#125; <span class="keyword">do</span> &#123; <span class="keyword">open</span> <span class="keyword">my</span> $fa, <span class="string">'&lt;'</span>, <span class="string">'filea'</span> <span class="keyword">or</span> <span class="keyword">die</span> $!; &lt;$fa&gt; &#125;;</div><div class="line"><span class="keyword">my</span> %fileb = <span class="keyword">map</span> &#123; $_ =&gt; <span class="number">1</span> &#125; <span class="keyword">do</span> &#123; <span class="keyword">open</span> <span class="keyword">my</span> $fb, <span class="string">'&lt;'</span>, <span class="string">'fileb'</span> <span class="keyword">or</span> <span class="keyword">die</span> $!; &lt;$fb&gt; &#125;;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">keys</span> %filea )&#123;</div><div class="line">    <span class="keyword">print</span> <span class="keyword">if</span> $fileb&#123;$_&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Perl 6 中就长这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @a := &quot;filea&quot;.IO.lines;</div><div class="line">my @b := &quot;fileb&quot;.IO.lines;</div><div class="line">.say for keys( @a ∩ @b );</div></pre></td></tr></table></figure>
<p>因为  Perl 6 中的”惰性列表”, 底层实现能把工作分割成不同的任务并行执行, 然后在需要结果的时候返回给它们. 所以, 这种情况下, <code>@a</code> 和  <code>@b</code> 的填充可以同时运行.但是要点是, 如果你有耗费时间,不彼此依赖的操作, 或者函数A要传递一个 item列表给函数B, 这些操作可能并行执行, 提高速度, 你不需要做任何线程相关的东西. 非常赞!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象的Perl6]]></title>
      <url>http://ohmycloud.github.io/2015/06/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84Perl6/</url>
      <content type="html"><![CDATA[<p> Perl 6 有很多预先定义好的类型，这些类型可以归为 2 类：<code>普通类型</code>和<code>原生类型</code>。原生类型用于<code>底层类型</code>（例如 uint 64）。原生类型没有和对象同样的功能，尽管你可以在它们身上调用方法， 它们还是被包装成普通的对象。所有你能存储到变量中的东西要么是一个原生的 value， 要么是一个对象。这包括字面值、类型（类型对象）、code 和容器。</p>
<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><hr>
<p>方法可以有参数， 但是方法名和参数列表之间不可以有空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say &quot;abc&quot;.uc;                   </div><div class="line">#        ^^^ 不带参数的方法调用</div><div class="line">my @words = $string.comb(/\w+/);</div><div class="line">#                  ^^^^^^^^^^^^ 带一个参数的方法调用</div></pre></td></tr></table></figure>
<p>另外一种方法调用的语法将方法名和参数列表用一个冒号分开(冒号紧跟方法名, 中间不能有空格):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say @*INC.join: &apos;:&apos;;</div></pre></td></tr></table></figure>
<p>方法能返回一个可变容器, 这种情况下 你可以赋值给方法调用的返回值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$*IN.input-line-separator = &quot;\r\n&quot;;</div></pre></td></tr></table></figure>
<h2 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h2><hr>
<p>Types本身就是对象 ，你可以使用类型的名字获取 type object :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $int-type-obj = Int;</div></pre></td></tr></table></figure>
<p>你可以通过调用 WHAT 方法查看任何对象的 type object(它实际上是一个方法形式的macro):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $int-type-obj = 1.WHAT;</div></pre></td></tr></table></figure>
<p>使用 === 操作符可以比较 类型对象的相等性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sub f(Int $x) &#123;</div><div class="line">    if $x.WHAT === Int &#123;</div><div class="line">        say &apos;you passed an Int&apos;;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        say &apos;you passed a subtype of Int&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类型可以使用 smart-matching来检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if $type ~~ Real &#123;</div><div class="line">    say &apos;$type contains Real or a subtype thereof&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><hr>
<p>使用 class 关键字进行类的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>声明一个词法作用域的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my class Journey &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这在嵌套类中很有用。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><hr>
<p>属性存在于每个类的实例中。属性中存储着对象的状态。在 Perl 6 中, 一切属性都是<code>私有的</code>.  它们一般使用 <code>has</code> 关键字和 <code>!</code> twigil 进行声明.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $!origin;</div><div class="line">    has $!destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $!notes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而, 没有像这样的公共(甚至保护属性)属性, 不过有一种方式能<code>自动生成访问方法</code>: 使用 <code>.</code>代替 <code>!</code> twigil 。(那个 <code>.</code> 应该让你想起了<strong>方法调用</strong>).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $.origin;</div><div class="line">    has $.destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $.notes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这默认提供了一种<strong>只读</strong>的取值方法, 为了允许更改属性, 要添加 <code>is rw</code> 特性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $.origin;</div><div class="line">    has $.destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $.notes is rw;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为类默认继承于构造器 <code>Mu</code>, 我们也要求类为我们生成一些<strong>存取方法</strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 创建一个新的类的实例.</div><div class="line">my $vacation = Journey.new(</div><div class="line">    origin      =&gt; &apos;Sweden&apos;,</div><div class="line">    destination =&gt; &apos;Switzerland&apos;,</div><div class="line">    notes       =&gt; &apos;Pack hiking gear!&apos;</div><div class="line">);</div><div class="line"># 使用存取器; 这打印出 Sweden.</div><div class="line">say $vacation.origin;</div><div class="line"># 使用 rw 存取器来更改属性的值.</div><div class="line">$vacation.notes = &apos;Pack hiking gear and sunglasses!&apos;;</div></pre></td></tr></table></figure>
<p>注意, 默认的构造器只会设置含有存取器方法的属性.</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><hr>
<p>使用 <code>method</code> 关键字定义类中的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $.origin;</div><div class="line">    has $.destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $.notes is rw;</div><div class="line"></div><div class="line">    method add_traveller($name) &#123;</div><div class="line">        if $name ne any(@!travellers) &#123;</div><div class="line">            push @!travellers, $name;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            warn &quot;$name is already going on the journey!&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method describe() &#123;</div><div class="line">        &quot;From $!origin to $!destination&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法可以有签名, 就像子例程一样。 方法中能访问对象的属性,  并且总是能使用 <code>!</code> twigil, 即使属性是用 <code>.</code> twigil 声明的. 这是因为, . twigil 是在那个位置上使用 ! twigil 声明了属性, 然后额外又添加了一个取值器方法.</p>
<p>即 <code>has $.attribute</code> 等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">has $!attribute</div><div class="line">method attribute() &#123; ... &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class A &#123;    </div><div class="line">    has $.attr is rw;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class A &#123;    </div><div class="line">    has $!attr;    </div><div class="line">    method attr() is rw &#123;</div><div class="line">        $!attr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 describe 方法中使用 $!origin 和 $.origin ,这之间有一个微小但很重要的差别.  $!origin 只是属性的简单查看. 它是廉价的, 并且你知道它是类中声明的属性. $.origin 真正的是一个方法调用, 因此能在子类中被覆写. 如果你真的显式地要覆写它才使用 $.origin 吧.</p>
<h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><hr>
<p>在方法内部, self 是可用的, 它被绑定到调用者, 例如方法调用的对象. self 能用于在调用者上调用深层的方法, 例如:</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><hr>
<p>在方法的名字前面引入一个感叹号, 这个方法就变为类的私有方法, 这个方法只在内的内部使用, 不能在其它任何地方调用.</p>
<p>私有方法的调用要使用感叹号而非点号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">method !do-something-private($x) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">method public($x) &#123;</div><div class="line">    if self.precondition &#123;</div><div class="line">        self!do-something--private(2 * $x)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>私有方法不能被子类继承.</p>
<h3 id="子方法"><a href="#子方法" class="headerlink" title="子方法"></a>子方法</h3><hr>
<p>submethod  是不会被子类继承的公开方法。从词干名来看它们在语义上与子例程类似。</p>
<p>Submethods 对于对象构建和解构任务很有用。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr>
<p>类可以有父类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Child is Parent1 is Parent2 &#123; &#125;</div></pre></td></tr></table></figure>
<p>如果在子类中调用一个方法, 但是子类没有提供那个方法, 就会调用父类中同名的方法, 如果父类中存在那个方法的话. 父类被询问的顺序就叫做方法解析顺序(MRO). Perl 6 使用 C3 方法解析顺序. 你可以通过调用一个类型的元类型方法得知这个类型的 MRO.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say Parcel.^mro;    # Parcel() Cool() Any() Mu()</div></pre></td></tr></table></figure>
<p>如果一个类没有指定它的父类, 就假定默认为 <code>Any</code>. 所有的类都直接或间接的派生于 Mu-类型层级的根.</p>
<h2 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h2><hr>
<p>对象通常通过方法调用创建, 或者通过类型对象或者通过同类型的其它对象创建. 类 Mu 提供了一个叫做 new 的构造器方法, 这个方法接收命名参数然后使用它们来初始化公共属性.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y = 2 * $!x;</div><div class="line">&#125;</div><div class="line">my $p = Point.new( x =&gt; 1, y =&gt; 2);</div><div class="line">#             ^^^ 继承自类 Mu</div></pre></td></tr></table></figure>
<p><code>Mu.new</code> 在调用者身上调用 <code>bless</code> 方法, 传递所有的具名参数. bless 创建新的对象, 然后调用该对象的 <code>BUILDALL</code> 方法.  <strong>BUILDALL</strong> 以<code>相反的</code>方法解析顺序(继承层级树自上而下)遍历所有子类(例如, 从 Mu 到 派生类), 并且在每个类中检查名为 <code>BUILD</code> 的方法是否存在。 如果存在就调用它, 再把传递给 new 方法的所有具名参数传递给这个 <code>BUILD</code> 方法。 如果没有, 这个类的公开属性就会用<code>同名的</code>具名参数进行初始化.  这两种情况下, 如果 <strong>BULID</strong> 方法和 <strong>默认构造函数</strong> 都没有对属性进行初始化, 就会应用默认值 (上面例子中的 <code>2 * $!x</code>)。</p>
<p>这种构造模式对于自定义构造器有几处暗示. 首先, 自定义 BUILD 方法应该总是子方法(submethod), 否则它们会中断子类中的属性初始化. 第二, BUILD 子方法能用于在对象构造时执行自定义代码. 它们也能用于为属性初始化<strong>创建别名</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class EncodedBuffer &#123;</div><div class="line">    has $.enc;</div><div class="line">    has $.data;</div><div class="line"></div><div class="line">    submethod BUILD(:encoding(:$enc), :$data) &#123;</div><div class="line">        $!enc  := $enc;</div><div class="line">        $!data := $data;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">my $b1 = EncodedBuffer.new( encoding =&gt; &apos;UTF-8&apos;, data =&gt; [64, 65] );</div><div class="line">my $b2 = EncodedBuffer.new( enc      =&gt; &apos;UTF-8&apos;, data =&gt; [64, 65] );</div><div class="line">#  现在 enc 和 encoding 都被允许</div></pre></td></tr></table></figure>
<p>因为传递实参给子例程把实参绑定给了形参, 如果把属性用作形参,单独绑定那一步就不需要了. 所以上面的例子可以写为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">submethod BUILD(:encoding(:$!enc), :$!data) &#123;</div><div class="line">    # nothing to do here anymore, the signature binding</div><div class="line">    # does all the work for us.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三个暗示是如果你想要一个接收位置参数的构造函数, 你必须自己写 new 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">    method new($x, $y) &#123;</div><div class="line">        self.bless(*, :$x, :$y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而, 这不是最佳实践, 因为这让来自子类的对象的初始化正确更难了.</p>
<h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h2><hr>
<p>Roles 在某种程度上和类相似, 它们都是属性和方法的集合. 不同之处在于,  roles 是用来描述对象行为的某<strong>一部分</strong>的, 和 roles 怎样应用于类中. 或怎样解析。 类用于管理对象实例, 而 roles 用于<strong>管理行为</strong>和<strong>代码复用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">role Serializable &#123;</div><div class="line">    method serialize() &#123;</div><div class="line">        self.perl; # 很粗超的序列化</div><div class="line">    &#125;</div><div class="line">    method deserialization-code($buf) &#123;</div><div class="line">        EVAL $buf; #  反转 .perl 操作</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Point does Serializable &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">&#125;</div><div class="line">my $p = Point.new(:x(1), :y(2));</div><div class="line">my $serialized = $p.serialize;      # 由 role 提供的方法</div><div class="line">my $clone-of-p = Point.deserialization-code($serialized);</div><div class="line">say $clone-of-p.x;      # 1</div></pre></td></tr></table></figure>
<p>编译器一解析到 role 声明的闭合花括号, roles 就不可变了。</p>
<h2 id="Role-Application"><a href="#Role-Application" class="headerlink" title="Role Application"></a>Role Application</h2><hr>
<p>Role 应用和类继承有重大不同。 当 role 应用到类中时, 那个 role 的方法被复制到类中。如果多个 roles 被应用到同一个类中, 冲突( 例如同名的非 multi 方法(s) )会导致编译时错误, 这可以通过在类中提供一个同名的方法来解决冲突。<br>这比多重继承更安全, 在冲突从来不会被编译器检测到的地方, 但是代替的是借助于在 MRO 中出现更早的父类, 这可能是也可能不是程序员想要的。</p>
<p>当一个 role 被应用到第二个 role上, 实际的程序被延迟直到第二个 role 被应用到类, 这时两个 roles 才都被应用到那个类中。 因此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">role R1 &#123;</div><div class="line">    # methods here</div><div class="line">&#125;</div><div class="line">role R2 does R1 &#123;</div><div class="line">    # methods here</div><div class="line">&#125;</div><div class="line">class C does R2 &#123; &#125;</div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">role R1 &#123;</div><div class="line">    <span class="comment"># methods here</span></div><div class="line">&#125;</div><div class="line">role R2 &#123;</div><div class="line">    <span class="comment"># methods here</span></div><div class="line">&#125;</div><div class="line">class C does R2 does R1 &#123; &#125;</div></pre></td></tr></table></figure>
<h2 id="Stubs"><a href="#Stubs" class="headerlink" title="Stubs"></a>Stubs</h2><hr>
<p>当 role 中包含了一个 stubbed 方法, 在这个 role 被应用到类中时, 必须提供一个同名的非 stubbed 版本的方法。这允许你创建如抽象接口那样的 roles。这有点像 Swift 中的 Protocol 协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">role AbstractSerializable &#123;</div><div class="line">    method serialize() &#123; ... &#125;  # 字面的三个点 ... 把方法标记为 stub</div><div class="line">&#125;</div><div class="line"></div><div class="line">#  下面是一个编译时错误, 例如</div><div class="line">#        Method &apos;serialize&apos; must be implemented by APoint because</div><div class="line">#        it is required by a role</div><div class="line">class APoint does AbstractSerializable &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 这个有效:</div><div class="line">class SPoint does AbstractSerializable &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">    method serialize() &#123; &quot;p($.x, $.y)&quot; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那个 stubbed 方法的实现也可能由另外一个 role 提供。</p>
<p>TODO: 参数化的 roles</p>
<h2 id="元对象编程和自省"><a href="#元对象编程和自省" class="headerlink" title="元对象编程和自省"></a>元对象编程和自省</h2><hr>
<p>Perl 6 有一个元对象系统, 这意味着对象,类,roles,grammars,enums 它们自身的行为都被其它对象控制; 那些对象叫做元对象(想想元操作符, 它操作的对象是普通操作符). 元对象, 像普通对象一样,  是类的实例, 这时我们称它们为元类.</p>
<p>对每个对象或类, 你能通过调用 <code>.HOW</code>方法获取元对象. 注意, 尽管这看起来像是一个方法调用, 然而它实际上是编译器中的特殊案列, 所以它更像一个 macro.</p>
<p>所以, 你能用元对象干些什么呢? 你可以通过比较元类的相等性来检查两个对象是否具有同样的元类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say 1.HOW ===   2.HOW;      # True</div><div class="line">say 1.HOW === Int.HOW;      # True</div><div class="line">say 1.HOW === Num.HOW;      # False</div></pre></td></tr></table></figure>
<p>Perl 6 使用单词 <code>HOW</code>, Higher Order Workings, 来引用元对象系统. 因此, 在 Rakudo 中不必对此吃惊, 控制类行为的元类的类名叫做 <code>Perl6::Metamodel::ClassHow</code>. 每个类都有一个 <code>Perl6::Metamodel::ClassHOW</code>的实例.</p>
<p>但是,理所当然的, 元模型为你做了很多. 例如它允许你内省对象和类.  元对象方法调用的约定是, 在元对象上调用方法, 并且传递感兴趣的对象作为对象的第一参数. 所以, 要获取对象的类名, 你可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $object = 1;</div><div class="line">my $metaobject = 1.HOW;</div><div class="line">say $metaobject.name($object);      # Int</div><div class="line"># or shorter:</div><div class="line">say 1.HOW.name(1);                  # Int</div></pre></td></tr></table></figure>
<p>为了避免使用同一个对象两次, 有一个便捷写法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say 1.^name;                        # Int</div><div class="line"># same as</div><div class="line">say 1.HOW.name(1);                  # Int</div></pre></td></tr></table></figure>
<h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><hr>
<p>内省就是在运行时获取对象或类的信息的过程. 在 Perl 6 中,  所有的内省都会搜查原对象. 标准的基于类对象的 ClassHow 提供了这些工具:</p>
<h3 id="can"><a href="#can" class="headerlink" title="can"></a>can</h3><hr>
<p>给定一个方法名, 它返回一个Parcel, 这个 Parcel 里面是可用的方法名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class A      &#123; method x($a) &#123;&#125; &#125;;</div><div class="line">class B is A &#123; method x()   &#123;&#125; &#125;;</div><div class="line">say B.^can(&apos;x&apos;).elems;              # 2</div><div class="line">for B.^can(&apos;x&apos;) &#123;</div><div class="line">    say .arity;                     # 1, 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中, 类 B 中有两个名为 x 的方法可能可用(尽管一个正常的方法调用仅仅会直接调用安置在 B 中那个方法). B 中的那个方法有一个参数(例如, 它期望一个参数, 一个调用者(self)), 而 A 中的 x 方法期望 2 个参数( self 和 $a).</p>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><hr>
<p>返回类中可用公共方法的列表( 这包括父类和 roles 中的方法). 默认它会停在类 Cool, Any 或 Mu 那儿; 若真要获取所有的方法, 使用副词 <code>:all</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">    method x() &#123; &#125;;</div><div class="line">&#125;</div><div class="line">say A.^methods();                   # x</div><div class="line">say A.^methods(:all);               # x infinite defined ...</div></pre></td></tr></table></figure>
<h3 id="mro"><a href="#mro" class="headerlink" title="mro"></a>mro</h3><hr>
<p>按方法解析顺序返回类自身的列表和它们的父类.  当方法被调用时, 类和它的父类按那个顺序被访问.(仅仅是概念上; 实际上方法列表在类构建是就创建了).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say 1.^mro;                         # (Int) (Cool) (Any) (Mu)</div></pre></td></tr></table></figure>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><hr>
<p>返回类的名字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &apos;a string&apos;.^name;               # Str</div></pre></td></tr></table></figure>
<h3 id="parents"><a href="#parents" class="headerlink" title="parents"></a>parents</h3><hr>
<p>返回一个父类的列表. 默认它会停在 Cool, Any 或者 Mu 那儿, 但你可以提供一个副词 <code>:all</code>来压制它. 使用副词 <code>:tree</code> 会返回一个嵌套列表.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class D             &#123; &#125;;</div><div class="line">class C1 is D       &#123; &#125;;</div><div class="line">class C2 is D       &#123; &#125;;</div><div class="line">class B is C1 is C2 &#123; &#125;;</div><div class="line">class A is B        &#123; &#125;;</div><div class="line">say A.^parents(:all).perl;          # (B, C1, C2, D, Any, Mu)</div><div class="line">say A.^parents(:all, :tree).perl;</div><div class="line">    # ([B, [C1, [D, [Any, [Mu]]]], [C2, [D, [Any, [Mu]]]]],)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式一例]]></title>
      <url>http://ohmycloud.github.io/2015/06/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>以指定音量随机播放音频文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my %v;                                 # hash to hold data</div><div class="line">my token filename    &#123; .+? \.\S\S\S &#125;; # filenames end in .???</div><div class="line">my token volume      &#123; \d+ &#125;;          # any digits for volume</div><div class="line">my regex extra       &#123; .+ \S &#125;;        # anything following that</div><div class="line">my $mixer          = &apos;mixer&apos;;</div><div class="line">my $player         = &apos;mplayer -vf dsize=600:-2 -geometry +200-10 &apos;;</div><div class="line">my $lockfile       = &apos;/tmp/myplayer&apos;;</div><div class="line"></div><div class="line">$lockfile.IO.spurt( $*PID );          # store the process ID so other process can kill this one</div><div class="line">END &#123; $lockfile.IO.unlink; &#125;          # remove the lockfile at end</div><div class="line"></div><div class="line">for $=finish.lines &#123;                  # loop through the lines below &apos;=begin finish&apos;</div><div class="line">    last if /STOP/;                   # stop at a STOP line</div><div class="line">    if m/     (&lt;filename&gt;)</div><div class="line">          \s+ (&lt;volume&gt;)</div><div class="line">          \s* (&lt;extra&gt;?) / &#123;          # use the regexes/tokens</div><div class="line">        my ( $m, $v, $e ) = $/[0..2]; # get captured values from $/</div><div class="line">        if $m and $v &#123;                # if there&apos;s a filename and volume</div><div class="line">            %v&#123;$m&#125;&lt;v&gt; ~= $v;          #   store it in the hash</div><div class="line">            %v&#123;$m&#125;&lt;e&gt; ~= $e // &apos;&apos;;    #   with any extra arguments</div><div class="line">        &#125;&#125;&#125; # lisp-y to save lines</div><div class="line">for %v.keys.pick(*) -&gt; $m &#123;           # loop randomly through keys</div><div class="line">    say &quot;Playing $m&quot;;</div><div class="line">    print qqx&#123; $mixer  %v&#123;$m&#125;&lt;v&gt;      &#125;;  # set the volume</div><div class="line">    print qqx&#123; $player %v&#123;$m&#125;&lt;e&gt; &quot;$m&quot; &#125;;  # play the file</div><div class="line">&#125;</div><div class="line"></div><div class="line"># the rest is like a Perl5 __DATA__ section</div><div class="line">=begin finish</div><div class="line">300.avi 77</div><div class="line">Crystal Skull Rifftrax.avi 77 -aid 2</div><div class="line">Star Trek 5.avi 77</div><div class="line">Star Trek 7.avi</div><div class="line">aeon-flux.avi 93</div></pre></td></tr></table></figure>
<p>改进版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#! /usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @mixer          = &apos;mixer&apos;;</div><div class="line">my @player         = &lt; m6player -vf dsize=600:-2 -geometry +200-10 &gt;;</div><div class="line">my $lockfile       = &apos;/tmp/myplayer&apos;;</div><div class="line"></div><div class="line">$lockfile.IO.spurt( $*PID );</div><div class="line"></div><div class="line">END &#123; $lockfile.IO.unlink; &#125;</div><div class="line"></div><div class="line">my token filename    &#123; .+? \.\S\S\S &#125;;</div><div class="line">my token volume      &#123; \d+ &#125;;</div><div class="line">my regex extra       &#123; .* &#125;;</div><div class="line"></div><div class="line">my %song-data;</div><div class="line"></div><div class="line">for $=finish.lines &#123;</div><div class="line">    last if /^ \s* STOP \s* $/;</div><div class="line">    next unless  m/ \s* &lt;filename&gt; \s+ &lt;volume&gt; &lt;extra&gt; /;</div><div class="line">    # $&lt;extra&gt; is short for $/&#123;&apos;extra&apos;&#125;</div><div class="line">    %song-data&#123;~$&lt;filename&gt;&#125;&lt;v e&gt; = +$&lt;volume&gt;, [$&lt;extra&gt;.words];</div><div class="line">&#125;</div><div class="line"></div><div class="line"># uses sub-signature unpacking</div><div class="line"></div><div class="line">for %song-data.pick(*) -&gt; ( :key($m), :value($) (:$v,:@e)) &#123;</div><div class="line">    say &quot;Playing $m&quot;;</div><div class="line">    print run( @mixer,  $v,     :out ).out.slurp-rest.indent(4);</div><div class="line">    print run( @player, @e, $m, :out ).out.slurp-rest.indent(4);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">=begin finish</div><div class="line">300.avi 77</div><div class="line">Crystal Skull Rifftrax.avi 77 -aid 2</div><div class="line">Star Trek 5.avi 77</div><div class="line">Star Trek 7.avi</div><div class="line">aeon-flux.avi 93</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[class-List]]></title>
      <url>http://ohmycloud.github.io/2015/06/10/class-List/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">﻿</div><div class="line">my class List is Iterable does Positional &#123; .. &#125;</div></pre></td></tr></table></figure>
<p><strong>List</strong> 以序列化的方式存储 items并且潜在是惰性的。</p>
<p>默认列表和数组的索引从 0 开始。</p>
<p>你可以给列表中的元素赋值如果它们是容器的话。使用数组以使列表中的每个元素存储在容器中。</p>
<h4 id="Items-Flattening-and-Sigils"><a href="#Items-Flattening-and-Sigils" class="headerlink" title="Items, Flattening and Sigils"></a>Items, Flattening and Sigils</h4><hr>
<p>在 Perl 6 中, 把 <strong>List</strong> 赋值给一个标量变量不会丢死信息。不同之处在于迭代通常会把标量中的列表(或其它任何像列表的东西, 例如 Parcel 和 数组)当作单个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my @a = 1, 2, 3;</div><div class="line">for @a &#123; &#125;      # 三次迭代</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my $s = @a;</div><div class="line">for $s &#123; &#125;      # 一次迭代</div><div class="line">for @a.item &#123; &#125; # 一次迭代</div><div class="line">for $s.list &#123; &#125; # 三次迭代</div></pre></td></tr></table></figure>
<p><strong>Lists</strong> 通常会插值(展开)除非它们通过一个 item(scalar)容器访问:(GLR 的影响？)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my @a = 1, 2, 3;</div><div class="line">my @flat   = @a, @a;           # two elements</div><div class="line">my @nested = @a.item, @a.item; # two elements</div></pre></td></tr></table></figure>
<p><code>.item</code> 通常能被写为 <code>$( ... )</code>, 而在数组变量上甚至写为  <code>$@a</code>。</p>
<h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><hr>
<h5 id="elems"><a href="#elems" class="headerlink" title="elems"></a>elems</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    elems($list)  returns Int:D</div><div class="line">multi method elems(List:D:) returns Int:D</div></pre></td></tr></table></figure>
<p>返回列表中元素的个数。</p>
<h5 id="end"><a href="#end" class="headerlink" title="end"></a>end</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    end($list)  returns Int:D</div><div class="line">multi method end(List:D:) returns Int:D</div></pre></td></tr></table></figure>
<p>返回列表中最后一个元素的索引</p>
<h5 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    keys($list)  returns List:D</div><div class="line">multi method keys(List:D:) returns List:D</div></pre></td></tr></table></figure>
<p>返回一个索引列表( 例如 <code>0..(@list.elems-1)</code> )</p>
<h5 id="values"><a href="#values" class="headerlink" title="values"></a>values</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    values($list)  returns List:D</div><div class="line">multi method values(List:D:) returns List:D</div></pre></td></tr></table></figure>
<p>返回列表的一份拷贝。</p>
<h5 id="kv"><a href="#kv" class="headerlink" title="kv"></a>kv</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    kv($list)  returns List:D</div><div class="line">multi method kv(List:D:) returns List:D</div></pre></td></tr></table></figure>
<p>返回索引和值的交替的列表。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;a b c&gt;.kv</div></pre></td></tr></table></figure>
<p>返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">0, &apos;a&apos;, 1, &apos;b&apos;, 2, &apos;c&apos;</div></pre></td></tr></table></figure>
<h5 id="pairs"><a href="#pairs" class="headerlink" title="pairs"></a>pairs</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    pairs($list)   returns List:D</div><div class="line">multi method pairs(List:D:) returns List:D</div></pre></td></tr></table></figure>
<p>返回一个 pairs 的列表, 使用索引作为键, 列表值作为键值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;a b c&gt;.pairs   # 0 =&gt; &apos;a&apos;, 1 =&gt; &apos;b&apos;, 2 =&gt; &apos;c&apos;</div></pre></td></tr></table></figure></p>
<h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    join($separator, *@list) returns Str:D</div><div class="line">multi method join(List:D: $separator) returns Str:D</div></pre></td></tr></table></figure>
<p>把列表中元素当作字符串, 在元素之间插入 <code>$separator</code> 并把所有东西连接成单个字符串。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">join &apos;, &apos;, &lt;a b c&gt;;     # &apos;a, b, c&apos;</div></pre></td></tr></table></figure>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    map(&amp;code, *@elems) returns List:D</div><div class="line">multi method map(List:D: &amp;code) returns List:D</div></pre></td></tr></table></figure>
<p>对每个元素调用 <code>&amp;code</code> 并且把值收集到另外一个列表中并返回它。这个过程是惰性的。 <code>&amp;code</code>只在返回值被访问的时候调用。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt; (&apos;hello&apos;, 1, 22/7, 42, &apos;world&apos;).map: &#123; .WHAT.perl &#125;</div><div class="line">Str Int Rat Int Str</div><div class="line">&gt; map *.Str.chars, &apos;hello&apos;, 1, 22/7, 42, &apos;world&apos;</div><div class="line">5 1 8 2 5</div></pre></td></tr></table></figure>
<h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    grep(Mu $matcher, *@elems) returns List:D</div><div class="line">multi method grep(List:D:  Mu $matcher) returns List:D</div></pre></td></tr></table></figure>
<p>返回一个使用 <code>$matcher</code> 智能匹配的惰性列表。元素是以出现在原列表中的顺序返回的。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt; (&apos;hello&apos;, 1, 22/7, 42, &apos;world&apos;).grep: Int</div><div class="line">1 42</div><div class="line">&gt; grep &#123; .Str.chars &gt; 3 &#125;, &apos;hello&apos;, 1, 22/7, 42, &apos;world&apos;</div><div class="line">hello 3.142857 world</div></pre></td></tr></table></figure>
<h5 id="first"><a href="#first" class="headerlink" title="first"></a>first</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    first(Mu $matcher, *@elems)</div><div class="line">multi method first(List:D:  Mu $matcher)</div></pre></td></tr></table></figure>
<p>返回列表中第一个匹配 $matcher 的元素, 当没有匹配值时, 失败。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say (1, 22/7, 42).first: * &gt; 5;     # 42</div><div class="line">say $f = (&apos;hello&apos;, 1, 22/7, 42, &apos;world&apos;).first: Complex;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;  (&apos;hello&apos;, 1, 22/7, 42, &apos;world&apos;,1+2i).first: Complex;</div><div class="line">1+2i</div><div class="line">say $f.perl; #  Failure.new(exception =&gt; X::AdHoc.new(payload =&gt; &quot;No values matched&quot;))</div></pre></td></tr></table></figure>
<h5 id="classify"><a href="#classify" class="headerlink" title="classify"></a>classify</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    classify(&amp;mapper, *@values) returns Hash:D</div><div class="line">multi method classify(List:D: &amp;mapper)   returns Hash:D</div></pre></td></tr></table></figure>
<p>根据映射器把一列值转换成代表那些值的类别的散列; 散列的每个键代表着将要归入列表的一个或多个值的类别。比如字符个数， 元素多少， 键值就是根据 mapper 得到的这个类别下的元素， 它来自于原始列表：</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say classify &#123; $_ %% 2 ?? &apos;even&apos; !! &apos;odd&apos; &#125;, (1, 7, 6, 3, 2);</div><div class="line"># (&quot;odd&quot; =&gt; [1, 7, 3], &quot;even&quot; =&gt; [6, 2]).hash;</div><div class="line"></div><div class="line">say (&apos;hello&apos;, 1, 22/7, 42, &apos;world&apos;).classify: &#123; .Str.chars &#125;;</div><div class="line"># (&quot;5&quot; =&gt; [&quot;hello&quot;, &quot;world&quot;], &quot;1&quot; =&gt; [1], &quot;8&quot; =&gt; [22/7], &quot;2&quot; =&gt; [42]).hash</div></pre></td></tr></table></figure>
<h5 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi method Bool(List:D:) returns Bool:D</div></pre></td></tr></table></figure>
<p>如果列表至少含有一个元素则返回 True, 如果列表为空则返回 False。</p>
<h5 id="Str"><a href="#Str" class="headerlink" title="Str"></a>Str</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi method Str(List:D:) returns Str:D</div></pre></td></tr></table></figure>
<p>字符串化列表中的元素并使用空格把这些元素连接起来。( 和 <code>.join(&#39; &#39;)</code> 一样)。</p>
<h5 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi method Int(List:D:) return Int:D</div></pre></td></tr></table></figure>
<p>返回列表中元素的数量(和 <code>.elems</code> 一样)</p>
<h5 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    pick($count, *@list) returns List:D</div><div class="line">multi method pick(List:D: $count = 1)</div></pre></td></tr></table></figure>
<p>从调用者身上随机返回 $count 个不重复的元素。 如果 * 作为 $count 传递进来或 $count 大于或等于列表的大小, 那么就以随机序列的方式返回列表中的所有元素。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say &lt;a b c d e&gt;.pick;           # b</div><div class="line">say &lt;a b c d e&gt;.pick: 3;        # c a e</div><div class="line">say  &lt;a b c d e&gt;.pick: *;       # e d a b c</div></pre></td></tr></table></figure>
<h5 id="roll"><a href="#roll" class="headerlink" title="roll"></a>roll</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    roll($count, *@list) returns List:D</div><div class="line">multi method roll(List:D: $count = 1)</div></pre></td></tr></table></figure>
<p>返回一个 $count 个元素的惰性列表, 每个元素都从列表中随机选择。每个随机选择都是独立的.</p>
<p>如果给 $count 传递了* 号, 则返回一个惰性的, 从原列表中随机选取元素的无限列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say &lt;a b c d e&gt;.roll;       # b</div><div class="line">say &lt;a b c d e&gt;.roll: 3;    # c c e</div><div class="line">say roll 8, &lt;a b c d e&gt;;    # b a e d a e b c</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my $random_digits := (^10).roll(*);1;</div><div class="line">say $random_digits[^15];    # 3 8 7 6 0 1 3 2 0 8 8 5 8 0 5</div></pre></td></tr></table></figure>
<h5 id="eager"><a href="#eager" class="headerlink" title="eager"></a>eager</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi method eager(List:D:) returns List:D</div></pre></td></tr></table></figure>
<p>急切地计算列表中的所有元素, 并返回调用者。如果列表标示它是”konw inifinite” 的, 急切求值可以停止在探测到的无限的点上。</p>
<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    reverse(*@list ) returns List:D</div><div class="line">multi method reverse(List:D:) returns List:D</div></pre></td></tr></table></figure>
<p>以相反的顺序返回一个含有相同元素的列表。</p>
<p>注意 reverse 总是指反转列表中的元素, 如果你想反转字符串中的字符, 那么使用 flip。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say &lt;hello world!&gt;.reverse      #  world! hello</div><div class="line">say reverse ^10                 # 9 8 7 6 5 4 3 2 1 0</div></pre></td></tr></table></figure>
<h5 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    rotate(@list,  Int:D $n = 1) returns List:D</div><div class="line">multi method rotate(List:D: Int:D $n = 1) returns List:D</div></pre></td></tr></table></figure>
<p>以 $n 个元素旋转列表, 这把原列表分成两部分, 旋转中心就是在这两部分之间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;a b c d e&gt;.rotate(2);   # &lt;c d e a b&gt;</div><div class="line">&lt;a b c d e&gt;.rotate(-1);  # &lt;e a b c d&gt;</div></pre></td></tr></table></figure>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    sort(*@elems)      returns List:D</div><div class="line">multi sub    sort(&amp;by, *@elems) returns List:D</div><div class="line">multi method sort(List:D:)      returns List:D</div><div class="line">multi method sort(List:D:, &amp;by) returns List:D</div></pre></td></tr></table></figure>
<p>列表排序, 最小的元素首先。默认使用 <code>infix:&lt;cmp&gt;</code> 排序列表中的元素。</p>
<p>如果提供了 <code>&amp;by</code>, 那么它接收两个参数, 它由列表元素对儿调用, 并且应该返回 Order::Increase, Order::Same 或 Order::Decrease.</p>
<p>如果 <code>&amp;by</code>只接受一个参数, 那么列表元素是通过 <code>by($a)  cmp by($b)</code> 来排序的。<code>&amp;by</code> 的返回值被缓存起来,  以使每个列表元素只调用一次 <code>&amp;by</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say (3, -4, 7, -1, 2, 0).sort;                  # -4 -1 0 2 3 7</div><div class="line">say (3, -4, 7, -1, 2, 0).sort: *.abs;           # 0 -1 2 3 -4 7</div><div class="line">say (3, -4, 7, -1, 2, 0).sort: &#123; $^b leg $^a &#125;; # 7 3 2 0 -4 -1</div></pre></td></tr></table></figure>
<p>reduce</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    reduce(&amp;with, *@elems)</div><div class="line">multi method reduce(List:D: &amp;with)</div></pre></td></tr></table></figure>
<p>把 <code>&amp;with</code> 应用到列表中的第一个和第二个值上, 然后把 <code>&amp;with</code>应用到那个计算的结果值和第三个值上, 以此类推。按照那种方式生成单个项。</p>
<p>注意 reduce 是一个隐式的循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say (1, 2, 3).reduce: * - *;    # -4</div></pre></td></tr></table></figure>
<h5 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    splice(@list,  $start, $elems?, *@replacement) returns List:D</div><div class="line">multi method splice(List:D: $start, $elems?, *@replacement) returns List:D</div></pre></td></tr></table></figure>
<p>从列表中删除从 $start 索引开始的 $elems 个元素, 返回删除的元素并用 @replacement 来代替它。如果省略了 $elems, 所有从 $index 开始的元素都被删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my @foo = &lt;a b c d e f g&gt;;</div><div class="line">say @foo.splice(2, 3, &lt;M N O P&gt;);       # c d e</div><div class="line">say @foo;                               # a b M N O P f g</div></pre></td></tr></table></figure>
<h5 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    pop(List:D )</div><div class="line">multi method pop(List:D:)</div></pre></td></tr></table></figure>
<p>从列表中移除并返回最后一项。如果列表为空则失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt; my @foo = &lt;a b&gt;;</div><div class="line">&gt; @foo.pop;  # b</div><div class="line">&gt; pop @foo   # a</div><div class="line">&gt; pop @foo   # Element popped from empty list</div></pre></td></tr></table></figure>
<h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    push(List:D, *@values) returns List:D</div><div class="line">multi method push(List:D: *@values) returns List:D</div></pre></td></tr></table></figure>
<p>把 @values 添加到列表的末尾, 并返回修改后的列表。 如果列表是无限列表则失败。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my @foo = &lt;a b c&gt;;</div><div class="line">@foo.push: 1, 3 ... 11;</div><div class="line">say @foo;                   # a b c 1 3 5 7 9 11</div></pre></td></tr></table></figure>
<h5 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    shift(List:D )</div><div class="line">multi method shift(List:D:)</div></pre></td></tr></table></figure>
<p>从列表中移除并返回第一项元素。 如果列表为空则失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my @foo = &lt;a b&gt;;</div><div class="line">say @foo.shift;     # a</div><div class="line">say @foo.shift;     # b</div><div class="line">say @foo.shift;     # Element shifted from empty list</div></pre></td></tr></table></figure>
<h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi sub    unshift(List:D, *@values) returns List:D</div><div class="line">multi method unshift(List:D: *@values) returns List:D</div></pre></td></tr></table></figure>
<p>添加 @values 到列表的开头, 并返回修改后的列表。 如果列表是无限列表则失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my @foo = &lt;a b c&gt;;</div><div class="line">@foo.unshift: 1, 3 ... 11;</div><div class="line">say @foo;                   # 1 3 5 7 9 11 a b c</div></pre></td></tr></table></figure>
<h5 id="combinations"><a href="#combinations" class="headerlink" title="combinations"></a>combinations</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi method combinations (List:D: Int:D $of)          returns List:D</div><div class="line">multi method combinations (List:D: Range:D $of = 0..*) returns List:D</div><div class="line">multi sub    combinations ($n, $k)                     returns List:D</div></pre></td></tr></table></figure>
<p>Int 变体返回调用者列表所有的 $of-combinations 组合。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say .join(&apos;|&apos;) for &lt;a b c&gt;.combinations(2);</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">a|b</div><div class="line">a|c</div><div class="line">b|c</div></pre></td></tr></table></figure>
<p>因为  ‘a’, ‘b’, ‘c’ 的所有 2-combinations 是  [‘a’, ‘b’], [‘a’, ‘c’], [‘b’, ‘c’].</p>
<p>Range 变体把所有单独的组合组合到单个列表中, 所以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say .join(&apos;|&apos;) for &lt;a b c&gt;.combinations(2..3);</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">a|b</div><div class="line">a|c</div><div class="line">b|c</div><div class="line">a|b|c</div></pre></td></tr></table></figure>
<p>因为那是一个所有 2-和3-combinations 组合的列表。</p>
<p>子例程 <code>combinations($n, $k)</code> 等价于 <code>(^$n).combinations($k)</code>, 所以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.say for combinations(4, 2)</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">0 1</div><div class="line">0 2</div><div class="line">0 3</div><div class="line">1 2</div><div class="line">1 3</div><div class="line">2 3</div></pre></td></tr></table></figure>
<h5 id="permutations"><a href="#permutations" class="headerlink" title="permutations"></a>permutations</h5><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">multi method permutations(List:D:) returns List:D</div><div class="line">multi sub    permutations($n)      returns List:D</div></pre></td></tr></table></figure>
<p>返回列表所有可能的组合作为数组的列表。所以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">say .join(&apos;|&apos;) for &lt;a b c&gt;.permutations</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">a|b|c</div><div class="line">a|c|b</div><div class="line">b|a|c</div><div class="line">b|c|a</div><div class="line">c|a|b</div><div class="line">c|b|a</div></pre></td></tr></table></figure>
<p>The subroutine form , so</p>
<p>permutations 把所有列表元素当作可区别的, 所以 (1, 1, 2).permutations 仍旧返回 6 个元素的列表, 即使只有 3 个不同的排列。</p>
<p><code>permutations($n)</code> 等价于 <code>(^$n).permutations</code>, 所以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.say for permutations 3;</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1 2 3</div><div class="line">1 3 2</div><div class="line">2 1 3</div><div class="line">2 3 1</div><div class="line">3 1 2</div><div class="line">3 2 1</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[怎么在Perl6中自定义存取器]]></title>
      <url>http://ohmycloud.github.io/2015/05/19/%E6%80%8E%E4%B9%88%E5%9C%A8Perl6%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%8F%96%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="How-does-one-write-custom-accessor-methods-in-Perl6"><a href="#How-does-one-write-custom-accessor-methods-in-Perl6" class="headerlink" title="How does one write custom accessor methods in Perl6?"></a>How does one write custom accessor methods in Perl6?</h2><hr>
<p>我有一个类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Wizard &#123;</div><div class="line">    has Int $.mana is rw;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我可以这样做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my Wizard $gandalf .= new;</div><div class="line">$gandalf.mana = 150;</div></pre></td></tr></table></figure>
<p>我想在不放弃使用<code>$gandalf.mana = 150;</code> 的情况下, 在  <code>setter</code>里面做一些检查。换句话说, 我不想这样写: <code>$gandalf.setMana(150)</code>。 如果程序尝试设置一个负值的话, 就退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Wizard &#123;</div><div class="line">    has Int $!mana;</div><div class="line"></div><div class="line">    method mana() is rw &#123;</div><div class="line">        return Proxy.new:</div><div class="line">            FETCH =&gt; sub ($) &#123; return $!mana &#125;,</div><div class="line">            STORE =&gt; sub ($, $mana) &#123;</div><div class="line">                die &quot;It&apos;s over 9000!&quot; if ($mana // 0) &gt; 9000;</div><div class="line">                $!mana = $mana;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">my Wizard $gandalf .= new;</div><div class="line">say $gandalf.mana;</div><div class="line">$gandalf.mana = 150;</div><div class="line">say $gandalf.mana;</div></pre></td></tr></table></figure>
<p><code>Pxoxy</code>是一种拦截对存储进行读写调用, 并做一些非默认行为的方式。在解析像 <code>$gandalf.mana = $gandalf.mana + 5</code> 这种表达式的时候, Perl 6 会自动调用 <code>FETCH</code> 和 <code>STORE</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Baby &#123;</div><div class="line">  has Int $.mana; # use . instead of ! for better `.perl` representation</div><div class="line"></div><div class="line">  # overwrite the method the attribute declaration added</div><div class="line">  method mana () is rw &#123;</div><div class="line">    Proxy.new(</div><div class="line">      FETCH =&gt; -&gt; $ &#123; $!mana &#125;,</div><div class="line">      STORE =&gt; -&gt; $, Int $new &#123;</div><div class="line">        die &apos;invalid mana&apos; unless $new &gt;= 0; # placeholder for a better error</div><div class="line">        $!mana = $new</div><div class="line">      &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my Baby $baby .= new;</div><div class="line">$baby.mana = 9;</div><div class="line">say $baby.mana;</div><div class="line">$baby.mana = -9;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[reddit-Random-Bag-System]]></title>
      <url>http://ohmycloud.github.io/2015/05/19/reddit-Random-Bag-System/</url>
      <content type="html"><![CDATA[<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><hr>
<p>有 7 块板子放在一个”袋子”中, 随机从袋子中移除一个板子展示到玩家面前直到袋子变空。当袋子变空时, 它会被重新装填, 如果需要额外的板子, 则重复前面那个过程。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><hr>
<p>使用随机 bag 系统随机输出 50 块板子。</p>
<p>板子如下:</p>
<ul>
<li>O</li>
<li>I</li>
<li>S</li>
<li>Z</li>
<li>L</li>
<li>J</li>
<li>T</li>
</ul>
<h4 id="输出样本"><a href="#输出样本" class="headerlink" title="输出样本"></a>输出样本</h4><hr>
<ul>
<li><code>LJOZISTTLOSZIJOSTJZILLTZISJOOJSIZLTZISOJTLIOJLTSZO</code></li>
<li><code>OTJZSILILTZJOSOSIZTJLITZOJLSLZISTOJZTSIOJLZOSILJTS</code></li>
<li><code>ITJLZOSILJZSOTTJLOSIZIOLTZSJOLSJZITOZTLJISTLSZOIJO</code></li>
</ul>
<p>在 Perl 6 中我会这样写 (smls):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say (|&lt;O I S Z L J T&gt;.pick(*) xx *).[^50].join;</div></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>| 操作符把每次迭代的项展开进外部的列表中, 以使你不必在结果上显式地调用 .flat 方法</li>
<li>使用 <code>&lt; &gt;</code> 字符串列表字面量看起来比在字符串字面量上使用 .comb 方法更合适</li>
<li>xx 操作符每次都会重新计算它左侧的表达式</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[下标副词]]></title>
      <url>http://ohmycloud.github.io/2015/05/18/%E4%B8%8B%E6%A0%87%E5%89%AF%E8%AF%8D/</url>
      <content type="html"><![CDATA[<h1 id="下标副词"><a href="#下标副词" class="headerlink" title="下标副词"></a><a href="https://desgin.perl6.org/S02.html#Subscript_adverbs" target="_blank" rel="external">下标副词</a></h1><p>为了使切片下标返回除了值以外的其它东西，那么给下标(subscript)添加合适的副词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@array = &lt;A B&gt;;</div><div class="line">@array[0,1,2];      # returns &apos;A&apos;, &apos;B&apos;, (Any)</div><div class="line">@array[0,1,2] :p;   # returns 0 =&gt; &apos;A&apos;, 1 =&gt; &apos;B&apos;</div><div class="line">@array[0,1,2] :kv;  # returns 0, &apos;A&apos;, 1, &apos;B&apos;</div><div class="line">@array[0,1,2] :k;   # returns 0, 1</div><div class="line">@array[0,1,2] :v;   # returns &apos;A&apos;, &apos;B&apos;</div><div class="line"></div><div class="line">%hash = (:a&lt;A&gt;, :b&lt;B&gt;);</div><div class="line">%hash&lt;a b c&gt;;       # returns &apos;A&apos;, &apos;B&apos;, (Any)</div><div class="line">%hash&lt;a b c&gt; :p;    # returns a =&gt; &apos;A&apos;, b =&gt; &apos;B&apos;</div><div class="line">%hash&lt;a b c&gt; :kv;   # returns &apos;a&apos;, &apos;A&apos;, &apos;b&apos;, &apos;B&apos;</div><div class="line">%hash&lt;a b c&gt; :k;    # returns &apos;a&apos;, &apos;b&apos;</div><div class="line">%hash&lt;a b c&gt; :v;    # returns &apos;A&apos;, &apos;B&apos;</div></pre></td></tr></table></figure>
<p>如果副词为真，那么这些副词形式都会清除不存在的条目；如果为假的话，就会留下不存在的项，就像普通的切片那样。所以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@array[0,1,2] :!p;  # returns 0 =&gt; &apos;A&apos;, 1 =&gt; &apos;B&apos;, 2 =&gt; (Any)</div><div class="line">%hash&lt;a b c&gt;  :!kv; # returns &apos;a&apos;, &apos;A&apos;, &apos;b&apos;, &apos;B&apos;, &apos;c&apos;, (Any)</div></pre></td></tr></table></figure>
<p>同样地，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my ($a,$b,$c) = %hash&lt;a b c&gt; :delete;</div></pre></td></tr></table></figure>
<p>删除那些条目并顺道返回它们。这种形式能够工作是因为下标是顶端的在前的操作符。如果某些其它的操作符的优先级比处于顶端的逗号操作符的优先级紧凑，那么你必须用括号括起它或强制为列表上下文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 + (%hash&#123;$x&#125; :delete);</div><div class="line">$x = (%hash&#123;$x&#125; :delete);</div><div class="line">($x) = %hash&#123;$x&#125; :delete;</div></pre></td></tr></table></figure>
<p>只有在副词为真的时候元素才会被删除。而 :!delete 本质上是一个空操作；你可以基于传递的诸如 :delete($kill’em) 标记顺带有条件地删除条目。在任何一种情况下，被删除的值会被返回。</p>
<p>你也可以执行存在性测试，要么测试单个条目是否存在，要么测试条目的连接是否存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if %hash&lt;foo&gt; :exists           &#123;...&#125;</div><div class="line">if %hash&#123;any &lt;a b c&gt;&#125;  :exists  &#123;...&#125;</div><div class="line">if %hash&#123;all &lt;a b c&gt;&#125;  :exists  &#123;...&#125;</div><div class="line">if %hash&#123;one &lt;a b c&gt;&#125;  :exists  &#123;...&#125;</div><div class="line">if %hash&#123;none &lt;a b c&gt;&#125; :exists  &#123;...&#125;</div></pre></td></tr></table></figure>
<p>把 <code>:exists</code> 副词和一组切片结果的布尔值列表结合起来使用，你也可以用类型的语义这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if any %hash&lt;a b c&gt;  :exists &#123;...&#125;</div><div class="line">if all %hash&lt;a b c&gt;  :exists &#123;...&#125;</div><div class="line">if one %hash&lt;a b c&gt;  :exists &#123;...&#125;</div><div class="line">if none %hash&lt;a b c&gt; :exists &#123;...&#125;</div></pre></td></tr></table></figure>
<p>你可以使用 <code>:!exists</code> 来测试不存在。这特别便捷因为优先级规则让 <code>!%hash&lt;a&gt; :exists</code> 把 <code>:exists</code> 应用到前缀 <code>!</code> 上。 <code>%hash&lt;a&gt; :!exists</code> 没有那个问题。</p>
<h2 id="组合下标副词"><a href="#组合下标副词" class="headerlink" title="组合下标副词"></a>组合下标副词</h2><p>像调用中得具名参数那样，下标中处理多个副词是没有顺序之分的。有些组合有意义，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%a = %b&#123;@keys-to-extract&#125; :delete :p; # same as :p :delete</div></pre></td></tr></table></figure>
<p>会把给定的键分片到另外一个散列中。而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@actually-deleted = %h&#123;@keys-to-extract&#125; :delete :k; # same as :k :delete</div></pre></td></tr></table></figure>
<p>会返回真正从散列中删除的键。</p>
<p>只指定返回类型的副词，不能被组合，因为诸如 <code>:kv :p</code>、或 <code>:v :k</code> 就没有意义。</p>
<p>下面的这些副词组合被看做是合法的：</p>
<pre><code class="perl6">:delete :kv            delete, return key/values of actually deleted keys
:delete :!kv           delete, return key/values of all keys attempted
:delete :p             delete, return pairs of actually deleted keys
:delete :!p            delete, return pairs of all keys attempted
:delete :k             delete, return actually deleted keys
:delete :!k            delete, return all keys attempted to delete
:delete :v             delete, return values of actually deleted keys
:delete :!v            delete, return values of all keys attempted
:delete :exists        delete, return Bools indicating keys existed
:delete :!exists       delete, return Bools indicating keys did not exist
:delete :exists :kv    delete, return list with key,True for key existed
:delete :!exists :kv   delete, return list with key,False for key existed
:delete :exists :!kv   delete, return list with key,Bool whether key existed
:delete :!exists :!kv  delete, return list with key,!Bool whether key existed
:delete :exists :p     delete, return pairs with key/True for key existed
:delete :!exists :p    delete, return pairs with key/False for key existed
:delete :exists :!p    delete, return pairs with key/Bool whether key existed
:delete :!exists :!p   delete, return pairs with key/!Bool whether key existed
:exists :kv            return pairs with key,True for key exists
:!exists :kv           return pairs with key,False for key exists
:exists :!kv           return pairs with key,Bool for key exists
:!exists :!kv          return pairs with key,!Bool for key exists
:exists :p             return pairs with key/True for key exists
:!exists :p            return pairs with key/False for key exists
:exists :!p            return pairs with key/Bool for key exists
:!exists :!p           return pairs with key/!Bool for key exists
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Perl6中异步地执行外部程序]]></title>
      <url>http://ohmycloud.github.io/2015/05/14/%E5%9C%A8Perl6%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%9C%B0%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><a href="http://ks0608.hatenablog.com/entry/2016/05/17/001826" target="_blank" rel="external">Execute an external program with timeout in Perl6</a></p>
<p>Proc::Async 允许我们异步地执行外部程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $proc = Proc::Async.new(&quot;curl&quot;, &quot;-s&quot;, &quot;-o&quot;, &quot;index.html&quot;, &quot;http://www.cpan.org&quot;);</div><div class="line">my $res = await $proc.start;</div></pre></td></tr></table></figure>
<p>我们可以在 Proc::Async 中使用超时吗? Proc::Async 没有正式支持该功能，但是我们可以很容易地实现它。看一下这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Proc::Async::Timeout is Proc::Async &#123;</div><div class="line">    has $.timeout is rw;</div><div class="line">    method start($self: |) &#123;</div><div class="line">        return callsame unless $.timeout;</div><div class="line">        my $killer = Promise.in($.timeout).then: &#123; $self.kill &#125;;</div><div class="line">        my $promise = callsame;</div><div class="line">        Promise.anyof($promise, $killer).then: &#123; $promise.result &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $proc = Proc::Async::Timeout.new(&quot;perl&quot;, &quot;-E&quot;, &quot;sleep 5; warn &apos;end&apos;&quot;);</div><div class="line">$proc.timeout = 1;</div><div class="line">my $res = await $proc.start;</div><div class="line">say &quot;maybe timeout&quot; if $res.signal;</div></pre></td></tr></table></figure>
<p>你甚至可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my $start = Proc::Async.^methods.first(*.name eq &quot;start&quot;);</div><div class="line"></div><div class="line">$start.wrap: method ($self: :$timeout, |c) &#123;</div><div class="line">    return callwith($self, |c) unless $timeout;</div><div class="line">    my $killer = Promise.in($timeout).then: &#123; $self.kill &#125;;</div><div class="line">    my $promise = callwith($self, |c);</div><div class="line">    Promise.anyof($promise, $killer).then: &#123; $promise.result &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">say await Proc::Async.new(&quot;perl&quot;, &quot;-E&quot;, &apos;sleep 3; say &quot;end&quot;&apos;).start(timeout =&gt; 2);</div></pre></td></tr></table></figure>
<p>哇，哇！如果你发现了更酷的方法，请告诉我。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-入门指南]]></title>
      <url>http://ohmycloud.github.io/2015/05/08/Perl-6-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h2 id="exit，warn，die"><a href="#exit，warn，die" class="headerlink" title="exit，warn，die"></a>exit，warn，die</h2><hr>
<p>exit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">say &quot;hello&quot;;</div><div class="line">exit;</div><div class="line">say &quot;world&quot;; # 这句不会执行了</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">warn &quot;This is a warning&quot;; # 打印警告，带行号</div><div class="line">say &quot;Hello World&quot;;</div></pre></td></tr></table></figure>
<p>die</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">say &quot;Before calling die&quot;;</div><div class="line">die &quot;This will kill the script&quot;;</div><div class="line">say &quot;This will not show up&quot;;</div></pre></td></tr></table></figure>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><hr>
<p>Hello World</p>
<p>使用关键字 say打印出字符串，并在字符串结尾自动添加一个换行符。字符串被双引号包裹住。Perl 6 中语句以分号结束。<br>examples/intro/hello_world.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">say &quot;Hello Perl 6 World&quot;;</div></pre></td></tr></table></figure>
<p>同样地， OOP 风格:<br>examples/intro/hello_world_oop.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">&quot;Hello again Perl 6 World&quot;.say;</div></pre></td></tr></table></figure>
<p>你可以键入  perl6 hello_world.p6   或  perl6 hello_world_oop.p6 中的任意一个.<br>实际上你甚至不需要所有3行，下面这个例子同样有效，如果你这样写  perl6 hello_world_bare.p6 .<br>examples/intro/hello_world_bare.p6<br>say “Hello Perl 6 World”;<br>sh-bang 行- 只在Unix/Linux下使用</p>
<p>文件后缀</p>
<p>尽管不是必须的，我使用文件后缀p6来表明这是个Perl 6 脚本。有些人只是使用常规的pl后缀，而实际上在UNIX 系统中这没有什么不可。只是在有些编辑器是基于它们的文件后缀名来高亮语法时才显得必要。<br><code>use v6;</code></p>
<p>这一行告诉perl下面的代码需要Perl 6 或更高版本。如果你使用perl6来运行，这段代码也会正确运行。但在Perl5下运行会有迷惑。例如 perl hell_world_bare.p6   输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">examples/intro/hello_world_bare.err</div><div class="line">String found where operator expected at books/examples/intro/hello_world_bare.p6 line 1, near &quot;say &quot;Hello Perl 6 World&quot;&quot;</div><div class="line">        (Do you need to predeclare say?)</div><div class="line">syntax error at books/examples/intro/hello_world_bare.p6 line 1, near &quot;say &quot;Hello Perl 6 World&quot;&quot;</div><div class="line">Execution of books/examples/intro/hello_world_bare.p6 aborted due to compilation errors.</div></pre></td></tr></table></figure>
<p>如果代码中使用了use v6,但是使用perl 5 来运行的话，会发生什么？</p>
<p>perl hello_world.p6   输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">examples/intro/hello_world.err</div><div class="line">Perl v6.0.0 required--this is only v5.14.2, stopped at books/examples/intro/hello_world.p6 line 2.</div><div class="line">BEGIN failed--compilation aborted at books/examples/intro/hello_world.p6 line 2.</div><div class="line">现在问题更清晰了 (Though it would be nice if the error message printed by perl 5 was something like:  This code requires Perl v6.0.0. You ran it using v5.14.2.</div></pre></td></tr></table></figure>
<h2 id="given-when-结构"><a href="#given-when-结构" class="headerlink" title="given-when 结构"></a>given-when 结构</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $a         = prompt &quot;Number:&quot;;</div><div class="line">my $operator  = prompt &quot;Operator: [+-*/]:&quot;;</div><div class="line">my $b         = prompt &quot;Number:&quot;;</div><div class="line"></div><div class="line">given $operator &#123;</div><div class="line">    when &quot;+&quot; &#123; say $a + $b; &#125;</div><div class="line">    when &quot;-&quot; &#123; say $a - $b; &#125;</div><div class="line">    when &quot;*&quot; &#123; say $a * $b; &#125;</div><div class="line">    when &quot;/&quot; &#123; say $a / $b; &#125;</div><div class="line">    default  &#123; say &quot;Invalid operator $operator&quot;; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="标量变量"><a href="#标量变量" class="headerlink" title="标量变量"></a>标量变量</h2><hr>
<p>字符串可以存储在所谓的标量变量中。每个标量变量以符号 $ 开头，后面跟着字母数字、单词、下划线和破折号。在第一次使用这种标量之前，我们必须使用 my 关键字 声明它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  my $this_is_a_variable;</div><div class="line">  my $ThisIsAnotherVariableBut WeDontLikeItSoMuch;</div><div class="line">  my $this-is-a-variable;</div><div class="line">```  </div><div class="line">变量是大小写敏感的。</div><div class="line"></div><div class="line">```perl6</div><div class="line">  my $h;</div><div class="line">  my $H;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $greeting = &quot;Hello World&quot;;</div><div class="line">say $greeting;</div><div class="line"></div><div class="line">my $Gábor-was-born-in = &apos;Hungary&apos;;</div><div class="line">say $Gábor-was-born-in;</div></pre></td></tr></table></figure>
<p>默认地，标量变量没有特定的类型，但是随后我们会看到，怎样限制一个标量让其能容纳一个数字或任何其它类型。</p>
<p>声明一个变量时也可不用初始化它的值:  <code>my $x;</code><br>在这种情况下，该变量的值为<code>Any()</code>,也就是还没被定义。</p>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><hr>
<p>你可以使用if 语句和其中之一的比较操作符来比较两个值或标量变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $age = 23;</div><div class="line">if $age &gt; 18 &#123;</div><div class="line">    say &quot;You can vote in most countries.&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他类型的 if 语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if COND &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if COND &#123;</div><div class="line">&#125; else &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">if COND &#123;</div><div class="line">&#125; elsif COND &#123;</div><div class="line">&#125; elsif COND &#123;</div><div class="line">&#125; else &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Perl-6-的散列"><a href="#Perl-6-的散列" class="headerlink" title="Perl 6 的散列"></a>Perl 6 的散列</h2><hr>
<p>散列（也叫做关联数组）是一列键值对，其中，键是唯一的字符串，键值可以是任意值。<br>散列以 % 符号开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my %user_a = &quot;fname&quot;, &quot;Foo&quot;, &quot;lname&quot;, &quot;Bar&quot;;</div><div class="line">my %user_b =</div><div class="line">      &quot;fname&quot; =&gt; &quot;Foo&quot;,</div><div class="line">      &quot;lname&quot; =&gt; &quot;Bar&quot;,</div><div class="line">;</div><div class="line">say %user_a&#123;&quot;fname&quot;&#125;;</div><div class="line">%user_a&#123;&quot;email&quot;&#125; = &quot; foo@bar.com &quot;;</div><div class="line">say %user_a&#123;&quot;email&quot;&#125;;</div><div class="line">say %user_b;</div></pre></td></tr></table></figure>
<p>输出:<br>Foo<br>foo@bar.com<br>Bar</p>
<p>从散列中取回数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my %user =</div><div class="line">      &quot;fname&quot; =&gt; &quot;Foo&quot;,</div><div class="line">      &quot;lname&quot; =&gt; &quot;Bar&quot;,</div><div class="line">      &quot;email&quot; =&gt; &quot; foo@bar.com &quot;,</div><div class="line">;</div><div class="line">for %user.keys.sort -&gt; $key &#123;</div><div class="line">      say &quot;$key  %user&#123;$key&#125;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<pre><code>email  foo@bar.com
fname  Foo
lname  Bar
</code></pre><p>多维散列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my %xml;</div><div class="line">%xml[0] = &apos;Foo&apos;;</div><div class="line">%xml[1] = &apos;Bar&apos;;</div><div class="line">say %xml.perl;</div></pre></td></tr></table></figure>
<p>输出:<br>(“person” =&gt; [“Foo”, “Bar”]).hash</p>
<p>计算字数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my $filename = &apos;examples/words.txt&apos;;</div><div class="line">my %counter;</div><div class="line">my $fh = open $filename;</div><div class="line">for $fh.lines -&gt; $line &#123;</div><div class="line">      my @words = split /\s+/, $line;</div><div class="line">      for @words -&gt; $word &#123;</div><div class="line">              %counter&#123;$word&#125;++;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line">for %counter.keys.sort -&gt; $word &#123;</div><div class="line">      say &quot;$word &#123;%counter&#123;$word&#125;&#125;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回顾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"># 创建散列</div><div class="line">my %h1 = first =&gt; &apos;1st&apos;, second =&gt; &apos;2nd&apos;;</div><div class="line">if %h1&#123;&apos;first&apos;&#125;.defined &#123;</div><div class="line">      say &quot;the value of &apos;first&apos; is defined&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if %h1.defined &#123;</div><div class="line">      say &quot;the value of &apos;second&apos; is defined&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if %h1.exists(&apos;first&apos;) &#123;</div><div class="line">      say &quot;the key &apos;first&apos; exists in h2&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say %h1.exists(&apos;third&apos;) ?? &quot;third exists&quot; !! &quot;third does not exist&quot;;</div><div class="line">say %h1;</div><div class="line">say %h1;</div><div class="line"></div><div class="line"># TODO hash with fixed keys not implemented yet</div><div class="line">#my %h2&#123;&apos;a&apos;, &apos;b&apos;&#125; = (&apos;A&apos;, &apos;B&apos;);</div><div class="line">#say %h2.delete(&apos;a&apos;);</div><div class="line">#say %h2.delete(&apos;a&apos;);</div></pre></td></tr></table></figure>
<p>输出:</p>
<p>the value of ‘first’ is defined<br>the value of ‘second’ is defined<br>the key ‘first’ exists in h2<br>third does not exist<br>1st<br>2nd<br>slurp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my $filename = &apos;examples/phonebook.txt&apos;;</div><div class="line">my @lines = lines $filename.IO;</div><div class="line">for @lines -&gt; $line &#123;</div><div class="line">      say &quot;L: $line&quot;;</div><div class="line">&#125;</div><div class="line">#my %phonebook = map &#123;split &quot;,&quot;, $_&#125;, @lines;</div><div class="line">#my %phonebook = map &#123;$_.comb(/\w+/)&#125;, @lines;</div><div class="line">my %phonebook = slurp($filename).comb(/\w+/);</div><div class="line">my $name = prompt &quot;Name:&quot;;</div><div class="line">say %phonebook&#123;$name&#125;;</div></pre></td></tr></table></figure>
<p>输出：<br>Foo,123<br>Bar,78<br>Baz,12321<br>kv</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my %user =</div><div class="line">      &quot;fname&quot; =&gt; &quot;Foo&quot;,</div><div class="line">      &quot;lname&quot; =&gt; &quot;Bar&quot;,</div><div class="line">      &quot;email&quot; =&gt; &quot; foo@bar.com &quot;,</div><div class="line">;</div><div class="line">for %user.kv -&gt; $key, $value &#123;</div><div class="line">      say &quot;$key  $value&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出:<br>fname  Foo<br>lname  Bar<br>email  foo@bar.com</p>
<p>遍历散列键<br>使用 “keys” 函数也可以遍历散列键.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my %phone =</div><div class="line">      &quot;Foo&quot; =&gt; 123,</div><div class="line">      &quot;Bar&quot; =&gt; 456,</div><div class="line">;</div><div class="line">for keys %phone -&gt; $name &#123;</div><div class="line">      say &quot;$name %phone&#123;$name&#125;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出:<br>Bar 456<br>Foo 123</p>
<h2 id="POD文档"><a href="#POD文档" class="headerlink" title="POD文档"></a>POD文档</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">print &quot;Hello&quot;;</div><div class="line">=begin pod</div><div class="line">=head1 Title</div><div class="line">text</div><div class="line">=end pod</div><div class="line">say &quot; World&quot;;</div></pre></td></tr></table></figure>
<p>这会打印出Hello World</p>
<h2 id="slurp"><a href="#slurp" class="headerlink" title="slurp"></a>slurp</h2><hr>
<p>读取整个文件内容到标量变量中</p>
<p>Perl 6 有一个内建模式来一次性吸入文件内容, 那就是把整个文件内容读到一个标量变量中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $filename = $*PROGRAM_NAME;</div><div class="line">my $data = slurp $filename;</div><div class="line">say $data.bytes;</div></pre></td></tr></table></figure>
<h2 id="Twigils-和特殊变量"><a href="#Twigils-和特殊变量" class="headerlink" title="Twigils 和特殊变量"></a>Twigils 和特殊变量</h2><hr>
<p>Perl 6 有很多特殊变量.为了更容易地跟普通变量区分开，它们用一种叫做twigil的第二个前缀来标记。<br>通常,用户自定义的变量有一个魔符($ @ 或%)在变量名前。</p>
<p>系统变量有额外的字符在魔符和变量名之间</p>
<p>Examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$*PROGRAM_NAME 包含当前运行的Perl 6 脚本的路径.</div><div class="line">$*CWD          是当前工作目录的路径。</div><div class="line">$*IN           是标准输入(STDIN).你可以使用 $*IN.get 读入一行。</div></pre></td></tr></table></figure>
<p>你可以阅读S28了解更多。</p>
<h2 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h2><hr>
<p>有两种相关的比较操作符. 一种是比较数字，一种是比较字符串,基于 ASCII表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3 == 4               # false</div><div class="line">&apos;35&apos; eq 35.0         # false</div><div class="line">&apos;35&apos; == 35.0         # true</div><div class="line">13 &gt; 2               # true</div><div class="line">13 gt 2              # false !!!</div><div class="line">&quot;hello&quot; == &quot;world&quot;   # throws exception</div><div class="line">&quot;hello&quot; eq &quot;world&quot;   # false</div><div class="line">&quot;hello&quot; == &quot;&quot;        # throws exception</div><div class="line">&quot;hello&quot; eq &quot;&quot;        # false</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">say 4       == 4 ?? &quot;TRUE&quot; !! &quot;FALSE&quot;;     # TRUE</div><div class="line">say 3       == 4 ?? &quot;TRUE&quot; !! &quot;FALSE&quot;;     # FALSE</div><div class="line">say &quot;3.0&quot;   == 3 ?? &quot;TRUE&quot; !! &quot;FALSE&quot;;     # TRUE</div><div class="line">say &quot;3.0&quot;   eq 3 ?? &quot;TRUE&quot; !! &quot;FALSE&quot;;     # FALSE</div><div class="line">say 13     &gt;   2 ?? &quot;TRUE&quot; !! &quot;FALSE&quot;;     # TRUE</div><div class="line">say 13     gt 2 ?? &quot;TRUE&quot; !! &quot;FALSE&quot;;      # FALSE</div><div class="line">say &quot;foo&quot;   == &quot;&quot; ?? &quot;TRUE&quot; !! &quot;FALSE&quot;;    # TRUE</div><div class="line">say &quot;foo&quot;   eq &quot;&quot; ?? &quot;TRUE&quot; !! &quot;FALSE&quot;;    # FALSE</div><div class="line">say &quot;foo&quot;   == &quot;bar&quot; ?? &quot;TRUE&quot; !! &quot;FALSE&quot;; # TRUE</div><div class="line">say &quot;foo&quot;   eq &quot;bar&quot; ?? &quot;TRUE&quot; !! &quot;FALSE&quot;; # FALSE</div></pre></td></tr></table></figure>
<p>  不能转换字符串为数字：十进制数字必须以合法数字或点开头</p>
<h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">布尔表达式 (逻辑操作符)</div><div class="line">  if COND and COND &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if COND or COND &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if not COND &#123;</div><div class="line">  &#125;</div><div class="line">examples/scalars/logical_operators.p6</div><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">say (2 and 1);   # 1</div><div class="line">say (1 and 2);   # 2</div><div class="line">say (1 and 0);   # 0</div><div class="line">say (0 and 1);   # 0</div><div class="line">say (0 and 0);   # 0</div><div class="line">say &quot;---&quot;;</div><div class="line"></div><div class="line">say (1 or 0);   # 1</div><div class="line">say (1 or 2);   # 1</div><div class="line">say (0 or 1);   # 1</div><div class="line">say (0 or 0);   # 0</div><div class="line">say &quot;---&quot;;</div><div class="line"></div><div class="line">say (1 // 0);     # 1</div><div class="line">say (0 // 1);     # 0</div><div class="line">say (0 // 0);     # 0</div><div class="line">say &quot;---&quot;;</div><div class="line"></div><div class="line">say (1 xor 0);     # 1</div><div class="line">say (0 xor 1);     # 1</div><div class="line">say (0 xor 0);     # 0</div><div class="line">say (1 xor 1);     # Nil</div><div class="line">say &quot;---&quot;;</div><div class="line"></div><div class="line">say (not 1);       # False</div><div class="line">say (not 0);       # True</div><div class="line">say &quot;---&quot;;</div></pre></td></tr></table></figure>
<h2 id="超级or-多选分支"><a href="#超级or-多选分支" class="headerlink" title="超级or - 多选分支"></a>超级or - 多选分支</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">say &quot;Please select an option:&quot;;</div><div class="line">say &quot;1) one&quot;;</div><div class="line">say &quot;2) two&quot;;</div><div class="line">say &quot;3) three&quot;;</div><div class="line">my $c = prompt(&apos;&apos;);</div><div class="line"></div><div class="line">if $c == 1 or $c == 2 or $c == 3 &#123;</div><div class="line">    say &quot;correct choice: $c&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    say &quot;Incorrect choice: $c&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">这种新颖的语法</div><div class="line">if $c == 1|2|3 &#123;</div><div class="line">    say &quot;correct choice: $c&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    say &quot;Incorrect choice: $c&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="从键盘读入"><a href="#从键盘读入" class="headerlink" title="从键盘读入"></a>从键盘读入</h2><hr>
<p>prompt读取用户输入内容知道用户按下 Enter键。但是它只传递第一个换行之前的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my $name = prompt(&quot;Please type in yourname: &quot;);</div><div class="line">say &quot;Hello $name&quot;; #还不能处理汉字，prompt是一个函数，其参数为提示信息</div></pre></td></tr></table></figure>
<h2 id="读取文件内容到数组中"><a href="#读取文件内容到数组中" class="headerlink" title="读取文件内容到数组中"></a>读取文件内容到数组中</h2><hr>
<p>当我们把调用slurp() 的结果放进数组中时，数组中将只有一个元素，该元素的值就是要读取的文件中的所有内容。如果你想读取所有行到数组中不同的元素中，你需要使用 <code>lines</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $filename = $*PROGRAM_NAME;</div><div class="line"></div><div class="line"># reads all the content of the file in the first element of the array!</div><div class="line">my @content = slurp $filename;</div><div class="line">say @content.elems;</div><div class="line"></div><div class="line"># reads all the content of the file, every line an element in the array</div><div class="line">my @rows = lines $filename.IO;</div><div class="line">say @rows.elems;</div></pre></td></tr></table></figure>
<h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><hr>
<p>numbers.txt:(另存为ansi编码)<br>3<br>8<br>19<br>-7<br>13</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $filename = &apos;numbers.txt&apos;;</div><div class="line"></div><div class="line">my $total;</div><div class="line">my $count;</div><div class="line">my $min;</div><div class="line">my $max;</div><div class="line"></div><div class="line">if (my $fh = open $filename, :r) &#123;</div><div class="line">    for $fh.lines -&gt; $line &#123;</div><div class="line">        if (not $count) &#123;</div><div class="line">            $min = $max = $line;</div><div class="line">        &#125;</div><div class="line">        $total += $line;</div><div class="line">        if ($min &gt; $line) &#123;</div><div class="line">            $min = $line;</div><div class="line">        &#125;</div><div class="line">        if ($max &lt; $line) &#123;</div><div class="line">            $max = $line;</div><div class="line">        &#125;</div><div class="line">        $count++;</div><div class="line">    &#125;</div><div class="line">    my $average = $total / $count;</div><div class="line">    say &quot;Total: $total, Count: $count Average: $average Min: $min Max: $max&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    say &quot;Could not open &apos;$filename&apos;&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># There is a minor issue in this solution, what if there are no values at all in the file?</div></pre></td></tr></table></figure>
<h2 id="列表和数组"><a href="#列表和数组" class="headerlink" title="列表和数组"></a>列表和数组</h2><hr>
<p>括号()中用逗号分隔的东西叫做列表。实际上你甚至不需要括号。 列表就是一组有序的标量值。例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">(1, 5.2, &quot;apple&quot;);           # 3 values</div><div class="line">(1,2,3,4,5,6,7,8,9,10);      # 很好但是我们很懒，所以我们这样写：:</div><div class="line">(1..10);                     # 与(1,2,3,4,5,6,7,8,9,10)一样</div><div class="line">(1..Inf);                    # represents the list of all the numbers</div><div class="line">(1..*);                      # this too</div><div class="line"></div><div class="line">(&quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;blueberry&quot;);    # is the same as</div><div class="line">&lt;apple banana peach blueberry&gt;;               # quote word</div><div class="line"></div><div class="line">my ($x, $y, $z);             # 我们也能使用标量变量作为列表的元素</div></pre></td></tr></table></figure>
<p>在大多数情况下，我们实际上甚至不需要括号.</p>
<p>列表赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  my ($x, $y, $z);</div><div class="line">  ($x, $y, $z) = f();   # 如果 f() 返回 (2, 3, 7) 则它几乎与$x=2; $y=3; $z=7;相同</div><div class="line">  ($x, $y, $z) = f();   # 如果 f() 返回 (2, 3, 7, 9), 则忽略 9</div><div class="line">  ($x, $y, $z) = f();   # 如果 f() 返回 (2, 3); 则 $z 是 undef</div><div class="line">我们怎么交换两个变量的值，比如说 $x 和 $y?</div></pre></td></tr></table></figure>
<p>交换两个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">say &quot;Type in two values:&quot;;</div><div class="line">my $a = $*IN.get;</div><div class="line">my $b = $*IN.get;</div><div class="line"></div><div class="line">($a, $b) = ($b, $a);</div><div class="line">say $a;</div><div class="line">say $b;</div></pre></td></tr></table></figure>
<p>用for循环遍历列表的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">for &quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot; -&gt; $name &#123;</div><div class="line">    say $name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say &quot;---&quot;;</div><div class="line"></div><div class="line">for 1..5 -&gt; $i &#123;</div><div class="line">    say $i;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say &quot;---&quot;;</div><div class="line"></div><div class="line">for 1..Inf -&gt; $i &#123;</div><div class="line">    say $i;</div><div class="line">    last if $i &gt; 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say &quot;---&quot;;</div><div class="line"></div><div class="line">for 1..* -&gt; $i &#123;</div><div class="line">    say $i;</div><div class="line">    last if $i &gt; 3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建数组, 遍历数组</p>
<p>你可以给一列值赋值给数组。<br>在双引号中数组不会进行插值。这与Perl 5 不一样。<br>就像你看见的，列表周围的括号是可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @colors = &quot;Blue&quot;, &quot;Yellow&quot;, &quot;Brown&quot;, &quot;White&quot;;  # 列表周围的括号是可选的</div><div class="line">say @colors;</div><div class="line"></div><div class="line">say &quot;--------------------------------&quot;;               # just for separation...</div><div class="line"></div><div class="line">say &quot;@colors&quot;;                                                   # 没有插值!</div><div class="line"></div><div class="line">say &quot;--------------------------------&quot;;               # just for separation...</div><div class="line"></div><div class="line">say &quot;&#123;@colors&#125;&quot;;</div><div class="line"></div><div class="line">say &quot;--------------------------------&quot;;               # just for separation...</div><div class="line"></div><div class="line">say &quot;@colors[]&quot;;</div><div class="line"></div><div class="line">say &quot;--------------------------------&quot;;               # just for separation...</div><div class="line"></div><div class="line">for @colors -&gt; $color &#123;</div><div class="line">    say $color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Blue Yellow Brown White</div><div class="line">--------------------------------</div><div class="line">Blue Yellow Brown White</div><div class="line">--------------------------------</div><div class="line">Blue</div><div class="line">Yellow</div><div class="line">Brown</div><div class="line">White</div></pre></td></tr></table></figure>
<p>  数组元素 (create menu)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my @colors = &lt;Blue Yellow Brown White&gt;;</div><div class="line"></div><div class="line">for 1..@colors.elems -&gt; $i &#123;</div><div class="line">    say &quot;$i) @colors[$i-1]&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $input = prompt(&quot;Please select a number: &quot;);</div><div class="line">say &quot;You selected @colors[$input-1]&quot;;</div></pre></td></tr></table></figure>
<p>数组赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $owner = &quot;Moose&quot;;</div><div class="line">my @tenants = &quot;Foo&quot;, &quot;Bar&quot;;</div><div class="line">my @people = ($owner, &apos;Baz&apos;, @tenants);   # 数组被展开:</div><div class="line">say &quot;&#123;@people&#125;&quot;;                          # Moose Baz Foo Bar</div><div class="line"></div><div class="line"></div><div class="line">my ($x, @y)     = (1, 2, 3, 4);</div><div class="line">say $x;                               # $x = 1</div><div class="line">say &quot;&#123;@y&#125;&quot;;                           # @y = (2, 3, 4)</div></pre></td></tr></table></figure>
<p>命令行选项<br>@*ARGS 数组由语言维护，它存储着命令行的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $color = @*ARGS[0];</div><div class="line"></div><div class="line">if not $color &#123;</div><div class="line">    my @colors = &lt;Blue Yellow Brown White&gt;;</div><div class="line"></div><div class="line">    for 1 .. @colors.elems -&gt; $i &#123;</div><div class="line">        say &quot;$i) @colors[$i-1]&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    my $input = prompt &quot;Please select a number: &quot;;</div><div class="line">    $color = @colors[$input-1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">say &quot;You selected $color&quot;;</div></pre></td></tr></table></figure>
<p>处理 CSV 文件<br>examples/arrays/sample_csv_file.csv</p>
<p>Foo,Bar,10,home<br>Orgo,Morgo,7,away<br>Big,Shrek,100,US<br>Small,Fiona,9,tower</p>
<p>examples/arrays/process_csv_file.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $file = &apos;examples/arrays/sample_csv_file.csv&apos;;</div><div class="line">if defined @*ARGS[0] &#123;</div><div class="line">    $file = @*ARGS[0];</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $sum = 0;</div><div class="line">my $data = open $file;</div><div class="line">for $data.lines -&gt; $line &#123;</div><div class="line">    my @columns = split &quot;,&quot;, $line;</div><div class="line">    $sum += @columns[2];</div><div class="line">&#125;</div><div class="line">say $sum;</div></pre></td></tr></table></figure>
<p>join<br>examples/arrays/join.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @fields = &lt;Foo Bar foo@bar.com&gt;;</div><div class="line">my $line = join &quot;;&quot;, @fields;</div><div class="line">say $line;     # Foo;Bar;foo@bar.com</div></pre></td></tr></table></figure>
<p>  uniq 函数<br>examples/arrays/unique.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @duplicates = 1, 1, 2, 5, 1, 4, 3, 2, 1;</div><div class="line">say @duplicates.perl;</div><div class="line"># prints Array.new(1, 1, 2, 5, 1, 4, 3, 2, 1)</div><div class="line"></div><div class="line"></div><div class="line">my @unique = uniq @duplicates;</div><div class="line">say @unique.perl;</div><div class="line"></div><div class="line"># prints Array.new(1, 2, 5, 4, 3)</div><div class="line"></div><div class="line"></div><div class="line">my @chars = &lt;b c a d b a a a b&gt;;</div><div class="line">say @chars.perl;</div><div class="line"></div><div class="line"># prints Array.new(&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;)</div><div class="line"></div><div class="line">my @singles = uniq @chars;</div><div class="line">say @singles.perl;</div><div class="line"></div><div class="line"># prints Array.new(&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">examples/arrays/loop_over_array.p6</div><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @fellows = &lt;Foo Bar Baz&gt;;</div><div class="line">for @fellows -&gt; $name &#123;</div><div class="line">    say $name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>examples/arrays/looping_over_many_elements.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @scores = &lt;</div><div class="line">    Valencia         1 1     Recreativo_Huelva</div><div class="line">    Athletic_Bilbao  2 5     Real_Madrid</div><div class="line">    Malaga           2 2     Sevilla_FC</div><div class="line">    Sporting_Gijon   3 2     Deportivo_La_Coruna</div><div class="line">    Valladolid       1 0     Getafe</div><div class="line">    Real_Betis       0 0     Osasuna</div><div class="line">    Racing_Santander 5 0     Numancia</div><div class="line">    Espanyol         3 3     Mallorca</div><div class="line">    Atletico_Madrid  3 2     Villarreal</div><div class="line">    Almeria          0 2     Barcelona</div><div class="line">&gt;;</div><div class="line"></div><div class="line">for @scores -&gt; $home, $home_score, $guest_score, $guest &#123;</div><div class="line">    say &quot;$home $guest $home_score : $guest_score&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺失值</p>
<p>examples/arrays/missing_values.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">for (1, 2, 3, 4, 5) -&gt; $x, $y &#123;</div><div class="line">    say &quot;$x $y&quot;;</div><div class="line">&#125;</div><div class="line">say &apos;done&apos;;</div></pre></td></tr></table></figure>
<p>examples/arrays/missing_values.p6.output<br>1 2<br>3 4<br>Not enough positional parameters passed; got 1 but expected 2<br>  in block <anon> at examples/arrays/missing_values.p6:4</anon></p>
<p>examples/arrays/missing_values_fixed.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">for (1, 2, 3, 4, 5) -&gt; $x, $y? &#123;</div><div class="line">    say &quot;$x $y&quot;;</div><div class="line">&#125;</div><div class="line">say &apos;done&apos;;</div></pre></td></tr></table></figure>
<p>examples/arrays/missing_values_fixed.p6.output<br>1 2<br>3 4<br>use of uninitialized value of type Mu in string context<br>    in block <anon> at examples/arrays/missing_values_fixed.p6:5<br>5<br>done</anon></p>
<p>examples/arrays/z.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @chars   = &lt;a b c&gt;;</div><div class="line">my @numbers = &lt;1 2 3&gt;;</div><div class="line"></div><div class="line">for @chars Z @numbers -&gt; $letter, $number &#123;</div><div class="line">    say &quot;$letter $number&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output:</p>
<p>examples/arrays/z.p6.out<br>a 1<br>b 2<br>c 3</p>
<p>examples/arrays/z_on_more.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @operator   = &lt;+ - *&gt;;</div><div class="line">my @left       = &lt;1 2 3&gt;;</div><div class="line">my @right     = &lt;7 8 9&gt;;</div><div class="line"></div><div class="line">for @left Z @operator Z @right -&gt; $a, $o, $b &#123;</div><div class="line">    say &quot;$a $o $b&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Output:</p>
<p>examples/arrays/z_on_more.p6.out<br>1 + 7<br>2 - 8<br>3 * 9</p>
<p>xx - string multiplicator<br>examples/arrays/xx.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @moose = &quot;moose&quot; xx 3;</div><div class="line">say &quot;&#123;@moose&#125;&quot;;</div></pre></td></tr></table></figure>
<p>sort values<br>examples/arrays/sort.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt;foo bar moose bu&gt;;</div><div class="line">my @sorted_names = sort @names;</div><div class="line">say @sorted_names.perl;   # [&quot;bar&quot;, &quot;bu&quot;, &quot;foo&quot;, &quot;moose&quot;]</div><div class="line"></div><div class="line"></div><div class="line">my @numbers = 23, 17, 4;</div><div class="line">my @sorted_numbers = sort @numbers;</div><div class="line">say @sorted_numbers.perl;   # [4, 17, 23]</div><div class="line"></div><div class="line"></div><div class="line">my @sort_names_by_length = sort &#123; $^a.bytes &lt;=&gt; $^b.bytes &#125;, @names;</div><div class="line">say @sort_names_by_length.perl;   # [&quot;bu&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;moose&quot;]</div><div class="line"></div><div class="line"># the same result with one sub (Schwartizian transformation)</div><div class="line">my @sort_1 = sort &#123; $_.bytes &#125;, @names;</div><div class="line">say @sort_1.perl;     # [&quot;bu&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;moose&quot;]</div><div class="line"></div><div class="line">my @sort_2 = @names.sort(&#123; $_.bytes &#125;);</div><div class="line">say @sort_2.perl;     # [&quot;bu&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;moose&quot;]</div><div class="line"></div><div class="line">my @sort_3 = @names.sort: &#123; $_.bytes &#125;;</div><div class="line">say @sort_3.perl;     # [&quot;bu&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;moose&quot;]</div><div class="line"></div><div class="line"></div><div class="line">my @words = &lt;moo foo bar moose bu&gt;;</div><div class="line">say @words.sort(&#123; $^a.bytes &lt;=&gt; $^b.bytes&#125;).perl; # [&quot;bu&quot;, &quot;moo&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;moose&quot;];</div><div class="line"></div><div class="line">say @words.sort(&#123; $^a.bytes &lt;=&gt; $^b.bytes or $^a cmp $^b&#125;).perl; # [&quot;bu&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;moo&quot;, &quot;moose&quot;];</div><div class="line"></div><div class="line"># TODO: should be also:</div><div class="line"># say @words.sort(&#123; $^a.bytes &lt;=&gt; $^b.bytes &#125;, &#123;$^a cmp $^b&#125;).perl; # [&quot;bu&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;moo&quot;, &quot;moose&quot;];</div><div class="line"># say @words.sort(&#123; $_.bytes &#125;,   &#123;$^a cmp $^b&#125;).perl; # [&quot;bu&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;moo&quot;, &quot;moose&quot;];</div></pre></td></tr></table></figure>
<p>创建数组, Data::Dumper, 调试打印</p>
<p>在Perl6 中创建数组跟在Perl5 中一样，对于调试打印我们会使用Perl6 的<code>.perl</code>方法来代替Perl5中的<code>Data::Dumper</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @numbers = (&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</div><div class="line">say @numbers.perl;   # Array.new(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</div></pre></td></tr></table></figure>
<p>在Perl6中，列表周围的<code>圆括号不再需要了</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @digits = 1, 3, 6;</div><div class="line">say @digits.perl;  # Array.new(1, 3, 6)</div></pre></td></tr></table></figure>
<p>qw() 不再使用</p>
<p>Perl 5 中的 <code>qw()</code> 操作符被<code>尖括号</code>取代：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt;foo bar baz&gt; ;</div><div class="line">say @names.perl;  # Array.new(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)</div></pre></td></tr></table></figure>
<p>字符串中的数组插值</p>
<p>在双引号字符串中，数组不再插值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &quot;red&quot;,&quot;yellow&quot;,&quot;green&quot;;</div><div class="line">say &quot;@names&quot;;  # @names</div></pre></td></tr></table></figure>
<p>你可以放心地写下这样的句子而不转义 @ 符号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt;Tom Cat&gt;;</div><div class="line">say &quot;joe@names.org&quot;;    # joe@names.org</div></pre></td></tr></table></figure>
<p>如果你确实要内插数组的值，你必须将数组放在一对 <code>花括号</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt; foo bar baz &gt; ;</div><div class="line">say &quot;names: &#123;@names&#125;&quot;; # names: foo bar baz</div></pre></td></tr></table></figure>
<p>取数组元素, 魔符不变</p>
<p>当在Perl 6 中访问数组的元素时，元素前的符号不会改变！这对Perl 5 程序员来说会很奇怪，但是长期看来它有优势。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt; foo bar baz &gt; ;</div><div class="line">say @names[0];    # foo</div></pre></td></tr></table></figure>
<p>内插一个数组元素</p>
<p>  作为一个特殊情况，一个数组元素能被内插在双引号字符串中而不使用花括号。术语 <code>post-circumfix</code> 对于<code>方括号</code>或<code>花括号</code>来说是一个一般称谓. 一般地,带有前置符号的变量可以被内插.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt; foo bar baz &gt;;</div><div class="line">say &quot;name:@names[0]&quot;;   # name: foo</div></pre></td></tr></table></figure>
<p>数组中元素的个数</p>
<p>在  Perl 6 中,推荐使用<code>elems()</code>方法和相关的函数来得到数组的元素个数。实际上，我认为面向对象的写法更美观:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt; foo bar baz &gt;;</div><div class="line">say elems @names;    # 3</div><div class="line">say @names.elems;    # 3</div></pre></td></tr></table></figure>
<p>范围</p>
<p>范围在Perl 6 中跟Perl 5 很像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @d = 1..11;</div><div class="line">say @d.perl;    # Array.new(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)</div></pre></td></tr></table></figure>
<p>The same works with scalar variables on either side:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $start = 1;</div><div class="line">my $end = 11;</div><div class="line"></div><div class="line">my @d = $start .. $end;</div><div class="line">say @d.perl;  # Array.new(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)</div></pre></td></tr></table></figure>
<p>ranges一个很有意思的方面可能是，你能对单个或两个范围的终点使用<code>^</code>符号告诉它们排除终点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $start = 1;</div><div class="line">my $end = 11;</div><div class="line"></div><div class="line">my @d = $start ^..^ $end; # 1的终点是1，,11的终点是11，排除这两个值</div><div class="line">say @d.perl;  # Array.new(2, 3, 4, 5, 6, 7, 8, 9, 10)</div></pre></td></tr></table></figure>
<p>范围操作符同样对<code>字符</code>有效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @chars = (&apos;a&apos; .. &apos;d&apos;);</div><div class="line">say @chars.perl;    # Array.new(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</div></pre></td></tr></table></figure>
<p>for  和 foreach 循环</p>
<p>  Perl 5 中C风格的for 循环现在叫做loop，但是我不会在这儿展示它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">for 1..3 -&gt; $i &#123;</div><div class="line">    say $i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为<br>1<br>2<br>3<br>这同样对数组有效:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt; foo bar baz &gt;;</div><div class="line">for @names -&gt; $n &#123;</div><div class="line">    say $n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出:<br>foo<br>bar<br>baz</p>
<p>顺便提一下,这是你<code>不用使用my声明一个变量</code>的情况之一。循环变量自动被声明好了，并且作用到for循环块中。</p>
<p>遍历数组的索引</p>
<p>如果你想遍历数组的索引，你可以使用范围，从0一直到最大的索引值。最大索引值比数组元素的个数少1.你可以用 <code>@names.elems -1</code> 作为最优的范围 ,或者你可以使用 <code>^</code>  符号告诉范围排除最后一个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt; foo bar baz &gt;;</div><div class="line">for 0 ..^@names.elems -&gt; $i &#123;</div><div class="line">    say &quot;$i &#123;@names[$i]&#125;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出:<br>0 foo<br>1 bar<br>2 baz</p>
<p>或者这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt; foo bar baz &gt;;</div><div class="line">for @names.keys -&gt; $i &#123;</div><div class="line">    say &quot;$i &#123;@names[$i]&#125;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从散列中借来的<code>keys()</code>方法会返回数组所有的索引。即使你的数组含有‘空’值，即带有<code>undef</code>的元素，<code>keys()</code>仍旧会包含这样的元素的索引。</p>
<p>split</p>
<p>split() 表现的就像Perl 5 中split的<code>副本</code>一样，但是默认行为不再应用，无论如何，你应该查看文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say &quot;a,b,c&quot;.split(&apos;,&apos;).perl;  # (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).list</div></pre></td></tr></table></figure>
<h2 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $age = 42;</div><div class="line"></div><div class="line">if $age &gt; 18 &#123;</div><div class="line">    say &quot;Above 18&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">    say &quot;Below 18&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say $age &gt; 18 ?? &quot;Above 18&quot; !! &quot;Below 18&quot;;</div></pre></td></tr></table></figure>
<p>语法：   COND ?? VALUE_IF_TRUE !! VALUE_IF_FALSE</p>
<h2 id="数字运算符"><a href="#数字运算符" class="headerlink" title="数字运算符"></a>数字运算符</h2><hr>
<p>数字运算符可以用在标量值上面。</p>
<p>examples/scalars/numerical_operators.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $x = 3;</div><div class="line">my $y = 11;</div><div class="line"></div><div class="line">my $z = $x + $y;</div><div class="line">say $z;             # 14</div><div class="line"></div><div class="line">$z = $x * $y;</div><div class="line">say $z;             # 33</div><div class="line">say $y / $x;        # 3.66666666666667</div><div class="line"></div><div class="line">$z = $y % $x;       # (模)</div><div class="line">say $z;             # 2</div><div class="line"></div><div class="line">$z += 14;           # is the same as   $z = $z + 14;</div><div class="line">say $z;             # 16</div><div class="line"></div><div class="line">$z++;               # is the same as   $z = $z + 1;</div><div class="line">$z--;               # is the same as   $z = $z - 1;</div><div class="line"></div><div class="line">$z = 23 ** 2;       # 幂</div><div class="line">say $z;             # 529</div></pre></td></tr></table></figure>
<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><hr>
<p>从文件中读取行<br>打开文件时的模式：</p>
<pre><code>:r   - read
:w   - write
:a   - append
</code></pre><p>open函数的两个参数：文件名和模式.为了打开一个文件读取，模式需为 :r . 此函数要么返回一个存在标量变量中的文件句柄，要么失败时返回 undef 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fh = open $filename, :r</div></pre></td></tr></table></figure>
<p>一旦我们打开了一个文件句柄，我们可以使用 get 方法 ($fh.get) 从给定的文件中读取一行。</p>
<p>你也可以连续调用 get 方法 读取多行，但还有更好的方法。</p>
<p>examples/files/read_one_line.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $filename = $*PROGRAM_NAME;</div><div class="line"></div><div class="line">my $fh = open $filename;</div><div class="line">my $line = $fh.get;</div><div class="line">say $line;</div></pre></td></tr></table></figure>
<p>读取所有行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $filename = $*PROGRAM_NAME;</div><div class="line"></div><div class="line">my $fh = open $filename;</div><div class="line">while (defined my $line = $fh.get) &#123;</div><div class="line">    say $line;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逐行读取文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $filename = $*PROGRAM_NAME;</div><div class="line"></div><div class="line">my $fh = open $filename;</div><div class="line">for $fh.lines -&gt; $line &#123;</div><div class="line">    say $line;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>lines 方法返回文件的所有行或部分行</p>
<p>在Perl 6中对存在的数据结构进行操作是有趣的，但是如果没有输入与输出的话，就会限制在真实世界中的用途。<br>因此，读取文件内容是一个明智的操作.</p>
<p><code>open</code><br><code>get</code><br><code>read</code><br><code>IO</code><br><code>lines</code></p>
<p>一行行读取（Read line-by-line）<br>  open   函数会打开一个文件，默认情况下，你可以显示地传递一个 :r 作为open函数的第二个参数。 Open会返回一个文件句柄，即一个IO类的实例。<br>  get    方法会从文件读取并返回一行，末尾的新行会自动被移除。 (Perl 5  开发者也可以认为 get 方法自动调用了chomp操作.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $fh = open $filename;</div><div class="line">my $line = $fh.get;</div></pre></td></tr></table></figure>
<p>你也可以在一个while循环中读取文件的所有行。  与 Perl 5相反, 在这个while循环中，对是否定义没有隐式地检测.你必须在条件语句中显示地添加单词defined.否则，读取操作将在第一个空行处停止。<br><code>my $fh = open $filename;</code></p>
<pre><code>while (defined my $line = $fh.get)
  {
    say $line;
  }
</code></pre><p>在for循环中使用    <code>lines</code>  方法可能更具有Perl-6风格。     lines   方法会依次读取文件的每一行，然后将读取到行赋值给变量 <code>$line</code> ,然后执行代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $fh = open $filename;</div><div class="line">for $fh.lines -&gt; $line &#123;</div><div class="line">      say $line;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><hr>
<p>为了写入内容到文件我们首先要开启 :w 模式.如果成功，我们得到一个文件句柄，在该文件句柄上我们可以使用普通的诸如print()、say()、或printf()等输出方法。<br>examples/files/write_file.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $filename = &quot;temp.txt&quot;;</div><div class="line"></div><div class="line">my $fh = open $filename, :w;</div><div class="line">$fh.say(&quot;hello world&quot;);</div><div class="line">$fh.close;</div></pre></td></tr></table></figure>
<h2 id="元操作符"><a href="#元操作符" class="headerlink" title="元操作符"></a>元操作符</h2><hr>
<p>元操作符<br>examples/arrays/assignment_shortcut.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $num = 23;</div><div class="line">say $num + 19;             # 42</div><div class="line">say $num;                  # 23</div><div class="line">$num += 19;</div><div class="line">say $num;                  # 42</div></pre></td></tr></table></figure>
<p>赋值时的方法调用<br>在Perl 6 中它扩展了点操作符的功能，允许在对象上进行方法调用。想想下面的例子。subst方法能够用一个字符串替换另外一个，但是并不改变原来的字符串。默认地，它返回改变了的字符串.<br>如果你想改变原字符串，你可以写为 <code>$str = $str.subst(&#39;B&#39;, &#39;X&#39;);</code> 或者你可以写成它的 shortcut version.<br>examples/arrays/assignment_operators.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my $str = &apos;ABBA&apos;;</div><div class="line">say $str.subst(&apos;B&apos;, &apos;X&apos;);      # AXBA</div><div class="line">say $str;                      # ABBA</div><div class="line"></div><div class="line">say $str .= subst(&apos;B&apos;, &apos;X&apos;);   # AXBA</div><div class="line">say $str;                      # AXBA</div></pre></td></tr></table></figure>
<p>赋值时调用函数<br>这也同样可以用于函数中，就如 <code>$lower = min($lower, $new_value);</code> 你可以写为 <code>$lower min= $new_value;</code></p>
<p>examples/arrays/assignment_function_shortcuts.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $lower = 2;</div><div class="line">$lower min= 3;</div><div class="line">say $lower;                # 2</div><div class="line">$lower min= 1;</div><div class="line">say $lower;                # 1</div></pre></td></tr></table></figure>
<p>这甚至可以有效地使用逗号操作符向数组中压入更多值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">  my @a = (1, 2, 3);</div><div class="line">  @a ,= 4;</div><div class="line">  @a.say;</div><div class="line">```  </div><div class="line">  反转关系操作符</div><div class="line">等号(==)操作符在Perl6 中用于比较数字，eq用于比较字符串。 The negated version are the same just with an exclamation mark ( ! ) in front of them. 所以它们看起来就是 !== 和 !eq.</div><div class="line">幸运的是，那些都有它们的快捷写法，可以写为!=和ne。</div><div class="line">其他操作符也有相应的反转版本，所以你可以写 !&gt;= ，它的意思是不大于 (对于数字) 并且你可以写!gt ，对于字符串来说是一样的. 我没有全部摊出我们为什么需要这个。</div><div class="line">一个我能明白的优点是如果你创建了一个叫做I的操作符，然后你会自动得到一个看起来像!I 的操作符，那是它的反转。</div><div class="line">examples/arrays/negated_operators.p6</div><div class="line"></div><div class="line"></div><div class="line">```perl6</div><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"># 相等</div><div class="line">say 1 ==  1       ?? &apos;y&apos; !! &apos;n&apos;; # y</div><div class="line">say 1 !== 1       ?? &apos;y&apos; !! &apos;n&apos;; # n</div><div class="line">say 1 !=  1       ?? &apos;y&apos; !! &apos;n&apos;; # n</div><div class="line">say &apos;ac&apos; eq  &apos;dc&apos; ?? &apos;y&apos; !! &apos;n&apos;; # n</div><div class="line">say &apos;ac&apos; !eq &apos;dc&apos; ?? &apos;y&apos; !! &apos;n&apos;; # y</div><div class="line">say 1 &lt;  2        ?? &apos;y&apos; !! &apos;n&apos;; # y</div><div class="line">####say 1 !&lt; 2    ?? &apos;y&apos; !! &apos;n&apos;; # n</div><div class="line">say 1 &lt;=  2       ?? &apos;y&apos; !! &apos;n&apos;; # y</div><div class="line">####say 1 !&lt;= 2   ?? &apos;y&apos; !! &apos;n&apos;; # n</div><div class="line">say 1 &gt;=  2       ?? &apos;y&apos; !! &apos;n&apos;; # n</div><div class="line">####say 1 !&gt;= 2   ?? &apos;y&apos; !! &apos;n&apos;; # y</div></pre></td></tr></table></figure>
<p>反转操作符<br>反转操作符会反转两个操作数的意思. 所以就像交换 <code>$b cmp $a</code> 中参数的值，你可以写为 <code>$a Rcmp $b</code>.</p>
<p>examples/arrays/reversed_operators.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"># 宇宙飞船操作符</div><div class="line">say 1 &lt;=&gt; 2;   # -1</div><div class="line">say 2 &lt;=&gt; 1;   # 1</div><div class="line">say 1 R&lt;=&gt; 2;  # 1</div><div class="line">say 2 R&lt;=&gt; 1;  # -1</div></pre></td></tr></table></figure>
<p>输出：<br>examples/arrays/reversed_operators.p6.out<br>Increase<br>Decrease<br>Decrease<br>Increase</p>
<p>Hyper 操作符</p>
<p>examples/arrays/hyper.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my @x = (1, 2) &gt;&gt;+&lt;&lt; (3, 4);</div><div class="line">say @x.perl;  # [4, 6]</div><div class="line">#my @d = (1, 2) &gt;&gt;+&lt;&lt; (3);</div><div class="line">#say @d.perl;  # [4, 6]</div><div class="line"># Non-dwimmy hyperoperator cannot be used  on arrays of different sizes or dimensions.</div><div class="line">my @z = (1, 2, 3, 4) &gt;&gt;+&gt;&gt; (1, 2);</div><div class="line">say @z.perl;          # [2, 4, 5, 6]</div><div class="line"></div><div class="line">@z = (1, 2, 3, 4) &lt;&lt;+&gt;&gt; (1, 2);</div><div class="line">say @z.perl;          # [2, 4, 5, 6]</div><div class="line">@z = (4) &lt;&lt;+&gt;&gt; (1, 2);</div><div class="line">say @z.perl;          # [5, 6]</div><div class="line"></div><div class="line">my @y = (1, 2) &gt;&gt;+&gt;&gt; 1;</div><div class="line">say @y.perl;          # [2, 3]</div></pre></td></tr></table></figure>
<p>examples/arrays/hyper.p6.out<br>Array.new(4, 6)<br>Array.new(2, 4, 4, 6)<br>Array.new(2, 4, 4, 6)<br>Array.new(5, 6)<br>Array.new(2, 3)</p>
<p>Reduction 操作符<br>examples/arrays/reduction_operators.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">say [+] 1, 2;    # 3</div><div class="line">say [+] 1..10;   # 55</div><div class="line"># 阶乘</div><div class="line">say [*] 1..5;    # 120</div><div class="line">say [**] 2,2,2;  # 16      == 2**2**2</div><div class="line">my @numbers = (2, 4, 3);</div><div class="line"># 检查数字是否是递增顺序</div><div class="line">say [&lt;] @numbers;          # False</div><div class="line">say [&lt;] sort @numbers;     # True</div></pre></td></tr></table></figure>
<p>输出<br>examples/arrays/reduction_operators.p6.out<br>3<br>55<br>120<br>16<br>False<br>True</p>
<p>Reduction Triangle operators<br>The ~ in front of the operator is only needed for the stringification of the list to inject spaces between the values when printed.<br>examples/arrays/triangle_operators.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">say ~[\+] 1..5;  # 1 3 6 10 15 (1 1+2 1+2+3 ... 1+2+3+4+5)</div><div class="line">say ~[\*] 1..5;  # 1 2 6 24 120</div></pre></td></tr></table></figure>
<p>输出：<br>examples/arrays/triangle_operators.p6.out<br>1 3 6 10 15<br>1 2 6 24 120</p>
<p>交叉操作符 Cross operators<br>examples/arrays/cross_operators.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line">my @x = (1, 2) X+ (4, 7);</div><div class="line">say @x.perl;                # [5, 8, 6, 9] 1+4,1+7,2+4,2+7</div><div class="line"></div><div class="line">my @y = 1, 2 X+ 4, 7;</div><div class="line">say @y.perl;                # [5, 8, 6, 9]</div><div class="line"></div><div class="line">my @str = 1, 2 X~ 4, 7;</div><div class="line">say @str.perl;              # [&quot;14&quot;, &quot;17&quot;, &quot;24&quot;, &quot;27&quot;]</div><div class="line"># without any special operator  (is the same with X, should be)</div><div class="line">my @z = 1, 2 X 4, 7;</div><div class="line">say @z.perl;                # [1, 4, 1, 7, 2, 4, 2, 7]</div></pre></td></tr></table></figure>
<p>输出：<br>examples/arrays/cross_operators.p6.out<br>Array.new(5, 8, 6, 9)<br>Array.new(5, 8, 6, 9)<br>Array.new(“14”, “17”, “24”, “27”)<br>Array.new(1, 4, 1, 7, 2, 4, 2, 7)</p>
<p> 积的交叉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @y = 1, 2 X* 4, 7;</div></pre></td></tr></table></figure>
<p>输出 4 7 8 14</p>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><hr>
<p>自动将字符串转换为数字</p>
<p>examples/scalars/add.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $a = prompt &quot;First number:&quot;;</div><div class="line">my $b = prompt &quot;Second number:&quot;;</div><div class="line"></div><div class="line">my $c = $a + $b;</div><div class="line"></div><div class="line">say &quot;\nResult: $c&quot;;</div></pre></td></tr></table></figure>
<p>字符串操作<br>examples/scalars/string_operators.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $x = &quot;Hello&quot;;</div><div class="line">my $y = &quot;World&quot;;</div><div class="line"></div><div class="line"># ~ 是连接操作符,连接字符串</div><div class="line">my $z = $x ~ &quot; &quot; ~ $y;   # the same as &quot;$x $y&quot;</div><div class="line">say $z;                  # Hello World</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $w = &quot;Take &quot; ~ (2 + 3);</div><div class="line">say $w;                         # Take 5</div><div class="line">say &quot;Take 2 + 3&quot;;               # Take 2 + 3</div><div class="line">say &quot;Take &#123;2 + 3&#125;&quot;;             # Take 5</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$z ~= &quot;! &quot;;             #   the same as   $z = $z ~ &quot;! &quot;;</div><div class="line">say &quot;&apos;$z&apos;&quot;;             # &apos;Hello World! &apos;</div></pre></td></tr></table></figure>
<p>  ~ 连接2个字符串.<br>就像上面见到的那样，任何操作符都能使用花括号语法插入到字符串中。.</p>
<p>字符串连接<br>examples/scalars/concat.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $a = prompt &quot;First string:&quot;;</div><div class="line">my $b = prompt &quot;Second string:&quot;;</div><div class="line"></div><div class="line">my $c = $a ~ $b;</div><div class="line"></div><div class="line">say &quot;\nResult: $c&quot;;</div></pre></td></tr></table></figure>
<p>字符串重复操作<br>examples/scalars/string_repetition.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $z = &quot;Hello World! &quot;;</div><div class="line"></div><div class="line"># x is the string repetition operator</div><div class="line">my $q = $z x 3;</div><div class="line">say &quot; &apos; $q &apos; &quot;;         # &apos;Hello World! Hello World! Hello World! &apos;</div></pre></td></tr></table></figure>
<h2 id="字符串函数-index"><a href="#字符串函数-index" class="headerlink" title="字符串函数 - index"></a>字符串函数 - index</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $s = &quot;The black cat jumped from the green tree&quot;;</div><div class="line"></div><div class="line">say index $s, &quot;e&quot;;                          # 2</div><div class="line">say index $s, &quot;e&quot;, 3;                       # 18</div><div class="line"></div><div class="line">say rindex $s, &quot;e&quot;;                         # 39</div><div class="line">say rindex $s, &quot;e&quot;, 38;                     # 38</div><div class="line">say rindex $s, &quot;e&quot;, 37;                     # 33</div></pre></td></tr></table></figure>
<h2 id="字符串函数-substr"><a href="#字符串函数-substr" class="headerlink" title="字符串函数 - substr"></a>字符串函数 - substr</h2><hr>
<p>字符串函数: substr<br>examples/scalars/string_functions_substr.p6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line">use v6;</div><div class="line"></div><div class="line">my $s = &quot;The black cat climbed the green tree&quot;;</div><div class="line">my $z;</div><div class="line">$z = substr $s, 4, 5;                     # $z = black</div><div class="line">say $z;</div><div class="line">$z = substr $s, 4, *-11;                  # $z = black cat climbed the   从索引4开始截取，不要最后的11个字符</div><div class="line">say $z;</div><div class="line">$z = substr $s, 14;                       # $z = climbed the green tree，从索引14开始知道结束</div><div class="line">say $z;</div><div class="line">$z = substr $s, *-4;                      # $z = tree</div><div class="line">say $z;</div><div class="line">$z = substr $s, *-4, 2;                   # $z = tr</div><div class="line">say $z;</div></pre></td></tr></table></figure>
<h2 id="值在给定的列表中吗"><a href="#值在给定的列表中吗" class="headerlink" title="值在给定的列表中吗"></a>值在给定的列表中吗</h2><hr>
<p>怎样找出一个给定的值是否在一些值的中间？这跟SQL中的IN操作符相似。</p>
<p>在 Perl 6  中，有一个 any() 函数，其功能与SQL 中的IN 关键字相似。让我们看看它如何工作:<br>它是一个weekday吗?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @weekdays = &lt;Monday Sunday Tuesday Wednesday Thursday Friday  Saturday &gt;;</div><div class="line"></div><div class="line">my $day = &quot;Tuesday&quot;;</div><div class="line">say $day eq any(@weekdays)</div><div class="line"> ??</div><div class="line"> &quot;$day is a weekday&quot;</div><div class="line"> !!</div><div class="line"> &quot;$day is NOT a weekday&quot;;</div></pre></td></tr></table></figure>
<p>上面的代码将打印出：<br>Tuesday is a weekday</p>
<p>perl会尝试使用 eq 让@weekdays中的每一个元素都与$day标量的内容相比较，如果它们中的任意一个为真，表达式即为真。</p>
<p>Perl 6 中的三元操作符</p>
<p>旁注:  ?? !! 对Perl 6 的三元操作符。它语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CONDITION</div><div class="line">??</div><div class="line">   VALUE_IF_TRUE</div><div class="line"></div><div class="line">!!</div><div class="line">    VALUE_IF_FALSE</div><div class="line">;</div></pre></td></tr></table></figure>
<p>它仍然是weekday吗?</p>
<p>更完整的例子让我们来看当所有这些值都不匹配时会发生什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @weekdays = &lt;Monday Sunday Tuesday Wednesday Thursday Friday  Saturday &gt;;</div><div class="line"></div><div class="line">my $other = &quot;Holiday&quot;;</div><div class="line">say $other eq any(@weekdays)</div><div class="line"></div><div class="line">??</div><div class="line">&quot;$other is a weekday&quot;</div><div class="line">!!</div><div class="line"> &quot;$other is NOT a weekday&quot;;</div></pre></td></tr></table></figure>
<p>代码相同但是不会打印匹配值:<br>Holiday is  NOT  a weekday</p>
<p>使用小于号比较数字</p>
<p>下个例子我们将会看到any函数能用于其它诸如小于号操作符的比较运算符上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @numbers = (6, -12, 20);</div><div class="line">say any(@numbers)&lt; 0</div><div class="line">    ?? &quot;There is a negative number&quot;</div><div class="line">    !! &quot;No negative number here&quot;;</div></pre></td></tr></table></figure>
<p>结果为:<br>There is a negative number</p>
<p>你也可以使用其它操作符.<br>假使没有负数它也有效:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @positive_numbers = (6, 12, 20);</div><div class="line">say any(@positive_numbers) &lt; 0</div><div class="line">    ?? &quot;There is a negative number&quot;</div><div class="line">    !! &quot;No negative number here&quot;;</div></pre></td></tr></table></figure>
<p>输出:<br>No negative number here</p>
<p>其它关键字: <code>none</code>, <code>all</code>, <code>one</code></p>
<p>还有其它函数, 不仅仅是 <em>any</em> 函数: (all, one and none)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @positive_numbers = (6, 12, 20);</div><div class="line">say none(@positive_numbers) &lt; 0</div><div class="line">    ?? &quot;No negative number here&quot;</div><div class="line">    !! &quot;There is a negative number&quot;;</div></pre></td></tr></table></figure>
<p>会打印:<br>No negative number here</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @positive_numbers = (6, 12, 20);</div><div class="line">say all(@positive_numbers) &gt; 0</div><div class="line">    ?? &quot;All are positive numbers&quot;</div><div class="line">    !! &quot;There is a NOT positive number&quot;;</div></pre></td></tr></table></figure>
<p>会打印:<br>All are positive numbers</p>
<p>使用最合适的那个函数。<br>更短的写法</p>
<p>有时候你有一个值，你需要检测它是否等于一个所列值中的任意一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $n = 12;</div><div class="line">say ($n == 23 or $n == 42) ?? &quot;ok&quot; !! &quot;not ok&quot;;  # not ok</div></pre></td></tr></table></figure>
<p>使用 any 函数你可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $n = 12;</div><div class="line">say $n == any(23, 42)</div><div class="line"> ?? &quot;ok&quot;</div><div class="line"> !! &quot;not ok&quot;;  # not ok</div></pre></td></tr></table></figure>
<p>any 函数也有一个单管道线的中缀操作符版本，所以你也能这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my  $n = 12;</div><div class="line">say $n == 23|42</div><div class="line"> ?? &quot;ok&quot;</div><div class="line"> !! &quot;not ok&quot;;  # not ok</div></pre></td></tr></table></figure>
<p>交叉</p>
<p>这些关键词和相关操作所做的实际上是创建了一种叫做<code>Junction</code>的数据类型。它是一个标量，以一种无序的方式存储着多个值。跟集合类似。<br>第一个例子也可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $weekdays = any &lt;Monday Sunday Tuesday Wednesday Thursday Friday  Saturday &gt;;</div><div class="line"></div><div class="line">my $day = &quot;Tuesday&quot;;</div><div class="line"></div><div class="line">say $day eq $weekdays</div><div class="line">    ?? &quot;$day is a weekday&quot;</div><div class="line">    !! &quot;$day is NOT a weekday&quot;;</div></pre></td></tr></table></figure>
<p>这里我们创建了一个junction而非数组，然后使用该junction进行比较。<br>Other operations on Junctions</p>
<p>In addition to the comparison operations we saw earlier, we can do other operations on junctions. The operation will be executed on each one of the values in the junction and the result will be a new junction with the changed values:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $numbers = any(23, 42);</div><div class="line">$numbers.perl.say;</div><div class="line"></div><div class="line">$numbers++;</div><div class="line">$numbers.perl.say;</div></pre></td></tr></table></figure>
<p>这会打印该 junction的perl表现:<br>any(23, 42)<br>any(24, 43)<br>Functions on Junctions</p>
<p>你也可以将 junctions 作为参数传递给函数。 The function will be executed on each value separately in an undefined order, and the result will be another junction. For example if we would like to create the 3 character version of the months we can use the following code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $months = any ;</div><div class="line"></div><div class="line">my $short_names = substr($months, 0, 3);</div><div class="line">$short_names.perl.say;</div></pre></td></tr></table></figure>
<p>Which should print<br>any(“Jan”, “Feb”, “Mar”, “Apr”, “May”, “Jun”, “Jul”, “Aug”,  “Sep”, “Oct”, “Nov”, “Dec”);</p>
<h2 id="Perl-6-的正则"><a href="#Perl-6-的正则" class="headerlink" title="Perl 6 的正则"></a>Perl 6 的正则</h2><hr>
<p>正则操作符<br>在 Perl 6 中智能匹配 ~~ 操作符用于正则匹配。<br>对于相反的匹配，使用 !~~ 操作符。</p>
<p>基本用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;abc123&apos;;</div><div class="line">if $str ~~ m/a/ &#123;</div><div class="line">      say &quot;Matching&quot;;</div><div class="line">&#125;</div><div class="line">if $str !~~ m/z/ &#123;</div><div class="line">      say &quot;No z in $str&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个条件都是真的，所以两组字符串 “Matching” 和”No z in abc123”都会被打印。<br>特殊符号<br>Perl6中有一个重要改变，那就是在Perl6 中，任何<code>非字母数字字符</code>需要被转义。<br>在下个例子中，我们需要转义 <code>-</code> 符号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;abc - 123&apos;;</div><div class="line">if $str ~~ m/-/ &#123;</div><div class="line">      say &quot;Matching&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成:</p>
<p>===SORRY!===<br>Unrecognized regex metacharacter - (must be quoted to match literally) at line 6, near “/) {\n      s”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;abc - 123&apos;;</div><div class="line">if $str ~~ m/\-/ &#123;</div><div class="line">      say &quot;Matching&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有效，打印匹配。</p>
<p>新特殊字符<br><code>#</code>现在是一个特殊字符，代表注释,所以当我们真正需要一个<code>#</code>号时，需要转义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;abc # 123&apos;;</div><div class="line">if $str ~~ m/(#.)/ &#123;</div><div class="line">      say &quot;match &apos;$/&apos;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>报错：</p>
<p>===SORRY!===<br>Unrecognized regex metacharacter ( (must be quoted to match literally) at line 6, near “#.)/ {\n    “</p>
<p>转义后正确：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;abc # 123&apos;;</div><div class="line">if $str ~~ m/(\#.)/ &#123;</div><div class="line">      say &quot;match &apos;$/&apos;&quot;;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">Perl 6 的匹配变量</div><div class="line">每次一有正则操作，一个叫做 `$/` 的本地化变量被设置成实际匹配到的值。</div><div class="line"></div><div class="line">```perl6</div><div class="line">use v6;</div><div class="line">my $str = &apos;abc123&apos;;</div><div class="line">if $str ~~ m/a/ &#123;</div><div class="line">      say &quot;Matching    &apos;$/&apos;&quot;;        # Matching  &apos;a&apos;</div><div class="line">&#125;</div><div class="line">if $str !~~ m/z/ &#123;</div><div class="line">      say &quot;No z in $str &apos;$/&apos;&quot;;       # No z in abc123  &apos;&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Perl 6 正则中的空格<br>在Perl 6 中，正则默认忽略空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;The black cat climbed to the green tree.&apos;;</div><div class="line">if $str ~~ m/black/ &#123;</div><div class="line">      say &quot;Matching &apos;$/&apos;&quot;;        # Matching &apos;black&apos;</div><div class="line">&#125;</div><div class="line">if $str ~~ m/black cat/ &#123;</div><div class="line">      say &quot;Matching &apos;$/&apos;&quot;;</div><div class="line">&#125; else &#123;</div><div class="line">      say &quot;No match as whitespaces are disregarded&quot;;  # prints this</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那怎样匹配空格呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;The black cat climbed to the green tree.&apos;;</div><div class="line">if $str ~~ m/black\scat/ &#123;</div><div class="line">      say &quot;Matching &apos;$/&apos; - Perl 5 style white-space meta character works&quot;;</div><div class="line">&#125;</div><div class="line">if $str ~~ m/black \s cat/ &#123;</div><div class="line">      say &quot;Matching &apos;$/&apos; - Meta white-space matched, real space is disregarded&quot;;</div><div class="line">&#125;</div><div class="line">if $str ~~ m/black  &apos; &apos;  cat/ &#123;</div><div class="line">      print &quot;Matching &apos;$/&apos; - &quot;;</div><div class="line">      say &quot;the real Perl 6 style would be to use strings embedded in regexes&quot;;</div><div class="line">&#125;</div><div class="line">if $str ~~ m/black cat/ &#123;</div><div class="line">      print &quot;Matching &apos;$/&apos; - &quot;;</div><div class="line">      say &quot;or maybe the Perl 6 style is using named character classes &quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任何情况下，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;The black cat climbed to the green tree.&apos;;</div><div class="line">if $str ~~ m/  b l a c k c a t/ &#123;</div><div class="line">      say &quot;Matching &apos;$/&apos; - a regex in Perl 6 is just a sequence of tokens&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你看，你可以使用<code>单引号</code>在正则中嵌入字面字符串，也有新类型的字符类，使用尖括号。</p>
<p>匹配任何字符<br>点(.)匹配任何字符，包括<code>换行符</code>。<br>如果你想匹配除新行外的所有其他字符，你可以使用 <code>\N</code> 特殊字符类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $str = &apos;The black cat climbed to the green tree.&apos;;</div><div class="line">if $str ~~ m/c./ &#123;</div><div class="line">      say &quot;Matching &apos;$/&apos;&quot;;          # &apos;ck&apos;</div><div class="line">&#125;</div><div class="line">my $text = &quot;</div><div class="line">The black cat</div><div class="line">climbed the green tree&quot;;</div><div class="line">if $text ~~ m/t./ &#123;</div><div class="line">      say &quot;Matching &apos;$/&apos;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个正则匹配并打印’ck’,第二个打印：<br>‘t<br>‘</p>
<p>使用 <code>\N</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $text = &quot;</div><div class="line">The black cat</div><div class="line">climbed the green tree&quot;;</div><div class="line">if $text ~~ m/t\N/ &#123;</div><div class="line">      say &quot;Matching &apos;$/&apos;&quot;;        # &apos;th&apos;      of the word &apos;the&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在最后一个例子中你看到 <code>\N</code> 能匹配字母 h，而非新行。</p>
<h2 id="Perl6的一些特性"><a href="#Perl6的一些特性" class="headerlink" title="Perl6的一些特性"></a>Perl6的一些特性</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt; my $foo = &quot;bar&quot;;</div><div class="line">bar</div><div class="line">&gt; if $foo eq &quot;foo&quot; | &quot;bar&quot; | &quot;baz&quot; &#123; say &quot;ok&quot; &#125;</div><div class="line">ok</div><div class="line">&gt; my $num = 10;</div><div class="line">10</div><div class="line">&gt; if 5 &lt; $num &lt; 15 &#123; say &quot;ok&quot; &#125;</div><div class="line">ok</div><div class="line">&gt; say 1, 2, 4 ... 1024</div><div class="line">1 2 4 8 16 32 64 128 256 512 1024</div><div class="line">&gt; my @fib = 1, 1, *+* ... *;</div><div class="line">1 1 2 3 ...</div><div class="line">&gt; say @fib[0..9]</div><div class="line">1 1 2 3 5 8 13 21 34 55</div><div class="line">&gt; say @fib[^10]</div><div class="line">1 1 2 3 5 8 13 21 34 55</div><div class="line">&gt; say [+] 1..100</div><div class="line">5050</div><div class="line">&gt; say 1..6 Z~ &apos;A&apos;..&apos;F&apos;</div><div class="line">1A 2B 3C 4D 5E 6F</div><div class="line">&gt; say 1..3 X~ &apos;A&apos;..&apos;D&apos;</div><div class="line">1A 1B 1C 1D 2A 2B 2C 2D 3A 3B 3C 3D</div></pre></td></tr></table></figure>
<h2 id="Perl-6-中一系列整数的操作"><a href="#Perl-6-中一系列整数的操作" class="headerlink" title="Perl 6 中一系列整数的操作"></a>Perl 6 中一系列整数的操作</h2><hr>
<p>Perl 6 中一系列整数的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $x = 23;</div><div class="line">my $z = 27;</div><div class="line">for $x .. $z -&gt; $i &#123;</div><div class="line">      say $i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会打印出期望的数字 23, 24, 25, 26, 27 .</p>
<p>C风格的循环<br>C风格, 有3部分的for循环在Perl 6 中也是可行的但不推荐。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $x = 23;</div><div class="line">my $z = 27;</div><div class="line">loop (my $i = $x; $i &lt;= $z; $i++) &#123;</div><div class="line">      say $i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>序列</p>
<p>在Perl 6 中用 for 循环每隔2个数遍历也是可以的，我们使用3个 . 而非2个 . 这里我们谈论的是序列而非范围。<br>我们设置序列的前两个元素和序列的上限.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $x = 23;</div><div class="line">my $z = 27;</div><div class="line">for $x, $x+2 ... $z  -&gt; $i &#123;</div><div class="line">  say $i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这会打印 23, 25, 27<br>你必须保证上限的准确:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for 1, 3 ... 7  -&gt; $i &#123;</div><div class="line">  say $i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这会打印 1, 3, 5, 7<br>另一方面，这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for 1, 3 ... 8  -&gt; $i &#123;</div><div class="line">  say $i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会报错。(现在已修正， 打印 1，3，5，7)</p>
<h2 id="Perl-6-中的标量、数组、散列如何插值"><a href="#Perl-6-中的标量、数组、散列如何插值" class="headerlink" title="Perl 6 中的标量、数组、散列如何插值"></a>Perl 6 中的标量、数组、散列如何插值</h2><hr>
<p>标量、数组和散列插值</p>
<p>将标量放在双引号中会进行插值，就跟Perl 5 中一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my $name = &quot;Foo&quot;;</div><div class="line">say &quot;Hello $name, how are you?&quot;;</div></pre></td></tr></table></figure>
<p>这会打印:<br>Hello Foo, how are you?</p>
<p>数组和散列不是这样进行插值的，在字符串中，任何放进<code>花括号</code>中的东西都会被插值，所以如果你有一个数组，您能这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt;Foo Bar Moo&gt;;</div><div class="line">say &quot;Hello &#123;@names&#125;, how are you?&quot;;</div></pre></td></tr></table></figure>
<p>to get this output:<br>Hello Foo Bar Moo, how are you?</p>
<p>这里的问题是基于输出结果你不知道数组是有3个元素还是2个：<br>“Foo Bar” 和 “Moo”, 或仅仅一个元素: “Foo Bar Moo”.</p>
<p>内插表达式</p>
<p>上面的就不是个问题！ 在用双引号引起来的字符串中，你可以将任何表达式放在<code>花括号</code>中。表达式会被计算，其结果会被插值：<br>你可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @names = &lt;Foo Bar Moo&gt;;</div><div class="line">say &quot;Hello &#123; join(&apos;, &apos;, @names) &#125; how are you?&quot;;</div></pre></td></tr></table></figure>
<p>输出如下:<br>Hello Foo, Bar, Moo how are you?</p>
<p>然而这依然没有准确地显示有几个值，这显得稍微复杂了。<br>作为旁注，万一你更喜欢面向对象的代码，你也可以像下面这样写:<br><code>say &quot;Hello { @names.join(&#39;, &#39;) } how are you?&quot;;</code><br>结果一样.</p>
<p>调试打印</p>
<p>对于基本的调试目的，做好使用数组的 <code>.perl</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;Names: &#123; @names.perl &#125;&quot;;</div></pre></td></tr></table></figure>
<p>那会打印：</p>
<pre><code>Names: Array.new(&quot;Foo&quot;, &quot;Bar&quot;, &quot;Moo&quot;)
</code></pre><p>假使你想同时看到变量名呢？那你可以依赖数组在双引号字符串中不插值这点这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot; @names = &#123; @names.perl &#125;&quot;;</div></pre></td></tr></table></figure>
<p>那会打印：</p>
<pre><code>@names = Array.new(&quot;Foo&quot;, &quot;Bar&quot;, &quot;Moo&quot;)
</code></pre><p>仅仅是表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">say &quot;Take 1+4&quot;;</div></pre></td></tr></table></figure>
<p>会打印：</p>
<pre><code>Take 1+4
</code></pre><p>就像我所写的，你可以将任何表达式放进花括号中，你也可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">say &quot;Take &#123;1+4&#125;&quot;;</div></pre></td></tr></table></figure>
<p>那会打印：</p>
<pre><code>Take 5
</code></pre><p>插值散列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my %phone = (</div><div class="line">      foo =&gt; 1,</div><div class="line">      bar =&gt; 2,</div><div class="line">);</div><div class="line"></div><div class="line">say &quot;%phone = &#123; %phone &#125; &quot;;</div></pre></td></tr></table></figure>
<p>会打印：</p>
<pre><code>%phone = foo    1 bar  2
</code></pre><p>这分不清哪些是键，哪些是值. 对于调试目的，你最好用 <code>.perl</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;%phone = &#123; %phone.perl &#125; &quot;;</div></pre></td></tr></table></figure>
<p>会打印:</p>
<pre><code>%phone = (&quot;foo&quot; =&gt; 1, &quot;bar&quot; =&gt; 2).hash
</code></pre><p>插值多维数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @matrix = (</div><div class="line">    [1, 2],</div><div class="line">    [3, 4],</div><div class="line">);</div><div class="line"></div><div class="line">say &quot;@matrix = &#123; @matrix.perl &#125;&quot;;</div></pre></td></tr></table></figure>
<p>输出:</p>
<pre><code>@matrix = Array.new([1, 2], [3, 4])
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sneaky-methods]]></title>
      <url>http://ohmycloud.github.io/2015/05/01/Sneaky-methods/</url>
      <content type="html"><![CDATA[<p><a href="https://gfldex.wordpress.com/2016/07/20/sneaky-methods/" target="_blank" rel="external">Sneaky methods</a></p>
<p>就像你想的那样, 在类的定义中可以声明和定义方法。你期望不高的甚至文档中都很少提及是用 <code>my</code> 关键字声明的免费浮点方法。现在为什么你想要:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my method foo(SomeClass:D:) &#123; self &#125;</div></pre></td></tr></table></figure>
<p>明显的答案是<a href="https://docs.perl6.org/language/mop" target="_blank" rel="external">元对象协议</a>中的 <a href="https://docs.perl6.org/type/Metamodel$COLON$COLONMethodContainer#method_add_method" target="_blank" rel="external">add_method</a> 方法, 在 Rakudo 里你能找到它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">src/core/Bool.pm</div><div class="line">32:    Bool.^add_method(&apos;pred&apos;,  my method pred() &#123; Bool::False &#125;);</div><div class="line">33:    Bool.^add_method(&apos;succ&apos;,  my method succ() &#123; Bool::True &#125;);</div><div class="line">35:    Bool.^add_method(&apos;enums&apos;, my method enums() &#123; self.^enum_values &#125;);</div></pre></td></tr></table></figure>
<p>这种方法还有另外一种更诡异的用法。你可能很想知道在链式方法调用中究竟发生了什么。我们可以扯开最上面的那个表达式并插入一个短的变量, 输出我们的调试, 并且继续链式调用。好的名字很重要并且把它们浪费在一个短变量上没有必要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;a b c&gt;.&amp;(my method ::(List:D) &#123; dd self; self &#125; ).say;</div><div class="line"></div><div class="line"># output</div><div class="line"># (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div><div class="line"># (a b c)</div></pre></td></tr></table></figure>
<p>没有显式调用我们就不能没有名字, 因为 Perl 6 不允许我们这样做, 所以我们使用了空的作用域 <code>::</code> 以使解析器高兴。使用一个合适的调用, 我们就不需要它了。还有, 那个匿名方法不是 List 中的一员。我们需要使用后缀 <code>.&amp;</code> 来调用它。如果我们需要多次使用那个方法我们可以把它拉出来并给它一个名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my multi method debug(List:D:) &#123; dd self; self &#125;;</div><div class="line">&lt;a b c&gt;.&amp;debug.say;</div><div class="line"></div><div class="line"># output</div><div class="line">(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div><div class="line">(a b c)</div></pre></td></tr></table></figure>
<p>或者, 如果我们想允许回调的话, 我们可以把它作为默认参数赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sub f(@l, :&amp;debug = my method (List:D:)&#123;self&#125;) &#123; @l.&amp;debug.say &#125;;</div><div class="line">f &lt;a b c&gt;, debug =&gt; my method ::(List:D)&#123;dd self; self&#125;;</div><div class="line"></div><div class="line"># output</div><div class="line">#(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div><div class="line"># (a b c)</div></pre></td></tr></table></figure>
<p>在 Perl 6 中基本上所有的东西都是类, 包括<a href="https://docs.perl6.org/type/Method" target="_blank" rel="external">方法</a>。 如果它是类它可以是一个对象并且我们能在我们喜欢的任何地方溜进去。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的正则表达式(五)]]></title>
      <url>http://ohmycloud.github.io/2015/04/28/Perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BA%94/</url>
      <content type="html"><![CDATA[<h1 id="从匹配中返回值"><a href="#从匹配中返回值" class="headerlink" title="从匹配中返回值"></a>从匹配中返回值</h1><h1 id="Match-对象"><a href="#Match-对象" class="headerlink" title="Match 对象"></a>Match 对象</h1><ul>
<li>成功的匹配总是返回一个 <code>Match</code> 对象, 这个对象通常也被放进 <code>$/</code> 中, (具名 <code>regex</code>, <code>token</code>, 或 <code>rule</code> 是一个子例程, 因此会声明它们自己的本地 <code>$/</code> 变量, 它通常指 rule 中最近一次的 submatch, 如果有的话)。当前的匹配状态被保存到 regex 的 <code>$¢</code> 变量中, 当匹配结束时它最终会被绑定到用户的 <code>$/</code>变量中</li>
</ul>
<p>不成功的匹配会返回 Nil (并把 <code>$/</code> 设置为 Nil, 如果匹配已经设置了 <code>$/</code>的话)</p>
<ul>
<li><p>名义上, Match 对象包含一个布尔的成功值, 一个<code>有序的</code>子匹配对象(submatch objects)<code>数组</code>, 一个<code>具名的</code>子匹配对象(submatch objects)<code>散列</code>.(它也可选地包含一个用于创建抽象语法树(AST)的<strong>抽象对象</strong>) 为了提供访问这些各种各样值的便捷方法, Match 对象在不同上下文中求值也不同:</p>
</li>
<li><p>在布尔上下文中 Match 对象被求值为真或假</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if /pattern/ &#123;...&#125;</div><div class="line"># 或:</div><div class="line">/pattern/; if $/ &#123;...&#125;</div></pre></td></tr></table></figure>
<p>如果模式使用 <code>:global</code> 或 <code>:overlap</code> 或 <code>:exhaustive</code> 修饰符, 会在<code>第一个匹配处</code>返回布尔真值.  如果在列表上下文中求值, <code>Match</code> 对象会根据需要(lazily)产生剩下的结果.</p>
<ul>
<li>在字符串上下文中, Match 对象会被求值为匹配(match)的字符串化的值,  这通常是整个匹配的字符串.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print %hash&#123; &quot;&#123;$text ~~ /&lt;.ident&gt;/&#125;&quot; &#125;;</div><div class="line"># 或等价的:</div><div class="line">$text ~~ /&lt;.ident&gt;/  &amp;&amp;  print %hash&#123;~$/&#125;;</div></pre></td></tr></table></figure>
<p>但是通常你应该写成 <code>~$/</code>, 如果你想要字符串化匹配对象的话.</p>
<ul>
<li>在数字上下文中, Match 对象会被计算成它的匹配的数字值, 这通常是整个匹配的字符串:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$sum += /\d+/;</div><div class="line"># 或等价的:</div><div class="line">/\d+/; $sum = $sum + $/;</div></pre></td></tr></table></figure>
<ul>
<li>在标量上下文中, Match 对象求值结果为自身.</li>
</ul>
<p>然而, 有时你想要一个备用标量值伴随着匹配. Match 对象自身描述了一个具体的解析树, 这个额外的值叫做抽象对象;它作为 Match 对象的一个属性伴随着匹配. <code>.made</code> 方法默认返回一个未定义值. <code>$()</code> 是 <code>$($/.made // ~$/)</code> 的简写形式.</p>
<p>因此, <code>$()</code> 通常就是整个匹配的字符串, 但是你能在 regex 内部调用 <code>make</code> 来重写它:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $moose = $(m[</div><div class="line">    &lt;antler&gt; &lt;body&gt;</div><div class="line">    &#123; make Moose.new( body =&gt; $&lt;body&gt;.attach($&lt;antler&gt;) ) &#125;</div><div class="line">    # 匹配成功 -- 忽略该 regex 的剩余部分</div><div class="line">]);</div></pre></td></tr></table></figure>
<p>这把新的抽象节点放进 <code>$/.made</code>中. 抽象节点(AST)可以是任何类型. 使用 <code>make</code> / <code>.made</code> 构造, 创建任意节点类型的抽象语法树就很方便了.</p>
<p>然而, <code>make</code> 函数不限于仅仅用作存储 AST 节点并创建抽象语法树。  这就是特殊的 Perl 6 泛函性的内部使用.  <code>make</code>函数也不会把任何 item 或 列表上下文强加到它们的参数上, 所以, 你写了某些含糊不清的 listy, 像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">make ()</div><div class="line">make @array</div><div class="line">make foo()</div></pre></td></tr></table></figure>
<p>那么从 <code>.made</code> 返回的值会被插值到列表中。 要抑制这, 使用下面这些:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">make ().item</div><div class="line">make []</div><div class="line">make $@array</div><div class="line">make [@array]</div><div class="line">make foo().item</div><div class="line">make $(foo())</div></pre></td></tr></table></figure>
<p>或者在接收终端上使用 <code>.made.item</code> 或 <code>$</code>变量</p>
<p><code>.ast</code> 方法就是 <code>.made</code> 的同义词, 它俩没什么不同. 它的存在一方面是因为历史原因, 另一方面也是为了给阅读你的代码的人标示一个更像 AST 用法的 <code>made/.make</code> </p>
<ul>
<li>你也能使用 <code>&lt;(...)&gt;</code> 构造捕获匹配的一个子集(subset):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;foo123bar&quot; ~~ / foo &lt;( \d+ )&gt; bar /</div><div class="line">say $();    # says 123</div></pre></td></tr></table></figure>
<p>这时, 当做字符串匹配时, <code>$()</code> 总是一个字符串, 当做列表匹配时, <code>$()</code>总是一个或多个元素的列表.这个构造没有设置 <code>.made</code> 属性.</p>
<ul>
<li>当用作数组时, Match 对象伪装成一个数组, 数组里是 Match 对象的所有位置捕获.因此,</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">($key, $val) = ms/ (\S+) &apos;=&gt;&apos; (\S+)/;</div></pre></td></tr></table></figure>
<p>也能被写作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$result = ms/ (\S+) &apos;=&gt;&apos; (\S+)/;</div><div class="line">($key, $val) = @$result;</div></pre></td></tr></table></figure>
<p>要把单个捕获放到字符串中, 使用下标:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$mystring = &quot;&#123; ms/ (\S+) &apos;=&gt;&apos; (\S+)/[0] &#125;&quot;;</div></pre></td></tr></table></figure>
<p>要把所有捕获都放到字符串中, 使用一个禅切:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$mystring = &quot;&#123; ms/ (\S+) &apos;=&gt;&apos; (\S+)/[] &#125;&quot;;</div></pre></td></tr></table></figure>
<p>或把它扔到数组里:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$mystring = &quot;@( ms/ (\S+) &apos;=&gt;&apos; (\S+)/ )&quot;;</div></pre></td></tr></table></figure>
<p>注意, 作为一个标量, <code>$/</code> 在列表上下文中不会自动展平(flatten). 在列表上下文中使用 <code>@()</code>作为 <code>@($/)</code> 的简写形式来展平位置捕获. 注意, Match 对象能在列表上下文中按需计算它的匹配.使用 <code>@()</code> 来强制进行迫切( eager)匹配.</p>
<ul>
<li>当作为散列时, Match 对象伪装成一个含有具名捕获的散列. 散列的键不包括任何符号, 所以如果你把变量捕获到变量 <code>@&lt;foo&gt;</code>, 它的真实名字为 <code>$/{&#39;foo&#39;}</code> 或 <code>$/&lt;foo&gt;</code>.然而, 在<code>$/</code> 可见的任何地方, 你仍旧能把它作为 <code>@&lt;foo&gt;</code> 引用. (但是, 对于两个不同的捕获数据类型,使用同一个名字是错误的.)<br><a href="https://github.com/perl6/roast/blob/master/S05-capture/subrule.t#L17-L119" target="_blank" rel="external"><code>S05-capture/subrule.t lines 17–119</code></a></li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-match/capturing-contexts.t#L35-L164" target="_blank" rel="external"><code>S05-match/capturing-contexts.t lines 35–164</code></a></p>
<p>注意, 作为一个标量, <code>$/</code> 在列表上下文中不会自动展平(flatten). 在列表上下文中使用 <code>%()</code>作为 <code>%($/)</code> 的简写形式来作为一个散列来展平, 或把它绑定到一个合适类型的变量上. 就像 <code>@()</code>, <code>%()</code>能在列表上下文中按需产生它的 pair 对儿. </p>
<ul>
<li><p>编号过的捕获能被当作命名捕获那样, 所以 <code>$&lt;0 1 2&gt;</code>  等价于 <code>$/[0,1,2]</code>.  这允许你混写命名捕获和编号捕获.</p>
</li>
<li><p><code>.keys</code>, <code>.values</code> 和 <code>.kv</code> 方法对列表和散列都起作用, 列表部分首当其冲.` </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;abcd&apos; ~~ /(.)(.)**2 &lt;alpha&gt;/;</div><div class="line">say ~$/.keys;           # 0 1 alpha</div></pre></td></tr></table></figure>
<ul>
<li><p>在普通代码中, 变量 <code>$0</code>,<code>$1</code>等等就是 <code>$/[0]</code> ,<code>$/[1]</code> 的别名, 等等, 因此, 如果最后的匹配失败, 它们都会变为未定义的. (除非它们被显式地绑定到一个闭包中, 而不使用 let 关键字)<br><a href="https://github.com/perl6/roast/blob/master/S32-scalar/undef.t#L220-L280" target="_blank" rel="external"><code>S32-scalar/undef.t lines 220–280</code></a></p>
</li>
<li><p>Match 对象有一些方法提供了关于匹配的额外信息, 例如:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if m/ def &lt;ident&gt; &lt;codeblock&gt; / &#123;</div><div class="line">   say &quot;Found sub def from index $/.from.bytes &quot;,</div><div class="line">       &quot;to index $/.to.bytes&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当前定义过的方法有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$/.from      # 初始匹配位置</div><div class="line">$/.to        # 最终匹配位置</div><div class="line">$/.chars     # $/.to - $/.from</div><div class="line">$/.orig      # 原匹配字符串</div><div class="line">$/.Str       # substr($/.orig, $/.from, $/.chars)</div><div class="line">$/.made      # 关于该节点(来自于 make)的抽象结果</div><div class="line">$/.ast       # 和 $/.made 相同</div><div class="line">$/.caps      # 相继的捕获</div></pre></td></tr></table></figure>
<p><a href="https://github.com/perl6/roast/blob/master/S05-capture/caps.t#L5-L94" target="_blank" rel="external"><code>S05-capture/caps.t lines 5–94</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$/.chunks    # sequential tokenization</div><div class="line">$/.prematch  # $/.orig.substr(0, $/.from)</div><div class="line">$/.postmatch # $/.orig.substr($/.to)</div></pre></td></tr></table></figure>
<p>在 regex 内部, 当前匹配状态 <code>$¢</code> 也提供了这个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.pos        # 当前匹配位置</div></pre></td></tr></table></figure>
<p>最后那个值根据匹配是向前处理还是向后处理对应于 <code>$¢.from</code> 或 <code>$¢.to</code>.( 后一种情况出现在 <code>&lt;?after ...&gt;</code> 断言内部 ).</p>
<ul>
<li><p>就像上面描述的那样, 在列表上下文中, Match 对象返回它的位置捕获. 然而, 有时你更想以它们出现在文本中的顺序, 得到一个展平的 tokens 列表. <code>.caps</code> 方法按顺序返回一个所有捕获的列表, 而不管它是如何被绑定命名捕获或带编号捕获上的. (除了顺序, 这儿没有新的信息; 列表中的所有元素都是同样的 Match 对象,并被任意绑定.) 绑定实际上是作为 键/键值对儿返回, 而 键是名字或编号, 而值是 Match 对象自身.</p>
<p>除了返回那些捕获的 Match 对象外, <code>.chunks</code> 方法也在两个捕获之间返回交错的噪音. 就像 <code>.caps</code> , 列表元素的顺序跟它们原来在文本中的顺序相同.交错的部分也返回一个 pairs, 而键是 <code>~</code>, 值为一个简单的只包含字符串的 Match 对象, 即使未绑定的诸如 <code>.ws</code> 的子规则首先遍历文本. 在这样一个 Match对象上调用 <code>.made</code> 方法总是返回 一个 <code>Str</code>.</p>
</li>
</ul>
<p>如果 <code>.caps</code> 或 <code>.chunks</code> 发现它们有重叠绑定, 会出现一个警告. 没有这样的重叠, <code>.chunks</code> 保证将它匹配到的每一部分字符串映射为它返回的所有匹配的精确的一个元素, 所以, 覆盖范围是完整的.</p>
<ul>
<li>所有与任何 regex, subrule, or subpattern 匹配的尝试, 成功与否, 会返回一个能被求值为布尔值的对象.(这个对象要么是一个 Match, 要么是 Nil.)即:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$match_obj = $str ~~ /pattern/;</div><div class="line">say &quot;Matched&quot; if $match_obj;</div></pre></td></tr></table></figure>
<ul>
<li>不管成功与否,这个返回的对象也被自动的绑定到当前环境的词法变量 <code>$/</code> 上:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$str ~~ /pattern/;</div><div class="line">say &quot;Matched&quot; if $/;</div></pre></td></tr></table></figure>
<ul>
<li>在 regex 里面, 变量 <code>$¢</code> 保存着当前 regex 的未完成的 Match 对象, 这就是所谓的匹配状态(类型为 Cursor).通常, 这不应该被被修改, 除非你知道怎么创建并传递匹配状态.所有的 regexes 实际上返回匹配状态即使当你认为它们会返回其它东西时, 因为匹配状态为你追踪模式的成功和失败.</li>
</ul>
<p>幸运的是, 伴随着默认的具体的 Match 对象, 当你只想返回一个不同的抽象结果时, 你可以使用 <code>make</code> 函数把当前匹配状态和返回值关联起来, 这跟 return 有点像, 但是不会 clobber 匹配状态:<br><a href="https://github.com/perl6/roast/blob/master/S05-match/make.t#L9-L24" target="_blank" rel="external"><code>S05-match/make.t lines 9–24</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$str ~~ / foo                 # Match &apos;foo&apos;</div><div class="line">           &#123; make &apos;bar&apos; &#125;     # But pretend we matched &apos;bar&apos;</div><div class="line">         /;</div><div class="line">say $();                      # says &apos;bar&apos;</div></pre></td></tr></table></figure>
<p>通过 <code>.made</code> 方法能访问到任何 Match 对象的值(例如一个抽象对象). 因此, 这些抽象对象能被独立的管理.</p>
<p>当前指针对象总是由 Cursor 派生而来, 否则匹配不会起作用. 然而, 在那个约束之下, 当前指针的实际类型定义可当前正在解析的是哪一种语言. 当你进入一个 grammar 的顶部时, 这个指针通常开始于一个对象, 该对象的类型是你所在的 grammar 的名字, 但是当前语言可以通过各种方法修改, 当它们通过返回 blessed 为不同类型的指针对象来修改当前语言, 这可能也或许不是从当前 grammar 中派生出来的.</p>
<h1 id="子模式捕获"><a href="#子模式捕获" class="headerlink" title="子模式捕获"></a>子模式捕获</h1><ul>
<li>regex 中任何闭合在<code>捕获圆括号</code>中的那部分就是所谓的 <code>subpattern</code>, 例如:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  #               subpattern</div><div class="line">  #  _________________/\___________________</div><div class="line">  # |                                      |</div><div class="line">  # |       subpattern  subpattern         |</div><div class="line">  # |          __/\__    __/\__            |</div><div class="line">  # |         |      |  |      |           |</div><div class="line">ms/ (I am the (walrus), ( khoo )**2  kachoo) /;</div></pre></td></tr></table></figure>
<ul>
<li><p>如果匹配成功,  regex 中的每个 subpattern 都会产生一个 Match 对象</p>
</li>
<li><p>每个 subpattern 要么显式地赋值给一个具名目标,要么隐式地被添加到含有很多匹配的<code>数组</code>中去.</p>
</li>
</ul>
<p>对于每一个没有显式地给定名字的 subpattern, 该 subpattern 的 Match 对象被推入到外部的属于周围作用域的 <code>Match</code> 对象里面的数组中(即它的父 Match 对象). 周围作用域要么是最内部的周围作用域(如果 subpattern 是嵌套的) 要么是整个 regex 自身.</p>
<ul>
<li><p>像捕获一样, 这些对数组的赋值是假设的, 如果  subpattern 回溯, 这些赋值会被撤销.</p>
</li>
<li><p>举个例子, 如果下面这个模式匹配成功:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  #                subpat-A</div><div class="line">  #  _________________/\__________________</div><div class="line">  # |                                     |</div><div class="line">  # |         subpat-B  subpat-C          |</div><div class="line">  # |          __/\__    __/\__           |</div><div class="line">  # |         |      |  |      |          |</div><div class="line">ms/ (I am the (walrus), ( khoo )**2 kachoo) /;</div></pre></td></tr></table></figure>
<p>则由 <em>subpat-B</em>  和 <em>subpat-C</em> 产生的 Match 对象会被成功地推入到 <em>subpat- A</em>  的 Match 对象里面的数组中.  然后 <em>subpat-A</em>  的  <code>Match</code> 对象自身会被推入到整个 regex 的 Match 对象里面的数组中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $str = &quot;I am the walrus, khoo khoo kachoo&quot;;</div><div class="line">$str ~~ ms/ (I am the (walrus)\, ( khoo )**2 kachoo) /;</div><div class="line">say ~$/[0];       # I am the walrus, khoo khoo kachoo</div><div class="line">say ~$/[0][0];    # walrus</div><div class="line">say ~$/[0][1];    # khoo  khoo</div><div class="line">say ~$/[0][1][0]; # khoo</div><div class="line">say ~$/[0][1][1]; # khoo</div></pre></td></tr></table></figure>
<p>可以看出, subpat-A 的 Match 对象是 <code>$/</code>数组的一个元素, subpat-A 和 subpat-B 的 Match 对象在同一个数组 <code>$/[0]</code> 中。</p>
<ul>
<li>因为这些语义, Perl 6 中的捕获括号是分等级的, 而非线性的. (see “Nested subpattern captures”)</li>
</ul>
<h1 id="访问捕获的子模式"><a href="#访问捕获的子模式" class="headerlink" title="访问捕获的子模式"></a>访问捕获的子模式</h1><ul>
<li><code>Match</code> 对象的<code>数组元素</code>要么使用标准的数组访问记法(例如  <code>$/[0]</code>, <code>$/[1]</code>, <code>$/[2]</code> 等.) 要么通过对应的词法作用域<code>数字别名</code>(例如: <code>$0</code>, <code>$1</code>, <code>$2</code>), 所以:</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-match/capturing-contexts.t#L25-L34" target="_blank" rel="external"><code>S05-match/capturing-contexts.t lines 25–34</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;$/[1] was found between $/[0] and $/[2]&quot;;</div></pre></td></tr></table></figure>
<p>和下面这个相同:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;$1 was found between $0 and $2&quot;;</div></pre></td></tr></table></figure>
<ul>
<li><p>注意, 在 Perl 6 中, 数字捕获变量从 <code>$0</code>开始, 而非 <code>$1</code>, 使用 <code>$/</code> 中对应元素的索引中的数字.</p>
</li>
<li><p>regex 的 Match 对象(例如 $/)中的<code>数组元素</code>分别存储着单独的 Match 对象, 这些 Match 对象就是匹配到的<code>子字符串</code>, 并被第一个, 第二个,第三个,直到最外面的 subpattern 捕获(非嵌套). 所以这些元素能被看成完全合格的匹配结果. 例如:<br><a href="https://github.com/perl6/roast/blob/master/S05-capture/dot.t#L13-L55" target="_blank" rel="external">S05-capture/dot.t lines 13–55</a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if m/ (\d\d\d\d)-(\d\d)-(\d\d) (BCE?|AD|CE)?/ &#123;</div><div class="line">     ($yr, $mon, $day) = $/[0..2];</div><div class="line">     $era = &quot;$3&quot; if $3;                    # stringify/boolify</div><div class="line">     @datepos = ( $0.from() .. $2.to() );  # Call Match methods</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="嵌套的子模式捕获"><a href="#嵌套的子模式捕获" class="headerlink" title="嵌套的子模式捕获"></a>嵌套的子模式捕获</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-capture/named.t#L16-L25" target="_blank" rel="external"><code>S05-capture/named.t lines 16–25</code></a></p>
<ul>
<li><p>通过嵌套的 subpattern 匹配到的子字符串被赋值给嵌套的 subpattern 的 <code>父 Match 对象</code>里面的<code>数组</code>中, 而不是 $/ 的数组中.</p>
</li>
<li><p>这种行为和 Perl 5 的语义完全不同:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> # Perl 5...</div><div class="line"> #</div><div class="line"> # $1---------------------  $4---------  $5------------------</div><div class="line"> # |   $2---------------  | |          | | $6----  $7------  |</div><div class="line"> # |   |         $3--   | | |          | | |     | |       | |</div><div class="line"> # |   |         |   |  | | |          | | |     | |       | |</div><div class="line">m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /x;</div></pre></td></tr></table></figure>
<ul>
<li>在 Perl 6中, 嵌套的圆括号产生可能的嵌套的捕获</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> # Perl 6...</div><div class="line"> #</div><div class="line"> # $0---------------------  $1---------  $2------------------</div><div class="line"> # |   $0[0]------------  | |          | | $2[0]-  $2[1]---  |</div><div class="line"> # |   |       $0[0][0] | | |          | | |     | |       | |</div><div class="line"> # |   |         |   |  | | |          | | |     | |       | |</div><div class="line">m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /;</div></pre></td></tr></table></figure>
<p>如上, 在匹配嵌套的 subpattern 时, <code>$0</code>, <code>$1</code>, <code>$2</code> 是平级的, 它们都是父 Match 对象 <code>$/</code> 数组中的子元素, 即 <code>$/[0]</code>、<code>$/[1]</code>、<code>$/[2]</code>。而 <code>$0</code> 和 <code>$2</code> 中有嵌套的 subpattern, 所以 <code>$0</code> 和 <code>$2</code> 也成为父 subpattern, 依次类推。</p>
<h1 id="量词化的子模式捕获"><a href="#量词化的子模式捕获" class="headerlink" title="量词化的子模式捕获"></a>量词化的子模式捕获</h1><ul>
<li>如果 subpattern 后面直接使用 <code>?</code>量词, 它要么产生单个 Match 对象, 要么产生 Nil.(?表示匹配0次或1次。) 如果 subpattern 后直接使用任何其它量词, 它绝不会产生单个 Match 对象. 相反, 它产生一个 Match 对象的列表, 列表中的元素对应于由重复的 subpattern 产生的各自匹配的序列. 如果想区分这两种类别, <code>?</code> 是一个 item 量词, 而 <code>*</code>, <code>+</code> 和 <code>**</code> 叫做列表量词.</li>
</ul>
<p>如果匹配到 0 个值, 则捕获到的值取决于用的是哪个量词. 如果量词是 <code>?</code>, 并且匹配次数为 0, 则捕获到 Nil. 如果量词是 <code>*</code>, 则是<code>空列表</code>, 即 <code>()</code>. (如果匹配次数为 0, +量词什么也不会捕获, 因为它会引发回溯, 但是 如果在一个不成功的匹配之后, 又尝试使用它, 则捕获变量会返回 Nil ) . 如果它的最小范围是 0,  <code>**</code> 量词会像<code>*</code>那样返回 <code>()</code>, 否则就会回溯.</p>
<p>注意,  不像 ?,  <code>** 0..1</code> 总是被认为是一个列表量词.</p>
<p>把 <code>?</code> 看作 item 量词的理由是为了使它符合 <code>$object.?meth</code> 定义的方式, 并减少不必要的 <code>.[0]</code>下标, 这会使大部分人惊讶.既然 Nil 被认为是未定义的而非<code>()</code>的同义词, 使用 <code>$0 // &quot;default&quot;</code> 或诸如此类的来安全地解引用捕获就很容易了.</p>
<ul>
<li>因为列表量词化的 subpattern 返回一个 Match 对象的列表, 对应的量词化的捕获数组元素会存储一个(嵌套的)数组而不是单个 Match 对象.例如:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if m/ (\w+) \: (\w+ \s+)* / &#123;</div><div class="line">   say &quot;Key:    $0&quot;;         # Unquantified --&gt; single Match</div><div class="line">   say &quot;Values: @($1)&quot;;      # Quantified   --&gt; array of Match</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="间接量词化的子模式捕获"><a href="#间接量词化的子模式捕获" class="headerlink" title="间接量词化的子模式捕获"></a>间接量词化的子模式捕获</h1><ul>
<li>subpattern 有时会嵌套在一个量词化的非捕获结构中:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> #       non-capturing       quantifier</div><div class="line"> #  __________/\____________  __/\__</div><div class="line"> # |                        ||      |</div><div class="line"> # |   $0         $1        ||      |</div><div class="line"> # |  _^_      ___^___      ||      |</div><div class="line"> # | |   |    |       |     ||      |</div><div class="line">m/ [ (\w+) \: (\w+ \h*)* \n ] ** 2..* /</div></pre></td></tr></table></figure>
<p>非捕获括号不会创建单独的嵌套词法作用域, 所以那两个 subpattern 实际上仍然在 regex 的顶层作用域中, 因此, 它们的顶层名字是 <code>$0</code> 和 <code>$1</code>.</p>
<ul>
<li>然而, 因为那两个 subpattern 在量词化结构里面, <code>$0</code> 和 <code>$1</code> 每个都会包含一个数组.  每次迭代非捕获分组, 数组的元素会是对应 subpattern 返回的 submatch.例如:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $text = &quot;foo:food fool\nbar:bard barb&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          #   $0--     $1------</div><div class="line">          #   |   |    |       |</div><div class="line">$text ~~ m/ [ (\w+) \: (\w+ \h*)* \n? ] ** 2..* /;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 因为它们在一个量词化的非捕获 block 中...</div><div class="line"># say $/[0].perl;</div><div class="line"># $0 包含着下面的等同物:</div><div class="line">#</div><div class="line">#       [ Match.new(str=&gt;&apos;foo&apos;), Match.new(str=&gt;&apos;bar&apos;) ]</div><div class="line">#</div><div class="line"># 并且 $1 包含下面的等同物:</div><div class="line">#</div><div class="line">#       [ Match.new(str=&gt;&apos;food &apos;),</div><div class="line">#         Match.new(str=&gt;&apos;fool&apos; ),</div><div class="line">#         Match.new(str=&gt;&apos;bard &apos;),</div><div class="line">#         Match.new(str=&gt;&apos;barb&apos; ),</div><div class="line">#       ]</div></pre></td></tr></table></figure>
<ul>
<li>与此相反, 如果外部的量词化结构是一个<em>捕获</em>结构(例如. 一个 subpattern), 那么它会引入一个嵌套的词法作用域. 外部的量词化结构会返回一个 Match 对象的数组, 代表对每个迭代的内部括号的捕获。即:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $text = &quot;foo:food fool\nbar:bard barb&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          # $0-----------------------</div><div class="line">          # |                        |</div><div class="line">          # | $0[0]    $0[1]---      |</div><div class="line">          # | |   |    |       |     |</div><div class="line">$text ~~ m/ ( (\w+) \: (\w+ \h*)* \n ) ** 2..* /;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># 因为它是一个量词化的捕获 block,</div><div class="line"># $0 包含如下等价物:</div><div class="line">#</div><div class="line">#       [ Match.new( str=&gt;&quot;foo:food fool\n&quot;,</div><div class="line">#                    arr=&gt;[ Match.new(str=&gt;&apos;foo&apos;),</div><div class="line">#                           [</div><div class="line">#                               Match.new(str=&gt;&apos;food &apos;),</div><div class="line">#                               Match.new(str=&gt;&apos;fool&apos;),</div><div class="line">#                           ]</div><div class="line">#                         ],</div><div class="line">#                  ),</div><div class="line">#         Match.new( str=&gt;&apos;bar:bard barb&apos;,</div><div class="line">#                    arr=&gt;[ Match.new(str=&gt;&apos;bar&apos;),</div><div class="line">#                           [</div><div class="line">#                               Match.new(str=&gt;&apos;bard &apos;),</div><div class="line">#                               Match.new(str=&gt;&apos;barb&apos;),</div><div class="line">#                           ]</div><div class="line">#                         ],</div><div class="line">#                  ),</div><div class="line">#       ]</div><div class="line">#</div><div class="line"># 并且没有 $1</div></pre></td></tr></table></figure>
<ul>
<li>换句话说, 量词化的非捕获括号把它们的组件聚集到就近展平的列表中, 而量词化的捕获括号把它们的部件聚集到就近的分等级的结构中.</li>
</ul>
<p>此外,  sublist 彼此间是被同步保存的,作为每个空匹配, 在我们例子中的 <code>$0[1]</code>情形下, 如果冒号后面跟着一个换行符, 那么将会在给定的列表中有一个对应的 Nil值。</p>
<h1 id="子模式编号"><a href="#子模式编号" class="headerlink" title="子模式编号"></a>子模式编号</h1><ul>
<li><p>给定 subpattern 的索引总是能被静态地决定, 但不是唯一也不是无变化的. subpattern 的编号从每个词法作用域重新开始.( regex, subpattern, 或备选分支中的任意一个)</p>
</li>
<li><p>特别地, 在每个 <code>|</code> 或 <code>||</code> 之后, 捕获括号的索引重新开始.(但是不是在每个 &amp; 或 &amp;&amp; 之后)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">             # $0        $1    $2   $3    $4           $5</div><div class="line">$tune_up = rx/ (&quot;don&apos;t&quot;) (ray) (me) (for) (solar tea), (&quot;d&apos;oh!&quot;)</div><div class="line">             # $0      $1      $2    $3        $4</div><div class="line">             | (every) (green) (BEM) (devours) (faces)</div><div class="line">             /;</div></pre></td></tr></table></figure>
<p>这意味着, 如果第二个备选分支匹配, 匹配的列表中将会包含 <code>(&#39;every&#39;, &#39;green&#39;, &#39;BEM&#39;, &#39;devours&#39;, &#39;faces&#39;)</code> 而非 Perl 5 的 <code>(undef, undef, undef, undef, undef, undef, &#39;every&#39;, &#39;green&#39;, &#39;BEM&#39;, &#39;devours&#39;, &#39;faces&#39;)</code>.</p>
<ul>
<li>注意, 仍旧能模仿无变化的 Perl 5 捕获索引语义.查看下面的 “Numbered scalar aliasing”</li>
</ul>
<h1 id="Subrule-捕获"><a href="#Subrule-捕获" class="headerlink" title="Subrule 捕获"></a>Subrule 捕获</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-capture/named.t#L36-L74" target="_blank" rel="external"><code>S05-capture/named.t lines 36–74</code></a></p>
<ul>
<li><p>在模式中调用任何一个命名的 <code>&lt;regex&gt;</code> 被称为 <code>subrule</code>, 不管那个正则表达式实际上被定义为一个 <code>regex</code>, 或者 <code>token</code>, 或者甚至普通的方法或 <code>multi</code>.</p>
</li>
<li><p>任何别名为具名变量的括号结构也是一个 <code>subrule</code></p>
</li>
<li><p>例如, 下面这个正则表达式包含 3 个 subrules:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> # subrule       subrule     subrule</div><div class="line"> #  __^__    _______^_____    __^__</div><div class="line"> # |     |  |             |  |     |</div><div class="line">m/ &lt;ident&gt;  $&lt;spaces&gt;=(\s*)  &lt;digit&gt;+ /</div></pre></td></tr></table></figure>
<ul>
<li>就像 subpatterns 那样, 在正则表达式中每个成功匹配的 subrule 都产生一个 Match 对象. 但是, 跟 subpatterns 不同的是, 那个 Match 对象没有赋值给它的父 Match 对象里面的数组. 相反, 它被赋值给它的父 Match 对象里面的散列中的一个条目(键值对儿). 例如:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#  .... $/ .....................................</div><div class="line"># :                                             :</div><div class="line"># :              .... $/[0] ..................  :</div><div class="line"># :             :                             : :</div><div class="line"># : $/&lt;ident&gt;   :        $/[0]&lt;ident&gt;         : :</div><div class="line"># :   __^__     :           __^__             : :</div><div class="line"># :  |     |    :          |     |            : :</div><div class="line">ms/  &lt;ident&gt; \: ( known as &lt;ident&gt; previously ) /</div></pre></td></tr></table></figure>
<h1 id="访问捕获的-subrules"><a href="#访问捕获的-subrules" class="headerlink" title="访问捕获的 subrules"></a>访问捕获的 subrules</h1><ul>
<li>Match 对象的散列条目可以使用任何一个标准的散列访问记法(<code>$/{&#39;foo&#39;}</code>, <code>$/</code>, <code>$/«baz»</code>, 等等.) 查阅, 或通过对应的词法作用域别名 (<strong><code>$&lt;foo&gt;</code></strong>, <code>$«bar»</code>, <strong><code>$&lt;baz&gt;</code></strong>, 等等.)访问. 所以前面的例子也意味着:<br><a href="https://github.com/perl6/roast/blob/master/S05-capture/dot.t#L62-L87" target="_blank" rel="external"><code>S05-capture/dot.t lines 62–87</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#    $&lt;ident&gt;             $0&lt;ident&gt;</div><div class="line">#     __^__                 __^__</div><div class="line">#    |     |               |     |</div><div class="line">ms/  &lt;ident&gt; \: ( known as &lt;ident&gt; previously ) /</div></pre></td></tr></table></figure>
<ul>
<li>注意, subrule 是使用尖括号(<em><ident></ident></em>) 或者使用内部别名(<em><ident=.name></ident=.name></em>)还是使用外部别名( <strong>$<ident>=(&lt;.alpha&gt;\w*)</ident></strong> )是没有分别的.</li>
</ul>
<h1 id="同一个-subrule-的重复捕获"><a href="#同一个-subrule-的重复捕获" class="headerlink" title="同一个 subrule 的重复捕获"></a>同一个 subrule 的重复捕获</h1><ul>
<li><p>如果在词法作用域的任何一个分支中出现 2次(或更多) subrules (例如,在同一个 subpattern 和备选中出现2次), 或者, 如果 在给定作用域的任何地方, subrule 是列表量词化的(那就是, 使用除了?之外的任何其它量词), 那么, 它的对应散列条目总是被赋值给 Match 对象的数组中, 而不是赋值给单个 Match 对象.</p>
</li>
<li><p>同一个 subrule 的成功匹配( 无论是来自于单独的调用还是来自于单个量词化重复)把单独的 Match 对象追加到这个数组中, 例如:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ms/ mv &lt;file&gt; &lt;file&gt; / &#123;</div><div class="line">    $from = $&lt;file&gt;[0];</div><div class="line">    $to   = $&lt;file&gt;[1];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(注意, 为了代码清晰, 我们这里忽略了空白的细微之处 – 普通的 sigspace rules 只会在字母数字字符之间要求有空白, 这是错误的. 假设我们的 <code>&lt;file&gt;</code> subrule 自己处理空白.)</p>
<p>同样地, 使用量词化的 subrule:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ms/ mv &lt;file&gt; ** 2 / &#123;</div><div class="line">    $from = $&lt;file&gt;[0];</div><div class="line">    $to   = $&lt;file&gt;[1];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有使用它们两者的混合:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ms/ mv &lt;file&gt;+ &lt;file&gt; / &#123;</div><div class="line">    $to   = pop @($&lt;file&gt;);</div><div class="line">    @from = @($&lt;file&gt;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>为了避免名字冲突, 可以使用一个前置的点来抑制原来的名字, 然后使用别名给捕获一个不同的名字:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ms/ mv &lt;file&gt; &lt;dir=.file&gt; / &#123;</div><div class="line">    $from = $&lt;file&gt;;  # 只有一个 subrule 叫做 &lt;file&gt;, 所以是标量</div><div class="line">    $to   = $&lt;dir&gt;;   # 这个捕获之前叫做 &lt;file&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样地, 下面的结构都不会让 <code>&lt;file&gt;</code> 产生一个 Match 对象的数组, 因为在同一个词法作用域中, 它们都没有两个或更多的 <code>&lt;file&gt;</code> subrules.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if ms/ (keep) &lt;file&gt; | (toss) &lt;file&gt; / &#123;</div><div class="line">    # 每个 &lt;file&gt; 都是单独的备选分支,</div><div class="line">    # 因此 &lt;file&gt; 在任何一个作用域中都没有被重复, 因此, $&lt;file&gt; 不是数组对象.</div><div class="line">    $action = $0;</div><div class="line">    $target = $&lt;file&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ms/ &lt;file&gt; \: (&lt;file&gt;|none) / &#123;</div><div class="line">    # 第二个 &lt;file&gt; 嵌套在不同作用域中的 subpattern 中</div><div class="line">    $actual  = $/&lt;file&gt;;</div><div class="line">    $virtual = $/[0]&lt;file&gt; if $/[0]&lt;file&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>另一方面, 未别名化的方括号没有被授予单独的作用域(因为它们没有关联的 Match 对象).所以:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ms/ &lt;file&gt; \: [&lt;file&gt;|none] / &#123; # 这两个 &lt;file&gt; 在同一个作用域中</div><div class="line">    $actual  = $/&lt;file&gt;[0];</div><div class="line">    $virtual = $/&lt;file&gt;[1] if $/&lt;file&gt;[1];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>别名可以被命名或编号. 它们可以是 <em>scalar-</em>, <em>array-</em>, 或 <em>hash-like</em>. 并且它们能被应用到捕获或非捕获结构中.  下面的章节会突出那些组合语义的特殊功能.</p>
<h1 id="让具名标量成为subpatterns的别名"><a href="#让具名标量成为subpatterns的别名" class="headerlink" title="让具名标量成为subpatterns的别名"></a>让具名标量成为subpatterns的别名</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-capture/named.t#L26-L35" target="_blank" rel="external"><code>S05-capture/named.t lines 26–35</code></a></p>
<ul>
<li>如果一个具名标量别名被应用了一组<strong>捕获</strong>圆括号:<br><a href="https://github.com/perl6/roast/blob/master/S05-capture/alias.t#L17-L26" target="_blank" rel="external"><code>S05-capture/alias.t lines 17–26</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  #         _____/capturing parens\_____</div><div class="line">  #        |                            |</div><div class="line">  #        |                            |</div><div class="line">ms/ $&lt;key&gt;=( (&lt;[A..E]&gt;) (\d**3..6) (X?) ) /;</div></pre></td></tr></table></figure>
<p>那么远离外部的圆括号不再像非别名括号那样捕获到 <code>$/</code> 数组中。相反, 别名化的圆括号捕获到了 <code>$/</code> 散列中; 特别是捕获到键名是别名名字的散列元素中。</p>
<ul>
<li><p>所以, 在上面的例子中, 一个成功的匹配设置了 <code>$&lt;key&gt;</code>(例如 <code>$/&lt;key&gt;</code>), 而非 <code>$0</code>(例如 不是 <code>$/[0]</code>)。</p>
</li>
<li><p>更确切地说:</p>
<ul>
<li><code>$/</code> 会包含之间已经放进 <code>$/[0]</code> 中的 <code>Match</code> 对象。</li>
<li><code>$/[0]</code> 会包含 A-E 字母,</li>
<li><code>$/[1]</code> 会包含数字,</li>
<li><code>$/[2]</code> 会包含可选的 X.</li>
</ul>
</li>
<li><p>了解这种行为的另外一种方法是别名化的括号创建了一种本地作用域的具名 subrule; 圆括号的内容被当作就像它们是单独的 subrule 的一部分, 它的名字就是别名。</p>
</li>
</ul>
<h1 id="让具名标量成为非捕获分组的别名"><a href="#让具名标量成为非捕获分组的别名" class="headerlink" title="让具名标量成为非捕获分组的别名"></a>让具名标量成为非捕获分组的别名</h1><ul>
<li>如果一个具名标量别名被应用到一组非捕获括号:<br><a href="https://github.com/perl6/roast/blob/master/S05-capture/alias.t#L33-L68" target="_blank" rel="external"><code>S05-capture/alias.t lines 33–68</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  #         __/non-capturing brackets\__</div><div class="line">  #        |                            |</div><div class="line">  #        |                            |</div><div class="line">ms/ $&lt;key&gt;=[ (&lt;[A..E]&gt;) (\d**3..6) (X?) ] /;</div></pre></td></tr></table></figure>
<p>则对应的 <code>$/</code> <code>Match</code> 对象只会包含非捕获括号匹配到的字符串.</p>
<ul>
<li><p>特别地,  <code>$/</code> 数组中的条目是空的. 那是因为方括号不会创建嵌套的词法作用域. 所以 subpatterns 是非嵌套的, 并且因此对应于<code>$0</code>, <code>$1</code>, 和 <code>$2</code>, 而不是对应于  <code>$/[0]</code>, <code>$/[1]</code>, 和 <code>$/[2]</code>.</p>
</li>
<li><p>换句话说:</p>
<ul>
<li><code>$/</code> 会包含方括号匹配到的整个子字符串  (in a <code>Match</code> object, as described above),</li>
<li><code>$0</code> 会包含字母 <code>A-E</code>,</li>
<li><code>$1</code> 会包含数字,</li>
<li><code>$2</code>会包含可选的 X.</li>
</ul>
</li>
</ul>
<h1 id="让具名标量成为-subrules-的别名"><a href="#让具名标量成为-subrules-的别名" class="headerlink" title="让具名标量成为 subrules 的别名"></a>让具名标量成为 subrules 的别名</h1><ul>
<li>如果 subrule 被设置了别名, 它会把它的 Match 对象设置为散列的条目, 散列的键是别名的名字, 它和 subrule 原来的名字一样.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if m/ ID\: &lt;id=ident&gt; / &#123;</div><div class="line">    say &quot;Identified as $/&lt;id&gt; and $/&lt;ident&gt;&quot;;    # both names defined</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要抑制原来的名字, 使用带点形式的名字:<br>  ​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if m/ ID\: &lt;id=.ident&gt; / &#123;</div><div class="line">    say &quot;Identified as $/&lt;id&gt;&quot;;    # $/&lt;ident&gt; is undefined</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>因此, 给一个带点的 subrule 起别名改变了 subrule 的 Match 对象的目标.在同一个作用域内, 这对于区分对同一个 subrule 的两次或多次调用.例如:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ms/ mv &lt;file&gt;+ &lt;dir=.file&gt; / &#123;</div><div class="line">    @from = @($&lt;file&gt;);</div><div class="line">    $to   = $&lt;dir&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="给标量别名编号"><a href="#给标量别名编号" class="headerlink" title="给标量别名编号"></a>给标量别名编号</h1><ul>
<li>如果使用编号别名而非使用具名别名:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">m/ $1=(&lt;-[:]&gt;*) \:  $0=&lt;ident&gt; /   # captures $&lt;ident&gt; too</div><div class="line">m/ $1=(&lt;-[:]&gt;*) \:  $0=&lt;.ident&gt; /  # doesn&apos;t capture $&lt;ident&gt;</div></pre></td></tr></table></figure>
<p>编号别名的行为就和具名别名的一样(i.e. 上面描述过的各种情况), 除了结果 Match 对象被赋值给对应的合适数组元素, 而非散列元素.</p>
<ul>
<li>如果使用了编号别名, 后续同一作用域中未起别名的 subpatterns 的编号会从那个别名编号开始自动增长(跟枚举数值从最后一个显式值开始增长很像). 即:<br><a href="https://github.com/perl6/roast/blob/master/S05-capture/alias.t#L27-L32" target="_blank" rel="external"><code>S05-capture/alias.t lines 27–32</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> #  --$1---    -$2-    --$6---    -$7-</div><div class="line"> # |       |  |    |  |       |  |    |</div><div class="line">m/ $1=(food)  (bard)  $6=(bazd)  (quxd) /;</div></pre></td></tr></table></figure>
<ul>
<li>这种后续的行为对于在备选分支中重新建立 Perl5语义中的连续 subpattern 编号特别有用:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$tune_up = rx/ (&quot;don&apos;t&quot;) (ray) (me) (for) (solar tea), (&quot;d&apos;oh!&quot;)</div><div class="line">             | $6 = (every) (green) (BEM) (devours) (faces)</div><div class="line">             #              $7      $8    $9        $10</div><div class="line">             /;</div></pre></td></tr></table></figure>
<ul>
<li><p>这也在 Perl 6 中提供了一种简单的方式来重建嵌套的 Perl 5 subpatterns 的非嵌套编号语义:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="comment"># Perl 5...</span></div><div class="line"> <span class="comment">#               $1</span></div><div class="line"> <span class="comment">#  _____________/\___________</span></div><div class="line"> <span class="comment"># |    $2        $3      $4  |</span></div><div class="line"> <span class="comment"># |  __/\___   __/\___   /\  |</span></div><div class="line"> <span class="comment"># | |       | |       | |  | |</span></div><div class="line"><span class="keyword">m</span>/ ( ( [A-E] ) (\d&#123;<span class="number">3</span>,<span class="number">6</span>&#125;) (X?) ) /<span class="keyword">x</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> # Perl 6...</div><div class="line"> #                $0</div><div class="line"> #  ______________/\______________</div><div class="line"> # |   $0[0]       $0[1]    $0[2] |</div><div class="line"> # |  ___/\___   ____/\____   /\  |</div><div class="line"> # | |        | |          | |  | |</div><div class="line">m/ ( (&lt;[A..E]&gt;) (\d ** 3..6) (X?) ) /;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> # Perl 6 simulating Perl 5...</div><div class="line"> #                 $1</div><div class="line"> #  _______________/\________________</div><div class="line"> # |        $2          $3       $4  |</div><div class="line"> # |     ___/\___   ____/\____   /\  |</div><div class="line"> # |    |        | |          | |  | |</div><div class="line">m/ $1=[ (&lt;[A..E]&gt;) (\d ** 3..6) (X?) ] /;</div></pre></td></tr></table></figure>
<p>非捕获括号没有引入作用域, 所以非捕获括号中的 subpatterns 处于 regex 作用域, 并因此在括号顶层开始编号. 给方括号起别名为 <code>$1</code>意味着同一级别的下一个 subpattern(例如 <code>(&lt;[A..E]&gt;)</code>)的编号继续(i.e. <code>$2</code>). 等等.<br>  ​</p>
<h1 id="给量词化结构应用标量别名"><a href="#给量词化结构应用标量别名" class="headerlink" title="给量词化结构应用标量别名"></a>给量词化结构应用标量别名</h1><ul>
<li><p>上面所有的语义可以同等地应用到绑定了量词化结构的别名身上.</p>
</li>
<li><p>唯一不同的是, 如果别名化的结构是一个 subrule 或 subpattern, 那么量词化的 subrule 或 subpattern 必然会返回一个 Match 对象的列表. (像 “Quantified subpattern captures”) 和 “Repeated captures of the same subrule”) 中描述的那样). 所以, 别名所对应的数组元素或散列条目会包含一个数组, 而不是单个 Match 对象.</p>
</li>
<li><p>换句话说, 别名和量词化是完全正交的,例如:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if ms/ mv $0=&lt;.file&gt;+ / &#123;</div><div class="line">    # &lt;file&gt;+ 返回一个 Match objects 的列表,</div><div class="line">    # 所以 $0 包含一个 Match objects 的数组,</div><div class="line">    # one for each successful call to &lt;file&gt;</div><div class="line">    # $/&lt;file&gt; 不存在 (因为它被点号抑制了)</div><div class="line">&#125;</div><div class="line"></div><div class="line">if m/ mv \s+ $&lt;from&gt;=(\S+ \s+)* / &#123;</div><div class="line">    # 量词化的子模式返回一个 Match objects 的列表,</div><div class="line">    # 所以 $/&lt;from&gt; 包含了一个 Match objects 的数组,</div><div class="line">    # one for each successful match of the subpattern</div><div class="line">    # $0 不存在 ($0 被别名预先清空了)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注意, 一组量词化的非捕获括号总是返回单个 Match 对象,  该 Match 对象只包含通过全组重复括号匹配到的整个子字符串.(就像 “具名标量别名应用到非捕获括号”) 中描述的那样). 例如:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;coffee fifo fumble&quot; ~~ m/ $&lt;effs&gt;=[f &lt;-[f]&gt; ** 1..2 \s*]+ /;</div><div class="line">say $&lt;effs&gt;;    # 打印 &quot;fee fifo fum&quot;</div></pre></td></tr></table></figure>
<h1 id="数组别名"><a href="#数组别名" class="headerlink" title="数组别名"></a>数组别名</h1><ul>
<li>别名也能使用一个数组而非标量作为别名。例如:</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-capture/array-alias.t#L13-L92" target="_blank" rel="external"><code>S05-capture/array-alias.t lines 13–92</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">m/ mv \s+ @&lt;from&gt;=[(\S+) \s+]* &lt;dir&gt; /;</div><div class="line"></div><div class="line">&quot;    a b\tc&quot; ~~ m/@&lt;chars&gt;=( \s+ \S+)+/;</div><div class="line">join(&quot;|&quot;, @&lt;chars&gt;) #     a| b|	c</div></pre></td></tr></table></figure>
<ul>
<li>使用 <code>@alias=</code> 记法而非 <code>$alias=</code>  迫使对应散列条目或数组元素总是接收一个 Match 对象的数组, 即使正被起别名的结构通常返回的是单个 Match 对象。 这对于根据结构不同的备选分支创建一致的捕获语义很有用。(通过在所有分支中强制数组捕获):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ms/ Mr?s? @&lt;names&gt;=&lt;ident&gt; W\. @&lt;names&gt;=&lt;ident&gt;</div><div class="line">   | Mr?s? @&lt;names&gt;=&lt;ident&gt;</div><div class="line">   /;</div><div class="line"># 别名起为 @names 意味着 $/&lt;names&gt; 总是一个 Array 对象, 所以...</div><div class="line">say @($/&lt;names&gt;);</div></pre></td></tr></table></figure>
<ul>
<li>为了方便和一致性,  <code>@</code> 也能用在 regex 外面. 作为<code>@( $/ )</code> 的简写形式。 即:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$_ = &quot;Mrs camelia W. rakudo&quot;</div><div class="line">ms/ Mr?s? @&lt;names&gt;=&lt;ident&gt; W\. @&lt;names&gt;=&lt;ident&gt;</div><div class="line">   | Mr?s? @&lt;names&gt;=&lt;ident&gt;</div><div class="line">   /;</div><div class="line">say @&lt;names&gt;; # [｢camelia｣ ｢rakudo｣]</div></pre></td></tr></table></figure>
<p>其中 <code>ms</code> 中的 <strong>s</strong> 使 regex 中的空格有意义。<br>  ​</p>
<ul>
<li>如果把数组别名应用到量词化的非捕获括号上, 它会捕获由每次括号的重复匹配到的子字符串, 捕获到对应数组的单独的元素中.即:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ms/ mv $&lt;files&gt;=[ f.. \s* ]* /; # $/&lt;files&gt; assigned a single</div><div class="line">                                # Match object containing the</div><div class="line">                                # complete substring matched by</div><div class="line">                                # the full set of repetitions</div><div class="line">                                # of the non-capturing brackets</div></pre></td></tr></table></figure>
<p><code>$/&lt;files&gt;</code> 被赋值了单个包含由全套重复的非捕获括号所匹配到的完整子字符串的Match 对象。<br>  ​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ms/ mv @&lt;files&gt;=[ f.. \s* ]* /; # $/&lt;files&gt; assigned an array,</div><div class="line">                                # each element of which is a</div><div class="line">                                # Match object containing</div><div class="line">                                # the substring matched by Nth</div><div class="line">                                # repetition of the non-</div><div class="line">                                # capturing bracket match</div></pre></td></tr></table></figure></p>
<p><code>$/&lt;files&gt;</code> 被赋值给了一个数组, 数组中的每个元素是含有通过第 N 个 重复的非捕获括号匹配所匹配到的子字符串的 Match 对象。</p>
<ul>
<li>如果数组别名应用到捕获的括号（即一个子模式）的量词化对儿上，那么相应的散列或数组元素被分配通过连接由子模式的一个重复返回的每个<code>Match</code>对象的数组值构成的列表。也就是说，一个子模式阵列别名变平，并收集混叠子模式中的所有嵌套子模式拍摄。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if ms/ $&lt;pairs&gt;=( (\w+) \: (\N+) )+ / &#123;</div><div class="line">    # Scalar alias, so $/&lt;pairs&gt; is assigned an array</div><div class="line">    # of Match objects, each of which has its own array</div><div class="line">    # of two subcaptures...</div><div class="line">    for @($&lt;pairs&gt;) -&gt; $pair &#123;</div><div class="line">        say &quot;Key: $pair[0]&quot;;</div><div class="line">        say &quot;Val: $pair[1]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if ms/ @&lt;pairs&gt;=( (\w+) \: (\N+) )+ / &#123;</div><div class="line">    # Array alias, so $/&lt;pairs&gt; is assigned an array</div><div class="line">    # of Match objects, each of which is flattened out of</div><div class="line">    # the two subcaptures within the subpattern</div><div class="line"></div><div class="line">    for @($&lt;pairs&gt;) -&gt; $key, $val &#123;</div><div class="line">        say &quot;Key: $key&quot;;</div><div class="line">        say &quot;Val: $val&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>同样地, 如果数组别名(array alias)被应用到量词化的 subrule 上, 那么对应于别名的散列元素或数组元素被赋值了一个列表, 这个列表包含了从每次 subrule 重复返回的每个 <code>Match</code> 对象的数组值, 它们都被展开到单个数组中: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rule pair &#123; (\w+) \: (\N+) \n &#125;</div><div class="line"></div><div class="line">if ms/ $&lt;pairs&gt;=&lt;pair&gt;+ / &#123;</div><div class="line">    # 标量别名, 所以 $/&lt;pairs&gt; 包含了一个 Match 对象的数组</div><div class="line">    # 数组中的每个值都是 &lt;pair&gt; subrule 调用的结果...</div><div class="line"></div><div class="line"> for @($&lt;pairs&gt;) -&gt; $pair &#123;</div><div class="line">        say &quot;Key: $pair[0]&quot;;</div><div class="line">        say &quot;Val: $pair[1]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">rule pair &#123; (\w+) \: (\N+) \n &#125;</div><div class="line"></div><div class="line">if ms/ mv @&lt;pairs&gt;=&lt;pair&gt;+ / &#123;</div><div class="line">    # 数组别名, 所以 $/&lt;pairs&gt; 包含了一个 Match objects 的数组</div><div class="line">    # all flattened down from the</div><div class="line">    # nested arrays inside the Match objects returned</div><div class="line">    # by each match of the &lt;pair&gt; subrule...</div><div class="line">    # 从 &lt;pair&gt; subrule 的每次匹配返回的 Match objects 里面嵌套的数组都向下展开</div><div class="line"></div><div class="line">   for @($&lt;pairs&gt;) -&gt; $key, $val &#123;</div><div class="line">        say &quot;Key: $key&quot;;</div><div class="line">        say &quot;Val: $val&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>换句话说, 数组别名在把任何可能出现在量词化 subpattern 或 subrule 中的嵌套的捕获展开到单个数组中时很有用。而标量别名对保存每次重复的顶级数组内部结构很有用。</p>
</li>
<li><p>把数字编号变量用作数组别名也是可行的。语义和上面描述的相同。唯一不同的是 <code>Match</code> objects 的结果数组被赋值给了该 regex 的匹配数组的合适元素中而不是它的匹配散列的键中。例如:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if m/ mv  \s+  @0=((\w+) \s+)+  $1=((\W+) (\s*))* / &#123;</div><div class="line">    #          |                |</div><div class="line">    #          |                |</div><div class="line">    #          |                 \_ 标量别名, 所以 $1 得到一个数组</div><div class="line">    #          |                    数组中的每个元素都是一个 Match 对象</div><div class="line">    #          |                    每个 Match 对象都包含了两个嵌套的捕获</div><div class="line">    #          |</div><div class="line">    #          |</div><div class="line">    #           \___ 数组别名, 所以 $0 得到了一个展开的数组</div><div class="line">    #                数组中的每个元素都是从每次重复所得到的 (\w+) 捕获</div><div class="line"></div><div class="line">    @from     = @($0);      # 展开的列表</div><div class="line">    $to_str   = $1[0][0];   # Nested elems of</div><div class="line">    $to_gap   = $1[0][1];   #    unflattened list</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>再次注意, 在 regex 外面, <code>@0</code> 就是 <code>@($0)</code> 的简写形式, 所以上面代码中的第一次赋值也能写作这样:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@from = @0;</div></pre></td></tr></table></figure>
<h1 id="散列别名"><a href="#散列别名" class="headerlink" title="散列别名"></a>散列别名</h1><ul>
<li>除了使用标量或数组, 使用散列作为别名变量也能指定别名, 例如:<br><a href="https://github.com/perl6/roast/blob/master/S05-capture/hash.t#L13-L159" target="_blank" rel="external">S05-capture/hash.t lines 13–159</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m/ mv %&lt;location&gt;=( (&lt;ident&gt;) \: (\N+) )+ /;</div></pre></td></tr></table></figure>
<ul>
<li><p>散列别名让当前作用域中 <code>Match</code> 对象对应的散列或数组元素被赋值了一个(嵌套的) Hash 对象(而不是一个 <code>Array</code> 对象或单个 <code>Match</code> 对象)。</p>
</li>
<li><p>如果散列别名被应用到 subrule 或 subpattern 上, 那么第一个嵌套的数字捕获变成每个散列条目的键, 剩下的数字捕获成为键值(如果不止一个则在数组中)。</p>
</li>
<li><p>就像数组别名那样, 把编号变量用作散列别名也是可行的, 唯一不同的是 <code>Match</code> 对象的结果的存储位置:<br>​</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rule one_to_many &#123;  (\w+) \: (\S+) (\S+) (\S+) &#125;</div><div class="line"></div><div class="line">   if ms/ %0=&lt;one_to_many&gt;+ / &#123;</div><div class="line">     # $/[0] 含有一个散列, 其中每个键由 &lt;one_to_many&gt; 中的第一个 subcapture 提供</div><div class="line">     # 每个键值是一个包含了 subrule 的第二个、第三个、第四个等 subcaptures 的数组...</div><div class="line"></div><div class="line">     for %($/[0]) -&gt; $pair &#123;</div><div class="line">           say &quot;One:  $pair.key()&quot;;</div><div class="line">           say &quot;Many: &#123; @($pair.value) &#125;&quot;;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在 regex 外部, <code>%0</code> 是  <code>%($0)</code>的简写:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for %0 -&gt; $pair &#123;</div><div class="line">    say &quot;One:  $pair.key()&quot;;</div><div class="line">    say &quot;Many: @($pair.value)&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="外部别名"><a href="#外部别名" class="headerlink" title="外部别名"></a>外部别名</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-capture/external-aliasing.t#L6-L38" target="_blank" rel="external">S05-capture/external-aliasing.t lines 6–38</a></p>
<ul>
<li>代替像这样在内部使用别名:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m/ mv  @&lt;files&gt;=&lt;ident&gt;+  $&lt;dir&gt;=&lt;ident&gt; /</div></pre></td></tr></table></figure>
<p> 普通变量名能用作外部别名, 像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m/ mv  @OUTER::files=&lt;ident&gt;+  $OUTER::dir=&lt;ident&gt; /</div></pre></td></tr></table></figure>
<ul>
<li>这时, 每个别名的表现和之前章节所描述的相同。不同的是结果捕获被直接(但仍旧是假设)绑定给指定名字的变量, 而该变量必须已经存在于声明该 regex 的作用域中。</li>
</ul>
<h1 id="从重复匹配中捕获"><a href="#从重复匹配中捕获" class="headerlink" title="从重复匹配中捕获"></a>从重复匹配中捕获</h1><ul>
<li><p>当整个正则表达式使用重复(由 <code>:x</code> 或 <code>:g</code> 标记指定)或重叠(通过 <code>:ov</code> 或 <code>:ex</code> 标记指定)匹配成功时, 它会产生一个不同匹配的序列。</p>
</li>
<li><p>在任何这些标记之下, 成功的匹配仍旧在 <code>$/</code> 中返回单个 <code>Match</code> 对象。然而, 该对象可能代表着该 regex 的部分求值。还有, 这个匹配对象的值和通过非重复匹配提供的那些值有些许不同:</p>
<p>例如:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if $text ~~ ms:g/ (\S+:) &lt;rocks&gt; / &#123;</div><div class="line">   say &quot;Full match context is: [$/]&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是对应于每个单独的匹配的单独匹配对象的列表也是可得到的:<br>  ​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if $text ~~ ms:g/ (\S+:) &lt;rocks&gt; / &#123;</div><div class="line">    say &quot;Matched &#123; +lol() &#125; times&quot;;    # Note: forced eager here by +</div><div class="line"></div><div class="line">    for lol() -&gt; $m &#123;</div><div class="line">        say &quot;Match between $m.from() and $m.to()&quot;;</div><div class="line">        say &apos;Right on, dude!&apos; if $m[0] eq &apos;Perl&apos;;</div><div class="line">        say &quot;Rocks like $m&lt;rocks&gt;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>这样的匹配之后 <code>$/</code> 的布尔值要么是 true, 要么是 false, 取决于模式是否匹配。</li>
<li>字符串值是从第一次匹配开始到最后一次匹配结束的子字符串(包括任何 regex 跳过的发生于其间的部分字符串, 为了找到后来的匹配。)</li>
<li>Subcaptures 被作为多维列表返回, 用户可以选择两种方法之一来处理。如果你引用 <code>@().flat</code>(或仅仅在展开的列表上下文中使用 <code>@()</code>), 那么多维性被忽略而且所有的匹配被展开后(但是仍旧是懒惰的)返回。如果你引用了 <code>lol()</code>, 则你可以得到每个单独的 sublist 作为一个 <code>Parcel</code> 对象。就像任何多维列表那样, 每个 sublist 各自都可以是懒惰的。</li>
</ul>
<h1 id="Grammars"><a href="#Grammars" class="headerlink" title="Grammars"></a>Grammars</h1><ul>
<li>你私有的  <code>ident</code> rule 不能重写其它人的 <code>ident</code> rule. 所以需要某种机制将 rules 限制到一个名称空间中.</li>
<li>如果 subs 是 rules 的模型, 那么 <code>modules/classes</code> 明显就是用于凝聚它们的模型. 这种 rules 的集合就是所谓的 <em>grammars</em>​</li>
<li>就像一个类能把具名的 actions 收集在一起,  grammar 也能把一组具名的 <code>rules</code> 收集在一起:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Identity &#123;</div><div class="line">    method name &#123; &quot;Name = $!name&quot; &#125;</div><div class="line">    method age  &#123; &quot;Age  = $!age&quot;  &#125;</div><div class="line">    method addr &#123; &quot;Addr = $!addr&quot; &#125;</div><div class="line"></div><div class="line">    method desc &#123;</div><div class="line">        print &amp;.name(), &quot;\n&quot;,</div><div class="line">              &amp;.age(),  &quot;\n&quot;,</div><div class="line">              &amp;.addr(), &quot;\n&quot;;</div><div class="line">    &#125;</div><div class="line">    # etc.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">grammar Identity &#123;</div><div class="line">    rule name &#123; Name &apos;=&apos; (\N+) &#125;</div><div class="line">    rule age  &#123; Age  &apos;=&apos; (\d+) &#125;</div><div class="line">    rule addr &#123; Addr &apos;=&apos; (\N+) &#125;</div><div class="line">    rule desc &#123;</div><div class="line">        &lt;name&gt; \n</div><div class="line">        &lt;age&gt;  \n</div><div class="line">        &lt;addr&gt; \n</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    # etc.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>像类那样, grammars 也能继承:<br><a href="https://github.com/perl6/roast/blob/master/S05-grammar/inheritance.t#L6-L80" target="_blank" rel="external"><code>S05-grammar/inheritance.t lines 6–80</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">grammar Letter &#123;</div><div class="line">    rule text     &#123; &lt;greet&gt; $&lt;body&gt;=&lt;line&gt;+? &lt;close&gt; &#125;</div><div class="line">    rule greet    &#123; [Hi|Hey|Yo] $&lt;to&gt;=\S+? &apos;,&apos;       &#125;</div><div class="line">    rule close    &#123; Later dude &apos;,&apos; $&lt;from&gt;=.+        &#125;</div><div class="line">    token line    &#123; \N* \n                           &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">grammar FormalLetter is Letter &#123;</div><div class="line">    rule greet &#123; Dear $&lt;to&gt;=\S+? &apos;,&apos;            &#125;</div><div class="line">    rule greet &#123; Dear $&lt;to&gt;=\S+? &apos;,&apos;            &#125;</div><div class="line">    rule close &#123; Yours sincerely &apos;,&apos; $&lt;from&gt;=.+ &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>就像类中的方法,  grammar 中 rule 定义也是继承的(并且是多态的!). 所以没有必要重新指定文本, 行等等.<br><a href="https://github.com/perl6/roast/blob/master/S05-capture/dot.t#L88-L122" target="_blank" rel="external">S05-capture/dot.t lines 88–122</a></p>
</li>
<li><p>Perl 6 会携带至少一个预定义好的 grammar:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">grammar STD &#123;    # Perl 自己的标准 grammar</div><div class="line">     rule prog &#123; &lt;statement&gt;* &#125;</div><div class="line">     rule statement &#123;</div><div class="line">              | &lt;decl&gt;</div><div class="line">              | &lt;loop&gt;</div><div class="line">              | &lt;label&gt; [&lt;cond&gt;|&lt;sideff&gt;|&apos;;&apos;]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    rule decl &#123; &lt;sub&gt; | &lt;class&gt; | &lt;use&gt; &#125;</div><div class="line">    # etc. etc. etc.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>因此:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$parsetree = STD.parse($source_code)</div></pre></td></tr></table></figure>
<ul>
<li>你可以使用 <code>:lang</code> 副词在 regex 的中间切换到不同的 grammar. 例如, 要匹配一个嵌在花括号中来自于 <code>$funnylang</code> 的表达式  <code>&lt;expr&gt;</code>, 要说:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">token funnylang &#123; &apos;&#123;&apos; [ :lang($funnylang.unbalanced(&apos;&#125;&apos;)) &lt;expr&gt; ] &apos;&#125;&apos; &#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过在 grammar 身上调用  <code>.parse</code> 或 <code>.parsefile</code> 方法, 字符串就能与 grammar 匹配, 并且可以传递一个可选的 actions 对象给 grammar:</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-grammar/action-stubs.t#L7-L36" target="_blank" rel="external">S05-grammar/action-stubs.t lines 7–36</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyGrammar.parse($string, :actions($action-object))</div><div class="line">MyGrammar.parsefile($filename, :actions($action-object))</div></pre></td></tr></table></figure>
<p>​这创建了一个  <code>Grammar</code> 对象,  它的类型指示了当前被解析的语言, 还有派生自哪个用于扩展语言的 grammars. 所有的 grammars 对象派生自 <code>Cursor</code>, 所以每个 grammar 对象的值包含了当前匹配的当前状态.  这个新的 grammar 对象然后被作为 <code>MyGrammar</code> 的<code>TOP</code> 方法(<code>regex</code>, <code>token</code>, 或 <code>rule</code> )的调用者传递. 这个调用的默认 rule 的名字可以使用 <code>parse</code> 方法的  <code>:rule</code>  具名参数进行重写.  这对于  grammar rules 的单元测试很有用.  作为参数, rules 可以拥有参数, 所以如果必要的话, <code>:args</code> 具名参数可以用于传递这样的参数作为 parcel.</p>
<p>Grammar 对象是不可变的, 所以每个匹配返回不同的匹配状态, 并且多个匹配状态可同时存在.  每个这样的匹配状态被认为是 模式怎样会最终匹配的假设. 在模式匹配中, 一个能回溯的选择能在 Perl 6中作为一个匹配状态指针的惰性列表被轻易描绘. 回溯由只抛弃列表前面的值并继续匹配下一个值组成. 因此, 这些匹配指针的管理控制着回溯是怎样工作的, 并且从惰性列表的词形变化表中自然地往下落</p>
<p><code>.parse</code> 和 <code>.parsefile</code> 方法锚定到文本的开头和结尾,  并且如果没有到达文本的结尾会失败.(<code>TOP</code> rule 能自己检查 <code>$</code>, 如果它想产生它自己的错误信息.)</p>
<p>如果你想解析一部分文本, 那么使用 <code>subparse</code> 代替. 你可能传递一个 <code>:pos</code> 参数从某个不是 0 的位置开始解析. 你可能传递一个 <code>:rule</code> 参数来指定你想调用哪个 <code>subrule</code>. 通过检查返回的 Match 对象决定最终的位置.</p>
<h1 id="Action-对象"><a href="#Action-对象" class="headerlink" title="Action 对象"></a>Action 对象</h1><p>Action 对象(由 <code>Grammar.parse</code> 中的 <code>:actions</code> 具名参数提供)的方法对应于 grammar 中的 rules. 当 grammar 中的 rule 匹配时, action 对象中与 grammar 中的同名方法( 如果有的话) 就会用于 grammar 正在构建的 Match 的 AST 中.  </p>
<p>Action 方法只有一个参数(为了方法, <code>$/</code>), 它包含了 rule 的 Match 对象. 只要对应的 rule 成功匹配, Action 方法就会被调用, 不管匹配是一个零宽匹配还是一个最终失败的回溯分支, 所以 要通过 AST 来跟踪状态, 并且副作用可能导致意想不到的行为.</p>
<p>Action 方法是在 rule 的调用帧中被调用的, rule 中的动态变量设置被传递给了 action 方法.</p>
<h1 id="句法分类"><a href="#句法分类" class="headerlink" title="句法分类"></a>句法分类</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-syntactic-categories/new-symbols.t#L7-L33" target="_blank" rel="external"><code>S05-syntactic-categories/new-symbols.t lines 7–33</code></a></p>
<p>要写你自己的反引号和断言 subrules,  你可以使用下面的句法分类来扩展(你的拷贝) Regex sublanguage:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">augment slang Regex &#123;</div><div class="line">    token backslash:sym&lt;y&gt;   &#123; ... &#125;   # 定义你自己的 \y 和 \Y</div><div class="line">    token assertion:sym&lt;&gt;    &#123; ... &#125;   # 定义你自己的 &lt;stuff&gt;</div><div class="line">    token metachar:sym&lt;,&gt;    &#123; ... &#125;   # 定义一个新的元字符</div><div class="line">    multi method tweak (:$x) &#123; ... &#125;   # 定义你自己的 :x 修饰符</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h1><p>各种编译指令能用于控制 regex 编译的各个方面和未提供的用法. 这些被捆绑到特殊声明符 ? 上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use s :foo;         # control s defaults</div><div class="line">use m :foo;         # control m defaults</div><div class="line">use rx :foo;        # control rx defaults</div><div class="line">use regex :foo;     # control regex defaults</div><div class="line">use token :foo;     # control token defaults</div><div class="line">use rule :foo;      # control rule defaults</div></pre></td></tr></table></figure>
<h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-transliteration/trans.t#L11-L270" target="_blank" rel="external"><code>S05-transliteration/trans.t lines 11–270</code></a></p>
<ul>
<li><code>tr///</code> quote-like 操作符现在有一个叫做 <code>trans()</code>的方法. 它的参数是一个 pairs 的列表. 你可以使用任何能产生 pair 列表的东西:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str.trans( %mapping.pairs );</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用 <code>.=</code> 形式做就地转换:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str.=trans( %mapping.pairs );</div></pre></td></tr></table></figure>
<p>(Perl 6 不支持 <code>y///</code> 形式, 这种形式只存在于 sed 中, 因为它们用光了单个字母.)</p>
<ul>
<li>pair 的两边可以像 <code>tr///</code> 那样解释字符串:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str.=trans( &apos;A..C&apos; =&gt; &apos;a..c&apos;, &apos;XYZ&apos; =&gt; &apos;xyz&apos; );</div></pre></td></tr></table></figure>
<p>作为一种退化了的情况, pair 的每一边都可以是单个字符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str.=trans( &apos;A&apos;=&gt;&apos;a&apos;, &apos;B&apos;=&gt;&apos;b&apos;, &apos;C&apos;=&gt;&apos;c&apos; );</div></pre></td></tr></table></figure>
<p>空白字符作为字面字符, 作为转换的来源或目标.  <code>..</code> 范围序列是在字符串中唯一能被识别的元语法, 尽管你可以理所当然的在双引号中使用反斜线插值. 如果右侧的字符太短,   最后的字符会被重复直到和左侧字符的长度相等. 如果没有最后的字符, 是因为右侧的字符是一个空字符, 代替的是, 匹配的结果被删除.</p>
<ul>
<li>pair 的一边或两边也可以是一个数组对象:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str.=trans( [&apos;A&apos;..&apos;C&apos;] =&gt; [&apos;a&apos;..&apos;c&apos;], &lt;X Y Z&gt; =&gt; &lt;x y z&gt; );</div></pre></td></tr></table></figure>
<p>数组版本是基础原始的形式: 字符串形式的语义正等价于这种形式, 首先展开 <code>..</code>, 然后再把字符串分割为单个字符, 然后将它们用作数组.</p>
<ul>
<li>数组版本的转换能将一个或多个字符映射为一个或多个字符:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$str.=trans( [&apos; &apos;,      &apos;&lt;&apos;,    &apos;&gt;&apos;,    &apos;&amp;&apos;    ] =&gt;</div><div class="line">             [&apos; &apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, &apos;&amp;&apos; ]);</div></pre></td></tr></table></figure>
<p>在多于一个输入字符序列匹配的情况下, 最长的那个匹配胜出.在两个相同序列匹配的情况下, 排在第一的那个匹配胜出。<br>与字符串形式一样, 缺失的右侧元素重复最后的那个元素,  而一个空的数组会导致删除.</p>
<ul>
<li>字符串和数组形式的识别是基础的. 要实现更强大的功能, 左侧的识别元素可以通过构建字符类, 向前查看等 regex 来指定.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$str.=trans( [/ \h /,   &apos;&lt;&apos;,    &apos;&gt;&apos;,    &apos;&amp;&apos;    ] =&gt;</div><div class="line">             [&apos; &apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, &apos;&amp;&apos; ]);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$str.=trans( / \s+ / =&gt; &apos; &apos; );      # 将所有空白挤压为单个空格</div><div class="line">$str.=trans( / &lt;-alpha&gt; / =&gt; &apos;&apos; );  # 删除所有的非字母字符</div></pre></td></tr></table></figure>
<ul>
<li>如果箭头右侧是一个闭包, 它会被计算为要替换的值. 如果箭头左侧被一个 regex 匹配, 则在闭包中可以访问到结果匹配对象.</li>
</ul>
<p><a href="https://github.com/perl6/roast/blob/master/S05-transliteration/with-closure.t#L5-L63" target="_blank" rel="external"><code>S05-transliteration/with-closure.t lines 5–63</code></a></p>
<h1 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-substitution/subst.t#L7-L211" target="_blank" rel="external"><code>S05-substitution/subst.t lines 7–211</code></a><br><a href="https://github.com/perl6/roast/blob/master/S05-substitution/match.t#L7-L33" target="_blank" rel="external"><code>S05-substitution/match.t lines 7–33</code></a></p>
<p>也有 <code>m//</code> 和 <code>s///</code>形式的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$str.match(/pat/);</div><div class="line">$str.subst(/pat/, &quot;replacement&quot;);</div><div class="line">$str.subst(/pat/, &#123;&quot;replacement&quot;&#125;);</div><div class="line">$str.=subst(/pat/, &quot;replacement&quot;);</div><div class="line">$str.=subst(/pat/, &#123;&quot;replacement&quot;&#125;);</div></pre></td></tr></table></figure>
<p><code>.match</code> 和 <code>.subst</code> 方法支持 <code>m//</code> 和 <code>s///</code> 的副词作为具名参数, 所以你可以写成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str.match(/pat/, :g)</div></pre></td></tr></table></figure>
<p>这等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str.comb(/pat/, :match)</div></pre></td></tr></table></figure>
<p>这儿没有语法糖, 所以为了获得 replacement 延时计算, 你必须把它放到一个闭包中. 只有在 quotelike 形式才提供有语法糖. 首先, 有一个标准的 “triple quote” 形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/pattern/replacement/</div></pre></td></tr></table></figure>
<p>只有非括号字符才能被用于”triple quote”中.  右侧总是被当作在双引号中求值, 不管所选的引号是什么.</p>
<p>就像 Perl 5, 也支持括号形式, 但是不像 Perl 5, Perl 6 只在模式周围使用括号. replacement 被指定为就像普通的 item 赋值一样, 使用普通的引号 rules.  要在右侧选择你自己的引号, 只使用其中的一种 q 形式就好.  上面的替换等价于:<br><a href="https://github.com/perl6/roast/blob/master/S05-substitution/subst.t#L223-L323" target="_blank" rel="external"><code>S05-substitution/subst.t lines 223–323</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s[pattern] = &quot;replacement&quot;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s[pattern] = qq[replacement]</div></pre></td></tr></table></figure>
<p>这不是普通的赋值, 因为每次替换一匹配,右侧就会被求值一次. 这因此被称为形式转换. 它会被作为一段创建了动态作用域而非词法作用域的代码被调用. (你也可以把 thunk 看作一个使用当前词法作用域的闭包).实际上, 使用下面这个也没有影响:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s[pattern] = &#123; doit &#125;</div></pre></td></tr></table></figure>
<p>因为那会把闭包替换成字符串.</p>
<p>任何标量赋值操作符都能被使用; 那个替换宏知道怎么转换<br><a href="https://github.com/perl6/roast/blob/master/S05-substitution/subst.t#L324-L480" target="_blank" rel="external"><code>S05-substitution/subst.t lines 324–480</code></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$target ~~ s:g[pattern] op= expr</div></pre></td></tr></table></figure>
<p>为如下这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$target.=subst(rx[pattern], &#123; $() op expr &#125;, :g)</div></pre></td></tr></table></figure>
<p><code>s///</code> 的实际实现必须返回一个 Match 对象以使智能匹配能正确工作.  上面的重写只返回了改变了的字符串.</p>
<p>所以, 举个例子, 你可以把每个美元符号的数量乘以 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s:g[$ &lt;( \d+ )&gt;] *= 2</div></pre></td></tr></table></figure>
<p>(当然, 优化比实际调用要快)</p>
<p>你会注意到上面一个例子, 由于匹配的结果, 替换只发生在”正式的”字符串上, 即,  <code>$/.from</code> 和 <code>$/.to</code> 位置之间的那部分字符串.( 这里我们使用   <code>&lt;(…)&gt;</code> pair  显式地设置了那些, 否则,我们可能必须使用向前查看来匹配 <code>$</code>)</p>
<p>请注意,  <code>:ii</code>/<code>:samecase</code> 和 <code>:mm</code>/<code>:samemark</code>  开关实际上是一根绳子上的两个蚂蚱, 当编译器给 quote-like 形式的开关脱去语法糖时, 它会把语义分配给模式和替换部分.  即, 作用于替换上的 <code>:ii</code>  隐含了模式上的  <code>:i</code>,    <code>:mm</code> 隐含了 <code>:m</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s:ii/foo/bar/</div><div class="line">s:mm/boo/far/</div></pre></td></tr></table></figure>
<p>不是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.subst(/foo/, &apos;bar&apos;, :ii)   # WRONG</div><div class="line">.subst(/boo/, &apos;far&apos;, :mm)   # WRONG</div></pre></td></tr></table></figure>
<p>而是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.subst(rx:i/foo/, &apos;bar&apos;, :ii)   # okay</div><div class="line">.subst(rx:m/boo/, &apos;far&apos;, :mm)   # okay</div></pre></td></tr></table></figure>
<p>它专门不要求实现把正则表达式作为关于大小写和标记的通用实现。追溯重新编译是有害的。如果一个实现确实执行懒惰的一般的大小写和标记语义，它对于依赖于它的程序来说是错误的和不可移植的。 (天了噜, 这究竟怎么翻译?!)</p>
<p><code>s///</code> 和 <code>.subst</code> 形式的不同之处在于, <code>.subst</code> 返回修改过的字符串(因此不能用作智能匹配器), <code>s///</code> 形式要么返回一个  <code>Match</code> 对象, 来标示智能匹配成功了, 要么返回一个 <code>Nil</code> 值标示没有成功.  </p>
<p>同样地, 对于 <code>m:g</code> 匹配和 <code>s:g</code> 替换, 可能会找到多个匹配. 这些结构必须在智能匹配时仍旧能继续工作然后返回一个匹配列表. 幸运的是, <code>List</code> 是一个知名的类型, 匹配器能返回这个类型来标示匹配成功或失败. 所以这些结只是返回一个成功匹配的列表, 如果没有出现匹配则它会是一个空的列表(因此匹配失败).</p>
<h1 id="位置匹配-固定宽度类型"><a href="#位置匹配-固定宽度类型" class="headerlink" title="位置匹配, 固定宽度类型"></a>位置匹配, 固定宽度类型</h1><ul>
<li>在通常情况下, 要锚定到一个特定的位置你可以使用  <code>&lt;at($pos)&gt;</code> 断言, 来说当前位置和你提供的位置对象是相同的. 你可以通过 <code>:c</code> 和 <code>:p</code> 修饰符设置当前的匹配位置.</li>
</ul>
<p>然而, 请记住在 Perl 6 中, 字符串位置通常不是整数, 而是指向字符串中特定位置的对象, 不管你使用字节或代码点还是字形来计数. 如果使用的是整数, <code>at</code> 断言就会假设你意指当前词法作用域的 Unicode 级别, 假设这个整数是以某种方式在同一个这样的词法作用域中生成的. 如果这在当前字符串允许的 Unicode 抽象级别之外,会抛出异常. 查看 <code>$02</code> 获取字符串位置的更多讨论.</p>
<ul>
<li><code>Buf</code> 类型基于固定宽度的单元格, 因此处理整数位置刚刚好, 并把它们当作数组切片. 特别地, <code>buf8</code> (也是熟知的 <code>buf</code>) 就是老式的字节字符串. 在没有显式修饰符询问数组的值将被看作某种诸如 UTF-32的特殊编码时,  匹配 <code>Buf</code> 类型被约束为 ASCII 语义.(这对于那些跟 <code>Buf</code> 同构的紧致数组也适用). <code>Buf</code> 类型中的位置总是整数, 基本数组的的每个单元格计数 1. 注意 <code>from</code> 和 <code>to</code> 位置是在元素之间的. 如果匹配一个紧致的数组 <code>@foo</code>, 最后的位置 42 标示 <code>@foo[42]</code> 是未被包含的首个元素. (<em>翻译的真辛苦, 还不知所云, 坚持把!</em>)</li>
</ul>
<h1 id="匹配非字符串"><a href="#匹配非字符串" class="headerlink" title="匹配非字符串"></a>匹配非字符串</h1><p><a href="https://github.com/perl6/roast/blob/master/S05-nonstrings/basic.t#L7-L46" target="_blank" rel="external"><code>S05-nonstrings/basic.t lines 7–46</code></a></p>
<ul>
<li>任何可以绑到字符串上的东西都可以用  regex 匹配. 这个特性对输入流特别有用:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $stream := cat $fh.lines;       # tie scalar to filehandle</div><div class="line"># and later...</div><div class="line">$stream ~~ m/pattern/;             # match from stream</div></pre></td></tr></table></figure>
<ul>
<li>任何混合了字符串或对象的非紧致数组能匹配一个 regex, 只要你使用 <code>Str</code> 接口把它们呈现为对象, 这不妨碍其它对象含有诸如 <code>Array</code> 之类的其它接口. 正常地, 你会使用 <code>cat</code> 来生成这样的对象:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@array.cat ~~ / foo &lt;,&gt; bar &lt;elem&gt;* /;</div></pre></td></tr></table></figure>
<p>那个特殊的 <code>&lt;,&gt;</code> subrule 匹配元素之间的边界.   <code>&lt;elem&gt;</code> 断言匹配任何单独的数组元素.  整个 <code>&lt;elem&gt;</code> 元素就是点元字符的等价物.</p>
<p>如果数组元素是字符串, 事实上它们被连接成单个逻辑字符串. 如果数组元素是  tokens 或 其它这样的对象, 那么对象必须为这样的 subrules 提供合适的方法来匹配. 将字符串匹配断言和未提供字符串化查看的对象进行匹配会导致断言失败. 然而, 纯对象列表可以被解析, 只要匹配(包括任何 subrules)把自身约束为这样的断言:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;.isa(Dog)&gt;</div><div class="line">&lt;.does(Bark)&gt;</div><div class="line">&lt;.can(&apos;scratch&apos;)&gt;</div></pre></td></tr></table></figure>
<p>把对象和字符混合在数组中也是可以的, 只要它们在不同的元素中. 然而你不能在字符串中嵌入对象. 当然, 任何对象都可以假装它是一个字符串元素, 所以, <code>Cat</code> 对象可以用作子字符串, 使用与主字符串中同样的约束.</p>
<p>请注意,匹配数组时,  <code>.from</code> 和 <code>.to</code> 都会返回不透明对象的警告, 在一个特殊的位置, 这个位置既反映在数组中的位置, 又在数组的字符串中的位置. 不要期望使用这样的值来做匹配,  你也不要期望能跨越元素边界来提取子字符串[猜测:难道不是吗?] :PS  简直无法翻译!</p>
<ul>
<li>要匹配数组中的每一个元素, 使用 hyper 操作符:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@array».match($regex);</div></pre></td></tr></table></figure>
<ul>
<li>要匹配数组中的任意元素, 使用普通的智能匹配就足够了:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@array ~~ $regex;</div></pre></td></tr></table></figure>
<h1 id="在什么时候是有效的"><a href="#在什么时候是有效的" class="headerlink" title="$/ 在什么时候是有效的"></a><code>$/</code> 在什么时候是有效的</h1><p>为了提供实施自由, <code>$/</code> 变量并不能保证被定义, 直到模式到达需要它的序列点.(例如, 完成了匹配, 或者调用了嵌入的闭包, 或者计算一个 Perl 表达式作为它的参数的 submatch.)  在 regex 代码里面,  <code>$/</code> 未被正式定义, 引用 <code>$0</code> 或其它变量可能被编译产生当前值, 而不用引用 <code>$/</code>.  同样地,  引用 <code>$&lt;foo&gt;</code> 并不意味着 regex 中就有 <code>$/&lt;foo&gt;</code> . 在执行匹配期间, 当前匹配状态实际上存储在词法作用域到匹配部分的 <code>$¢</code> 变量中, 但是它不保证和 <code>$/</code> 对象的表现一样, 因为 <code>$/</code> 是 <code>Match</code> 类型, 而匹配状态的类型是从 <code>Cursor</code> 派生出来的.</p>
<p>在任何情况下, 这对于用户的简单匹配都是透明的; 在 regex 代码之外(还有 regex 的闭包中) <code>$/</code> 变量保证代表那个点的匹配状态. 即,  一般的 Perl 代码总是依靠 <code>$&lt;foo&gt;</code> 表示 <code>$/&lt;foo&gt;</code>,  依靠 <code>$0</code> 表示 <code>$/[0]</code> , 不论代码是嵌入在 regex 的闭包中还是在 regex 的外面, 在整匹配之后.</p>
<h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Damian Conway &lt;damian@conway.org&gt;</div><div class="line">Allison Randal &lt;al@shadowed.net&gt;</div><div class="line">Patrick Michaud &lt;pmichaud@pobox.com&gt;</div><div class="line">Larry Wall &lt;larry@wall.org&gt;</div><div class="line">Moritz Lenz &lt;moritz@faui2k3.org&gt;</div><div class="line">Tobias Leich &lt;email@froggs.de&gt;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从正则表达式到Grammars-Part-1]]></title>
      <url>http://ohmycloud.github.io/2015/04/27/%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0Grammars-Part-1/</url>
      <content type="html"><![CDATA[<p><a href="http://theperlfisher.blogspot.jp/2016/02/from-regular-expressions-to-grammars-pt.html" target="_blank" rel="external">原文</a></p>
<p>略去啰嗦的前半部分。</p>
<h2 id="Into-the-Breach"><a href="#Into-the-Breach" class="headerlink" title="Into the Breach"></a>Into the Breach</h2><hr>
<p>假设我们 的日志文件中有一个时间戳 <strong>2016-02-06T14:36+02:00</strong>, 我们使用智能匹配:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $logfile ~~ /2016-02-06T14:36+02:00/;</div></pre></td></tr></table></figure>
<p>这会报错:</p>
<blockquote>
<p>Unrecognized regex metacharacter - (must be quoted to match literally)</p>
</blockquote>
<p>在 Perl 6 的正则表达式中任何非<strong>字母数字字符</strong>(‘a’..’z’, ‘A’..’Z’, 0..9)都必须用引号引起来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $logfile ~~ /2016 &apos;-&apos; 02 &apos;-&apos; 06T14 &apos;:&apos; 36 &apos;+&apos; 02 &apos;:&apos; 00/;</div></pre></td></tr></table></figure>
<p>现在我们得到等价的奇怪的表达式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">｢2016-01-29T13:25+01:00｣</div></pre></td></tr></table></figure>
<p>这仅仅告诉我们, <code>~~</code>智能匹配操作符匹配了一些文本, 这就是它匹配到的文本。<strong>｢｣</strong> 是日语引文标记, 故意和剩余的文本区分开来。</p>
<p>在 Perl 6 中, 默认打印出带有明确标记的匹配对象, 它准确地告诉你匹配从哪里开始, 到哪里结束。</p>
<h2 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h2><hr>
<p>我们想让该正则表达式更具普遍性, 例如匹配 2016 年的日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $logfile ~~ /2015 | 2016 &apos;-&apos; 02 &apos;-&apos; 06T14 &apos;:&apos; 36 &apos;+&apos; 02 &apos;:&apos; 00/;</div></pre></td></tr></table></figure>
<p>但是这还会匹配到我们不想要的东西, 例如  ‘/post/2015/02’ 或者甚至 ‘/number/120153’。因为 <code>|</code>的优先级没有字符间的连接优先级高。所以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $logfile ~~ / [2015 | 2016] &apos;-&apos; 02 &apos;-&apos; 06T14 &apos;:&apos; 36 &apos;+&apos; 02 &apos;:&apos; 00/;</div></pre></td></tr></table></figure>
<p>问题解决, 但是我们想匹配 ‘[ 1997 | 1998 | 1999 | 2000… 2015 ]’ 这些呢？</p>
<h3 id="Learning-Shorthnd"><a href="#Learning-Shorthnd" class="headerlink" title="Learning Shorthnd"></a>Learning Shorthnd</h3><hr>
<p>匹配4位数字的年份好了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $logfile ~~ / \d\d\d\d &apos;-&apos; 02 &apos;-&apos; 06T14.../;</div></pre></td></tr></table></figure>
<p>其它需要数字的地方也可以使用 <code>\d</code> 这种便捷形式的数字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $logfile ~~ / \d\d\d\d &apos;-&apos; \d\d - \d\d T \d\d &apos;:&apos; \d\d &apos;+&apos; \d\d &apos;:&apos; \d\d/;</div></pre></td></tr></table></figure>
<p>‘+’ <digits> : <digits> 只会匹配 +01 和 +12 之间的时区, 还有其它在 -11 到 -01 之间的时区, 所以我们使用 <code>|</code> 来匹配 ‘+’ 或 ‘-‘, 像这样:</digits></digits></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $logfile ~~ / \d\d\d\d &apos;-&apos; \d\d - \d\d T \d\d &apos;:&apos; \d\d [ &apos;+&apos; | &apos;-&apos; ] \d\d &apos;:&apos; \d\d/;</div></pre></td></tr></table></figure>
<p>基本正确了, 但是由于历史原因, 时区还能是一个字母 <code>Z</code>, 所以, 还有一处要修改:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say $logfile ~~ / \d\d\d\d &apos;-&apos; \d\d - \d\d T \d\d &apos;:&apos; \d\d [ [ &apos;+&apos; | &apos;-&apos; ] \d\d &apos;:&apos; \d\d | Z ] /;</div></pre></td></tr></table></figure>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><hr>
<p>但是那个 <strong>[ ‘+’ … Z ]</strong> 表达式太长了, 能重构就更好了。 <strong>regex</strong> 对象来拯救我们了, 它帮助我们清理代码。</p>
<p><strong>regex</strong> 对象看起来很像匹配表达式, 除了它使用花括号来告诉从哪开始, 到哪结束:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my regex Timezone &#123; Z | [&apos;+&apos; | &apos;-&apos;] \d\d &apos;:&apos; \d\d &#125;;</div><div class="line">say $logfile ~~ / \d\d\d\d &apos;-&apos; \d\d &apos;-&apos; \d\d T \d\d &apos;:&apos; \d\d &lt;Timezone&gt; /;</div></pre></td></tr></table></figure>
<p><code>&lt;..&gt;</code> 从外表上看把重构后的表达式和主文本分开了, 而让 Timezone 表达式分离意味着我们能在代码中的任何地方使用它了。事实上我们可以重构其它的正则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my regex Date &#123; \d\d\d\d &apos;-&apos; \d\d &apos;-&apos; \d\d &#125;;</div><div class="line">my regex Time &#123; \d\d &apos;:&apos; \d\d              &#125;;</div><div class="line">my regex Timezone &#123; Z | [ &apos;+&apos; | &apos;-&apos; ] \d\d &apos;:&apos; \d\d &#125;;</div><div class="line"></div><div class="line">say $logfile ~~ / &lt;Date&gt; T &lt;Time&gt; &lt;Timezone&gt; /;</div></pre></td></tr></table></figure>
<p>让所有这些 <code>\d\d</code> 坐在一块儿有些碍眼, 所以我们再重构下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my regex Integer &#123; \d+ &#125;;</div><div class="line"></div><div class="line">my regex Date     &#123; &lt;Integer&gt; &apos;-&apos; &lt;Integer&gt; &apos;-&apos; &lt;Integer&gt;     &#125;;</div><div class="line">my regex Time     &#123; &lt;Integer&gt; &apos;:&apos; &lt;Integer&gt;                   &#125;;</div><div class="line">my regex Timezone &#123; Z | [ &apos;+&apos; | &apos;-&apos; ] &lt;Integer&gt; &apos;:&apos; &lt;Integer&gt; &#125;;</div><div class="line"></div><div class="line">say $logfile ~~ / &lt;Date&gt; T &lt;Time&gt; &lt;Timezone&gt; /;</div></pre></td></tr></table></figure>
<p>下面的也没啥值得看的。(完)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Grammars-generating-grammars]]></title>
      <url>http://ohmycloud.github.io/2015/04/15/Grammars-generating-grammars/</url>
      <content type="html"><![CDATA[<p>现在你可能已经习惯了 Perl 6 中到处出现的前缀”meta”。<strong>Metaclasses</strong>, <strong>Metaobjects</strong>, <strong>Metaoperators</strong>, 还有迷一般的 Meta-Object 协议。听起来一点也不可怕, 你都见过了不是吗？今天, 在 Perl 6 Advent Calendar 上, 我们将进行完全的 <strong>meta</strong> 化(full meta)。我们将拥有能解析 grammars 的 grammars, 然后生成将用于解析 grammars 的 grammars。</p>
<p>Grammars 无疑是 Perl 6 的杀手级功能。我们拥有了正则表达式曾经没有的东西: 可读性、可组合性当然还有解析 Perl 6 自身的能力。— 如果这不能展示它的强大, 那我不知道什么能够!</p>
<p>为预定义好的 grammars(例如以 <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form" target="_blank" rel="external">Bachus-Naur</a> 形式)写解析器总是有点无趣, 几乎和复制粘贴一样。如果你曾经坐下来重头开始写一个解析器(或者期间温习一遍那本优秀的”让我们构建一个编译器”图书), 你可能会意识到模式是如此相似:从你的 grammar 中拿出单个 rule, 为它写一个子例程, 让它调用(可能是递归的)其它类似的为其它 grmmars rules 定义的子例程, 清洗, 重复。现在我们有了Perl 6 Grammars! 在这个新世界中, 我们不必为每个 token 写上子例程来完成工作了。 现在我们写 <strong>grammar</strong> 类, 里面放上 <em>tokens</em>、<em>rules</em>、<em>regexes</em> 标志。在标志里写正则表达式(或代码)并引用(可能是递归的) Perl 6 gramamr 中的其它标志。如果你曾经使用过这些东西, 你肯定会意识到 Perl 6 中的 gramamrs 是多么的方便。</p>
<p>但是假如我们已经有了一个 grammar, 例如之前提到过的 BNF? 我们所做的就是小心地把已经存在的 grammar(实际上在我们头脑中解析它)重新键入到一个新的 Perl 6  Grammar 中以代表同样的一个东西, 但是那确实有一个可作为可执行代码的优势。对大多数人来说, 那都不是事儿。我们不是普通人, 我们是程序员。我们拥有资源。它们会让这些 Grammars 变得有意义。</p>
<p>绝妙的是 Perl 6 gramamrs 和语言的其它元素没什么两样。Grammars 就像类那样也是头等公民, 可以内省, 扩展。实际上, 你可以查看编译器源代码自身, 你会注意到<strong><a href="https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Metamodel/GrammarHOW.nqp" target="_blank" rel="external">Grammars 就是一种特定种类的类</a></strong>。它们遵守和类一样的规则, 允许我们就地创建 gramamrs, 就地给 gramamrs 添加 tokens, 最终完结这个 gramamr 以拥有一个合适的能实例化的类对象。现在既然我们能解析 BNF gramamrs(因为它们就是普通的文本)并从代码中创建 Perl 6 grammars, 让我们把这些片段放在一起并写点能手动把 BNF gramamr 转化为 Perl 6 grammar 的东西。</p>
<h4 id="解析-BNF-grammar-的-grammar"><a href="#解析-BNF-grammar-的-grammar" class="headerlink" title="解析 BNF grammar 的 grammar"></a>解析 BNF grammar 的 grammar</h4><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">grammar Grammar::BNF &#123;</div><div class="line">    token TOP &#123; \s* &lt;rule&gt;+ \s* &#125;</div><div class="line"></div><div class="line">    token rule &#123;</div><div class="line">        &lt;opt-ws&gt; &apos;&lt;&apos; &lt;rule-name&gt; &apos;&gt;&apos; &lt;opt-ws&gt; &apos;::=&apos; &lt;opt-ws&gt; &lt;expression&gt; &lt;line-end&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token expression &#123;</div><div class="line">        &lt;list-of-terms&gt; +% [\s* &apos;|&apos; &lt;opt-ws&gt;]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token term &#123;</div><div class="line">        &lt;literal&gt; | &apos;&lt;&apos; &lt;rule-name&gt; &apos;&gt;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token list-of-terms &#123; &lt;term&gt; +% &lt;opt-ws&gt;                &#125;</div><div class="line">    token rule-name     &#123; &lt;-[&gt;]&gt;+                           &#125;</div><div class="line">    token opt-ws        &#123; \h*                               &#125;</div><div class="line">    token line-end      &#123; [ &lt;opt-ws&gt; \n ]+                  &#125;</div><div class="line">    token literal       &#123; &apos;&quot;&apos; &lt;-[&quot;]&gt;* &apos;&quot;&apos; | &quot;&apos;&quot; &lt;-[&apos;]&gt;* &quot;&apos;&quot; &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最上层的 3 个 tokens 发生了有意思的事情。<em>rule</em> 是 BNF grammar 的核心构造块: 一个 <code>&lt;symbol&gt; ::=  &lt;expression&gt;</code> 块儿, 后面跟着一个换行符。整个 grammar 就是一列 rules。每个表达式是一列项、或可能的和它们的备选分支。每个项要么是一个字面值, 或一个由尖括号包围的标志名。足够了! 那涵盖了解析部分。让我们看一下生成自身。我们的确有一种”为 grammar 中的每个 token 做某事”的机制, 以 <strong>Actions</strong>的形式, 让我们继续并使用它:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my class Actions &#123;</div><div class="line">    has $.name = &apos;BNFGrammar&apos;;</div><div class="line">    method TOP($/) &#123;</div><div class="line">        my $grmr := Metamodel::GrammarHOW.new_type(:$.name);</div><div class="line">        $grmr.^add_method(&apos;TOP&apos;,</div><div class="line">            EVAL &apos;token &#123; &lt;&apos; ~ $&lt;rule&gt;[0].ast.key ~ &apos;&gt; &#125;&apos;);</div><div class="line">        for $&lt;rule&gt;.map(*.ast) -&gt; $rule &#123;</div><div class="line">            $grmr.^add_method($rule.key, $rule.value);</div><div class="line">        &#125;</div><div class="line">        $grmr.^compose;</div><div class="line">        make $grmr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method expression($/) &#123;</div><div class="line">        make EVAL &apos;token &#123; &apos; ~ ~$/ ~ &apos; &#125;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method rule($/) &#123;</div><div class="line">        make ~$&lt;rule-name&gt; =&gt; $&lt;expression&gt;.ast;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>TOP</strong>方法毫无疑问是最魔幻和最恐怖的, 所以擒贼先擒王, 其它小喽啰就无关紧要了。基本上, <em>TOP</em>那儿发生了三件事:</p>
<p>1、我们创建了一个新的 grammar, 作为一个新的 Perl 6 类型</p>
<p>2、我们使用 <code>^add_method</code>方法为 grammar 添加 tokens</p>
<p>3、我们使用 <code>^compose</code>方法定型该 grammar</p>
<p>虽然 Perl 6 指定名为 <strong>TOP</strong> 的 token 是解析开始的地方, 在 BNF 中第一个 rule 总是开始点。为了彼此适应,  我们精巧地制作了一个假的 <strong>TOP</strong> token, 它正是调用了 BNF grammar 中指定的第一个 rule。不可避免地, 恐怖又令人失望的 <strong>EVAL</strong> 引起了我们的注意, 就像它说了”这儿发生了可怕的事情” 一样。它那样说并不是完全错误的, 但是因为我们没有其它程序化构建单独正则的方法, 我们不得不接受这点不适。</p>
<p><strong>TOP</strong>之后我们继续为我们的 grammar 添加 BNF rules 的剩余部分, 这一次保留它们原来的名字, 然后 <code>^compose</code>整个东西, 最后让它(make)成为解析的结果: 一个做好的解析类。</p>
<p>在 <em>expression</em> 方法中我们把解析过的 BNF 元素粘贴到一块以产生合法的 Perl 6 代码。这变得特别容易, 因为那俩个单独的标志带有空格, 使用管道符号来轮试备选分支, 并使用尖括号包围标志名。目前为止, 一个 rule 看起来像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;foo&gt; ::= &apos;bar&apos; | &lt;baz&gt;</div></pre></td></tr></table></figure>
<p>我们求值(EVAL)的 Perl 6 代码变为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">token &#123; &apos;bar&apos; | &lt;baz&gt; &#125;</div></pre></td></tr></table></figure>
<p>因为我们已经在我们代码的 grammar 部分检测我们解析的 BNF 是正确的, 没有什么能够阻止我们传递解析整个表达式字面值到我们的代码中并使用一个 <code>token  { }</code>来包裹它, 所以让我们继续。</p>
<p>最后, 对于我们解析的每一个 BNF rule, 我们产生了一个很不错的 <em>Pair</em>, 所以我们的 <strong>TOP</strong> 方法很愉快地处理它们中的每个。</p>
<p>看起来我们好像在这儿结束了, 但是仅仅是为了方便使用者, 让我们写一个更好的方法, 接收一个 BNF grammar, 并为我们生成一个准备好使用的类型对象。我们记得, grammars 就是类, 所以我们没有什么能阻止我们直接为我们的 gramamr 添加它:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">grammar Grammar::BNF &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    method generate($source, :$name = &apos;BNFGrammar&apos;) &#123;</div><div class="line">        my $actions = Actions.new(:$name);</div><div class="line">        my $ret = self.new.parse($source, :$actions).ast;</div><div class="line">        return $ret.WHAT;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这儿看起来很不错! 在你开始往你自己的项目中复制粘贴所有这些之前, 记得  <a href="https://github.com/tadzik/Grammar-BNF/" target="_blank" rel="external">Grammar::BNF</a> 是一个可在  <a href="http://modules.perl6.org/" target="_blank" rel="external">Perl 6 Module Ecosystem</a>获得的 Perl 6 模块, 使用你喜欢的模块管理器安装。</p>
<p>假设你确实花费时间查看了开头的 post, 你可能会记得我许诺过我们将有 grammars(第一条)来解析 grammars(第二条), 然后生成 grammars(第三条), 使用生成的 grammars 来解析 grammars(第四条)。目前为止， 我们已经看到过 BNF::Grammar  grammar(那是第一条), 并解析一个 BNF grammar(那是第二条), 以类对象的形式来生成 Perl 6 grammar(第三条)。 就这些。我们仍旧缺乏最后一部分, 使用整个东西来解析 grammars。 我们只完成了 75% 的 meta化, 今天足够了。为什么现在停止? 为什么不拿一个 BNF grammar , 使用 Perl 6 grammar 来解析 grammar, 使用 Perl 6 BNF grammar 的结果来解析我们原来的 BNF Grammar? 那不是很好吗？ 是的, 那很好, 我们只是留了一个练习给你。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6圣诞月历-(2012)]]></title>
      <url>http://ohmycloud.github.io/2015/04/15/Perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2012/</url>
      <content type="html"><![CDATA[<h1 id="2012"><a href="#2012" class="headerlink" title="2012"></a>2012</h1><hr>
<h2 id="一个日历"><a href="#一个日历" class="headerlink" title="一个日历"></a>一个日历</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env perl6</div><div class="line"></div><div class="line">    constant @months = &lt;January February March April May June July August September October November December&gt;;</div><div class="line">    constant @days = &lt;Su Mo Tu We Th Fr Sa&gt;;</div><div class="line"></div><div class="line">    sub center(Str $text, Int $width) &#123;</div><div class="line">        my $prefix = &apos; &apos; x ($width - $text.chars) div 2;</div><div class="line">        my $suffix = &apos; &apos; x $width - $text.chars - $prefix.chars;</div><div class="line">        return $prefix ~ $text ~ $suffix;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sub MAIN(:$year = Date.today.year, :$month = Date.today.month) &#123;</div><div class="line">        my $dt = Date.new(:year($year), :month($month), :day(1) );</div><div class="line">        my $ss = $dt.day-of-week % 7;</div><div class="line">        my @slots = &apos;&apos;.fmt(&quot;%2s&quot;) xx $ss;</div><div class="line"></div><div class="line">        my $days-in-month = $dt.days-in-month;</div><div class="line">        for $ss ..^ $ss + $days-in-month &#123;</div><div class="line">            @slots[$_] = $dt.day.fmt(&quot;%2d&quot;);</div><div class="line">            $dt++</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        my $weekdays = @days.fmt(&quot;%2s&quot;).join: &quot; &quot;;</div><div class="line">        say center(@months[$month-1] ~ &quot; &quot; ~ $year, $weekdays.chars);</div><div class="line">        say $weekdays;</div><div class="line">        for @slots.kv -&gt; $k, $v &#123;</div><div class="line">            print &quot;$v &quot;;</div><div class="line">            print &quot;\n&quot; if ($k+1) %% 7 or $v == $days-in-month;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Bags-and-Sets"><a href="#Bags-and-Sets" class="headerlink" title="Bags and Sets"></a>Bags and Sets</h2><hr>
<p>December 13, 2012<br>过去几年，我写了很多这种代码的变种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my %words;</div><div class="line">for slurp.comb(/\w+/).map(*.lc) -&gt; $word &#123;</div><div class="line">    %words&#123;$word&#125;++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(此外: slurp.comb(/\w+/).map(*.lc) 从指定的标准输入或命令行读取文件，遍历数据中的单词，然后小写化该单词。 eg ： perl6 slurp.pl score.txt)<br>Perl6引入了两种新的组合类型来实现这种功能。 在这种情况下，半路杀出个KeyBag 代替了 hash:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my %words := KeyBag.new;</div><div class="line">for slurp.comb(/\w+/).map(*.lc) -&gt; $word &#123;</div><div class="line">    %words&#123;$word&#125;++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种情况下，为什么你会喜欢 KeyBag多于 散列呢，难道是前者代码更多吗？很好，如果你想要的是一个正整数值的散列的话，KeyBag将更好地表达出你的意思。</p>
<pre><code>&gt; %words{&quot;the&quot;} = &quot;green&quot;;
</code></pre><p>未处理过的异常：不能解析数字：green<br>然而KeyBag有几条锦囊妙计。首先，四行代码初始化你的 KeyBag 不是很罗嗦，但是Perl 6能让它全部写在一行也不会有问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my %words := KeyBag.new(slurp.comb(/\w+/).map(*.lc));</div></pre></td></tr></table></figure>
<p>KeyBag.new 尽力把放到它里面的东西变成KeyBag的内容。给出一个列表，列表中的每个元素都会被添加到 KeyBag 中，结果和之前的代码块是完全一样的。<br>如果你不需要在创建bag后去修改它，你可以使用 Bag 来代替 KeyBag。不同之处是 Bag 是不会改变的；如果 %words 是一个 Bag，则 %words{$word}++ 是非法的。如果对你的程序来说，不变没有问题的话，那你可以让代码更紧凑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my %words := bag slurp.comb(/\w+/).map(*.lc);  # 散列 %words不会再变化</div></pre></td></tr></table></figure>
<p>bag 是一个有用的子例程，它只是对任何你给它的东西上调用 Bag.new 方法。（我不清楚为什么没有同样功能的 keybag 子例程）<br>Bag 和 KeyBag 有几个雕虫小技。它们都有它们自己的 .roll 和 .pick 方法，以根据给定的值来权衡它们的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; my $bag = bag &quot;red&quot; =&gt; 2, &quot;blue&quot; =&gt; 10;</div><div class="line">&gt; say $bag.roll(10);</div><div class="line">&gt; say $bag.pick(*).join(&quot; &quot;);</div><div class="line">blue blue blue blue blue blue red blue red blue</div><div class="line">blue red blue blue red blue blue blue blue blue blue blue</div><div class="line">This wouldn’t be too hard to emulate using a normal Array, but this version would be:</div><div class="line">&gt; $bag = bag &quot;red&quot; =&gt; 20000000000000000001, &quot;blue&quot; =&gt; 100000000000000000000;</div><div class="line">&gt; say $bag.roll(10);</div><div class="line">&gt; say $bag.pick(10).join(&quot; &quot;);</div><div class="line">blue blue blue blue red blue red blue blue blue</div><div class="line">blue blue blue red blue blue blue red blue blue</div><div class="line"></div><div class="line">sub MAIN($file1, $file2) &#123;</div><div class="line">    my $words1 = bag slurp($file1).comb(/\w+/).map(*.lc);</div><div class="line">    my $words2 = set slurp($file2).comb(/\w+/).map(*.lc);</div><div class="line">    my $unique = ($words1 (-) $words2);</div><div class="line">    for $unique.list.sort(&#123; -$words1&#123;$_&#125; &#125;)[^10] -&gt; $word &#123;</div><div class="line">        say &quot;$word: &#123; $words1&#123;$word&#125; &#125;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传递两个文件名，这使得 Bag 从第一个文件中获取单词，让 Set 从第二个文件中获取单词，然后使用 集合差 操作符 (-) 来计算只在第一个文件中含有的单词，按那些单词出现的频率排序，然后打印出前10 个单词。<br>这是介绍 Set 的最好时机。就像你从上面猜到的一样，Set 跟 Bag 的作用很像。不同的地方在于，它们都是散列，而 Bag 是从Any到正整数的映射，Set 是从 Any 到 Bool::True的映射。集合Set 是不可改变的，所以也有一个 可变的 KeySet .<br>在 Set 和 Bag 之间，我们有很丰富的操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">操作符	Unicode	“Texas”	结果类型</div><div class="line"></div><div class="line">属于	∈	(elem)	Bool</div><div class="line">不属于	∉	!(elem)	Bool</div><div class="line">包含	∋	(cont)	Bool</div><div class="line">不包含	∌	!(cont)	Bool</div><div class="line"></div><div class="line">并集	∪	(|)	Set 或 Bag</div><div class="line">交集	∩	(&amp;)	Set 或 Bag</div><div class="line">差集	        (-)	Set</div><div class="line"></div><div class="line">子集	⊆	(&lt;=)	Bool</div><div class="line">非子集	⊈	!(&lt;=)	Bool</div><div class="line">真子集	⊂	(&lt;)	Bool</div><div class="line">非真子集	⊄	!(&lt;)	Bool</div><div class="line"></div><div class="line">超级	⊇	(&gt;=)	Bool</div><div class="line">非超级	⊉	!(&gt;=)	Bool</div><div class="line">真超级	⊃	(&gt;)	Bool</div><div class="line">非真超级	⊅	!(&gt;)	Bool</div><div class="line"></div><div class="line">bag multiplication	⊍	(.)	Bag</div><div class="line">bag addition	⊎	(+)	Bag</div><div class="line">set symmetric difference (^)	Set</div></pre></td></tr></table></figure>
<p>它们中的大多数都能不言自明。返回Set 的操作符在做运算前会将它们的参数提升为 Set。返回Bag 的操作符在做运算前会将它们的参数提升为 Bag 。返回Set 或Bag 的操作符在做运算前会将它们的参数提升为 Bag ，如果它们中至少有一个是 Bag 或 KeyBag，否则会转换为 Set； 在任何一种情况下，它们都返回提升后的类型。<br>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; my $a = bag &lt;a a a b b c&gt;;  # bag(a(3), b(2), c)</div><div class="line">&gt; my $b = bag &lt;a b b b&gt;;      # bag(a, b(3))</div><div class="line"></div><div class="line">&gt; $a (|) $b;</div><div class="line">bag(&quot;a&quot; =&gt; 3, &quot;b&quot; =&gt; 3, &quot;c&quot; =&gt; 1)</div><div class="line"></div><div class="line">&gt; $a (&amp;) $b;</div><div class="line">bag(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)</div><div class="line"></div><div class="line">&gt; $a (+) $b;</div><div class="line">bag(&quot;a&quot; =&gt; 4, &quot;b&quot; =&gt; 5, &quot;c&quot; =&gt; 1)</div><div class="line"></div><div class="line">&gt; $a (.) $b;</div><div class="line">bag(&quot;a&quot; =&gt; 3, &quot;b&quot; =&gt; 6)</div></pre></td></tr></table></figure>
<p><a href="https://github.com/colomon/perl6-set-bag-demo" target="_blank" rel="external">下面是作者放在 github上的 Demo：</a></p>
<p>A quick example of getting the 10 most common words in Hamlet which are not found in Much Ado About Nothing:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; perl6 bin/most-common-unique.pl data/Hamlet.txt data/Much_Ado_About_Nothing.txt</div></pre></td></tr></table></figure>
<p>ham: 358<br>queen: 119<br>hamlet: 118<br>hor: 111<br>pol: 86<br>laer: 62<br>oph: 58<br>ros: 53<br>horatio: 48<br>clown: 47</p>
<h2 id="超棒的匿名函数"><a href="#超棒的匿名函数" class="headerlink" title="超棒的匿名函数"></a>超棒的匿名函数</h2><hr>
<p>Perl6 对函数有很好的支持。Perl6 令人惊叹的把函数声明包起来，让你可以用各种方法来定义一个函数又不丢失任何特性。你可以定义参数类型、可选参数、命名参数，甚至在子句里也可以。如果我不知道更好的理由的话，我可能都在怀疑这是不是在补偿 Perl5 里那个相当基本的参数处理（咳咳 ，@_，你懂的）。<br>除开这些，Perl6 也允许你定义没有命名的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub &#123;say &quot;lol, I&apos;m so anonymous!&quot; &#125;</div></pre></td></tr></table></figure>
<p>这有什么用？你不命名它，就没法调用它啊，对不？错！<br>你可以保存这个函数到一个变量里。或者从另一个函数里 return 这个函数。或者传参给下一个函数。事实上，当你不命名你的函数的时候，你随后要运行什么代码就变得非常清晰了。就像一个可执行的” todo “列表一样。</p>
<p>现在让我们说说匿名函数可以给我们做点什么。在 Perl6 里它看起来会是什么样子呢？<br>嗯，就用最著名的排序来做例子吧。你可能想象 Perl6 有一个 sort_lexicographically 函数和一个 sort_numberically 函数。不过其实没有。只有一个 sort 函数。当你需要具体用某种形式的排序时，你就可以传递一个匿名函数给 sort 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @sorted_words   = @words.sort(&#123; ~$_ &#125;);</div><div class="line">my @sorted_numbers = @numbers.sort(&#123; +$_ &#125;);</div></pre></td></tr></table></figure>
<p>（从技术上来说，这是块，不是函数。不过如果你不打算在里面使用 return 的话，差异不大。）<br>当然你可以做的比这两个排序办法多多了。你可以通过鞋子大小排序，或者最大地面速度，或者自燃可能性的降序等等。因为你可以把任何逻辑作为一个参数传递进去。面向对象的教徒们对这种模式可非常自豪，还专门命名为“依赖注入”。<br>想想看，map 、 grep 和 reduce 都很依赖这种函数传递。我们有时候把这种传递函数给函数的做法叫“高阶编程”，好像这是某些高手的特权似的。但其实这是一个非常有用而且可以普通使用的技能。<br>上面的示例都是在当前执行时就运行函数了。其实这里没什么限制。我们可以创建函数，然后稍后再运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sub make_surprise_for($name) &#123;</div><div class="line">    return sub &#123; say &quot;Sur-priiise, $name!&quot; &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $reveal_surprise = make_surprise_for(&quot;Finn&quot;);    #</div><div class="line"></div><div class="line"># 目前什么都没发生</div><div class="line"># 等着</div><div class="line"># 继续等着</div><div class="line"># 等啊等啊等啊</div><div class="line">$reveal_surprise();        # &quot;Sur-priiise, Finn!&quot;</div></pre></td></tr></table></figure>
<p><code>$reveal_surpirse</code> 里的函数记住了 <code>$name</code> 变量值，虽然原始函数是在很早之前传递进去的参数。棒极了！这个效果就叫在 <code>$name</code> 变量上闭合的匿名函数。不过这里可没什么技术 – 反正很棒就是了。<br>事实上，如果放在其他主要存储机制比如数组和散列旁边再看匿名函数本身，这感觉是很自然的事情。所有这些都可以存储在变量里，作为参数传递或者从函数里返回。一个匿名数组允许你保存序列给以后调用。一个匿名散列允许你存储映射给以后调用。一个匿名函数允许你存储计算或者行为给以后调用。<br>本月晚些时候，我会写篇介绍怎样通过 Perl6 的动态域来创建漂亮的 DSL-y 接口。我们可以看到匿名函数在那里是怎么发挥作用的。</p>
<h2 id="第九天-最长标示匹配"><a href="#第九天-最长标示匹配" class="headerlink" title="第九天:最长标示匹配"></a>第九天:最长标示匹配</h2><hr>
<p>Perl6 正则表达式偏好尽可能的匹配最长的选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;food and drink&quot; ~~ / foo | food /;   # food</div></pre></td></tr></table></figure>
<p>这跟 Perl5 不一样。Perl5 更喜欢上面例子中的第一个选择，结果匹配的是 “foo” 。<br>如果你希望的话，你依然可以按照优先匹配的原则运行，这个原则隐藏在稍长选择操作符 <code>||</code> 背后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &quot;food and drink&quot; ~~ / foo || food /;  # foo</div></pre></td></tr></table></figure>
<p>…就是这样。这就是最长标记匹配。 ☺ 短文完毕。<br>“喂，等等！”你听见你绝望而惊讶的大叫了，满足你希望让每天的 Perl6 圣临历走的慢一点的愿望。“为什么说最长标记匹配很重要？谁会在意这个？”<br>我很高兴你这样问。事实证明，最长标记匹配（简称 LTM ）在如何解析的时候和我们的直觉配合相当默契。如果你创造了一门语言，你希望人们可以声明一个叫 forest_density 的变量而不用提及这个单词和循环里用的 for 语法冲突，LTM 可以做到。<br>我喜欢“奇怪的一致性”这个说法 – 尤其当程序语言设计的共性让大家越来越雷同的时候。这里就是一种在类和语法之间的一致性。 Perl6 基本上把这种一致性发挥到了极致。让我简单的阐述下我的意思。<br>现在我们习惯于写一个类，总体来看，类差不多是长这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class &#123;</div><div class="line">    method</div><div class="line">    method</div><div class="line">    method</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>奇怪的是，语法有个非常类似的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grammar &#123;</div><div class="line">    rule</div><div class="line">    rule</div><div class="line">    rule</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（实际上关键词有 regex，token 和 rule，不过当我们把他当作一个组来讨论的时候，我们暂时统一叫做 rules）<br>我们同样习惯于派生子类（class B is A），然后添加或者重写方法来产生一个新旧行为在一起的组合。Pelr6 提供了 multi methods ，它允许你添加相同名字的新方法，而且不重写原有的，它只尝试匹配所有的到新方法而已。这个调度是由一个（通常自动生成的） proto method 处理的。它负责调度给所有合格的候选者。</p>
<p>这些是怎样用语法和角色运行起来的呢？额，首先它从原有的里面派生出新的语法，和派生子类一样。（事实上，底层是 完全 相同的机制。语法不过是有个不同元类对象的类罢了。）新的角色也会重写原有的角色，和你在方法上习惯的一样。<br>S05 有个漂亮的解析信件的示例。然后派生出来解析正式信件的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">grammar Letter &#123;</div><div class="line">    rule text     &#123;    &#125;</div><div class="line">    rule greet &#123; [Hi|Hey|Yo] $=(\S+?) , $$&#125;</div><div class="line">    rule body     &#123; +? &#125;   # note: backtracks forwards via +?</div><div class="line">    rule close &#123; Later dude, $=(.+) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">grammar FormalLetter is Letter &#123;</div><div class="line">    rule greet &#123; Dear $=(\S+?) , $$&#125;</div><div class="line">    rule close &#123; Yours sincerely, $=(.+) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>派生出来的 FormalLetter 重写了 greet 和 close，但是没重写 body。<br>但是这一切在 multi 方法下也能正常运行吗？我们是不是可以定义一种“原型角色”来允许我们在一个语法里用同样的名字有多种角色，内容各不相同？比如，我们可能希望用一个角色 term 来解析语言，不过有很多不同的 terms：字符串、数字……而且数字可能是十进制、二进制、八进制、十六进制等……</p>
<p>Perl6 语法可以包含一个原型角色，然后你可以定义、重定义同名角色随便多少次。显然让我们回到文章最开始的 / foo | food /。所有你起了相同名字的角色会编译成一个大的 alternation（译者注：轮流选择，不确定怎么翻译更好）。</p>
<p>不仅如此 – 调用其他角色的角色，有些可能是原型角色，这些也会全部扁平化到一个大的 LTM 轮流选择里。实践中，这意味着一个 term 的所有可能会一次被全部尝试一遍，机会平等。没哪个会因为自己是先定义的所以胜出，只有最长匹配的那个选择才胜出。</p>
<p>这个奇怪的一致性说明事实上，在调用某个方式的时候，最具体的方法胜出，而且这个“最具体”必须加上引号。签名里参数描述类型越好，方法就越具体。<br>在分析某个角色的时候，同样是最具体的角色胜出，不过这里“最具体”必须成功解析才行。角色描述下一步进入的文本越详细，角色就越具体。<br>这就是奇怪的一致性。因为表面上方法和角色看起来就是完全不一样的怪兽。<br>我们真心相信我们理解了派生语法的原理并且得到了一门新的语言。 LTM 就是最合适的因为它允许新旧角色通过一个公平和可预测的办法混杂在一起。角色不是因为他们定义的前后而胜出，而是因为它能最好的解析文本。这才是挑选精英的办法。</p>
<p>事实上，Perl6 编译器自己就是这样工作的。它使用 Perl6 语法解析你的程序，这个语法是可以派生的……不管你在程序里什么时候声明了一个新操作符，都会给你派生出一个新的语法。新操作符的解析就作为新角色加入到新语法里。然后把解析剩余程序的任务交给新的语法。你的新操作符会胜过那写相同但匹配更短的，不过输给相同但匹配更长的。</p>
<h2 id="开开心心玩Rakudo和Euler项目"><a href="#开开心心玩Rakudo和Euler项目" class="headerlink" title="开开心心玩Rakudo和Euler项目"></a>开开心心玩Rakudo和Euler项目</h2><hr>
<p>Perl6 实现的领先者 Rakudo ，目前还不完美，说起性能也尤其让人尴尬。然而先行者不会问“他快么？”，而会问“他够快么？”，甚至是“我怎样能帮他变得更快呢？”。<br>为了说服你Rakudo已经能做到足够快了。我们准备尝试做一组Euler项目测试。其中很多涉及强行的数值计算，Rakudo目前还不是很擅长。不过我们可没必要就此顿足：语言性能降低了，程序员就要更心灵手巧了，这正是乐趣所在啊。<br>所有的代码都是在Rakudo 2012.11上测试通过的。<br>We’ll start with something simple: 先从一些简单的例子开始：<br>问题2</p>
<p>想想斐波那契序列里数值不超过四百万的元素，计算这些值的总和。<br>办法超级简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say [+] grep * %% 2, (1, 2, *+* ...^ * &gt; 4_000_000);</div></pre></td></tr></table></figure>
<p>运行时间：0.4秒</p>
<p>注意怎样使用操作符才能让代码即紧凑又保持可读性(当然这点大家肯定意见不一)。我们用了：</p>
<ul>
<li>无论如何用 * 创建 lambda 函数</li>
<li>用序列操作符…^来建立斐波那契序列</li>
<li>用整除操作符%%来过滤元素</li>
<li>用[+]做reduce操作计算和</li>
</ul>
<p>当然，没人强制你这样疯狂的使用操作符 – 香草(vanilla)命令式的代码也没问题：<br>问题3</p>
<p>600851475143的最大素因数是多少？<br>命令式的解决方案是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sub largest-prime-factor($n is copy) &#123;</div><div class="line">    for 2, 3, *+2 ... * &#123;</div><div class="line">        while $n %% $_ &#123;</div><div class="line">            $n div= $_;</div><div class="line">            return $_ if $_ &gt; $n;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say largest-prime-factor(600_851_475_143);</div></pre></td></tr></table></figure>
<p>运行时间：2.6秒</p>
<p>注意用的<code>is copy</code>，因为 Perl6 的绑定参数默认是<code>只读</code>的。还有用了<code>整数除法div</code>，而没用数值除法的<code>/</code>。<br>到目前为止都没有什么特别的，我们继续：</p>
<p>问题53</p>
<p>n从1到100， <sup>n</sup>C<sub>r</sub>的值，不一定要求不同，有多少大于一百万的？</p>
<p>我们将使用流入操作符==&gt;来分解算法成计算的每一步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[1], -&gt; @p &#123; [0, @p Z+ @p, 0] &#125; ... * # 生成杨辉三角</div><div class="line">==&gt; (*[0..100])()                     # 生成0到100的n行</div><div class="line">==&gt; map *.list                        # 平铺成一个列表</div><div class="line">==&gt; grep * &gt; 1_000_000                # 过滤超过1000000的数</div><div class="line">==&gt; elems()                           # 计算个数</div><div class="line">==&gt; say;                              # 输出结果</div></pre></td></tr></table></figure>
<p>运行时间：5.2s</p>
<p>注意使用了Z操作符和+来压缩 0,@p 和 @p,0 的两个列表。<br>这个单行生成杨辉三角的写法是从Rosetta代码里偷过来的。那是另一个不错的项目，如果你对 Perl6 的片段练习很感兴趣的话。</p>
<p>让我们做些更巧妙的：<br>问题9</p>
<p>存在一个毕达哥拉斯三元数组让 <code>a +b + c = 1000</code> 。求a、b、c的值。</p>
<p>暴力破解可以完成 (Polettix 的解决办法)，但是这个办法不够快（在我机器上花了11秒左右）。让我们用点代数知识把问题更简单的解决。<br>先创建一个 (a, b, c) 组成的毕达哥拉斯三元数组:<br>a &lt; b &lt; c<br>a² + b² = c²<br>要求 N = a + b +c 就要符合：<br>b = N·(N - 2a) / 2·(N - a)<br>c = N·(N - 2a) / 2·(N - a) + a²/(N - a)<br>这就自动符合了 b &lt; c 的条件。<br>而 a &lt; b 的条件则产生下面这个约束：<br>a &lt; (1 - 1/√2)·N<br>我们就得到以下代码了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sub triplets(\N) &#123;</div><div class="line">    for 1..Int((1 - sqrt(0.5)) * N) -&gt; \a &#123;</div><div class="line">        my \u = N * (N - 2 * a);</div><div class="line">        my \v = 2 * (N - a);</div><div class="line"></div><div class="line">        # 检查 b = u/v 是否是整数</div><div class="line">        # 如果是，我们就找到了一个三元数组</div><div class="line">        if u %% v &#123;</div><div class="line">            my \b = u div v;</div><div class="line">            my \c = N - a - b;</div><div class="line">            take $(a, b, c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say [*] .list for gather triplets(1000);</div></pre></td></tr></table></figure>
<p>运行时间：0.5s</p>
<p>注意 sigilless (译者注：实在不知道这个怎么翻译)变量\N，\a……的声明，$(…)是怎么用来把三元数组作为单独元素返回的，用<code>$_.list</code>的缩写.list来恢复其列表性。<br>&amp;triplets 子例程作为生成器，并且使用 &amp;take 切换到结果。相应的 &amp;gather 用来划定生成器的(动态)作用域，而且它也可以放进 &amp;triplets，这个可能返回一个懒惰列表。<br>我们同样可以使用流操作符改写成数据流驱动的风格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">constant N = 1000;</div><div class="line"></div><div class="line">1..Int((1 - sqrt(0.5)) * N)</div><div class="line">==&gt; map -&gt; \a &#123; [ a, N * (N - 2 * a), 2 * (N - a) ] &#125;</div><div class="line">==&gt; grep -&gt; [ \a, \u, \v ] &#123; u %% v &#125;</div><div class="line">==&gt; map -&gt; [ \a, \u, \v ] &#123;</div><div class="line">    my \b = u div v;</div><div class="line">    my \c = N - a - b;</div><div class="line">    a * b * c</div><div class="line">&#125;</div><div class="line">==&gt; say;</div></pre></td></tr></table></figure>
<p>运行时间：0.5s</p>
<p>注意我们是怎样用解压签名绑定 -&gt; […] 来解压传递过来的数组的。<br>使用这种特殊的风格没有什么实质的好处：事实上还很容易影响到性能，我们随后会看到一个这方面的例子。<br>写纯函数式算法是个超级好的路子。不过原则上这就意味着让那些足够先进的优化器乱来（想想自动向量化和线程）。不过Rakudo还没到这个复杂地步。<br>但是如果我们没有聪明到可以找到这么牛叉的解决办法，该怎么办呢？</p>
<p>问题47</p>
<p>求第一个连续四个整数，他们有四个不同的素因数。<br>除了暴力破解，我没找到任何更好的办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">constant $N = 4;</div><div class="line"></div><div class="line">my $i = 0;</div><div class="line">for 2..* &#123;</div><div class="line">    $i = factors($_) == $N ?? $i + 1 !! 0;</div><div class="line">    if $i == $N &#123;</div><div class="line">        say $_ - $N + 1;</div><div class="line">        last;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，&amp;fators 返回素因数的个数，原始的实现差不多是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sub factors($n is copy) &#123;</div><div class="line">    my $i = 0;</div><div class="line">    for 2, 3, *+2 ...^ * &gt; $n &#123;</div><div class="line">        if $n %% $_ &#123;</div><div class="line">            ++$i;</div><div class="line">            repeat while $n %% $_ &#123;</div><div class="line">                $n div= $_</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return $i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行时间：unknown (33s for N=3)</p>
<p>注意 repeat while …{…} 的用法, 这是do {…} while(…);的新写法。<br>我们可以加上点缓存来加速程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">BEGIN my %cache = 1 =&gt; 0;</div><div class="line"></div><div class="line">multi factors($n where %cache) &#123; %cache&#123;$n&#125; &#125;</div><div class="line">multi factors($n) &#123;</div><div class="line">    for 2, 3, *+2 ...^ * &gt; sqrt($n) &#123;</div><div class="line">        if $n %% $_ &#123;</div><div class="line">            my $r = $n;</div><div class="line">            $r div= $_ while $r %% $_;</div><div class="line">            return %cache&#123;$n&#125; = 1 + factors($r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return %cache&#123;$n&#125; = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行时间：unknown (3.5s for N=3)</p>
<p>注意用 BEGIN 来初始化缓存，不管出现在源代码里哪个位置。还有用 multi 来启用对 &amp;factors 的多样调度。where 子句可以根据参数的值进行动态调度。<br>哪怕有缓存，我们依然无法在一个合理的时间内回答上来原来的问题。现在我们怎么办？只能用点骗子手段了Zavolaj – Rakudo版本的NativeCall – 来在C语言里实现因式分解.<br>事实证明这还不够好，所以我们继续重构剩下的代码，添加一些原型声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">use NativeCall;</div><div class="line"></div><div class="line">sub factors(int $n) returns int is native(&apos;./prob047-gerdr&apos;) &#123; * &#125;</div><div class="line"></div><div class="line">my int $N = 4;</div><div class="line"></div><div class="line">my int $n = 2;</div><div class="line">my int $i = 0;</div><div class="line"></div><div class="line">while $i != $N &#123;</div><div class="line">    $i = factors($n) == $N ?? $i + 1 !! 0;</div><div class="line">    $n = $n + 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say $n - $N;</div></pre></td></tr></table></figure>
<p>运行时间：1m2s (0.8s for N=3)</p>
<p>相比之下，完全使用C语言实现这个算法，运行时间在0.1秒之内。所以目前Rakudo还没法赢得任何一种速度测试。<br>重复一下，用三种办法做一件事：<br>问题29</p>
<p>在 2 ≤ a ≤ 100 和 2 ≤ b ≤ 100 的情况下由a<sup>b</sup>生成的序列里有多少不一样的元素？<br>下面是一个很漂亮但很慢的解决办法，可以用来验证其他办法是否正确：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say +(2..100 X=&gt; 2..100).classify(&#123; .key ** .value &#125;);</div></pre></td></tr></table></figure>
<p>运行时间：11s</p>
<p>注意使用 X=&gt; 来构造笛卡尔乘积。用对构造器 =&gt; 防止序列被压扁而已。<br>因为Rakudo支持大整数语义，所以在计算像100100这种大数的时候没有精密度上的损失。<br>不过我们并不真的在意幂的值，不过用基数和指数来唯一标示幂。我们需要注意基数可能自己本身就是前面某次的幂值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">constant A = 100;</div><div class="line">constant B = 100;</div><div class="line"></div><div class="line">my (%powers, %count);</div><div class="line"></div><div class="line"># 找出那些是之前基数的幂的基数</div><div class="line"># 分别存储基数和指数</div><div class="line">for 2..Int(sqrt A) -&gt; \a &#123;</div><div class="line">    next if a ~~ %powers;</div><div class="line">    %powers&#123;a, a**2, a**3 ...^ * &gt; A&#125; = a X=&gt; 1..*;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 计算重复的个数</div><div class="line">for %powers.values -&gt; \p &#123;</div><div class="line">    for 2..B -&gt; \e &#123;</div><div class="line">        # 上升到 \e 的幂</div><div class="line">        # 根据之前的基数和对应指数分类</div><div class="line">        ++%count&#123;p.key =&gt; p.value * e&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 添加 +%count 作为一个需要保存的副本</div><div class="line">say (A - 1) * (B - 1) + %count - [+] %count.values;</div></pre></td></tr></table></figure>
<p>运行时间：0.9s</p>
<p>注意用序列操作符 …^ 推断集合序列，只要提供至少三个元素，列表赋值 %powers{…} = … 就会无休止的进行下去。<br>我们再次用数据驱动的函数式的风格重写一遍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sub cross(@a, @b) &#123; @a X @b &#125;</div><div class="line">sub dups(@a) &#123; @a - @a.uniq &#125;</div><div class="line"></div><div class="line">constant A = 100;</div><div class="line">constant B = 100;</div><div class="line"></div><div class="line">2..Int(sqrt A)</div><div class="line">==&gt; map -&gt; \a &#123; (a, a**2, a**3 ...^ * &gt; A) Z=&gt; (a X 1..*).tree &#125;</div><div class="line">==&gt; reverse()</div><div class="line">==&gt; hash()</div><div class="line">==&gt; values()</div><div class="line">==&gt; cross(2..B)</div><div class="line">==&gt; map -&gt; \n, [\r, \e] &#123; (r) =&gt; e * n &#125;</div><div class="line">==&gt; dups()</div><div class="line">==&gt; ((A - 1) * (B - 1) - *)()</div><div class="line">==&gt; say();</div></pre></td></tr></table></figure>
<p>运行时间：1.5s</p>
<p>注意我们怎么用 &amp;tree 来防止压扁的。我们可以像之前那样用 X=&gt; 替代 X ，不过这会让通过 -&gt;  \n, [\r, \e] 解构变得很复杂。<br>和预想的一样，这个写法没像命令式的那样执行出来。怎么才能正常运行呢？这算是我留给读者的作业吧。<br>最后</p>
<h2 id="解析-IPv4-地址"><a href="#解析-IPv4-地址" class="headerlink" title="解析 IPv4 地址"></a>解析 IPv4 地址</h2><hr>
<p>Perl6 的正则现在是一种子语言了，很多语法没有变:<br>/\d+/<br>捕获数字：<br>/(\d+)/<br>现在 <code>$0</code> 存储着匹配到的数字，而不是 Perl 5 中的 <code>$1</code>. 所有的特殊变量 <code>$0</code>,<code>$1</code>,<code>$2</code> 在 Perl6 里就是 <code>$/[0]</code>, <code>$/[1]</code>, <code>$/[2]</code>. 在Perl 5 中，<code>$0</code> 是脚本或程序的文件名，但是这在 Perl6 中变成了 <code>$*EXECUTABLE_NAME</code> .</p>
<p>Should you be interested in getting all of the captured groups of a regex match, you can use @(), which is syntactic sugar for @($/).<br>The object in the $/ variable holds lots of useful information about the last match. For example, $/.from will give you the starting string position of the match.<br>But $0 will get us far enough for this post. We use it to extract individual features from a string.</p>
<p>修饰符现在放在前面了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$_ = &apos;1 23 456 78.9&apos;;</div><div class="line">say .Str for m:g/(\d+)/; # 1 23 456 78 9</div></pre></td></tr></table></figure>
<p>匹配所有看起来像这样的东西很有用，以至于它有一个专门的 <code>.comb</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str.comb(/\d+/);</div></pre></td></tr></table></figure>
<p>如果你对  <code>.split</code>很熟悉，你可以想到 <code>.comb</code> 就是它的表哥，它匹配  <code>.split</code>丢弃的东西 。<br>Perl 5 中匹配 IPv4地址的正则如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)/</div></pre></td></tr></table></figure>
<p>这在 Perl6中是无效的。首先，{} 块在 Perl 6 的 正则中是真正的代码块；它们包含 Perl6 代码。第二，在 Perl 6 中请使用   <code>** N..M</code> (或 <code>** N..*</code>)  代替 <code>{N,M}</code></p>
<p>在 Perl 6 中匹配1到3位数字的正则如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/\d ** 1..3/</div></pre></td></tr></table></figure>
<p>匹配 Ipv4地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/(\d**1..3) \. (\d**1..3) \. (\d**1..3) \. (\d**1..3)/</div></pre></td></tr></table></figure>
<p>那仍有点笨拙。在Perl6的正则中，你可以使用重复操作符 % ，下面是重复 (\d ** 1..3) 这个正则 4次，并使用 . 点号 作为分隔符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/ (\d ** 1..3) ** 4 % &apos;.&apos; /</div></pre></td></tr></table></figure>
<p>% 操作符是一个量词修饰符，所以它只跟在一个像 <em> 或 + 或 *</em> 的量词后面。 上面的正则意思是 匹配 4 组数字，在每组数字间插入一个直接量 点号 .<br>你也可能注意到 <code>\.</code> 变成了 <code>&#39;.&#39;</code> ,它们是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$_ = &quot;Go 127.0.0.1, I said! He went to 173.194.32.32.&quot;;</div><div class="line"></div><div class="line">say .Str for m:g/ (\d ** 1..3) ** 4 % &apos;.&apos; /;</div><div class="line"># output: 127.0.0.1 173.194.32.32</div></pre></td></tr></table></figure>
<p>或者我们可以使用 .comb:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$_ = &quot;Go 127.0.0.1, I said! He went to 173.194.32.32.&quot;;</div><div class="line">my @ip4addrs = .comb(/ (\d ** 1..3) ** 4 % &apos;.&apos; /);   # 127.0.0.1 173.194.32.32</div></pre></td></tr></table></figure>
<p>如果我们对单独的数字感兴趣：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$_ = &quot;Go 127.0.0.1, I said! He went to 173.194.32.32.&quot;;</div><div class="line">say .list&gt;&gt;.Str.perl for m:g/ (\d ** 1..3) ** 4 % &apos;.&apos; /;</div><div class="line"># output: (&quot;127&quot;, &quot;0&quot;, &quot;0&quot;, &quot;1&quot;) (&quot;173&quot;, &quot;194&quot;, &quot;32&quot;, &quot;32&quot;)</div></pre></td></tr></table></figure>
<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><hr>
<p>在很多地方，Perl6 都提供给你更合理的默认设置以便在大多数情况下让你的工作变得更简单有趣。引号也不例外。<br>基础</p>
<p>最常见的两种引号就是单引号和双引号。单引号最简单：让你引起一个字符串。唯一的“魔法”就是你可以用反斜杠转义一个单引号。而因为反斜杠的这个作用，你可以用 <code>\\</code> 来表示反斜杠本身了。不过其实这个做法也是没必要的，反斜杠自己可以直接传递。下面是一组例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; say &apos;Everybody loves Magical Trevor’;</div><div class="line">Everybody loves Magical Trevor</div><div class="line">&gt; say &apos;Oh wow, it\&apos;s backslashed!’;</div><div class="line">Oh wow, it&apos;s backslashed!</div><div class="line">&gt; say &apos;You can include a \\ like this’;</div><div class="line">You can include a \ like this</div><div class="line">&gt; say &apos;Nothing like \n is available’;</div><div class="line">Nothing like \n is available</div><div class="line">&gt; say &apos;And a \ on its own is no problem’;</div><div class="line">And a \ on its own is no problem</div></pre></td></tr></table></figure>
<p>双引号，额，从字面上看就知道了，两倍自然更强大了。:-) 它支持反斜杠转义，但更重要的是他支持<code>内插</code>。也就是说<code>变量</code>和<code>闭包</code>可以放进双引号里。大大的帮你节约使用连接操作符或者字符串格式定义等等的时间。下面是几个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; say &quot;Ooh look!\nLine breaks!&quot;</div><div class="line">Ooh look!</div><div class="line">Line breaks!</div><div class="line">&gt; my $who = &apos;Ninochka&apos;; say &quot;Hello, dear $who&quot;</div><div class="line">Hello, dear Ninochka</div><div class="line">&gt; say &quot;Hello, &#123; prompt &apos;Enter your name: &apos; &#125;!&quot;</div><div class="line">Enter your name: _Jonathan_</div><div class="line">Hello, Jonathan!</div></pre></td></tr></table></figure>
<p>(that is, an array or hash subscript, parentheses to make an invocation, or a method call) 上面第二个例子展示了标量内插，第三个则展示了闭包也可以插入双引号字符串里。闭包产生的值会被字符串化然后插入字符串中。那除了 <code>$</code> 开头的呢？ 规则是这样的：所有的都可以插入，但前提是它们被某些后置框缀(译者注：postcircumfix)(也就是带下标或者扩的数组或者哈希，可以做引用或者方法调用)允许。事实上你也可以把他们都存进标量里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; my @beer = &lt;Chimay Hobgoblin Yeti&gt;;</div><div class="line">Chimay Hobgoblin Yeti</div><div class="line">&gt; say &quot;First up, a @beer[0]&quot;</div><div class="line">First up, a Chimay</div><div class="line">&gt; say &quot;Then @beer[1,2].join(&apos; and &apos;)!&quot;</div><div class="line">Then Hobgoblin and Yeti!</div><div class="line">&gt; say &quot;Tu je &amp;prompt(&apos;Ktore pivo chces? &apos;)&quot;</div><div class="line">Ktore pivo chces? _Starobrno_</div><div class="line">Tu je Starobrno</div></pre></td></tr></table></figure>
<p>这里你看到了一个数组元素的内插，一个被调用了方法的数组切片的内插和一个函数调用的内插。后置框缀规则意味着我们再也不会砸掉你口年的邮箱地址了(译者注：邮箱地址里有@号)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; say &quot;Please spam me at blackhole@jnthn.net&quot;</div><div class="line">Please spam me at blackhole@jnthn.net</div></pre></td></tr></table></figure>
<p>选择你自己的分隔符</p>
<p>单/双引号对大多数情况下都很好用，不过如果你想在字符串里使用这些引号的时候咋办？继续用反斜杠不是什么好主意。其实你可以自定义其他字符做为引号字符。Perl6 替你选好了。q和qq引号结构后面紧跟的字符就会被作为分隔符。如果这个字符有相对应的关闭符，那么就自动查找这个（比如，如果你用了一个开启花括号{，那么字符串就会在闭合花括号}处结束。注意你还可以使用多字符开启符和闭合符（不过要求是相同字符重复组成的多字符））。另外，q的语义等同于单引号，qq的语义等同于双引号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; say q&#123;C&apos;est la vie&#125;</div><div class="line">C&apos;est la vie</div><div class="line">&gt; say q&#123;&#123;Unmatched &#125; and &#123; are &#123; OK &#125; in &#123; here&#125;&#125;</div><div class="line">Unmatched &#125; and &#123; are &#123; OK &#125; in &#123; here</div><div class="line">&gt; say qq!Lottery results: &#123;(1..49).roll(6).sort&#125;!</div><div class="line">Lottery results: 12 13 26 34 36 46</div></pre></td></tr></table></figure>
<p>定界符(Heredoc)</p>
<p>所有的引号结构都允许你包含多行内容。不过，还有更好的办法：定界文档。还是用 q 或者 qq 开始，然后跟上 :to 副词来定义我们期望在文本最后某行匹配的字符。让我们通过下面这个感人的故事看看它是怎么工作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">print q:to/THE END/</div><div class="line">    Once upon a time, there was a pub. The pub had</div><div class="line">    lots of awesome beer. One day, a Perl workshop</div><div class="line">    was held near to the pub. The hackers drank</div><div class="line">    the pub dry. The pub owner could finally afford</div><div class="line">    a vacation.</div><div class="line">    THE END</div></pre></td></tr></table></figure>
<p>脚本的输出如下：<br>Once upon a time, there was a pub. The pub had<br>lots of awesome beer. One day, a Perl workshop<br>was held near to the pub. The hackers drank<br>the pub dry. The pub owner could finally afford<br>a vacation.</p>
<p>注意输出文本并没有像源程序那样缩进。定界符会自动清楚缩进到终端的级别。如果我们用 qq ，我们也可以往定界符里插入东西。注意这些都是通过字符串的 ident 方法实现的，但是如果你的字符串里没有内插，我们会在编译期的时候调用 ident 作为一种优化手段。<br>你同样可以有多个定界符，包括调用定界符里的数据的方法也是可以的（注意下面的程序就调用了 lines 方法）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">my ($input, @searches) = q:to/INPUT/, q:to/SEARCHES/.lines;</div><div class="line">    Once upon a time, there was a pub. The pub had</div><div class="line">    lots of awesome beer. One day, a Perl workshop</div><div class="line">    was held near to the pub. The hackers drank</div><div class="line">    the pub dry. The pub owner could finally afford</div><div class="line">    a vacation.</div><div class="line">    INPUT</div><div class="line">    beer</div><div class="line">    masak</div><div class="line">    vacation</div><div class="line">    whisky</div><div class="line">    SEARCHES</div><div class="line"></div><div class="line">for @searches -&gt; $s &#123;</div><div class="line">    say $input ~~ /$s/</div><div class="line">        ?? &quot;Found $s&quot;</div><div class="line">        !! &quot;Didn&apos;t find $s&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序输出是：<br>Found beer<br>Didn’t find masak<br>Found vacation<br>Didn’t find whisky</p>
<p>自定义引号结构的引号副词</p>
<p>单/双引号的语义，也是 q 和 qq 的语义，已经可以解决绝大多数情况了。不过如果你有这么种情况：你要输出内插闭包而不是标量怎么办？这时候就要用上引号副词了。它们决定你是否开启引号特性。下面是例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; say qq:!s&quot;It costs $10 to &#123;&lt;eat nom&gt;.pick&#125; here.&quot;</div><div class="line">It costs $10 to eat here.</div></pre></td></tr></table></figure>
<p>这里我们使用了 qq 语义，但是关闭里标量内插，这意味着我们可以放心往里写价钱而不用担心他会试图解析成上一次正则匹配的第十一个捕获值。注意这里使用的标准的冒号对( colonpair )语法。如果你希望从一个最基础的引号结构开始，然后自己手动的一个个打开选项，那么你应该使用 Q 结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; say Q&#123;$*OS\n&amp;sin(3)&#125;</div><div class="line">$*OS\n&amp;sin(3)</div><div class="line">&gt; say Q:s&#123;$*OS\n&amp;sin(3)&#125;</div><div class="line">MSWin32\n&amp;sin(3)</div><div class="line">&gt; say Q:s:b&#123;$*OS\n&amp;sin(3)&#125;</div><div class="line">MSWin32</div><div class="line">&amp;sin(3)</div><div class="line">&gt; say Q:s:b:f&#123;$*OS\n&amp;sin(3)&#125;</div><div class="line">MSWin32</div><div class="line">0.141120008059867</div></pre></td></tr></table></figure>
<p>这里我们用了无特性引号结构，然后打开附加特性，地一个是标量内插，然后是反斜杠转义，然后函数内插。注意我们同样可以选择自己希望的任何分隔符。<br>引号结构是一门语言</p>
<p>最后，值得一提的是：当解析器进入引号结构的时候，其实他是切换成解析另外一个语言了。当我们用副词构建引号结构的时候，他只不过是把这些额外的角色混合进基础的引号语言里来开启额外的特性。好奇的童鞋可以看这里： Rakudo 怎么做到的。而当我们碰到闭包或者其他内插的时候，解析器再临时切换回主语言。所以你可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; say &quot;Hello, &#123; prompt &quot;Enter your name: &quot; &#125;!&quot;</div><div class="line">Enter your name: Jonathan</div><div class="line">Hello, Jonathan!</div></pre></td></tr></table></figure>
<p>解析器不会困惑于内插的闭包里又带有其他双引号字符串的问题。因为我们解析主语言，然后切换到引号语言，然后返回主语言，然后重新再返回引号语言来解析这个程序里的字符串里的闭包里的字符串。这就是 Perl6 解析器送给我们的圣诞节礼物，俄罗斯套娃娃。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Capture]]></title>
      <url>http://ohmycloud.github.io/2015/04/01/Capture/</url>
      <content type="html"><![CDATA[<p><a href="http://doc.perl6.org/type/Capture" target="_blank" rel="external">Capture</a> 的定义:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Capture does Positional does Associative &#123; &#125;</div></pre></td></tr></table></figure>
<p>Capture 是一个用于给 code 对象传递参数的容器。Captures 是签名的另一面 — Captures 在调用方定义实参, 而签名(Signatures) 在被调用方定义形式参数。</p>
<p>当你调用 <code>print $a, $b</code> 时, <code>$a, $b</code> 这部分就是一个 Capture。<code>$a, $b</code> 在这儿是实参。</p>
<p>Captures 包含一个 list-like 部分的位置参数和一个 hash-like 部分的具名参数。对于具名参数, Captures 使用一种略微不同的语法而不是普通的 List。有两种简单的方法生成一个具名参数：</p>
<ul>
<li>使用一个未引起的键命名一个形参, 后面跟着 <code>=&gt;</code>, 然后跟着参数</li>
<li>使用以形参命名的冒号对儿字面量</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">say</span> unique <span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">as =&gt;</span> &#123; <span class="keyword">abs</span> $_ &#125;; <span class="comment"># 1, -2, 3</span></div><div class="line"><span class="comment"># ... is the same thing as:</span></div><div class="line"><span class="keyword">say</span> unique <span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, :as(&#123; <span class="keyword">abs</span> $_ &#125;);  <span class="comment"># 1, -2, 3</span></div><div class="line"><span class="comment"># Be careful not to quote the name of a named parameter:</span></div><div class="line"><span class="keyword">say</span> unique <span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'as'</span> =&gt; &#123; <span class="keyword">abs</span> $_ &#125;; <span class="comment"># 1, -2, 2, 3, "as" =&gt; &#123; ... &#125;</span></div></pre></td></tr></table></figure>
<p>单个独立的 Capture 也能被生成, 存储, 然后供之后使用。 在项(term)那儿前置一个反斜线 <code>\</code> 能生成一个字面的 Capture。通常, 这个 term 会是一个 terms 的列表, 在这个列表里面, 任何 Pair 字面值会被放在 Capture 的具名部分, 而其它 terms 会被放在Capture 的位置(positional) 部分。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $c = \(<span class="number">42</span>);               <span class="comment"># 带有一个 positional 部分的 Capture        </span></div><div class="line">$c = \(<span class="number">1</span>, <span class="number">2</span>, <span class="string">a =&gt;</span> <span class="string">'b'</span>);      <span class="comment"># 带有两个 positional 部分和一个具名部分的 Capture</span></div></pre></td></tr></table></figure>
<p>要使用这样的 Capture, 在函数调用里你可以在这个 Capture 前面使用 <code>|</code> , 那么它看起来会像这个 Capture 中的所有值都被作为实参直接传递这个函数了 — 具名参数作为具名参数传递, 而位置参数会作为位置参数传递。 只要你愿意, 你可以重用这个 Capture 任意次, 甚至使用不同的函数。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $c = \(<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line"><span class="keyword">reverse</span>(|$c).say; <span class="comment"># 3 2 4</span></div><div class="line"><span class="keyword">sort</span>(<span class="number">5</span>,|$c).say;  <span class="comment"># 2 3 4 5</span></div></pre></td></tr></table></figure>
<p>在签名( Signature) 里面, 可以在不含符号的形参那儿前置一个竖线 <code>|</code> 来创建一个 Capture。这会把余下的参数列表打包到那个形参中：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">f</span>($<span class="title">a</span>, |<span class="title">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">say</span> c; </div><div class="line">&#125;</div><div class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">a =&gt;</span> <span class="number">4</span>, <span class="string">b =&gt;</span> <span class="number">5</span>); <span class="comment"># c  is  \(2, 3, a =&gt; 4, b =&gt; 5)</span></div></pre></td></tr></table></figure>
<p>请注意，Capture 仍然是列表，因为它们可能包含容器，而不只是值:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">my</span> $b = <span class="number">1</span>;</div><div class="line"><span class="keyword">my</span> $c = \(<span class="number">4</span>,<span class="number">2</span>,$b,<span class="number">3</span>);</div><div class="line"><span class="keyword">sort</span>(|$c).say;        <span class="comment"># 1 2 3 4</span></div><div class="line">$b = <span class="number">6</span>;</div><div class="line"><span class="keyword">sort</span>(|$c).say;        <span class="comment"># 2 3 4 6</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sneaking-into-a-loop]]></title>
      <url>http://ohmycloud.github.io/2015/03/23/Sneaking-into-a-loop/</url>
      <content type="html"><![CDATA[<h2 id="Sneaking-into-a-loop"><a href="#Sneaking-into-a-loop" class="headerlink" title="Sneaking into a loop"></a>Sneaking into a loop</h2><p>[Sneaking into a loop]<a href="https://gfldex.wordpress.com/2016/08/10/sneaking-into-a-loop/" target="_blank" rel="external">https://gfldex.wordpress.com/2016/08/10/sneaking-into-a-loop/</a></p>
<p>Zoffix 回答了一个关于 Perl 5s &lt;&gt; 操作符的<a href="http://irclog.perlgeek.de/perl6/2016-08-09#i_12993090" target="_blank" rel="external">问题</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slurp.words.Bag.sort(-*.value).fmt(&quot;%10s3d\n&quot;).say;</div></pre></td></tr></table></figure>
<p><code>slurp</code> 会从 STDIN 中读取整个 “file” 并返回一个 Str。方法 <code>Str::words</code> 会按照某种 Unicode 意义的单词把该字符串分割成一个列表。把列表强转为 Bag 则创建一个计数 Hash, 它是如下表述的快捷方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %h;</div><div class="line">%h&#123;$_&#125;++ for &lt;peter paul marry&gt;;</div><div class="line">dd %h;</div><div class="line"></div><div class="line"># # OUTPUT«Hash %h = &#123;:marry(1), :paul(1), :peter(1)&#125;␤»</div></pre></td></tr></table></figure>
<p>在关联数组上调用 <code>.sort(-*.value)</code> 会按照值的降序排序并返回一个排序后的 Pairs 列表。List::fmt 会调用 Pair::fmt, 它调用 fmt 方法, .key 作为其第二个参数, .value 也作为参数。say 会会使用一个空格连接各个元素并输出到标准输出。最后一步有一点错误因为除了第一行之外的每一行前面都会有一个额外的空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slurp.words.Bag.sort(-*.value).fmt(&quot;%10s =&gt; %3d&quot;).join(&quot;\n&quot;).say;</div></pre></td></tr></table></figure>
<p>手动连接字符串更好。这对于简短的单行程序来说有点多了。我们需要找到最长的单词并使用 <code>.chars</code> 来获取列宽。</p>
<p>slurp 会在 <code>$*IN</code> 身上调用 <code>.slurp-rest</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$*IN = &lt;peter paul marry peter paul paul&gt; but role &#123; method slurp-rest &#123; self.Str &#125; &#125;;</div></pre></td></tr></table></figure>
<p>这是一种 hack 因为它会在任何形式的类型检测上失败并且它除了 slurp 之外不会对任何东西起作用。还有, 实际上我们从 <code>$*IN</code> 那里解绑 STDIN。不要在工作中使用这个奇淫技巧。</p>
<p>现在我们能开心地吞噬并开始计数了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my %counted-words = slurp.words.Bag;</div><div class="line">my $word-width = [max] %counted-words.keys».chars;</div></pre></td></tr></table></figure>
<p>并且继续在链子断开的地方继续。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%counted-words.sort(-*.value).fmt(&quot;%&#123;$word-width&#125;s3d&quot;).join(&quot;\n&quot;).say;</div></pre></td></tr></table></figure>
<p>问题解决了但是很丑陋。我们把一个单行程序拆开了。我们来修复 fmt 以使它再次完整。</p>
<p>我们想要的是一个 fmt 方法, 它接收一个位置的(Positional), 一个 printf 风格的格式字符串和一个格式字符串中的 block per <code>%*</code>。还有, 我们可能需要在 self.fmt 前面放上一个分隔符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my multi method fmt(Positional:D: $fmt-str, *@width where *.all ~~ Callable, :$separator = &quot; &quot;)&#123;</div><div class="line">    self.fmt(</div><div class="line">        $fmt-str.subst(:g, &quot;%*&quot;, &#123;</div><div class="line">            my &amp;width = @width[$++] // Failure.new(&quot;missingh block&quot;);</div><div class="line">            &apos;%&apos; ~ (&amp;width.count == 2 ?? width(self, $_) !! width(self))</div><div class="line">        &#125;), $separator);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>表达式 <code>*.all ~~ Callable</code> 检查 <a href="https://docs.perl6.org/type/Signature#Slurpy_(A.K.A._Variadic" target="_blank" rel="external">slurp array</a>_Parameters)中的所有元素是否实现了 CALL-ME(那是实际被执行的方法在你执行 foo()的时候)。</p>
<p>然后我们在格式字符串上使用了 <code>subst</code> 来替换 <code>%*</code>, 替换是一个(闭包)块儿, 它每次匹配被调用一次。而且这儿我们有不错的惯用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say &quot;1-a 2-b 3-c&quot;.subst(:g, /\d/, &#123;&lt;one two three&gt;[$++]&#125;);</div><div class="line"># one-a two-b three-c</div></pre></td></tr></table></figure>
<p>匿名状态变量 <code>$</code> 从 0  开始计数, 每次代码块执行时增 1。实际上我们在这儿做的就是移除一个循环并给 subst 偷偷加入一个额外的计数器和数组下标。或者可以说我们注册了一个迭代器到 subst 里面的循环中。有人可能会质疑 subst 应该接收一个 Seq 作为它的第二个位置参数, 它会让调用变得冗长。无论如何, 我们把洞补上了。</p>
<p>在第 11 行, 我们从吞噬数组中拿出一个元素或者在没有元素时创建一个 Failure。我们把 block 存储在一个变量中因为我们想在第 12 行中内省。如果那个 block 接收两个位置参数,we feed the topic subst is calling the block with as a 2nd parameter to our stored block. 那碰巧是一个 Match 并且对于影响所匹配的东西可能有用。在我们这个例子中我们对 <code>%*</code> 进行匹配并且当前位置由 <code>$++</code> 计数。做完那个之后我们得到了一个格式字符串, 它带有一个由用户提供的 fmt 版本的列宽参数。</p>
<p>用户提供的块儿使用一组 Pairs 调用。我们不得不深入一层以得到更大的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;[max] .values».keys».chars&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">得到第一列的列宽。</div><div class="line"></div><div class="line"></div><div class="line">```perl6</div><div class="line">print %counted-words.sort(-*.value).&amp;fmt(&quot;%*s3d&quot;, &#123;[max] .values».keys».chars&#125;, separator =&gt; &quot;\n&quot;);</div></pre></td></tr></table></figure>
<p>那个时髦的 <code>.&amp;fmt</code> 调用是必须的因为我们免费的浮点方法不是 List 的方法。</p>
<p>– 翻译的好烂。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的模块]]></title>
      <url>http://ohmycloud.github.io/2015/03/23/Perl6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h1 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h1><hr>
<h2 id="Exporting-and-Selective-Importing"><a href="#Exporting-and-Selective-Importing" class="headerlink" title="Exporting and Selective Importing"></a>Exporting and Selective Importing</h2><hr>
<h3 id="is-export"><a href="#is-export" class="headerlink" title="is export"></a>is export</h3><hr>
<p>packages(包), subroutines(子例程), variables(变量), constants(常量) 和 enums(枚举) , 通过在它们的名字后面添加 <code>is export</code> 特性来导出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">unit module MyModule;</div><div class="line">our $var is export = 3;</div><div class="line">sub foo is export &#123; ... &#125;;</div><div class="line">constant $FOO is export = &quot;foobar&quot;;</div><div class="line">enum FooBar is export &lt;one two three&gt;;</div><div class="line"></div><div class="line"># Packages like classes can be exported too</div><div class="line">class MyClass is export &#123;&#125;;</div><div class="line"></div><div class="line"># If a subpackage is in the namespace of the current package</div><div class="line"># it doesn&apos;t need to be explicitly exported</div><div class="line">class MyModule::MyClass &#123;&#125;;</div></pre></td></tr></table></figure>
<p>就像所有的 traits 一样, 如果应用到子例程(routine)上, “is export” 应该出现在参数列表的后面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub foo (Str $string) is export &#123;...&#125;</div></pre></td></tr></table></figure>
<p>你可以给 <code>is export</code> 传递命名参数以组织要导出的符号, 然后导入程序 (importer) 可以剔除和选择导入哪一个。有 3 个预先定义好的标签： <code>ALL</code>, <code>DEFAULT</code>, <code>MANDATORY</code>（强制的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># lib/MyModule.pm</div><div class="line">unit module MyModule;</div><div class="line">sub bag        is export              &#123; ... &#125;</div><div class="line">sub pants      is export(:MANDATORY)  &#123; ... &#125;</div><div class="line">sub sunglasses is export(:day)        &#123; ... &#125;</div><div class="line">sub torch      is export(:night)      &#123; ... &#125;</div><div class="line">sub underpants is export(:ALL)        &#123; ... &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># main.pl</div><div class="line">use lib &apos;lib&apos;;</div><div class="line">use MyModule;           #bag, pants</div><div class="line">use MyModule :DEFAULT;  #the same</div><div class="line">use MyModule :day;      #pants, sunglasses</div><div class="line">use MyModule :night;    #pants, torch</div><div class="line">use MyModule :ALL;      #bag, pants, sunglasses, torch, underpants</div></pre></td></tr></table></figure>
<h3 id="UNIT-EXPORT"><a href="#UNIT-EXPORT" class="headerlink" title="UNIT::EXPORT::*"></a>UNIT::EXPORT::*</h3><hr>
<p>表象之下, 其实 <code>is export</code> 是把符号添加到 <code>EXPORT</code> 命名空间中的 <code>UNIT</code> 作用域包中。例如, <code>is export(:FOO)</code> 会把目标添加到 <code>UNIT::EXPORT::FOO</code> 包中。这正是 Perl 6 决定导入什么所做的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">unit module MyModule;</div><div class="line"></div><div class="line">sub foo is export         &#123; ... &#125;</div><div class="line">sub bar is export(:other) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">unit module MyModule;</div><div class="line"></div><div class="line">my package EXPORT::DEFAULT &#123;</div><div class="line">  our sub foo &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my package EXPORT::other &#123;</div><div class="line">  our sub bar &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多数时候, <code>is export</code> 足够用了, 但是当你想动态生成要导出的符号时, <code>EXPORT</code> 包就很有用了。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># lib/MyModule.pm</div><div class="line">unit module MuModule;</div><div class="line"></div><div class="line">my package EXPORT::DEFAULT &#123;</div><div class="line">  for &lt;zero one two three four&gt;.kv -&gt; $number, $name &#123;</div><div class="line">      for &lt;sqrt log&gt; -&gt; $func &#123;</div><div class="line">          OUR::&#123;&apos;&amp;&apos; ~ $func ~ &apos;-of-&apos; ~ $name &#125; := sub &#123; $number.&quot;$func()&quot; &#125;;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># main.pl</div><div class="line">use MyModule;</div><div class="line">say sqrt-of-four; #-&gt; 2</div><div class="line">say log-of-zero;  #-&gt; -Inf</div></pre></td></tr></table></figure>
<h3 id="EXPORT"><a href="#EXPORT" class="headerlink" title="EXPORT"></a>EXPORT</h3><hr>
<p>你可以用一个 <code>EXPORT</code> 子例程导出任意符号。 <code>EXPORT</code> 必须返回一个 <code>Map</code>, 在 map 里面键是符号名, 键值是想要的值。符号名应该包含(如果有的话)关联类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class MyModule::Class &#123; ... &#125;</div><div class="line"></div><div class="line">sub EXPORT &#123;</div><div class="line">  &#123;</div><div class="line">      &apos;$var&apos;      =&gt; &apos;one&apos;,</div><div class="line">      &apos;@array&apos;    =&gt; &lt;one two three&gt;,</div><div class="line">      &apos;%hash&apos;     =&gt; &#123; one =&gt; &apos;two&apos;, three =&gt; &apos;four&apos;&#125;,</div><div class="line">      &apos;&amp;doit&apos;     =&gt; sub &#123; ... &#125;,</div><div class="line">      &apos;ShortName&apos; =&gt; MyModule::class</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># main.pl</div><div class="line">use lib &apos;lib&apos;;</div><div class="line">use MyModule;</div><div class="line">say $var;</div><div class="line">say @array;</div><div class="line">say %hash;</div><div class="line">doit();</div><div class="line">say ShortName.new;  #-&gt; MyModule::Class.new</div></pre></td></tr></table></figure>
<p>注意, <code>EXPORT</code> 不能声明在包内, 因为目前的 rakudo(2015.09) 好像把 EXPORT 当作 compunit 的一部分而非包的一部分。</p>
<p>虽然 <code>UNIT::EXPORT</code> 包处理传递给 <code>use</code> 的命名参数, 而 <code>EXPORT</code> sub 处理位置参数。如果你把位置参数传递给 <code>use</code>, 那么这些参数会被传递给 <code>EXPORT</code>. 如果传递了位置参数, 那么 module 就不再需要导出默认符号了。你仍然可以伴随着你的位置参数, 通过显式地给 use 传递 <code>:DEFAULT</code> 参数来导入它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># lib/MyModule</div><div class="line"></div><div class="line">class MyModule::Class &#123;&#125;</div><div class="line"></div><div class="line">sub EXPORT($short_name?) &#123;</div><div class="line">    &#123;</div><div class="line">      do $short_name =&gt; MyModule::Class if $short_name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub always is export(:MANDATORY) &#123; say &quot;works&quot; &#125;</div><div class="line"></div><div class="line">#import with :ALL or :DEFAULT to get</div><div class="line">sub shy is export &#123; say &quot;you found me!&quot; &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># main.pl</div><div class="line">use lib &apos;lib&apos;;</div><div class="line">use MyModule &apos;foo&apos;;</div><div class="line">say foo.new(); #MyModule::Class.new</div><div class="line">always();      #OK   - is imported</div><div class="line">shy();         #FAIL - won&apos;t be imported</div></pre></td></tr></table></figure>
<h2 id="发布模块"><a href="#发布模块" class="headerlink" title="发布模块"></a>发布模块</h2><hr>
<p>如果你已经写了一个 Perl 6模块, 你想把它分享到社区, 我们会很高兴地把它放到 Perl 6 模块文件夹清单中。<a href="http://modules.perl6.org/" target="_blank" rel="external">Perl 6 modules directory</a></p>
<p>现在, 你需要使用 git 对你的模块进行版本控制。</p>
<p>这需要你有一个 Github 帐号, 以使你的模块能被从它的 Github 仓库中分享出去。</p>
<p>要分享你的模块, 按照下面说的做：</p>
<ul>
<li><p>创建一个以你的模块命名的工程文件夹。 例如, 如果你的模块是 <code>Vortex::TotalPerspective</code> , 那么就创建一个叫做 <code>Vortex::TotalPerspective</code> 的工程文件夹。这个工程目录的名字也会被用作 Github 仓库的名字。</p>
</li>
<li><p>让你的工程目录看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Vortex-TotalPerspective/</div><div class="line">|-- lib</div><div class="line">|   `-- Vortex</div><div class="line">|       `-- TotalPerspective.pm</div><div class="line">|-- LICENSE</div><div class="line">|-- META.info</div><div class="line">|-- README.md</div><div class="line">`-- t</div><div class="line">    `-- basic.t</div></pre></td></tr></table></figure>
<p>如果你的工程包含能帮助主模块完成工作的其它模块, 它们应该被放到你的 lib 目录中像这样组织：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">lib</div><div class="line">`-- Vortex</div><div class="line">    |-- TotalPerspective.pm</div><div class="line">    `-- TotalPerspective</div><div class="line">        |-- FairyCake.pm</div><div class="line">        `-- Gargravarr.pm</div></pre></td></tr></table></figure>
<ul>
<li><p><code>README.md</code> 文件是一个 markdown 格式的文件, 它稍后会被 Github 自动渲染成 HTML</p>
</li>
<li><p>关于 LICENSE 文件, 如果你没有其它选择, 就是用和 Rakudo Perl 6 一样的 LICENSE 把。仅仅把它的原始 <a href="https://github.com/rakudo/rakudo/blob/nom/LICENSE" target="_blank" rel="external">license</a> 复制/粘贴进你自己的 LICENSE 文件中。</p>
</li>
<li><p>如果你还没有任何测试, 现在你可以忽略 <code>t</code> 目录 和 <code>basic.t</code> 文件。关于如何写测试, 你可以看看其它模块是怎么使用 <code>Test</code> 的。它和 Perl’5 的 <code>Test::More</code> 很类似。</p>
</li>
<li><p>如果要文档化你的模块, 在你的模块中使用 <a href="http://design.perl6.org/S26.html" target="_blank" rel="external">Perl 6 Pod</a> 标记。欢迎给模块写文档, 并且为了浏览的方便, 一旦 Perl 6 module directory(或其它网站) 开始把 Pod 文档渲染成 HTML, 写文档尤为重要。</p>
</li>
<li><p>让你的 <code>META.info</code> 文件看起来像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">       &quot;name&quot;        : &quot;Vortex::TotalPerspective&quot;,</div><div class="line">       &quot;version&quot;     : &quot;0.1.0&quot;,</div><div class="line">       &quot;description&quot; : &quot;Wonderful simulation to get some perspective.&quot;,</div><div class="line">       &quot;author&quot;      : &quot;Your Name&quot;,</div><div class="line">       &quot;provides&quot;    : &#123;</div><div class="line">           &quot;Vortex::TotalPerspective&quot; : &quot;lib/Vortex/TotalPerspective.pm&quot;</div><div class="line">       &#125;,</div><div class="line">       &quot;depends&quot;     : [ ],</div><div class="line">       &quot;source-url&quot;  : &quot;git://github.com/you/Vortex-TotalPerspective.git&quot;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>关于选择版本号的方案, 或许使用 “major.minor.patch” （查看  the spec on versioning 获取详细信息 ）。如果版本号现在对你或你的用户来说不重要, 你可以给版本那儿放上一颗星(*)。</p>
<p>在 <code>provides</code> 一节, 包含进你的发布中提供的所有命名空间。</p>
<ul>
<li>把你的工程放在 git 版本控制之下, 如果你还未这样做。</li>
<li>一旦你对你的工程满意了, 在 Github 上为它创建一个仓库。必要的话,  查看 <a href="https://help.github.com/" target="_blank" rel="external">Github’s help docs</a>。 你的 Github 仓库的名字应该和你工程目录的名字一样。创建完 Githhub 仓库后, Github 会为你展示怎么配置你的本地仓库以获悉你的 Github 仓库。</li>
<li>把你的工程推送到 Github</li>
<li>在 IRC 频道找个人帮你展示怎么把你的模块添加到<a href="https://github.com/perl6/ecosystem" target="_blank" rel="external">ecosystem</a>, 或者让他们是否能替你添加。</li>
<li>pull 请求被接收之后, 等个把小时。如果你的模块没有出现在  <a href="http://modules.perl6.org/" target="_blank" rel="external">http://modules.perl6.org/</a> , 请到 <a href="http://modules.perl6.org/log/update.log" target="_blank" rel="external">http://modules.perl6.org/log/update.log</a> 翻看log 日志文件, 以查找是否有错误。</li>
</ul>
</li>
</ul>
<p>就是这样啦！ 感谢为 Perl 6 社区做贡献！</p>
<p>如果你想尝试安装你的模块, 使用熊猫 panda 安装工具, 这已经包含在 Rakudo Perl 6 中了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">panda install Vortex::TotalPerspective</div></pre></td></tr></table></figure>
<p>这会下载你的模块到它自己的工作目录(~/.panda), 在那儿创建 build, 并把模块安装到 <code>~/.perl6</code></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-的薛定谔的猫---Junctions]]></title>
      <url>http://ohmycloud.github.io/2015/03/22/Perl-6-%E7%9A%84%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E7%8C%AB-Junctions/</url>
      <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Erwin_Schr%C3%B6dinger" target="_blank" rel="external">薛定谔欧文</a>应该是喜欢 Perl 6 的, 因为他的著名的<a href="https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat" target="_blank" rel="external">薛定谔的猫</a>可以用 Perl 6 的 <a href="https://docs.perl6.org/type/Junction" target="_blank" rel="external">Junction</a>表达:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $cat = &apos;dead&apos; | &apos;alive&apos;;</div><div class="line">say &quot;cat is both dead and alive&quot; if $cat eq &apos;dead&apos; and $cat eq &apos;alive&apos;;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># cat is both dead and alive</div></pre></td></tr></table></figure>
<p>这里面发生了什么事情? 我会告诉你全部的!</p>
<h2 id="Anyone-游戏"><a href="#Anyone-游戏" class="headerlink" title="Anyone 游戏?"></a>Anyone 游戏?</h2><p>拿最简单的来说, Junctions 允许你把一堆值当作单个值。例如, 你可以使用 <code>any</code> Junction 来测试一个变量是否等于所给定值中的任意一个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">say &apos;it matches!&apos; if &apos;foo&apos; eq &apos;foo&apos; | &apos;bar&apos; | &apos;ber&apos;;</div><div class="line">say &apos;single-digit prime&apos; if 5 == any ^9.grep: *.is-prime;</div><div class="line"></div><div class="line">my @values = ^100;</div><div class="line">say &quot;it&apos;s in there!&quot; if 42 == @values.any;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># it matches!</div><div class="line"># single-digit prime</div><div class="line"># it&apos;s in there!</div></pre></td></tr></table></figure>
<p>要从一堆值中创建一个 <code>any</code> Junction, 你可以使用 <code>|</code> 中缀操作符、调用 <code>any</code> 函数或者使用 <code>.any</code> 方法。上面的条件会返回 True 如果 Junction 中的任意一个(<code>any</code>) 值匹配所给定的值的话。事实上, 没有人能阻止你在两端都使用 Junction:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my @one = 1..10;</div><div class="line">my @two = 5..15;</div><div class="line">say &quot;There&apos;s overlap!&quot; if @one.any == @two.any;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># there&apos;s overlap!</div></pre></td></tr></table></figure>
<p>运算符会返回 True 如果 <code>@one</code> 中的任意一个值(<code>any</code>) 在数值上等于 <code>@two</code> 中的任意一个值(<code>any</code>)的话。这个语法糖很甜, 但是我们还可以做的更多。</p>
<h2 id="All-for-One-and-Any-for-None"><a href="#All-for-One-and-Any-for-None" class="headerlink" title="All for One and Any for None"></a>All for One and Any for None</h2><p><code>any</code> Junction 唯一一个你能获得的 Junction。你还可以选择 <code>all</code>、<code>any</code>、<code>one</code> 和 <code>none</code>。当在布尔上下文中时, 它们的意思就像下面这样; 构建 Junction 的函数/方法名和 Junction 自身的名字一样并且下面还列出了构建 Junction 的中缀操作符:</p>
<ul>
<li><code>all</code> — 所有的值都被计算为 True(使用中缀 <code>&amp;</code>)</li>
<li><code>any</code> — 至少其中的一个值被计算为 True(使用中缀 <code>|</code>)</li>
<li><code>one</code> — 正好其中有一个值被计算为 True(使用中缀 <code>^</code>)</li>
<li><code>none</code> — 没有一个值被计算为 True(没有可用的中缀)</li>
</ul>
<p>使用 <code>all</code> JUnction 时要特别注意:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my @values = 2, 3, 5;</div><div class="line">say &apos;all primes&apos; if @values.all ~~ *.is-prime;</div><div class="line"></div><div class="line">my @moar-values;</div><div class="line">say &apos;also all primes&apos; if @moar-values.all ~~ *.is-prime;</div></pre></td></tr></table></figure>
<p>即使它没有值的时候也会返回 True, 这可能不是你想要的。在那些情况下, 你可以使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my @moar-values;</div><div class="line">say &apos;also all primes&apos; if @moar-values and @moar-values.all ~~ *.is-prime;</div></pre></td></tr></table></figure>
<h2 id="Call-Me-Baby"><a href="#Call-Me-Baby" class="headerlink" title="Call Me, Baby"></a>Call Me, Baby</h2><p> 你可以把 Junctions 用作并不期望 Junction 的子例程的参数。那么会发生什么呢? 对于每一个 Junctioned 的值, 那个子例程都会被调用一次, 并且返回值会是一个 Junction：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> sub caculate-things($n) &#123;</div><div class="line">     say &quot;$n is prime&quot;          if $n.is-prime;</div><div class="line">     say &quot;$n is an even number&quot; if $n %% 2;</div><div class="line">     say &quot;$n is pretty big&quot;     if $n &gt; 1e6;</div><div class="line">     $n²;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">my @values = 1, 5, 42, 1e10.Int;</div><div class="line">say &apos;EXACTLY ONE square is larger than 1e10&apos;</div><div class="line">    if 1e10 &lt; calculate-things @values.one;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># 5 is a prime</div><div class="line"># 42 is an even number</div><div class="line"># 10000000000 is an even number</div><div class="line"># 10000000000 is pretty big</div><div class="line"># EXACTLY ONE square is larger than 1e10</div></pre></td></tr></table></figure>
<p>暴露的副作用可能有点太过神奇并且你可能不想在生产代码中看到它, 但是使用一个子例程来修改原来的 Junctioned 化的值是相当能接受的。执行一个数据库查询来获取”实际的”值并且在之后计算那个条件怎么样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">use DBIish;</div><div class="line"></div><div class="line">my $dbh = DBIish.connect: &apos;SQLite&apos;, :database&lt;test.db&gt;;</div><div class="line"></div><div class="line">sub lookup ($id) &#123;</div><div class="line">    given $dbh.prepare: &apos;SELECT id, text FROM stuff WHERE id = ?&apos; &#123;</div><div class="line">        .execute: $id;</div><div class="line">        .allrows[0][1] // &apos;&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my @ids = 3, 5, 10;</div><div class="line">say &apos;yeah, it got it, bruh&apos; if &apos;meow&apos; eq lookup @ids.any;</div><div class="line"></div><div class="line"># OUTPUT (the database has a row with id = 5 and text = &apos;meow&apos;):</div><div class="line"># yeah, it got it, bruh</div></pre></td></tr></table></figure>
<h2 id="我们一直在期盼你-请坐。"><a href="#我们一直在期盼你-请坐。" class="headerlink" title="我们一直在期盼你, 请坐。"></a>我们一直在期盼你, 请坐。</h2><p>那个游戏变化了当你的子例程正好期望一个 Junction 作为参数的时候。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sub do-stuff (Junction $n) &#123;</div><div class="line">    say &apos;value is even&apos;  if $n %% 2;</div><div class="line">    say &apos;value is prime&apos; if $n.is-prime;</div><div class="line">    say &apos;value is large&apos; if $n &gt; 1e10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">do-stuff (2, 3, 1e11.Int).one;</div><div class="line">say &apos;---&apos;;</div><div class="line">do-stuff (2, 3, 1e11.Int).any;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># value is large</div><div class="line"># ---</div><div class="line"># value is even</div><div class="line"># value is prime</div><div class="line"># value is large</div></pre></td></tr></table></figure>
<p>当我们提供了一个 <code>one</code> Junction 时, 只有正好满足给定值中的其中一个条件才会被触发。当我们提供一个 <code>any</code> Junction 时, 满足条件的任何一个给定值都会触发。</p>
<p>但是! 你没有必要非等着世界为你分发 Junctions。你自己制造一个怎么样呢, 还能在测试条件时节省代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sub do-stuff (*@v) &#123;</div><div class="line">    my $n = @v.one;</div><div class="line">    say &quot;$n is even&quot;  if $n %% 2;</div><div class="line">    say &quot;$n is prime&quot; if $n.is-prime;</div><div class="line">    say &quot;$n is large&quot; if $n &gt; 1e10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">do-stuff 2, 3, 1e11.Int;</div><div class="line">say &apos;---&apos;;</div><div class="line">do-stuff 42;</div><div class="line"></div><div class="line"># OUTPUT:</div><div class="line"># one(2, 3, 100000000000) is large</div><div class="line"># ---</div><div class="line"># one(42) is even</div></pre></td></tr></table></figure>
<h2 id="没有人想过将来吗"><a href="#没有人想过将来吗" class="headerlink" title="没有人想过将来吗?"></a>没有人想过将来吗?</h2><p>还有一个小秘密: Junctions 被设计为时<a href="https://en.wikipedia.org/wiki/Automatic_parallelization" target="_blank" rel="external">自动线程化</a>的(即 auto-threaded)。尽管在写这篇文章的时候它们只会使用仅仅一个线程, 你不应该依赖它们能以任何可预测的顺序被执行。自动线程化会在 2018 年的某个时间被实现, 所以保持关注… 你不必做任何事情, 你的值得自动线程化的复杂 Junctioned 化的操作可能会在几年之内变得更快。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Perl 6 的 Junctions 是值的叠加态, 它允许你测试多个值就像它们是一个值一样。除了提供非常短并且易读的语法, Junctions 还允许你使用子例程变换叠加值或者使用副作用。</p>
<p>你还可以生成显式操作 Junctions 的子例程或者把提供的多个值转换成 Junctions 以简化代码。</p>
<p>最后, Junctions 被设计为能使用所有你计算机所提供的可用能力并且在不久的将来会做成自动线程化。</p>
<p>Junctions 很精彩, 使用它们, 玩的开心!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Subset]]></title>
      <url>http://ohmycloud.github.io/2015/03/19/Subset/</url>
      <content type="html"><![CDATA[<p>简书对插入代码支持的不给力啊。 Perl 6 语法肯定识别不出， 但是空格对齐也不给力啊。 </p>
<hr>
<p>Subset 可用于声明某一类型的子集。</p>
<p>输入一个密码， 要求密码必须满足如下条件：</p>
<p>1、 至少 8 位<br>2、 必须包含大写字母、小写字母 和 数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">use v6; </div><div class="line"></div><div class="line"> subset Length8      of Str where *.chars &lt; 8;</div><div class="line"> subset UpCase       of Str where none(&apos;A&apos;..&apos;Z&apos;)  ∈ *.comb.Set;</div><div class="line"> subset LowerCase    of Str where none(&apos;a&apos;..&apos;z&apos;)  ∈ *.comb.Set;</div><div class="line"> subset IntNumber    of Str where none(&apos;0&apos;..&apos;9&apos;)  ∈ *.comb.Set;</div><div class="line"></div><div class="line"> my $guess = prompt(&apos;Enter your password:&apos;);</div><div class="line">    </div><div class="line"> given $guess &#123;</div><div class="line">     when Length8     &#123; say &apos;密码长度必须为 8 位 以上&apos;; proceed &#125;</div><div class="line">     when  UpCase     &#123; say &apos;密码必须包括大写字母&apos;;     proceed &#125; </div><div class="line">     when LowerCase   &#123; say &apos;密码必须包含小写字母&apos;;     proceed &#125;</div><div class="line">     when IntNumber   &#123; say &apos;密码必须包含数字&apos;;                &#125;   </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>该程序具有可扩展性， 要增加一种密码验证， 只有添加一个 subset 就好了，然后在 given/When 里面增加一个处理。</p>
<p>proceed ：vi. 前进; 继续下去。<br><code>proceed</code> 相当于 <code>continue</code>， 不像 C 里面的 falling through， Perl 6 里面的 proceed 在继续执行下一个  <code>when</code>  语句时会计算 when 后面的条件。 所以， 只要有 proceed ， 则 proceed 后面的那个条件就会被执行。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Perl-6-中的特性(二)]]></title>
      <url>http://ohmycloud.github.io/2015/03/16/Perl6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">my $keywords = set &lt;if for unless while&gt;; # create a set</div><div class="line"></div><div class="line">sub has-keyword(*@words) &#123;</div><div class="line">    for @words -&gt; $word &#123;</div><div class="line">        return True if $word (elem) $keywords; # 依次检查数组中的元素是否属于集合 $keywords</div><div class="line">    &#125;</div><div class="line">    False;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say has-keyword &apos;not&apos;, &apos;one&apos;, &apos;here&apos;;       # False</div><div class="line">say has-keyword &apos;but&apos;, &apos;here&apos;, &apos;for&apos;;       # True</div></pre></td></tr></table></figure>
<h2 id="Series-Operator"><a href="#Series-Operator" class="headerlink" title="Series Operator"></a>Series Operator</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @a=&lt;A G C T&gt;;</div><div class="line">my $x=@a;</div><div class="line">for 1 ... * -&gt; $a &#123;  (( [X~] $x xx $a )).join(&apos;,&apos;).say;last if $a==4;   &#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Works with: Rakudo Star version 2010.08</div><div class="line">for 10 ... 0 &#123;</div><div class="line">    .say;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my $file = open &apos;flip_flop.txt&apos;;</div><div class="line">for $file.lines -&gt; $line &#123;</div><div class="line">say $line if !($line ~~ m/^\;/ ff $line ~~ m/^\&quot;/);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>flip_flop.txt 内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">; next is some lines to skip,include this line</div><div class="line">fuck fuck fuck</div><div class="line">dam dam dam</div><div class="line">mie mie mie</div><div class="line">&quot; next is subject</div><div class="line">There is more than one way to do it</div><div class="line">                                -- Larry Wall</div><div class="line"></div><div class="line">We hope Perl6 is wrote by the hole Socfilia</div><div class="line">                                -- Larry Wall</div><div class="line">; next is some lines to skip,include this line</div><div class="line">fuck fuck fuck</div><div class="line">dam dam dam</div><div class="line">mie mie mie</div><div class="line">&quot; next is subject</div><div class="line">programming is hard,Let&apos;s go shopping</div><div class="line">                               -- Larry Wall</div><div class="line">Ruby is Another Perl6</div><div class="line">                               -- Larry Wall</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">There is more than one way to do it</div><div class="line">                                -- Larry Wall</div><div class="line">We hope Perl6 is wrote by the hole Socfilia</div><div class="line">                                -- Larry Wall</div><div class="line">programming is hard,Let&apos;s go shopping</div><div class="line">                               -- Larry Wall</div><div class="line">Ruby is Another Perl6</div><div class="line">                               -- Larry Wall</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">for 1..20 &#123;.say if $_==9 ff $_==16&#125;</div><div class="line">say &apos;-&apos; x 10;</div><div class="line">for 1..20 &#123;.say if $_==9 ^ff $_==16&#125;</div><div class="line">say &apos;-&apos; x 10;</div><div class="line">for 1..20 &#123;.say if $_==9 ff^ $_==16&#125;</div><div class="line">say &apos;-&apos; x 10;</div><div class="line">for 1..20 &#123;.say if $_==9 ^ff^ $_==16&#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">----------</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">----------</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">----------</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Works with: Rakudo Star version 2010.08</div><div class="line">loop &#123;</div><div class="line">    say &apos;SPAM&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># In addition, there are various ways of writing lazy, infinite lists in Perl 6:</div><div class="line">print &quot;SPAM\n&quot; xx *;      # repetition operator</div><div class="line">print &quot;SPAM\n&quot;, ~* ... *; # sequence operator</div><div class="line">map &#123;say &quot;SPAM&quot;&#125;, ^Inf;   # upto operator</div></pre></td></tr></table></figure>
<h2 id="Grammars"><a href="#Grammars" class="headerlink" title="Grammars"></a>Grammars</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">BEGIN &#123;</div><div class="line">    @*INC.push(&apos;/Volumes/WORK/1-Books/3-Perl6/examples/笔记/Grammars&apos;);</div><div class="line">&#125;</div><div class="line">use Add1;</div><div class="line"></div><div class="line">my @experssions = (</div><div class="line">    &quot;2 + 3&quot;,</div><div class="line">    &quot;2 + 4 &quot;,</div><div class="line">    &quot;2 + 3 x&quot;,</div><div class="line">    &quot;2 +&quot;,</div><div class="line">    &quot;2 3&quot;,</div><div class="line">    &quot;2 - 3&quot;,</div><div class="line">);</div><div class="line"></div><div class="line">for @experssions -&gt; $exp &#123;</div><div class="line">    print $exp, &quot; &quot;;</div><div class="line">    my $result = Add1.parse($exp);</div><div class="line">    say $result ?? &apos;OK&apos; !! &apos;NOT OK&apos;;</div><div class="line">    CATCH &#123;</div><div class="line">        say &quot;exception received: $!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">BEGIN &#123;</div><div class="line">    @*INC.push(&apos;/Volumes/WORK/1-Books/3-Perl6/examples/笔记/Grammars&apos;);</div><div class="line">&#125;</div><div class="line">use Add2;</div><div class="line"></div><div class="line">my @experssions = (</div><div class="line">    &quot;2 + 3&quot;,</div><div class="line">    &quot;2 + 4 &quot;,</div><div class="line">    &quot;2 + 3 x&quot;,</div><div class="line">    &quot;2 +&quot;,</div><div class="line">    &quot;2 3&quot;,</div><div class="line">    &quot;2 - 3&quot;,</div><div class="line">);</div><div class="line"></div><div class="line">for @experssions -&gt; $exp &#123;</div><div class="line">    print $exp, &quot; &quot;;</div><div class="line">    my $result = Add2.parse($exp);</div><div class="line">    say $result ?? &apos;OK&apos; !! &apos;NOT OK&apos;;</div><div class="line">    CATCH &#123;</div><div class="line">        say &quot;exception received: $!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">grammar CardGame &#123;</div><div class="line"></div><div class="line">    rule TOP &#123; ^ &lt;deal&gt; $ &#125;</div><div class="line"></div><div class="line">    rule deal &#123;</div><div class="line">        &lt;hand&gt;+ % &apos;;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    rule hand &#123; [ &lt;card&gt; ]**5 &#125;</div><div class="line">    token card &#123;&lt;face&gt;&lt;suit&gt;&#125;</div><div class="line"></div><div class="line">    proto token suit &#123;*&#125;</div><div class="line">    token suit:sym&lt;♥&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♦&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♣&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♠&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line"></div><div class="line">    token face &#123;:i &lt;[2..9]&gt; | 10 | j | q | k | a &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say CardGame.parse(&quot;2♥ 5♥ 7♦ 8♣ 9♠&quot;);</div><div class="line">say CardGame.parse(&quot;2♥ a♥ 7♦ 8♣ j♥&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">grammar CardGame &#123;</div><div class="line"></div><div class="line">    rule TOP &#123; ^ &lt;deal&gt; $ &#125;</div><div class="line"></div><div class="line">    rule deal &#123;</div><div class="line">       :my %*PLAYED = ();</div><div class="line">       &lt;hand&gt;+ % &apos;;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    rule hand &#123; [ &lt;card&gt; ]**5 &#125;</div><div class="line">    token card &#123;&lt;face&gt;&lt;suit&gt;&#125;</div><div class="line"></div><div class="line">    proto token suit &#123;*&#125;</div><div class="line">    token suit:sym&lt;♥&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♦&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♣&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♠&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line"></div><div class="line">    token face &#123;:i &lt;[2..9]&gt; | 10 | j | q | k | a &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class CardGame::Actions &#123;</div><div class="line">    method card($/) &#123;</div><div class="line">       my $card = $/.lc;</div><div class="line">       say &quot;Hey, there&apos;s an extra $card&quot;</div><div class="line">           if %*PLAYED&#123;$card&#125;++;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $a = CardGame::Actions.new;</div><div class="line">say CardGame.parse(&quot;a♥ a♥ 7♦ 8♣ j♥&quot;, :actions($a));</div><div class="line"># &quot;Hey there&apos;s an extra a♥&quot;</div><div class="line">say CardGame.parse(&quot;a♥ 7♥ 7♦ 8♣ j♥; 10♥ j♥ q♥ k♥ a♦&quot;,</div><div class="line">                   :actions($a));</div><div class="line"># &quot;Hey there&apos;s an extra j♥&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line">my %dict;</div><div class="line"></div><div class="line">grammar WordPairs &#123;</div><div class="line">    token TOP &#123; &lt;word-pair&gt;* &#125;</div><div class="line">    token word-pair &#123; (\S*) &apos; &apos; (\S*) &quot;\n&quot; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class WordPairsActions &#123;</div><div class="line">    method word-pair($/) &#123; %dict&#123;$0&#125;.push($1) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $match = WordPairs.parse(&quot;&#123;@*ARGS[0]&#125;&quot;.IO.slurp, :actions(WordPairsActions));</div><div class="line">say ?$match;</div><div class="line"></div><div class="line">say &quot;The pairs count of the key word \&quot;her\&quot; in wordpairs.txt is &#123;%dict&#123;&quot;her&quot;&#125;.elems&#125;&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line">my $file=open &quot;test.txt&quot;, :r;</div><div class="line"></div><div class="line">my %dict;</div><div class="line">my $line;</div><div class="line"></div><div class="line">repeat &#123;</div><div class="line">    $line=$file.get;</div><div class="line">    my ($p1,$p2)=$line.split(&apos; &apos;);</div><div class="line">    if ?%dict&#123;$p1&#125; &#123;</div><div class="line">        %dict&#123;$p1&#125; = &quot;&#123;%dict&#123;$p1&#125;&#125; &#123;$p2&#125;&quot;.words;</div><div class="line">    &#125; else &#123;</div><div class="line">        %dict&#123;$p1&#125; = $p2;</div><div class="line">    &#125;</div><div class="line">&#125; while !$file.eof;</div><div class="line"></div><div class="line">## Test</div><div class="line">say &quot;The pairs count of the key word \&quot;was\&quot; in wordpairs.txt is &#123;%dict&#123;&quot;was&quot;&#125;.elems&#125;&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">﻿grammar CSV &#123;</div><div class="line">    token TOP &#123; [ &lt;line&gt; \n? ]+ &#125;</div><div class="line">    token line &#123;</div><div class="line">        ^^            # Beginning of a line</div><div class="line">        &lt;value&gt;* % \, # Any number of &lt;value&gt;s with commas in `between` them</div><div class="line">        $$            # End of a line</div><div class="line">    &#125;</div><div class="line">    token value &#123;</div><div class="line">        [</div><div class="line">        | &lt;-[&quot;,\n]&gt;     # Anything not a double quote, comma or newline</div><div class="line">        | &lt;quoted-text&gt; # Or some quoted text</div><div class="line">        ]*              # Any number of times</div><div class="line">    &#125;</div><div class="line">    token quoted-text &#123;</div><div class="line">        \&quot;</div><div class="line">        [</div><div class="line">        | &lt;-[&quot;\\]&gt; # Anything not a &quot; or \</div><div class="line">        | &apos;\&quot;&apos;     # Or \&quot;, an escaped quotation mark</div><div class="line">        ]*         # Any number of times</div><div class="line">        \&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"># method parse($str, :$rule = &apos;TOP&apos;, :$actions) returns Match:D</div><div class="line">say &quot;Valid CSV file!&quot; if CSV.parse( q:to/EOCSV/ );</div><div class="line">    Year,Make,Model,Length</div><div class="line">    1997,Ford,E350,2.34</div><div class="line">    2000,Mercury,Cougar,2.38</div><div class="line">    EOCSV</div><div class="line"></div><div class="line">say CSV.parse( q:to/EOCSV/, &apos;line&apos;, :$actions );</div><div class="line">    Year,Make,Model,Length</div><div class="line">    1997,Ford,E350,2.34</div><div class="line">    2000,Mercury,Cougar,2.38</div><div class="line">    EOCSV</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">﻿grammar MyGrammar &#123;</div><div class="line">    token chunk &#123;</div><div class="line">        &#123; say &quot;chunk: called&quot; &#125;</div><div class="line">        ^^</div><div class="line">        &#123; say &quot;chunk: found start of line&quot; &#125;</div><div class="line">        (\S+)</div><div class="line">        &#123; say &quot;chunk: found first identifier: $0&quot; &#125;</div><div class="line">		#(\s*)</div><div class="line">		#&#123;say &quot;chunk: found space&quot;&#125;</div><div class="line">        \=</div><div class="line">        &#123; say &quot;chunk: found =&quot; &#125;</div><div class="line">		#(\s*)</div><div class="line">		#&#123;say &quot;chunk: found space&quot;&#125;</div><div class="line">        (\S+) $$</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say ?MyGrammar.parse(&quot;foo = bar&quot;, :rule&lt;chunk&gt;);</div><div class="line"></div><div class="line"># output:</div><div class="line">#</div><div class="line"># chunk: called</div><div class="line"># chunk: found start of line</div><div class="line"># chunk: found fist identifer: foo</div><div class="line"># False</div><div class="line"></div><div class="line">#You can see that the rule matched the start of the line, and foo, but not the equals sign. What&apos;s between the two? A space. For which there is no rule to match it. Making chunk a rule instead of a token fixes this problem.</div><div class="line"># 因为 (\S+)后面有一个空格, \= 后面也有个空格, rule 能识别空格</div><div class="line"></div><div class="line"># E:\1-技术书籍\Perl6\examples\Grammars&gt;perl6 -e &quot;&apos;aabcd&apos; ~~ /^ (.*)&#123;say $0.Str&#125; b/&quot;</div><div class="line">#aabcd</div><div class="line">#aabc</div><div class="line">#aab</div><div class="line">#aa</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">﻿grammar Perl6VariableNames &#123;</div><div class="line"></div><div class="line">    token variable &#123;</div><div class="line">        &lt;sigil&gt; &lt;name&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    #token sigil &#123;</div><div class="line">    #    &apos;$&apos; | &apos;@&apos; | &apos;&amp;&apos; | &apos;%&apos; | &apos;::&apos;</div><div class="line">    #&#125;</div><div class="line"></div><div class="line">    # 使用 proto</div><div class="line">	proto token sigil &#123;*&#125;</div><div class="line">    token sigil:sym&lt;$&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">    token sigil:sym&lt;@&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">    token sigil:sym&lt;%&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">    token sigil:sym&lt;&amp;&gt;  &#123; &lt;sym&gt; &#125;</div><div class="line">    token sigil:sym&lt;::&gt; &#123; &lt;sym&gt; &#125;</div><div class="line"></div><div class="line">	# [ ... ] are non-capturing groups</div><div class="line">	token name &#123;</div><div class="line">        &lt;identifier&gt;</div><div class="line">        [ &apos;::&apos; &lt;identifier&gt; ] *</div><div class="line">    &#125;</div><div class="line">	# 标识符以字母开头</div><div class="line">    token identifier &#123;</div><div class="line">        &lt;alpha&gt; \w+</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $match = Perl6VariableNames.parse(&quot;@array&quot;,:rule(&apos;variable&apos;));</div><div class="line">say $match;</div><div class="line"></div><div class="line">grammar SigilRichPerl6 is Perl6VariableNames &#123;</div><div class="line">    token sigil:sym&lt;ħ&gt; &#123; &lt;sym&gt; &#125; # physicists will love you</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $rich = SigilRichPerl6.parse(&quot;ħarray&quot;,:rule(&apos;variable&apos;));</div><div class="line">say $rich;</div><div class="line"></div><div class="line">grammar LowBudgetPerl6 is Perl6VariableNames &#123;</div><div class="line">    token sigil:sym&lt;$&gt; &#123; &apos;¢&apos; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $money = LowBudgetPerl6.parse(&apos;$array&apos;,:rule(&apos;variable&apos;));</div><div class="line">say $money;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">grammar StationDataParser &#123;</div><div class="line">    token TOP          &#123; ^ &lt;keyval&gt;+ &lt;observations&gt; $             &#125;</div><div class="line">    token keyval       &#123; $&lt;key&gt;=[&lt;-[=]&gt;+] &apos;=&apos; \h* $&lt;val&gt;=[\N+] \n &#125;</div><div class="line">    token observations &#123; &apos;Obs:&apos; \h* \n &lt;observation&gt;+             &#125;</div><div class="line">    token observation  &#123; $&lt;year&gt;=[\d+] \h* &lt;temp&gt;+ %% [\h*] \n    &#125;</div><div class="line">    token temp         &#123; &apos;-&apos;? \d+ \. \d+                          &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class StationData &#123;</div><div class="line">    has $.name;</div><div class="line">    has $.country;</div><div class="line">    has @.data;</div><div class="line"></div><div class="line">    submethod BUILD(:%info (:Name($!name), :Country($!country), *%), :@!data) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class StationDataActions &#123;</div><div class="line">    method TOP($/) &#123;</div><div class="line">        make StationData.new(</div><div class="line">            info =&gt; $&lt;keyval&gt;.map(*.ast).hash,</div><div class="line">            data =&gt; $&lt;observations&gt;.ast</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method keyval($/) &#123;</div><div class="line">        make ~$&lt;key&gt; =&gt; ~$&lt;val&gt;;</div><div class="line">    &#125;</div><div class="line">    method observations($/) &#123;</div><div class="line">        make $&lt;observation&gt;.map(*.ast).grep(*.value.none &lt;= -99);</div><div class="line">    &#125;</div><div class="line">    method observation($/) &#123;</div><div class="line">        make +$&lt;year&gt; =&gt; $&lt;temp&gt;.map(*.Num);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say StationDataParser.parse( q:to/EOCSV/, :actions(StationDataActions)).ast</div><div class="line">Name= Jan Mayen</div><div class="line">Country= NORWAY</div><div class="line">Lat=   70.9</div><div class="line">Long=    8.7</div><div class="line">Height= 10</div><div class="line">Start year= 1921</div><div class="line">End year= 2009</div><div class="line">Obs:</div><div class="line">1921 -4.4 -7.1 -6.8 -4.3 -0.8  2.2  4.7  5.8  2.7 -2.0 -2.1 -4.0  </div><div class="line">1922 -0.9 -1.7 -6.2 -3.7 -1.6  2.9  4.8  6.3  2.7 -0.2 -3.8 -2.6  </div><div class="line">2008 -2.8 -2.7 -4.6 -1.8  1.1  3.3  6.1  6.9  5.8  1.2 -3.5 -0.8  </div><div class="line">2009 -2.3 -5.3 -3.2 -1.6  2.0  2.9  6.7  7.2  3.8  0.6 -0.3 -1.3</div><div class="line">EOCSV</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"># file lib/JSON/Tiny/Grammar.pm</div><div class="line"></div><div class="line"> grammar JSON::Tiny::Grammar &#123;</div><div class="line">     rule TOP      &#123; ^[ &lt;object&gt; | &lt;array&gt; ]$ &#125;</div><div class="line">     rule object   &#123; &apos;&#123;&apos; ~ &apos;&#125;&apos; &lt;pairlist&gt;     &#125;</div><div class="line">     rule pairlist &#123; &lt;pair&gt;* % [ \, ]         &#125;</div><div class="line">     rule pair     &#123; &lt;string&gt; &apos;:&apos; &lt;value&gt;     &#125;</div><div class="line">     rule array    &#123; &apos;[&apos; ~ &apos;]&apos; [ &lt;value&gt;* % [ \, ] ] &#125;</div><div class="line"></div><div class="line"> proto token value &#123; &lt;...&gt; &#125;;</div><div class="line"></div><div class="line"> token value:sym&lt;number&gt; &#123;</div><div class="line">     &apos;-&apos;?</div><div class="line">     [ 0 | &lt;[1..9]&gt; &lt;[0..9]&gt;* ]</div><div class="line">     [ \. &lt;[0..9]&gt;+ ]?</div><div class="line">     [ &lt;[eE]&gt; [\+|\-]? &lt;[0..9]&gt;+ ]?</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> token value:sym&lt;true&gt;   &#123; &lt;sym&gt;    &#125;;</div><div class="line"> token value:sym&lt;false&gt;  &#123; &lt;sym&gt;    &#125;;</div><div class="line"> token value:sym&lt;null&gt;   &#123; &lt;sym&gt;    &#125;;</div><div class="line"> token value:sym&lt;object&gt; &#123; &lt;object&gt; &#125;;</div><div class="line"> token value:sym&lt;array&gt;  &#123; &lt;array&gt;  &#125;;</div><div class="line"> token value:sym&lt;string&gt; &#123; &lt;string&gt; &#125;</div><div class="line"></div><div class="line"> token string &#123;</div><div class="line">     \&quot; ~ \&quot; [ &lt;str&gt; | \\ &lt;str_escape&gt; ]*</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> token str &#123;</div><div class="line">     [</div><div class="line">         &lt;!before \t&gt;</div><div class="line">         &lt;!before \n&gt;</div><div class="line">         &lt;!before \\&gt;</div><div class="line">         &lt;!before \&quot;&gt;</div><div class="line">         .</div><div class="line">     ]+</div><div class="line">     # &lt;-[&quot;\\\t\n]&gt;+</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> token str_escape &#123;</div><div class="line">     &lt;[&quot;\\/bfnrt]&gt; | u &lt;xdigit&gt;**4</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"></div><div class="line"> # test it:</div><div class="line"> my $tester = &apos;&#123;</div><div class="line">     &quot;country&quot;: &quot;Austria&quot;,</div><div class="line">     &quot;cities&quot;: [ &quot;Wien&quot;, &quot;Salzburg&quot;, &quot;Innsbruck&quot; ],</div><div class="line">     &quot;population&quot;: 8353243</div><div class="line"> &#125;&apos;;</div><div class="line"></div><div class="line"> if JSON::Tiny::Grammar.parse($tester) &#123;</div><div class="line">     say &quot;It&apos;s valid JSON&quot;;</div><div class="line"> &#125; else &#123;</div><div class="line">     # TODO: error reporting</div><div class="line">     say &quot;Not quite...&quot;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">grammar JSON::Tiny::Grammar &#123;</div><div class="line">     rule TOP      &#123; ^[ &lt;object&gt; | &lt;array&gt; ]$ &#125;</div><div class="line">     rule object   &#123; &apos;&#123;&apos; ~ &apos;&#125;&apos; &lt;pairlist&gt;     &#125;</div><div class="line">     rule pairlist &#123; &lt;pair&gt;* % [ \, ]         &#125;</div><div class="line">     rule pair     &#123; &lt;string&gt; &apos;:&apos; &lt;value&gt;     &#125;</div><div class="line">     rule array    &#123; &apos;[&apos; ~ &apos;]&apos; [ &lt;value&gt;* % [ \, ] ] &#125;</div><div class="line"></div><div class="line"> proto token value &#123; &lt;...&gt; &#125;;</div><div class="line"></div><div class="line"> token value:sym&lt;number&gt; &#123;</div><div class="line">     &apos;-&apos;?</div><div class="line">     [ 0 | &lt;[1..9]&gt; &lt;[0..9]&gt;* ]</div><div class="line">     [ \. &lt;[0..9]&gt;+ ]?</div><div class="line">     [ &lt;[eE]&gt; [\+|\-]? &lt;[0..9]&gt;+ ]?</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> token value:sym&lt;true&gt;   &#123; &lt;sym&gt;    &#125;;</div><div class="line"> token value:sym&lt;false&gt;  &#123; &lt;sym&gt;    &#125;;</div><div class="line"> token value:sym&lt;null&gt;   &#123; &lt;sym&gt;    &#125;;</div><div class="line"> token value:sym&lt;object&gt; &#123; &lt;object&gt; &#125;;</div><div class="line"> token value:sym&lt;array&gt;  &#123; &lt;array&gt;  &#125;;</div><div class="line"> token value:sym&lt;string&gt; &#123; &lt;string&gt; &#125;</div><div class="line"></div><div class="line"> token string &#123;</div><div class="line">     \&quot; ~ \&quot; [ &lt;str&gt; | \\ &lt;str_escape&gt; ]*</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> token str &#123;</div><div class="line">     [</div><div class="line">         &lt;!before \t&gt;</div><div class="line">         &lt;!before \n&gt;</div><div class="line">         &lt;!before \\&gt;</div><div class="line">         &lt;!before \&quot;&gt;</div><div class="line">         .</div><div class="line">     ]+</div><div class="line">     # &lt;-[&quot;\\\t\n]&gt;+</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> token str_escape &#123;</div><div class="line">     &lt;[&quot;\\/bfnrt]&gt; | u &lt;xdigit&gt;**4</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"></div><div class="line"> # test it:</div><div class="line"> my $tester = &apos;&#123;</div><div class="line">     &quot;country&quot;: &quot;Austria&quot;,</div><div class="line">     &quot;cities&quot;: [ &quot;Wien&quot;, &quot;Salzburg&quot;, &quot;Innsbruck&quot; ],</div><div class="line">     &quot;population&quot;: 8353243</div><div class="line"> &#125;&apos;;</div><div class="line"></div><div class="line"> if JSON::Tiny::Grammar.parse($tester) &#123;</div><div class="line">     say &quot;It&apos;s valid JSON&quot;;</div><div class="line"> &#125; else &#123;</div><div class="line">     # TODO: error reporting</div><div class="line">     say &quot;Not quite...&quot;;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"> class JSON::Tiny::Actions &#123;</div><div class="line">    method TOP($/)      &#123; make $/.values.[0].ast              &#125;</div><div class="line">    method object($/)   &#123; make $&lt;pairlist&gt;.ast.hash           &#125;</div><div class="line">    method pairlist($/) &#123; make $&lt;pair&gt;&gt;&gt;.ast                   &#125;</div><div class="line">    method pair($/)     &#123; make $&lt;string&gt;.ast =&gt; $&lt;value&gt;.ast  &#125;</div><div class="line">    method array($/)    &#123; make [$&lt;value&gt;&gt;&gt;.ast]                &#125;</div><div class="line">    method string($/)   &#123; make join &apos;&apos;, $/.caps&gt;&gt;.value&gt;&gt;.ast &#125;</div><div class="line"></div><div class="line"> # TODO: make that</div><div class="line"> # make +$/</div><div class="line"> # once prefix:&lt;+&gt; is sufficiently polymorphic</div><div class="line">method value:sym&lt;number&gt;($/) &#123; make try $/       &#125;</div><div class="line">method value:sym&lt;string&gt;($/) &#123; make $&lt;string&gt;.ast &#125;</div><div class="line">method value:sym&lt;true&gt;  ($/) &#123; make Bool::True    &#125;</div><div class="line">method value:sym&lt;false&gt; ($/) &#123; make Bool::False   &#125;</div><div class="line">method value:sym&lt;null&gt;  ($/) &#123; make Any           &#125;</div><div class="line">method value:sym&lt;object&gt;($/) &#123; make $&lt;object&gt;.ast &#125;</div><div class="line">method value:sym&lt;array&gt; ($/) &#123; make $&lt;array&gt;.ast  &#125;</div><div class="line"></div><div class="line">method str($/)               &#123; make ~$/           &#125;</div><div class="line"></div><div class="line">method str_escape($/) &#123;</div><div class="line">    if $&lt;xdigit&gt; &#123;</div><div class="line">        make chr(:16($&lt;xdigit&gt;.join));</div><div class="line">    &#125; else &#123;</div><div class="line">        my %h = &apos;\\&apos; =&gt; &quot;\\&quot;,</div><div class="line">        &apos;n&apos; =&gt; &quot;\n&quot;,</div><div class="line">        &apos;t&apos; =&gt; &quot;\t&quot;,</div><div class="line">        &apos;f&apos; =&gt; &quot;\f&quot;,</div><div class="line">        &apos;r&apos; =&gt; &quot;\r&quot;;</div><div class="line">        make %h&#123;$/&#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $actions = JSON::Tiny::Actions.new();</div><div class="line">my $data_structure = JSON::Tiny::Grammar.parse($tester, &apos;TOP&apos;, :$actions);</div><div class="line">say $data_structure;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line">grammar KeyValuePairs &#123;</div><div class="line">    token TOP &#123;</div><div class="line">	    [ &lt;pair&gt; \n+ ]*</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	token ws &#123; \h* &#125;</div><div class="line"></div><div class="line">	rule pair &#123;</div><div class="line">	    &lt;key=.identifier&gt; &apos;=&apos; &lt;value=.identifier&gt;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	token identifier &#123; \w+ &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class KeyValuePairsActions &#123;</div><div class="line">    method identifier($/)  &#123; make ~$/                   &#125;</div><div class="line">	method pair      ($/)  &#123; make ~$&lt;key&gt; =&gt; ~$&lt;value&gt;  &#125;</div><div class="line">	method TOP       ($/)  &#123; make $&lt;pair&gt;&gt;&gt;.made        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $string = q:to/EOI/;</div><div class="line">second=b</div><div class="line">hits=42</div><div class="line">perl=6</div><div class="line">EOI</div><div class="line"></div><div class="line">my $actions = KeyValuePairsActions.new;</div><div class="line">my $match = KeyValuePairs.parse($string, :$actions).made;</div><div class="line"></div><div class="line">for @$match -&gt; $p &#123;</div><div class="line">    say &quot;key: $p.key()\tValue: $p.value()&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#use Module::Name::Actions;</div><div class="line">grammar Legal-Module-Name &#123;</div><div class="line">  token TOP &#123;</div><div class="line"></div><div class="line">	# identifier followed by zero or more separator identifier pairs</div><div class="line">    ^ &lt;identifier&gt; [&lt;separator&gt;&lt;identifier&gt;] ** 0..* $</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  token identifier  &#123;</div><div class="line">    # leading alpha or _ only</div><div class="line">    &lt;[A..Za..z_]&gt;</div><div class="line">    &lt;[A..Za..z0..9]&gt; ** 0..*</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  token separator  &#123;</div><div class="line">    &apos;::&apos; # colon pairs</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Module::Name::Actions &#123;</div><div class="line">  method TOP($/)</div><div class="line">  &#123; make $/.values.ast ~ &apos;-----&apos;;</div><div class="line">    if $&lt;identifier&gt;.elems &gt; 5</div><div class="line">    &#123;</div><div class="line">      warn &apos;Module name has a lot of identifiers, consider simplifying the name&apos;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $proposed_module_name = &apos;Superoooo::Newoooo::Moduleooooooooooo&apos;;</div><div class="line"></div><div class="line">my $actions = Module::Name::Actions.new();</div><div class="line">my $match_obj = Legal-Module-Name.parse($proposed_module_name, :actions($actions));</div><div class="line"></div><div class="line">say $match_obj.Str;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">use Grammar::Debugger;</div><div class="line">use Grammar::Tracer;</div><div class="line"></div><div class="line"># 第一个 Grammar, 修改了很多次, 借助于 Grammar::Debugger 和 Grammar::Tracer 方便看出 Grammar 在哪里失败.</div><div class="line"># TOP 里面添加了 ^ 和 $ 限制时, 其后面的 token 和 rule 不能在添加 ^ 和 $, 否则匹配失败</div><div class="line"></div><div class="line">use v6;</div><div class="line">grammar Markdown::Toc &#123;</div><div class="line">    # token TOP   is breakpoint    &#123;^ \s* &lt;section&gt;* $&#125;</div><div class="line">	token TOP    &#123;^ \s* &lt;section&gt;* $&#125;</div><div class="line">	token section   &#123;</div><div class="line">	    &lt;sname&gt;  &lt;ws&gt; \n</div><div class="line">		&lt;lines&gt;*</div><div class="line">	    &lt;subsection&gt;+</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    token subsection  &#123;</div><div class="line">    	&lt;subsname&gt; &lt;ws&gt; \n</div><div class="line">        &lt;lines&gt;*</div><div class="line">        &lt;s2section&gt; *</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    token s2section &#123;</div><div class="line">	    &lt;s2name&gt; &lt;ws&gt; \n</div><div class="line">		&lt;lines&gt;*</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	token sname          &#123; &lt;sigil2&gt;   &lt;ws&gt; &lt;snumber=.hnumber&gt;  &lt;ws&gt; &lt;shead=.hline&gt;     &#125;</div><div class="line">	token subsname       &#123; &lt;sigil3&gt;   &lt;ws&gt; &lt;subnumber=.number&gt; &lt;ws&gt; &lt;shline=.hline&gt;    &#125;</div><div class="line">	token s2name         &#123; &lt;sigil4&gt;   &lt;ws&gt; &lt;s2number=.number&gt;  &lt;ws&gt; &lt;s2hline=.hline&gt;   &#125;</div><div class="line">	token lines          &#123;</div><div class="line">	    [</div><div class="line">		    &lt;!after &apos;#&apos; ** 2..* &gt;</div><div class="line">            \N</div><div class="line">        ]+</div><div class="line">	    \n</div><div class="line">	&#125;</div><div class="line">	token number &#123;</div><div class="line">	    \d+ % \.</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	token hline &#123;</div><div class="line">	    \N+</div><div class="line">	&#125;</div><div class="line">	token hnumber &#123; \w+      &#125;</div><div class="line">	token ws      &#123; \h*      &#125;</div><div class="line">	token sigil2  &#123; &apos;#&apos; ** 2 &#125;</div><div class="line">	token sigil3  &#123; &apos;#&apos; ** 3 &#125;</div><div class="line">	token sigil4  &#123; &apos;#&apos; ** 4 &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $str = q:to/EOF/;</div><div class="line">## 第四章 子例程和签名</div><div class="line"></div><div class="line"></div><div class="line">一个子例程就是一段执行特殊任务的代码片段。它可以对提供的数据（`实参`）操作，并产生结果（返回值）。子例程的签名是它`所含的参数`和它产生的`返回值`的描述。从某一意义上来说，第三章描述的操作符也是Perl 6用特殊方式解释的子例程。</div><div class="line"></div><div class="line">### 4.1.0 申明子例程</div><div class="line"></div><div class="line"> 一个子例程申明由几部分组成。首先， `sub `表明你在申明一个子例程，然后是可选的子例程的名称和`可选的签名`。子例程的主体是一个用花括号扩起来的代码块。</div><div class="line">默认的，子例程是本地作用域的，就像任何使用 `my` 申明的变量一样。这意味着，一个子例程只能在它被申明的作用域内被调用。使用 `our` 来申明子例程可以使其在`当前包`中可见。</div><div class="line">EOF</div><div class="line"></div><div class="line"></div><div class="line">```perl6</div><div class="line">class Markdown::Toc::Actions &#123;</div><div class="line">	method s2section($/)        &#123;</div><div class="line">	    my $first = ~$&lt;s2name&gt;&lt;s2number&gt;;</div><div class="line">	    my $second = ~$&lt;s2name&gt;&lt;s2hline&gt;;</div><div class="line">		my $remove_dot = $first.subst(rx/\./,&apos;&apos;,:g);</div><div class="line">		my $remove_space = $second.subst(rx/\s+/,&apos;-&apos;,:g);</div><div class="line">		make &apos;    - &apos;~&apos;[&apos;~$first~&apos; &apos;~$second~&apos;]&apos; ~ &apos;(#&apos;~$remove_dot~$remove_space ~ &apos;)&apos; =&gt; $&lt;s2section&gt;&gt;&gt;.made;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	method subsection($/) &#123;</div><div class="line">	    my $first = ~$&lt;subsname&gt;&lt;subnumber&gt;;</div><div class="line">	    my $second = ~$&lt;subsname&gt;&lt;shline&gt;;</div><div class="line">		my $remove_dot = $first.subst(rx/\./,&apos;&apos;,:g);</div><div class="line">		my $remove_space = $second.subst(rx/\s+/,&apos;-&apos;,:g);</div><div class="line">		make &apos;  - &apos;~&apos;[&apos;~$first~&apos; &apos;~$second~&apos;]&apos; ~ &apos;(#&apos;~$remove_dot~$remove_space ~ &apos;)&apos;	=&gt; $&lt;s2section&gt;&gt;&gt;.made;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">    method section($/)    &#123;</div><div class="line">	    my $first = ~$&lt;sname&gt;&lt;snumber&gt;;</div><div class="line">		my $second = ~$&lt;sname&gt;&lt;shead&gt;;</div><div class="line">		#my $remove_dot = $first.subst(rx/\./,&apos;&apos;,:g);</div><div class="line">		my $remove_space = $second.subst(rx/\s+/,&apos;&apos;,:g);</div><div class="line">	    make &apos;- &apos;~&apos;[&apos;~$first~&apos; &apos;~$second~&apos;]&apos; ~ &apos;(#&apos;~$first~ &apos;-&apos;~$remove_space ~ &apos;)&apos;  =&gt; $&lt;subsection&gt;&gt;&gt;.made;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    method TOP($/)    &#123; make $&lt;section&gt;&gt;&gt;.made;                                                            &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">my $actions = Markdown::Toc::Actions.new;</div><div class="line">my $match  = Markdown::Toc.parse($str, :$actions).made;</div><div class="line">#say $match.Str;</div><div class="line"></div><div class="line">for @$match -&gt; $p &#123;</div><div class="line">    say $p.key();</div><div class="line">    for $p.value() -&gt; $v &#123;</div><div class="line">        for $v -&gt; $n &#123;</div><div class="line">		   .say for $n.hash().keys();</div><div class="line">		   for $n.hash().values() -&gt; $three &#123;</div><div class="line">		       .say for $three.hash().keys();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line">#use Grammar::Debugger;</div><div class="line">#use Grammar::Tracer;</div><div class="line"></div><div class="line"># 第一个 Grammar, 修改了很多次, 借助于 Grammar::Debugger 和 Grammar::Tracer 方便看出 Grammar 在哪里失败.</div><div class="line"># TOP 里面添加了 ^ 和 $ 限制时, 其后面的 token 和 rule 不能在添加 ^ 和 $, 否则匹配失败</div><div class="line"></div><div class="line">use v6;</div><div class="line">grammar Markdown::Toc &#123;</div><div class="line">    # token TOP   is breakpoint    &#123;^ \s* &lt;section&gt;* $&#125;</div><div class="line">	token TOP    &#123;^ \s* &lt;section&gt;* $&#125;</div><div class="line">	token section   &#123;</div><div class="line">	    &lt;sname&gt; &lt;ws&gt;</div><div class="line">		&lt;lines&gt;*</div><div class="line">	    &lt;subsection&gt;+</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    token subsection  &#123;</div><div class="line">    	&lt;subsname&gt; &lt;ws&gt;</div><div class="line">        &lt;lines&gt;*</div><div class="line">        &lt;s2section&gt; *</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    token s2section &#123;</div><div class="line">	    &lt;s2name&gt; &lt;ws&gt;</div><div class="line">		&lt;lines&gt;*</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	token sname          &#123; &lt;sigil2&gt;   &lt;ws&gt; &lt;snumber=.hnumber&gt; &lt;ws&gt; &lt;shead=.hline&gt;  &#125;</div><div class="line">	token subsname       &#123; &lt;sigil3&gt;   &lt;ws&gt; &lt;subnumber=.number&gt;    &lt;shline=.hline&gt;      &#125;</div><div class="line">	token s2name         &#123; &lt;sigil4&gt;   &lt;ws&gt; &lt;s2number=.number&gt; &lt;s2hline=.hline&gt;   &#125;</div><div class="line">	token lines          &#123;</div><div class="line">	    [</div><div class="line">		    &lt;!after &apos;#&apos; ** 2..* &gt;</div><div class="line">            \N</div><div class="line">        ]+</div><div class="line">	    \n</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	token number &#123;</div><div class="line">	    \d+ % \.</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	token hline &#123;</div><div class="line">	    \N+</div><div class="line">	&#125;</div><div class="line">	token hnumber &#123; \w+&#125;</div><div class="line">	token ws     &#123; \s*      &#125;</div><div class="line">	token sigil2 &#123; &apos;#&apos; ** 2 &#125;</div><div class="line">	token sigil3 &#123; &apos;#&apos; ** 3 &#125;</div><div class="line">	token sigil4 &#123; &apos;#&apos; ** 4 &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $str = q:to/EOF/;</div><div class="line">## 第三章 操作符</div><div class="line">blabla</div><div class="line">#blabla</div><div class="line">blabla</div><div class="line">blabla</div><div class="line">###  3.1 关于优先级的的一句话</div><div class="line">blabla</div><div class="line">###  3.2 比较和智能匹配</div><div class="line">blabla</div><div class="line">####   3.2.1 数字比较</div><div class="line">blabla</div><div class="line">####    3.2.2 字符串比较</div><div class="line">blabla</div><div class="line">####    3.2.3 智能匹配</div><div class="line">blabla</div><div class="line">### 3.3 测试</div><div class="line">## 第四章 子例程和签名</div><div class="line">blabla</div><div class="line">###  4.1 申明子例程</div><div class="line">blabla</div><div class="line">###  4.2 添加签名</div><div class="line">blabla</div><div class="line">####   4.2.1 基础</div><div class="line">blabla</div><div class="line">####    4.2.2 传递数组、散列和代码</div><div class="line">blabla</div><div class="line">####    4.2.3 插值、数组和散列</div><div class="line">blabla</div><div class="line">EOF</div><div class="line"></div><div class="line">class Markdown::Toc::Actions &#123;</div><div class="line">	method s2section($/)        &#123;</div><div class="line">	    my $first = ~$&lt;s2name&gt;&lt;s2number&gt;;</div><div class="line">	    my $second = ~$&lt;s2name&gt;&lt;s2hline&gt;;</div><div class="line">		my $remove_dot = $first.subst(rx/\./,&apos;&apos;,:g);</div><div class="line">		my $remove_space = $second.subst(rx/\s+/,&apos;-&apos;,:g);</div><div class="line">		make &apos;    - &apos;~&apos;[&apos;~$first~&apos; &apos;~$second~&apos;]&apos; ~ &apos;(#&apos;~$remove_dot~$remove_space ~ &apos;)&apos; =&gt; $&lt;s2section&gt;&gt;&gt;.made;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	method subsection($/) &#123;</div><div class="line">	    my $first = ~$&lt;subsname&gt;&lt;subnumber&gt;;</div><div class="line">	    my $second = ~$&lt;subsname&gt;&lt;shline&gt;;</div><div class="line">		my $remove_dot = $first.subst(rx/\./,&apos;&apos;,:g);</div><div class="line">		my $remove_space = $second.subst(rx/\s+/,&apos;-&apos;,:g);</div><div class="line">		make &apos;  - &apos;~&apos;[&apos;~$first~&apos; &apos;~$second~&apos;]&apos; ~ &apos;(#&apos;~$remove_dot~$remove_space ~ &apos;)&apos;	=&gt; $&lt;s2section&gt;&gt;&gt;.made;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">    method section($/)    &#123;</div><div class="line">	    my $first = ~$&lt;sname&gt;&lt;snumber&gt;;</div><div class="line">		my $second = ~$&lt;sname&gt;&lt;shead&gt;;</div><div class="line">		#my $remove_dot = $first.subst(rx/\./,&apos;&apos;,:g);</div><div class="line">		my $remove_space = $second.subst(rx/\s+/,&apos;&apos;,:g);</div><div class="line">	    make &apos;- &apos;~&apos;[&apos;~$first~&apos; &apos;~$second~&apos;]&apos; ~ &apos;(#&apos;~$first~ &apos;-&apos;~$remove_space ~ &apos;)&apos;  =&gt; $&lt;subsection&gt;&gt;&gt;.made;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    method TOP($/)    &#123; make $&lt;section&gt;&gt;&gt;.made;                                                            &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">my $actions = Markdown::Toc::Actions.new;</div><div class="line">my $match  = Markdown::Toc.parse($str, :$actions).made;</div><div class="line">#say $match.Str;</div><div class="line"></div><div class="line">for @$match -&gt; $p &#123;</div><div class="line">    say $p.key();</div><div class="line">    for $p.value() -&gt; $v &#123;</div><div class="line">        for $v -&gt; $n &#123;</div><div class="line">		   .say for $n.hash().keys();</div><div class="line">		   for $n.hash().values() -&gt; $three &#123;</div><div class="line">		       .say for $three.hash().keys();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">grammar KeyValuePairs &#123;</div><div class="line">    token TOP &#123;</div><div class="line">        [&lt;pair&gt; \n+]*</div><div class="line">    &#125;</div><div class="line">    token ws &#123; \h* &#125;</div><div class="line"></div><div class="line">    rule pair &#123;</div><div class="line">        &lt;key=.identifier&gt; &apos;=&apos; &lt;value=.identifier2&gt;</div><div class="line">    &#125;</div><div class="line">    token identifier &#123;</div><div class="line">        \w+</div><div class="line">    &#125;</div><div class="line">     token identifier2 &#123;</div><div class="line">        \w+</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class KeyValuePairsActions &#123;</div><div class="line">    method identifier($/) &#123; $/.make: &apos;[&apos; ~$/ ~ &apos;]&apos;                &#125;</div><div class="line">    method identifier2($/) &#123; $/.make: &apos;&#123;&apos; ~$/ ~ &apos;&#125;&apos;                &#125;</div><div class="line">    method pair      ($/) &#123; $/.make: $&lt;key&gt;.made =&gt; $&lt;value&gt;.made &#125;</div><div class="line">    method TOP       ($/) &#123; $/.make: $&lt;pair&gt;».made                &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my  $res = KeyValuePairs.parse(q:to/EOI/, :actions(KeyValuePairsActions)).made;</div><div class="line">    second=b</div><div class="line">    hits=42</div><div class="line">    perl=6</div><div class="line">    EOI</div><div class="line">say $res;</div><div class="line">for @$res -&gt; $p &#123;</div><div class="line">    say &quot;Key: $p.key()\tValue: $p.value()&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">﻿grammar VariableNames &#123;</div><div class="line"></div><div class="line">    token variable &#123;</div><div class="line">        &lt;sigil&gt; &lt;name&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token sigil &#123;</div><div class="line">        &apos;$&apos; | &apos;@&apos; | &apos;&amp;&apos; | &apos;%&apos; | &apos;::&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	# [ ... ] are non-capturing groups</div><div class="line">	token name &#123;</div><div class="line">        &lt;identifier&gt;</div><div class="line">        [ &apos;::&apos; &lt;identifier&gt; ] *</div><div class="line">    &#125;</div><div class="line">	# 标识符以字母开头</div><div class="line">    token identifier &#123;</div><div class="line">        &lt;alpha&gt; \w+</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $match = VariableNames.parse(&quot;@array&quot;,:rule(&apos;variable&apos;));</div><div class="line">say $match;</div><div class="line"></div><div class="line"># we inherit from the original grammar...</div><div class="line">grammar VARIABLENAMES is VariableNames &#123;</div><div class="line"></div><div class="line">    # ... and override that parsing rule that we want to change</div><div class="line">    token identifier &#123;</div><div class="line">        # char classes are &lt;[ ... ]&gt; in Perl 6</div><div class="line">        &lt;[A..Z]&gt; &lt;[A..Z0..9_]&gt;*</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">my $test = VARIABLENAMES.parse(&quot;%A_HASH_TABLE&quot;,:rule(&apos;variable&apos;));</div><div class="line">say $test;</div><div class="line"></div><div class="line">grammar LackMoney is VariableNames &#123;</div><div class="line">    token sigil &#123;</div><div class="line">        &apos;¢&apos; | &apos;@&apos; | &apos;&amp;&apos; | &apos;%&apos; | &apos;::&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 继承以后, 带¢的变量能够解析, 带$的变量解析不了了</div><div class="line">my $money = LackMoney.parse(&apos;$i_m_not_dollor&apos;,:rule(&apos;variable&apos;));</div><div class="line">say so $money; # false</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">grammar URL &#123;</div><div class="line">        token TOP &#123;</div><div class="line">            &lt;schema&gt; &apos;://&apos;</div><div class="line">            [&lt;ip&gt; | &lt;hostname&gt; ]</div><div class="line">            [ &apos;:&apos; &lt;port&gt;]?</div><div class="line">            &apos;/&apos; &lt;path&gt;?</div><div class="line">        &#125;</div><div class="line">        token byte &#123;</div><div class="line">            (\d**1..3) &lt;?&#123; $0 &lt; 256 &#125;&gt;</div><div class="line">        &#125;</div><div class="line">        token ip &#123;</div><div class="line">            &lt;byte&gt; [\. &lt;byte&gt; ] ** 3</div><div class="line">        &#125;</div><div class="line">        token schema &#123;</div><div class="line">            \w+</div><div class="line">        &#125;</div><div class="line">        token hostname &#123;</div><div class="line">            (\w+) ( \. \w+ )*</div><div class="line">        &#125;</div><div class="line">        token port &#123;</div><div class="line">            \d+</div><div class="line">        &#125;</div><div class="line">        token path &#123;</div><div class="line">            &lt;[ a..z A..Z 0..9 \-_.!~*&apos;():@&amp;=+$,/ ]&gt;+</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">my  $match = URL.parse(&apos;http://perl6.org/documentation/&apos;);</div><div class="line">say $match.WHAT();</div><div class="line">say $match&lt;path&gt;;       # perl6.org</div><div class="line">say &quot;hello &quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line">#use Grammar::Debugger;</div><div class="line">#use Grammar::Tracer;</div><div class="line"></div><div class="line">grammar SalesExport::Grammar &#123;</div><div class="line">    token TOP &#123; ^ &lt;country&gt;+ $ &#125;</div><div class="line">    token country &#123;</div><div class="line">        &lt;cname=.name&gt; \n</div><div class="line">        &lt;destination&gt;+</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token destination &#123;</div><div class="line">        \s+ &lt;dname=.name&gt; \s+ &apos;:&apos; \s+</div><div class="line">        &lt;lat=.num&gt; &apos;,&apos; &lt;long=.num&gt; \s+ &apos;:&apos; \s+</div><div class="line">        &lt;sales=.integer&gt; \n</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token name    &#123; \w+          &#125;</div><div class="line">    token num     &#123; \d+ [\.\d+]? &#125;</div><div class="line">    token integer &#123; \d+          &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $string = q:to/THE END/;</div><div class="line">Norway</div><div class="line">    Oslo : 59.914289,10.738739 : 2</div><div class="line">    Bergen : 60.388533,5.331856 : 4</div><div class="line">Ukraine</div><div class="line">    Kiev : 50.456001,30.50384 : 3</div><div class="line">Switzerland</div><div class="line">    Wengen : 46.608265,7.922065 : 3</div><div class="line">THE END</div><div class="line"></div><div class="line">class SalesExport::Grammar::Actions &#123;</div><div class="line">	method destination($/) &#123; make ~$&lt;dname&gt; =&gt; $&lt;sales&gt;          &#125;</div><div class="line">    method country($/)     &#123; make ~$&lt;cname&gt; =&gt; $&lt;destination&gt;    &#125;</div><div class="line">    method TOP($/)         &#123; make $&lt;country&gt;&gt;&gt;.made              &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $actions = SalesExport::Grammar::Actions.new;</div><div class="line">my $grammar_action = SalesExport::Grammar.parse($string, :actions($actions)).made;</div><div class="line"></div><div class="line"># 获取所有国家的名字</div><div class="line">for @$grammar_action -&gt; $p &#123;</div><div class="line">    say &quot;$p.key()&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say  &quot;-&quot; x 45;</div><div class="line">for @$grammar_action -&gt; $p &#123;</div><div class="line">    for $p.value() -&gt; $d &#123;</div><div class="line">	   for @$d -&gt; $n &#123;</div><div class="line">	      say ~$n&lt;dname&gt;;</div><div class="line">	   &#125;</div><div class="line">	  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say  &quot;-&quot; x 45;</div><div class="line"></div><div class="line"># 计算每个国家卖了多少票</div><div class="line">for @$grammar_action -&gt; $c &#123;</div><div class="line">    for $c.value() -&gt; $d &#123;</div><div class="line">	   my $sales_count=0;</div><div class="line">	   for @$d -&gt; $n &#123;</div><div class="line">	      $sales_count += ~$n&lt;sales&gt;;</div><div class="line">	   &#125;</div><div class="line">	   say $sales_count;</div><div class="line">	  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"> #`(</div><div class="line"># say $string;</div><div class="line">my $grammar_object = SalesExport::Grammar.parse($string);</div><div class="line">if $grammar_object &#123;</div><div class="line">     say &quot;It&apos;s works&quot;;</div><div class="line"> &#125; else &#123;</div><div class="line">     # TODO: error reporting</div><div class="line">     say &quot;Not quite works...&quot;;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"></div><div class="line"># say $grammar_object;</div><div class="line">#  say $grammar_object&lt;country&gt;.Str;</div><div class="line">say &quot;_&quot; x 45;</div><div class="line"># say $grammar_object&lt;country&gt;[0];</div><div class="line"># say $grammar_object&lt;country&gt;[1].Str;</div><div class="line"></div><div class="line"> say &quot;_&quot; x 45;</div><div class="line"># say $grammar_object&lt;country&gt;[].Str;</div><div class="line"># say $grammar_object&lt;country&gt;.values;</div><div class="line"></div><div class="line"># 获取国家的名字</div><div class="line">say $grammar_object&lt;country&gt;[0]&lt;name&gt;.Str;</div><div class="line">say $grammar_object&lt;country&gt;[1]&lt;name&gt;.Str;</div><div class="line">say $grammar_object&lt;country&gt;[2]&lt;name&gt;.Str;</div><div class="line"></div><div class="line"> say &quot;_&quot; x 45;</div><div class="line"># 获取目的地</div><div class="line">say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;name&gt;.Str;</div><div class="line">say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;name&gt;.Str;</div><div class="line"></div><div class="line"> say &quot;_&quot; x 45;</div><div class="line"># 获取经度</div><div class="line">say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;lat&gt;.Str;</div><div class="line">say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;lat&gt;.Str;</div><div class="line"></div><div class="line"> say &quot;_&quot; x 45;</div><div class="line"># 获取纬度</div><div class="line">say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;long&gt;.Str;</div><div class="line">say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;long&gt;.Str;</div><div class="line"></div><div class="line"> say &quot;_&quot; x 45;</div><div class="line"># 获取sales</div><div class="line">say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;sales&gt;.Str;</div><div class="line">say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;sales&gt;.Str;</div><div class="line"></div><div class="line"> say &quot;_&quot; x 45;</div><div class="line"> # 获取所有国家</div><div class="line">say $grammar_object&lt;country&gt;»&lt;name&gt;.Str;</div><div class="line"></div><div class="line"> say &quot;_&quot; x 45;</div><div class="line"> # 获取第一个国家的所有目的地</div><div class="line"> say $grammar_object&lt;country&gt;[0]&lt;destination&gt;»&lt;name&gt;.Str;</div><div class="line"></div><div class="line"> say &quot;_&quot; x 45;</div><div class="line"> # 获取第一个国家的所有的 sales</div><div class="line"> say $grammar_object&lt;country&gt;[0]&lt;destination&gt;»&lt;sales&gt;.Str;</div><div class="line">)</div></pre></td></tr></table></figure>
<p> 只能在叶子节点上(最后一个正则名字的前面)使用超运算符 »<br>  S/匹配对象中, 键就是正则的名字, 键值就是匹配到的部分内容.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">﻿#use Grammar::Debugger;</div><div class="line">#use Grammar::Tracer;</div><div class="line"></div><div class="line">grammar SalesExport::Grammar &#123;</div><div class="line">    token TOP &#123; ^ &lt;country&gt;+ $ &#125;</div><div class="line">    token country &#123;</div><div class="line">        &lt;cname=.name&gt; \n</div><div class="line">        &lt;destination&gt;+</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token destination &#123;</div><div class="line">        \s+ &lt;dname=.name&gt; \s+ &apos;:&apos; \s+</div><div class="line">        &lt;lat=.num&gt; &apos;,&apos; &lt;long=.num&gt; \s+ &apos;:&apos; \s+</div><div class="line">        &lt;sales=.integer&gt; \n</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token name    &#123; \w+          &#125;</div><div class="line">    token num     &#123; \d+ [\.\d+]? &#125;</div><div class="line">    token integer &#123; \d+          &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $string = q:to/THE END/;</div><div class="line">Norway</div><div class="line">    Oslo : 59.914289,10.738739 : 2</div><div class="line">    Bergen : 60.388533,5.331856 : 4</div><div class="line">Ukraine</div><div class="line">    Kiev : 50.456001,30.50384 : 3</div><div class="line">Switzerland</div><div class="line">    Wengen : 46.608265,7.922065 : 3</div><div class="line">THE END</div><div class="line"></div><div class="line">class SalesExport::Grammar::Actions &#123;</div><div class="line">	method destination($/) &#123; make ~$&lt;dname&gt; =&gt; [$&lt;sales&gt;.map(*.Num+10),$&lt;lat&gt;.map(*.Num+90) ]         &#125;</div><div class="line">    method country($/)     &#123; make ~$&lt;cname&gt; =&gt; $&lt;destination&gt;&gt;&gt;.made            &#125;</div><div class="line">    method TOP($/)         &#123; make $&lt;country&gt;&gt;&gt;.made                             &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $actions = SalesExport::Grammar::Actions.new;</div><div class="line">my $grammar_action = SalesExport::Grammar.parse($string, :actions($actions)).made;</div><div class="line">#say $grammar_action.Str;</div><div class="line"># 获取所有国家的名字</div><div class="line">for @$grammar_action -&gt; $p &#123;</div><div class="line">    say &quot;$p.key()&quot;;</div><div class="line">&#125;</div><div class="line">say &apos;-&apos; x 45;</div><div class="line"># 获取所有目的地</div><div class="line">for @$grammar_action -&gt; $p &#123;</div><div class="line">    for $p.value() -&gt; $d &#123;</div><div class="line">	    for @$d -&gt; $n&#123;</div><div class="line">		    say $n.key();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">say &apos;-&apos; x 45;</div><div class="line"># 获取出售的票数</div><div class="line">for @$grammar_action -&gt; $p &#123;</div><div class="line">    print &quot;$p.key()\t&quot;;</div><div class="line">    for $p.value() -&gt; $d &#123;</div><div class="line">	    my $count;</div><div class="line">	    for @$d -&gt; $n&#123;</div><div class="line">		    $count += $n.value()[0];</div><div class="line">		&#125;</div><div class="line">	say $count;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say &apos;-&apos; x 45;</div><div class="line"># 获取经度 lat</div><div class="line">for @$grammar_action -&gt; $p &#123;</div><div class="line">    for $p.value() -&gt; $d &#123;</div><div class="line">	    for @$d -&gt; $n&#123;</div><div class="line">		    say $n.value()[1];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将打印:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Norway</div><div class="line">Ukraine</div><div class="line">Switzerland</div><div class="line">---------------------------------------------</div><div class="line">Oslo</div><div class="line">Bergen</div><div class="line">Kiev</div><div class="line">Wengen</div><div class="line">---------------------------------------------</div><div class="line">Norway  26</div><div class="line">Ukraine 13</div><div class="line">Switzerland     13</div><div class="line">---------------------------------------------</div><div class="line">149.914289</div><div class="line">150.388533</div><div class="line">140.456001</div><div class="line">136.608265</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">grammar TestGrammar &#123;</div><div class="line">    token TOP &#123; ^ \d+ $ &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TestActions &#123;</div><div class="line">    method TOP($/) &#123;</div><div class="line">        $/.make(2 + ~$/);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $actions = TestActions.new;</div><div class="line">my $match = TestGrammar.parse(&apos;40&apos;, :$actions);</div><div class="line">say $match;         # ｢40｣</div><div class="line">say $match.made;    # 42</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">﻿grammar MyGrammar &#123;</div><div class="line">    token TOP &#123;</div><div class="line">        ^ [ &lt;comment&gt; | &lt;chunk&gt; ]* $</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token comment &#123;</div><div class="line">        &apos;#&apos; \N* \n</div><div class="line">    &#125;</div><div class="line">    token chunk &#123;</div><div class="line">      ^^  (\S+) &apos;=&apos; (\S+) $$</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 如何调试 Grammars</div><div class="line"># try to parse the whole thing</div><div class="line">say ?MyGrammar.parse(&quot;#a comment\nfoo = bar&quot;);            # False, 整体调试</div><div class="line"># and now one by one</div><div class="line">say so MyGrammar.parse(&quot;#a comment\n&quot;, :rule&lt;comment&gt;);   # True, 只单独调试 comment</div><div class="line">say so MyGrammar.parse(&quot;foo = bar&quot;, :rule&lt;chunk&gt;);        # False, 只单独调试 chunk, 失败, 说明 chunk 不能匹配! 原因是空白符没有匹配</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line">grammar TestGrammar &#123;</div><div class="line">    token TOP   &#123; ^ &lt;digit&gt; $ &#125;</div><div class="line">	token digit &#123; \d+         &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TestActions &#123;</div><div class="line">    method TOP($/) &#123;</div><div class="line">	   # $/.make( 2 + ~$/);</div><div class="line">	   make +$&lt;digit&gt; + 2 ;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $actions = TestActions.new;</div><div class="line">my $match   = TestGrammar.parse(&apos;40&apos;, :$actions);</div><div class="line">say $match;</div><div class="line">say $match.made;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#use Grammar::Debugger;</div><div class="line">#use Grammar::Tracer;</div><div class="line"></div><div class="line">grammar SalesExport &#123;</div><div class="line">    token TOP &#123; ^ &lt;country&gt;+ $ &#125;</div><div class="line">    token country &#123;</div><div class="line">        &lt;name&gt; \n</div><div class="line">        &lt;destination&gt;+</div><div class="line">    &#125;</div><div class="line">    token destination &#123;</div><div class="line">        \s+ &lt;name&gt; \s+ &apos;:&apos; \s+</div><div class="line">        &lt;lat=.num&gt; &apos;,&apos; &lt;long=.num&gt; \s+ &apos;:&apos; \s+</div><div class="line">        &lt;sales=.integer&gt; \n</div><div class="line">    &#125;</div><div class="line">    token name    &#123; \w+ [ \s \w+ ]*   &#125;</div><div class="line">    token num     &#123; &apos;-&apos;? \d+ [\.\d+]? &#125;</div><div class="line">    token integer &#123; &apos;-&apos;? \d+          &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"># Now we can turn any file in this format into a data structure.</div><div class="line">#  tripes.txt 最后一行要有一个空行</div><div class="line">my $parsed = SalesExport.parsefile(&apos;tripes.txt&apos;);</div><div class="line"></div><div class="line">if $parsed &#123;</div><div class="line">    my @countries = @($parsed&lt;country&gt;);</div><div class="line">	#for @countries -&gt; $country &#123; say ~$country&lt;name&gt;&#125;;</div><div class="line">	for @countries &#123; say [+] .&lt;destination&gt;»&lt;sales&gt;;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if $parsed &#123;</div><div class="line">    my @countries = @($parsed&lt;country&gt;);</div><div class="line">    my $top1 = @countries.max(&#123;</div><div class="line">       [+] .&lt;destination&gt;»&lt;sales&gt;</div><div class="line">       &#125;);</div><div class="line">    say &quot;Most popular today: $top1&lt;name&gt; &quot;, [+] $top1&lt;destination&gt;&gt;&gt;&lt;sales&gt;;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">    die &quot;Parse error!&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tripes.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Russia</div><div class="line">    Vladivostok : 43.131621,131.923828 : 4</div><div class="line">    Ulan Ude : 51.841624,107.608101 : 2</div><div class="line">    Saint Petersburg : 59.939977,30.315785 : 10</div><div class="line">Norway</div><div class="line">    Oslo : 59.914289,10.738739 : 2</div><div class="line">    Bergen : 60.388533,5.331856 : 4</div><div class="line">Ukraine</div><div class="line">    Kiev : 50.456001,30.50384 : 3</div><div class="line">Switzerland</div><div class="line">    Wengen : 46.608265,7.922065 : 3</div><div class="line">    Bern : 46.949076,7.448151 : 1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">﻿use v6;</div><div class="line"></div><div class="line">my $file=open &quot;wordpairs.txt&quot;, :r;</div><div class="line"></div><div class="line">my %dict;</div><div class="line">my $line;</div><div class="line"></div><div class="line">repeat &#123;</div><div class="line">    $line=$file.get;</div><div class="line">    my ($p1,$p2)=$line.split(&apos; &apos;);</div><div class="line">    if ?%dict&#123;$p1&#125; &#123;</div><div class="line">        %dict&#123;$p1&#125; = &quot;&#123;%dict&#123;$p1&#125;&#125; &#123;$p2&#125;&quot;.words;</div><div class="line">    &#125; else &#123;</div><div class="line">        %dict&#123;$p1&#125; = $p2;</div><div class="line">    &#125;</div><div class="line">&#125; while !$file.eof;</div></pre></td></tr></table></figure>
<p>wordpairs.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">it was</div><div class="line">was the</div><div class="line">the best</div><div class="line">best of</div><div class="line">of times</div><div class="line">times it</div><div class="line">it was</div><div class="line">was the</div><div class="line">the worst</div><div class="line">worst of</div><div class="line">of times</div><div class="line">times it</div><div class="line">it was</div><div class="line">was the</div><div class="line">the age</div><div class="line">age of</div><div class="line">of wisdom</div><div class="line">wisdom it</div></pre></td></tr></table></figure>
<h2 id="Great-List-Refactor"><a href="#Great-List-Refactor" class="headerlink" title="Great List Refactor"></a>Great List Refactor</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">﻿&gt; map &#123;$^x + 2&#125;, ( (1,2),3, (4,5))</div><div class="line">3 4 5 6 7</div><div class="line">&gt; map &#123;$_ + 2&#125;, ( (1,2),3, (4,5))</div><div class="line">3 4 5 6 7</div><div class="line">&gt; (10,(11,12,13),(14,15)).[2]</div><div class="line">14 15</div></pre></td></tr></table></figure>
<h2 id="Perl-6-Examples"><a href="#Perl-6-Examples" class="headerlink" title="Perl 6 Examples"></a>Perl 6 Examples</h2><hr>
<ul>
<li>1、生成8位随机密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my  @char_set = (0..9, &apos;a&apos;..&apos;z&apos;, &apos;A&apos;..&apos;Z&apos;,&apos;~&apos;,&apos;!&apos;,&apos;@&apos;,&apos;#&apos;,&apos;$&apos;,&apos;%&apos;,&apos;^&apos;,&apos;&amp;&apos;,&apos;*&apos;);</div><div class="line">say @char_set.pick(8).join(&quot;&quot;) # 不重复的8位密码</div><div class="line"></div><div class="line">say @char_set.roll(8).join(&quot;&quot;)  # 可以重复</div></pre></td></tr></table></figure>
<ul>
<li>2、打印前5个数字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.say for 1..10[^5]</div><div class="line">.say for 1,2,3,4 ... [^10]  # 这个会无限循环</div></pre></td></tr></table></figure>
<ul>
<li><p>3、排序</p>
</li>
<li><p>3.1 按数值排序</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; my %hash=&apos;Perl&apos;=&gt;100,&apos;Python&apos;=&gt;100,&apos;Go&apos;=&gt;100,&apos;CMD&apos;=&gt;20,&quot;Php&quot;=&gt;80,&quot;Java&quot;=&gt;85;</div><div class="line">&gt; %hash.values</div><div class="line">100 100 100 20 80 85</div><div class="line">&gt; %hash.values.sort</div><div class="line">20 80 85 100 100 100</div><div class="line">&gt; %hash.values.sort(-*)</div><div class="line">100 100 100 85 80 20</div></pre></td></tr></table></figure>
<ul>
<li>3.2 按分数排序散列：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my %hash = &apos;Perl&apos;=&gt;80,</div><div class="line">         &apos;Python&apos;=&gt;100,</div><div class="line">             &apos;Go&apos;=&gt;95,</div><div class="line">            &apos;CMD&apos;=&gt;20,</div><div class="line">            &quot;Php&quot;=&gt;80,</div><div class="line">           &quot;Java&quot;=&gt;85;</div><div class="line"></div><div class="line">for %hash.sort(&#123;-.value&#125;).hash.keys -&gt; $key &#123;</div><div class="line">    say $key, &quot;\t&quot;, %hash&#123;&quot;$key&quot;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># Python	100</div><div class="line"># Go	95</div><div class="line"># Java	85</div><div class="line"># Perl	80</div><div class="line"># Php	80</div><div class="line"># CMD	20</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt; (&apos;xx&apos;..&apos;zz&apos;).classify(*.substr(1))&lt;z&gt;</div><div class="line">xz yz zz</div><div class="line"></div><div class="line">加密：</div><div class="line">sub rot13 &#123; $^s.trans(&apos;a..z&apos; =&gt; &apos;n..za..m&apos;, &apos;A..Z&apos; =&gt; &apos;N..ZA..M&apos;) &#125;</div><div class="line"></div><div class="line"># 执行外部命令</div><div class="line">shell( &quot;ssh www.myopps.com uptime&quot; )</div><div class="line">shell( &quot;ls&quot; )</div><div class="line">shell( &quot;ls -a&quot; )</div><div class="line"># shell 将命令的执行结果直接发送到屏幕</div><div class="line"></div><div class="line">my $list = QX(&quot;ls&quot;)</div><div class="line"># 可以将命令的结果保存到变量中。</div><div class="line"></div><div class="line">#  批量创建文件夹</div><div class="line">for &apos;A&apos;.. &apos;Z&apos; -&gt; $i &#123; shell(&quot;mkdir $i&quot;) &#125;</div></pre></td></tr></table></figure>
<ul>
<li>4、求 1! + 2! + 3! + 4! +5! + 6! +7! +8! +9! +10!</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; multi sub postfix:&lt;!&gt;(Int $x)&#123; [*] 1..$x &#125;</div><div class="line">&gt; say [+] 1!,2!,3!,4!,5!,6!,7!,8!,9!,10! # 4037913</div></pre></td></tr></table></figure>
<ul>
<li>5、列出对象所有可用的方法<br>使用元对象协议， 即<code>对象名.^methods</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; &quot;SB&quot;.^methods</div></pre></td></tr></table></figure>
<blockquote>
<p>BUILD Int Num chomp chop substr pred succ match ords lines samecase samespace tr<br>im-leading trim-trailing trim words encode wordcase trans indent codes path WHIC<br>H Bool Str Stringy DUMP ACCEPTS Numeric gist perl comb subst split</p>
</blockquote>
<ul>
<li>6、 匿名子例程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $x = sub($a)&#123; $a+2 &#125;;say $x($_) for 1..4</div><div class="line">my $x = -&gt; $a &#123; $a+2 &#125;;say $x($_) for 1..4</div><div class="line">my $x = * + 2;say $x($_) for 1..4</div></pre></td></tr></table></figure>
<p>以后是不是不会写这种 <code>=*+2</code> 的都不好意思说自己会写Perl6</p>
<ul>
<li>7、字符串翻转与分割</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; 1223.flip</div><div class="line">3221</div><div class="line">&gt; &apos;abcd&apos;.flip</div><div class="line">dcba</div><div class="line">&gt; 1234.comb</div><div class="line">1 2 3 4</div><div class="line">&gt; 1234.comb(/./)</div><div class="line">1 2 3 4</div><div class="line">&gt; &apos;abcd&apos;.comb</div><div class="line">a b c d</div></pre></td></tr></table></figure>
<ul>
<li>8、有这么一个四位数A，其个位数相加得到B，将B 乘以 B的反转数后得到 A，请求出这个&gt;数字。</li>
</ul>
<p>举例， 1458 就符合这个条件，1+4+5+8 ＝ 18， 18 ＊ 81 ＝1458</p>
<p>请找出另一个符合上面条件的四位数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; (^37).map: &#123; my $r = $_ * .flip; 1000 &lt; $r and $_ == [+] $r.comb and say $r &#125;</div></pre></td></tr></table></figure>
<p>解释下：<br>(^37) 产生一个范围  0 .. ^37 , 就是 0到36之前的数，在表达式中代表 B</p>
<p>来个正常思维的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; my $b;</div><div class="line">&gt; for 1000..^10000 -&gt; $i &#123;$b=[+] $i.comb;say $i if $b*$b.flip == $i;&#125;</div></pre></td></tr></table></figure>
<p>1458<br>1729</p>
<ul>
<li>9、 大小写转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; my $word= &quot;I Love Perl 6&quot;</div><div class="line">I Love Perl 6</div><div class="line">&gt; $word.wordcase()</div><div class="line">I Love Perl 6</div><div class="line">&gt; my $lowercase = &quot;i love perl 6&quot;</div><div class="line">i love perl 6</div><div class="line">&gt; $lowercase.wordcase()</div><div class="line">I Love Perl 6</div><div class="line">&gt; $word.samecase(&apos;A&apos;)</div><div class="line">I LOVE PERL 6</div><div class="line">&gt; $word.samecase(&apos;a&apos;)</div><div class="line">i love perl 6</div><div class="line">&gt; $word.samecase(&apos;a&apos;).wordcase()</div><div class="line">I Love Perl 6</div></pre></td></tr></table></figure>
<ul>
<li>10、 多行文本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">my $string = q:to/THE END/;</div><div class="line">Norway</div><div class="line">    Oslo : 59.914289,10.738739 : 2</div><div class="line">    Bergen : 60.388533,5.331856 : 4</div><div class="line">Ukraine</div><div class="line">    Kiev : 50.456001,30.50384 : 3</div><div class="line">Switzerland</div><div class="line">    Wengen : 46.608265,7.922065 : 3</div><div class="line">THE END</div><div class="line"></div><div class="line">say $string;</div></pre></td></tr></table></figure>
<ul>
<li>11、 超运算符与子例程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line"></div><div class="line">my @a = &lt;1 2 3 4&gt;;</div><div class="line">sub by2($n)&#123;</div><div class="line">    return 2*$n;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub power2($n) &#123;</div><div class="line">    return $n ** 2;</div><div class="line">&#125;</div><div class="line">my @b = @a&gt;&gt;.&amp;by2&gt;&gt;.&amp;power2;</div><div class="line">say @b; # 4 16 36 64</div></pre></td></tr></table></figure>
<p>为什么是 &amp;function 呢：<br>the name of the by2 function is &amp;by2, just as the name of the foo scalar is $foo and the name of the foo array is @foo</p>
<ul>
<li>12、 如何在Perl 6 中执行外部命令并捕获输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; my $res = qqx&#123;mkdir 123456&#125;</div><div class="line"></div><div class="line"># 或使用 qx&#123; &#125;</div><div class="line">&gt; my $res = qx&#123;mkdir 112233&#125;</div></pre></td></tr></table></figure>
<ul>
<li>13、   Does Perl6 support something equivalent to Perl5’s <strong>DATA</strong> and <strong>END</strong> sections?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">=foo This is a Pod block. A single line one. This Pod block&apos;s name is &apos;foo&apos;.</div><div class="line"></div><div class="line">=begin qux</div><div class="line">This is another syntax for defining a Pod block.</div><div class="line">It allows for multi line content.</div><div class="line">This block&apos;s name is &apos;qux&apos;.</div><div class="line">=end qux</div><div class="line"></div><div class="line">=data A data block -- a Pod block with the name &apos;data&apos;.</div><div class="line"></div><div class="line"># Data blocks are P6&apos;s version of P5&apos;s __DATA__.</div><div class="line"># But you can have multiple data blocks:</div><div class="line"></div><div class="line">=begin data</div><div class="line">Another data block.</div><div class="line">This time a multi line one.</div><div class="line">=end data</div><div class="line"></div><div class="line">$=pod.grep(*.name eq &apos;data&apos;).map(*.contents[0].contents.say);</div><div class="line"></div><div class="line">say &apos;-&apos; x 45;</div><div class="line">for @$=pod &#123;</div><div class="line">  if .name eq &apos;data&apos; &#123;</div><div class="line">    say .contents[0].contents</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>14、生成含有26个英文字母和下划线的 junction</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; any(&apos;A&apos;..&apos;Z&apos;,&apos;a&apos;..&apos;z&apos;,&apos;_&apos;);</div><div class="line">any(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, _)</div></pre></td></tr></table></figure>
<ul>
<li>15、判断一个字符是否在某个集合中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;  so any(&apos;A&apos;..&apos;Z&apos;,&apos;a&apos;..&apos;z&apos;) ∈ set(&quot;12a34&quot;.comb)</div></pre></td></tr></table></figure>
<p>“12a34”.comb 会把字符串分割为单个字符，返回一个字符数组</p>
<ul>
<li>16、生成 IP 地址范围</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.say for &quot;192.168.10.&quot; &lt;&lt;~&gt;&gt; (0..255).list</div></pre></td></tr></table></figure>
<ul>
<li>17、 生成 OC 中的测试数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.say for &quot;@&quot; &lt;&lt;~&gt;&gt; &apos;&quot;Perl&apos; &lt;&lt;~&gt;&gt;  (1..30).list &lt;&lt;~&gt;&gt; &apos;&quot;,&apos;</div></pre></td></tr></table></figure>
<pre><code>@&quot;Perl&quot;1&quot;,
@&quot;Perl&quot;2&quot;,
@&quot;Perl&quot;3&quot;,
@&quot;Perl&quot;4&quot;,
@&quot;Perl&quot;5&quot;,
…
</code></pre><ul>
<li>18、我想以AGCT4种字母为基础生成字符串。</li>
</ul>
<p>比如希望长度为1，输出A,G,C,T。<br>如果长度为2，输出AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT。这样的结果。</p>
<p>@a X~ “”   # 长度为1<br>(@a X~ @a) # 长度为2<br>(@a X~ @a) X~ @a     # 长度为3<br>@a X~ @a X~ @a X~ @a # 长度为4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt; my @a=&lt;A G C T&gt;</div><div class="line">A G C T</div><div class="line">&gt; my $x=@a</div><div class="line">A G C T</div><div class="line">&gt; $x xx 2</div><div class="line">A G C T A G C T</div><div class="line">&gt; $x xx 3</div><div class="line">A G C T A G C T A G C T</div><div class="line">&gt; ($x xx 3).WHAT</div><div class="line">(List)</div><div class="line">&gt; $x.WHAT</div><div class="line">(Array)</div><div class="line"></div><div class="line">&gt; ([X~] $x xx 2).join(&apos;,&apos;)</div><div class="line">AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT</div></pre></td></tr></table></figure>
<p>惰性操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @a=&lt;A G C T&gt;;</div><div class="line">my $x=@a;  # 或者使用 $x =@(&apos;A&apos;,&apos;G&apos;,&apos;C&apos;,&apos;T&apos;)</div><div class="line">for 1 ...^ * -&gt; $a &#123;(([X~] $x xx $a)).join(&apos;,&apos;).say;last if $a==4;&#125;;</div></pre></td></tr></table></figure>
<h2 id="Best-Of-Perl-6"><a href="#Best-Of-Perl-6" class="headerlink" title="Best Of Perl 6"></a>Best Of Perl 6</h2><hr>
<ul>
<li>Command Line 命令行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">              Perl 5                                     Perl 6</div><div class="line">print &quot;bananas are good\n&quot;;                     say &quot;bananas are good&quot;;</div><div class="line">print &quot;and I said: $quotes&#123;\&quot;me\&quot;&#125;\n&quot;;          say &quot;and I said: %quotes&#123;&quot;me&quot;&#125;.&quot;;</div><div class="line">print &quot;and I said: $quotes&#123;\&quot;me\&quot;&#125;\n&quot;;          say &quot;and I said: %quotes&lt;me&gt;.&quot;;</div><div class="line">print &quot;What is ... &quot;;                           $result = prompt &quot;What is ... &quot;;</div><div class="line">chomp($result = &lt;&gt;);</div></pre></td></tr></table></figure>
<ul>
<li>File IO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">               Perl 5                                     Perl 6</div><div class="line"> $content = do &#123; local $/;                       $content = slurp &quot;poetry.txt&quot;;</div><div class="line">    open my $FH, &quot;poetry.txt&quot;; &lt;$FH&gt;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line">chomp(@content = do &#123;                            @content = lines &quot;poetry.txt&quot;;</div><div class="line">    open my $FH, &quot;poetry.txt&quot;; &lt;$FH&gt;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>Automatic multithreading</li>
</ul>
<p>Applying operations to junctions and arrays is now syntactically compact and readable. Perl 6 will create threads where appropriate to use multiple processors, cores or hyperthreading for high level language SIMD concurrent processing.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">              Perl 5                                     Perl 6</div><div class="line">my $sum;                                        my $sum = [+] @numbers;</div><div class="line">$sum += $_ for @numbers;</div><div class="line">for (0 .. $#factor1) &#123;                          @product = @factor1 &gt;&gt;*&lt;&lt; @factor2;</div><div class="line">  $product[$] = $factor1[$] * $factor2[$_];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The Perl 5 code is a simplification, of course Perl6 “does the right thing” when the arrays have different lengths.</p>
<ul>
<li>Comparison 比较</li>
</ul>
<p>Here are junctions, then chained comparison operators.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">              Perl 5                                     Perl 6</div><div class="line">if ($a == 3 or $a == 4 or $a == 7) &#123;...&#125;        if $a = 3 | 4 | 7 &#123;...&#125;</div><div class="line">if (4 &lt; $a and $a &lt; 12) &#123;...&#125;                   if 4 &lt; $a &lt; 12    &#123;...&#125;</div><div class="line">if (4 &lt; $a and $a &lt;= 12) &#123;...&#125;                  if $a ~~ 4^..12   &#123;...&#125;</div><div class="line">$a = defined $b ? $b : $c;                      $a = $b // $c;</div></pre></td></tr></table></figure>
<p>The defined-OR operator eases lot of cases where Perl 5 newbies could fall into traps.</p>
<ul>
<li>Case 结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">              Perl 5                                      Perl 6</div><div class="line">                                                    given $a &#123;</div><div class="line">if ($a == 2 or $a == 5) &#123;...&#125; &#125;&#125;                      when 2 | 5  &#123;...&#125;</div><div class="line">elsif ($a == 6 or $a == 7 or $a == 8 or $a == 9) &#123;&#125;   when 6 .. 9 &#123;...&#125;</div><div class="line">elsif ($a =~ /g/) &#123;...&#125;                               when &apos;g&apos;    &#123;...&#125;</div><div class="line">else &#123;...&#125;                                            default     &#123;...&#125;</div><div class="line">                                                    &#125;</div></pre></td></tr></table></figure>
<p>That new construct (backported to 5.10) is clear to read, very versatile and when used in combination with junctions, becomes even clearer.</p>
<ul>
<li>强大的循环</li>
</ul>
<p>List iteration via for is now much more versatile.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">              Perl 5                                     Perl 6</div><div class="line">for my $i (0..15) &#123;...&#125;                         for ^16 -&gt; $i        &#123;...&#125;</div><div class="line">for (my $i=15; $i&gt;1; $i-2) &#123;...&#125;                for 15,*-2...1 -&gt; $i &#123;...&#125;   # 15 13 11 9 7 5 3 1</div><div class="line">for my $key (keys %hash) &#123;                      for %hash.kv -&gt; $key, $value &#123;</div><div class="line">  print &quot;$key =&gt; $hash&#123;$key&#125;\n&quot;; ...              say &quot;$key =&gt; $value&quot;; ...</div><div class="line">for my $i (0..$#a) &#123;                            for zip(@a; @b; @c) -&gt; $a, $b, $c &#123;...&#125;</div><div class="line">  my $a = @a[$i];</div><div class="line">  my $b = @b[$i];</div><div class="line">  my $c = @c[$i]; ...</div></pre></td></tr></table></figure>
<ul>
<li>子例程中的具名参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">              Perl 5                                     Perl 6</div><div class="line">sub routine &#123;                                   sub routine ($a, $b, *@rest) &#123;...&#125;</div><div class="line">  my $a = shift;</div><div class="line">  my $b = shift;</div><div class="line">  my @rest = @_;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Objects with auto generated new and getters and setters</li>
</ul>
<p>Simple Object creation is now as easy as it gets.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">              Perl 5                                     Perl 6</div><div class="line">package Heart::Gold;                            class Heart::Gold &#123;</div><div class="line">                                                  has $.speed;</div><div class="line">sub new &#123;                                         method stop &#123; $.speed = 0 &#125;</div><div class="line">  bless &#123;speed =&gt; 0 &#125;, shift;                   &#125;  </div><div class="line">&#125;</div><div class="line">                                                my Heart::Gold $hg1 .= new;</div><div class="line">sub speed &#123;                                     $hg1.speed = 100;</div><div class="line">  my $self = shift;                             my $hg2 = $hg1.clone;</div><div class="line">  my $speed = shift;</div><div class="line">  if (defined $speed) &#123; $self-&gt;&#123;speed&#125; = $speed &#125;</div><div class="line">  else &#123; $self-&gt;&#123;speed&#125; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub stop &#123;</div><div class="line">  my $self = shift;</div><div class="line">  $self-&gt;&#123;speed&#125; = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Perl-6-Variable"><a href="#Perl-6-Variable" class="headerlink" title="Perl 6 Variable"></a>Perl 6 Variable</h2><hr>
<ul>
<li>Variable Types</li>
</ul>
<p>Perl 6 (as Perl 5) knows 3 basic types of variables: Scalars (single values), Arrays (ordered and indexed lists of several values) and Hashes (2 column table, with ID and associated value pairs). They can be easily distinguished, because in front of their name is a special character called sigil (latin for sign). It’s the $ (similar to S) for Scalars, @ (like an a) for Arrays and a % (kv pair icon) for a Hash. They are now invariant (not changing), which means for instance, an array vaiable starts always with an @, even if you just want a slice of the content.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$scalar</div><div class="line">@array</div><div class="line">@array[1]              # $array[1]   in Perl 5</div><div class="line">@array[1,2]            # @array[1,2] in Perl 5</div><div class="line">%hash</div><div class="line">%hash&#123;&apos;ba&apos;&#125;            # $hash&#123;&apos;ba&apos;&#125; in Perl 5</div><div class="line">%hash&#123;&apos;ba&apos;,&apos;da&apos;,&apos;bim&apos;&#125; # @hash&#123;&apos;ba&apos;,&apos;da&apos;,&apos;bim&apos;&#125; in Perl 5</div></pre></td></tr></table></figure>
<p>The sigils also mark distinct namespaces, meaning: in one lexical scope you can have 3 different variables named $stuff, @stuff and %stuff. These sigils can also be used as an operator to enforce a context in which the following data will be seen.</p>
<p>The fourth namespace is for subroutines and similar, even if you don’t usually think of them as variables. It’s sigil &amp; is used to refer to subroutines without calling them.</p>
<p>All special namespaces from Perl 5 (often marked with special syntax), like tokens (<strong>PACKAGE</strong>), formats, file or dir handles, or builtins are now regular variables or routines.</p>
<p>Because all variables contain objects, they have methods. In fact, all operators, including square or curly bracket subscripts, are just methods of an object with a fancy name.</p>
<p>The primary sigil can be followed by a secondary sigil, called a twigil, which indicates a special scope for that variable.</p>
<p>Scalar</p>
<p>This type stores one value, usually a reference to something: a value of a data type, a code object, an object or a compound of values like a pair, junction, array, hash or capture. The scalar context is now called item context, hence the scalar instruction from Perl 5 was renamed to item.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$CHAPTER = 3;              # first comment!</div><div class="line">$bin = 0b11;               # same value in binary format</div><div class="line">$pi = 3.14159_26535_89793; # the underscores just ease reading</div><div class="line">$float = 6.02e-23;         # floating number in scientific notation</div><div class="line">$text = &apos;Welcome all!&apos;;    # single quoted string</div><div class="line"></div><div class="line"># double quoted string, does eval $pi to it&apos;s content</div><div class="line">$text = &quot; What is $pi?&quot;;</div><div class="line">$text = q:to&apos;EOT&apos;;         # heredoc string</div><div class="line"></div><div class="line">    handy for multiline text</div><div class="line">    like HTML templates or email</div><div class="line"></div><div class="line">EOT</div><div class="line">$handle = open $file_name; # file handle</div><div class="line"># an object from a class with a nested namespace</div><div class="line">$object = Class::Name.new();</div><div class="line">$condition = 3|5|7;                # a junction, a logical conjunction of values</div><div class="line">$arrayref = [0,1,1,2,3,5,8,13,21]; # an array stored as a single item</div><div class="line"></div><div class="line"># a hash stored as a single item</div><div class="line">$hashref = &#123;&apos;audreyt&apos; =&gt; &apos;pugs&apos;,</div><div class="line">            &apos;pm&apos;      =&gt; &apos;pct&apos;,</div><div class="line">            &apos;damian&apos;  =&gt; &apos;larrys evil henchman&apos;&#125;;</div><div class="line"># pointing to a callable</div><div class="line">$coderef = sub &#123; do_something_completely_diffenent(@_) &#125;;</div></pre></td></tr></table></figure>
<p>(For info on some of those terms: comment, binary format, the underscores ease reading, scientific notation, single-quoted string, double-quoted string, heredoc string, file handle, class, junction, list of values, hash, callable.)</p>
<p>Unlike Perl 5, references are automatically dereferenced to a fitting context. So you could use these $arrayrefs and $hashrefs similarly to an array or hash, making $ the universal variable prefix, pretty much like in PHP. The primary difference is that $ prefixed lists are not flattened in lists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my $a = (1, 2, 3);</div><div class="line">my @a = 1, 2, 3;</div><div class="line">for $a &#123; &#125;          # just one iteration</div><div class="line">for @a &#123; &#125;          # three iterations</div></pre></td></tr></table></figure>
<p>Scalar Methods</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $chapter = 3;</div><div class="line">undefine $chapter;</div><div class="line">defined $a; # false, returns 0</div></pre></td></tr></table></figure>
<ul>
<li>Array</li>
</ul>
<p>An array is an ordered and indexed list of scalars. If not specified otherwise, they can be changed, expanded and shortened anytime and used as a list, stack, queue and much more. As in Haskell, lists are processed lazily, which means: the compiler looks only at the part it currently needs. This way Perl 6 can handle infinite lists or do computation on lists that have not been computed yet. The lazy command enforces this and the eager command forces all values to be computed.</p>
<p>The list context is forced with a @() operator or list() command. That’s not autoflattening like in Perl 5 (automatically convert a List of Lists into one List). If you still want that, say flat(). Or say lol() to explicitly prevent autoflattening.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@primes = (2,3,5,7,11,13,17,19,23); # an array gets filled like in Perl 5</div><div class="line">@primes =  2,3,5,7,11,13,17,19,23 ; # same thing, since unlike P5 round braces just do group</div><div class="line">@primes = &lt;2 3 5 7 11 13 17 19 23&gt;; # ditto, &lt;&gt; is the new qw()</div><div class="line">$primes = (2,3,5,7,11,13,17,19,23); # same array object just sits in $primes, $primes[0] is 2</div><div class="line">$primes = item @primes;             # same thing, more explicit</div><div class="line">$primes = 2,;                       # just 2, first element of the Parcel</div><div class="line">@primes = 2;                        # array with one element</div><div class="line">@primes = [2,3,5,7,11,13,17,19,23]; # array with one element (List of Lists - LoL)</div><div class="line">@dev    = &#123;&apos;dan&apos; =&gt; &apos;parrot&apos;&#125;;      # array with one element (a Hash)</div><div class="line">@data   = [1..5],[6..10],[11..15];  # Array of Arrays (LoL)</div><div class="line">@list   = lol @data;                # no change</div><div class="line">@list   = flat @data;               # returns 1..15</div></pre></td></tr></table></figure>
<ul>
<li>Array Slices</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@primes                       # all values as list</div><div class="line">@primes.values                # same thing</div><div class="line">@primes.keys                  # list of all indices</div><div class="line">&quot;@primes[]&quot;                   # insert all values in a string, uses [] to distinguish from mail adresses</div><div class="line">$prime = @primes[0];          # get the first prime</div><div class="line">$prime = @primes[*-1];        # get the last one</div><div class="line">@some = @primes[2..5];        # get several</div><div class="line">$cell = @data[1][2];          # get 8, third value of second value (list)</div><div class="line">$cell = @data[1;2];           # same thing, shorten syntax</div><div class="line">@numbers = @data[1];          # get a copy of the second subarray (6..10)</div><div class="line">@copy = @data;                # shallow copy of the array</div></pre></td></tr></table></figure>
<ul>
<li>Array Methods</li>
</ul>
<p>Some of the more important things you can do with lists. All the methods can also used like ops in “elems @array;”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">? @array;              # boolean context, Bool::True if array has any value in it, even if it&apos;s a 0</div><div class="line">+ @array;              # numeric context, number of elements (like in Perl 5 scalar @a)</div><div class="line">~ @array;              # string context, you get content of all cells, stringified and joined, same as &quot;@primes[]&quot;</div><div class="line"></div><div class="line">@array.elems;          # same as + @array</div><div class="line">@array.end;            # number of the last element, equal to @array.elems-1</div><div class="line">@array.cat;            # same ~ @array</div><div class="line">@array.join(&apos;&apos;);       # also same result, you can put another string as parameter that gets between all values</div><div class="line">@array.unshift;        # prepend one value to the array</div><div class="line">@array.shift;          # remove the first value and return it</div><div class="line">@array.push;           # add one value on the end</div><div class="line">@array.pop;            # remove one value from the end and return it</div><div class="line">@array.splice($pos,$n);# starting at $pos remove $n values and replace them with values that follow those two</div></pre></td></tr></table></figure>
<ul>
<li>parameters</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@array.delete(@ind);   # delete all cells with indices in @ind</div><div class="line">@array.exists(@ind);   # Bool::True if all indices of @ind have a value (can be 0 or &apos;&apos;)</div><div class="line">@array.pick([$n]);     # return $n (default is 1) randomly selected values, without duplication</div><div class="line">@array.roll([$n]);     # return $n (default is 1) randomly selected values, duplication possible (like roll dice)</div><div class="line">@array.reverse;        # all elements in reversed order</div><div class="line"># returns a list where $n times first item is taken to last</div><div class="line"># position if $n is positive, if negative the other way around</div><div class="line">@array.rotate($n);</div><div class="line"></div><div class="line">@array.sort($coderef); # returns a list sorted by a user-defined criteria, default is alphanumerical sorting</div><div class="line">@array.min;            # numerical smallest value of that array</div><div class="line">@array.max;            # numerical largest value of that array</div><div class="line">$a,$b= @array.minmax;  # both at once, like in .sort,  .min, or .max, a sorting algorithm can be provided</div><div class="line"></div><div class="line">@array.map($coderef);  # high oder map function, runs $coderef with every value as $_ and returns the list or results</div><div class="line">@array.classify($cr);  # kind of map, but creates a hash, where keys are the results of $cr and values are from @array</div><div class="line">@array.categorize($cr);# kind of classify, but closure can have no (Nil) or several results, so a key can have a list of values</div><div class="line">@array.grep(&#123;$_&gt;1&#125;);   # high order grep, returns only these elements that pass a condition ($cr returns something positive)</div><div class="line">@array.first($coder);  # kind of grep, return just the first matching value</div><div class="line">@array.zip;            # join arrays by picking first element left successively from here and then there</div><div class="line">There is even a whole class of metaoperators that work upon lists.</div></pre></td></tr></table></figure>
<ul>
<li>Hash</li>
</ul>
<p>In Perl 6 a Hash is an unordered list of Pairs. A Pair is a single key =&gt; value association and appears in many places of the language syntax. A hash allows lookup of values by key using {} or &lt;&gt; syntax.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">%dev =  &apos;pugs&apos;=&gt;&apos;audreyt&apos;, &apos;pct&apos;=&gt;&apos;pm&apos;, &quot;STD&quot;=&gt;&apos;larry&apos;;</div><div class="line">%dev = :rakudo(&apos;jnthn&apos;), :testsuite(&apos;moritz&apos;);            # adverb (pair) syntax works as well</div><div class="line">%dev = (&apos;audreyt&apos;, &apos;pugs&apos;, &apos;pm&apos;, &apos;pct&apos;, &apos;larry&apos;, &quot;STD&quot;);  # lists get autoconverted in hash context</div><div class="line">%compiler = Parrot =&gt; &#123;Rakudo =&gt; &apos;jnthn&apos;&#125;, SMOP =&gt; &#123;Mildew =&gt; &apos;ruoso&apos;&#125;;       # hash of hashes (HoH)</div></pre></td></tr></table></figure>
<ul>
<li>Hash Slices</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$value = %dev&#123;&apos;key&apos;&#125;;      # just give me the value related to that key, like in P5</div><div class="line">$value = %dev&lt;pm&gt;;         # &lt;&gt; autoquotes like qw() in P5</div><div class="line">$value = %dev&lt;&lt;$name&gt;&gt;;    # same thing, just with eval</div><div class="line">@values = %dev&#123;&apos;key1&apos;, &apos;key2&apos;&#125;;</div><div class="line">@values = %dev&lt;key1 key2&gt;;</div><div class="line">@values = %dev&lt;&lt;key1 key2 $key3&gt;&gt;;</div><div class="line">%compiler&lt;Parrot&gt;&lt;Rakudo&gt;; # value in a HoH, returns &apos;jnthn&apos;</div><div class="line">%compiler&lt;SMOP&gt;;           # returns the Pair: Mildew =&gt; &apos;ruoso&apos;</div><div class="line"></div><div class="line">%dev   &#123;&apos;audrey&apos;&#125;;         # error, spaces between varname and braces (postcircumfix operator) are no longer allowed</div><div class="line">%dev\  &#123;&apos;allison&apos;&#125;;        # works, quote the space</div><div class="line">%dev   .&lt;dukeleto&gt;;        # error</div><div class="line">%dev\ .&#123;&apos;patrick&apos;&#125;;        # works too, &quot;long dot style&quot;, because it&apos;s an object in truth</div></pre></td></tr></table></figure>
<ul>
<li>Hash Methods</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">? %dev                     # bool context, true if hash has any pairs</div><div class="line">+ %dev                     # numeric context, returns number of pairs(keys)</div><div class="line">~ %dev                     # string context, nicely formatted 2 column table using \t and \n</div><div class="line"></div><div class="line">$table = %dev;             # same as ~ %dev</div><div class="line">%dev.say;                  # stringified, but only $key and $value are separated by \t</div><div class="line">@pairs = %dev;             # list of all containing pairs</div><div class="line">%dev.pairs                 # same thing in all context</div><div class="line">%dev.elems                 # same as + %dev or + %dev.pairs</div><div class="line">%dev.keys                  # returns a list of all keys</div><div class="line">%dev.values                # list of all values</div><div class="line">%dev.kv                    # flat list with key1, value1, key 2 ...</div><div class="line">%dev.invert                # reverse all key =&gt; value relations</div><div class="line">%dev.push (@pairs)         # inserts a list of pairs, if a key is already present in %dev, both values gets added to an array</div></pre></td></tr></table></figure>
<ul>
<li>Callable</li>
</ul>
<p>Internally subroutines, methods and alike are variables with the sigil &amp; and stored in a fourth namespace. Unlike Perl 5, all subroutines can be overwritten or augmented with user defined routines. Of course scalars can also contain routines.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&amp;function = sub &#123; ... &#125;;         # store subroutine in callable namespace</div><div class="line">function();                      # call/run it</div><div class="line"></div><div class="line">$coderef = sub &#123; ... &#125;;          # store it in a scalar</div><div class="line">$coderef($several, $parameter);  # run that code</div></pre></td></tr></table></figure>
<ul>
<li>Data Types</li>
</ul>
<p>In contrast to variable types (container types) every value has a type too. These are organized internally as classes or roles and can be categorized into 3 piles: the undefined, immutable, and the mutable types.</p>
<p>You can assign one of these types to scalar, array, or hash variables, which enforces the contents to be that type.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my Int $a;</div><div class="line">my Int @a;  # array of Int</div></pre></td></tr></table></figure>
<ul>
<li>Pair</li>
</ul>
<p>Pairs are new and their syntax is used nearly everywhere in the language where there is an association between a name and a value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$pair = &apos;jakub&apos; =&gt; &apos;helena&apos;;  # &quot;=&gt;&quot; is the pair constructor</div><div class="line">$pair = :jakub(&apos;helena&apos;);     # same in adverbial notation</div><div class="line">$pair = :jakub&lt;helena&gt;;       # same using &lt;&gt;, the new qw()</div><div class="line">$pair.key                     # returns &apos;jakub&apos;</div><div class="line">$pair.value                   # returns &apos;helena&apos;</div><div class="line">$pair.isa(Pair)               # Bool::True</div></pre></td></tr></table></figure>
<ul>
<li>Enumeration</li>
</ul>
<p>enum</p>
<ul>
<li>Capture</li>
</ul>
<p>Captures are also a new type, which holds the parameters a routine gets. Because Perl now knows both positional and named parameters, it is a mixture of a list and array.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$cap = \(@a,$s,%h,&apos;a&apos;=&gt;3);    # creating a capture, &quot;\&quot; was free since there are no references anymore</div><div class="line">|$cap                         # flatten into argument list (without |, it will pass it as a single value)</div><div class="line">||$cap                        # flatten into semicolon list (meant for variadic functions that take list of lists)</div></pre></td></tr></table></figure>
<p>One important difference between a capture and a compound structure of lists and hashes: While assignments with = will copy the complete content of the named variables, this is not so in the case of a capture. When I change sinthelastexample, thecontentofcap changes too, because when parameters to a routine are variables, they are also interpolated in the moment the routine is called, not when it’s defined.</p>
<ul>
<li>Properties and Traits</li>
</ul>
<p>Properties</p>
<p>xxx</p>
<p>Traits</p>
<p>xxx</p>
<p>Scoping</p>
<p>scope declarator, scopes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my $var;</div><div class="line">state</div><div class="line">temp</div><div class="line">let</div><div class="line">our $var;</div><div class="line">$*var;</div><div class="line">Twigils</div></pre></td></tr></table></figure>
<p>xxx</p>
<ul>
<li>Assignment and Binding</li>
</ul>
<p>Assignment</p>
<p>As rightfully expected, assignments are done with the equal sign. But unlike Perl 5 you always get a copy of the right side data assigned to the left, no matter how nested the data structure was (lists of lists eg). You never get in Perl 6 a reference with =. The only exception may be seen captures.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @original = [1,2],[3,4];</div><div class="line">my $copy = @original[0]; # $copy points to [1,2]</div><div class="line">@original[0][0] = &apos;fresh stuff&apos;; # $copy[0] holds still 1</div></pre></td></tr></table></figure>
<ul>
<li>Binding</li>
</ul>
<p>Since every variable in Perl 6 is a reference, programmers can use binding to get 2 variables that point to the same memory location.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$original = 5;</div><div class="line">$original := $mirror;       # normal binding, done on runtime</div><div class="line">$original ::= $mirror;      # same thing, but done during compile time</div><div class="line">$original = 3;</div><div class="line">say $mirror;                # prints 3</div><div class="line">$original =:= $mirror       # true, because they&apos;re bound together</div><div class="line">$original === $mirror       # also true, because content and type are equal</div></pre></td></tr></table></figure>
<p>——-<br>    问题描述：</p>
<p>给定 2 个整数， A 和 B。 求这两个数的和</p>
<pre><code>输入数据：
A 和 B 来自输入流， 以空格分割

输出数据：
两个数据的和

Example：

Input    Output
2   2      4
3   2      5
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say [+] .words for lines</div></pre></td></tr></table></figure>
<p>——-</p>
<pre><code>任务：
以任意的顺序生成 含有 N 个开括号&quot;[&quot;  和 N 个闭括号&quot;]&quot; 的字符串

检查生成的字符串是否平衡
Example：
</code></pre><p>   (empty)   OK</p>
<p>   []        OK   ][        NOT OK</p>
<p>   [][]      OK   ][][      NOT OK</p>
<p>   [[][]]    OK   []][[]    NOT OK</p>
<ul>
<li>Depth counter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sub balanced($s) &#123;</div><div class="line">    my $l = 0;</div><div class="line">    for $s.comb &#123;</div><div class="line">        when &quot;]&quot; &#123;</div><div class="line">            --$l;</div><div class="line">            return False if $l &lt; 0;</div><div class="line">        &#125;</div><div class="line">        when &quot;[&quot; &#123;</div><div class="line">            ++$l;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return $l == 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $n = prompt &quot;Number of brackets&quot;;</div><div class="line">my $s = (&lt;[ ]&gt; xx $n).pick(*).join;</div><div class="line">say &quot;$s &#123;balanced($s) ?? &quot;is&quot; !! &quot;is not&quot;&#125; well-balanced&quot;</div></pre></td></tr></table></figure>
<ul>
<li>FP oriented</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sub balanced($s) &#123;</div><div class="line">    .none &lt; 0 and .[*-1] == 0</div><div class="line">        given [\+] &apos;\\&apos; «leg« $s.comb;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $n = prompt &quot;Number of bracket pairs: &quot;;</div><div class="line">my $s = &lt;[ ]&gt;.roll($n*2).join;</div><div class="line">say &quot;$s &#123; balanced($s) ?? &quot;is&quot; !! &quot;is not&quot; &#125; well-balanced&quot;</div></pre></td></tr></table></figure>
<ul>
<li>String munging</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sub balanced($_ is copy) &#123;</div><div class="line">    () while s:g/&apos;[]&apos;//;</div><div class="line">    $_ eq &apos;&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $n = prompt &quot;Number of bracket pairs: &quot;;</div><div class="line">my $s = &lt;[ ]&gt;.roll($n*2).join;</div><div class="line">say &quot;$s is&quot;, &apos; not&apos; xx not balanced($s)), &quot; well-balanced&quot;;</div></pre></td></tr></table></figure>
<ul>
<li>Parsing with a grammar</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grammar BalBrack &#123; token TOP &#123; &apos;[&apos; &lt;TOP&gt;* &apos;]&apos; &#125; &#125;</div><div class="line"></div><div class="line">my $n = prompt &quot;Number of bracket pairs: &quot;;</div><div class="line">my $s = (&apos;[&apos; xx $n, &apos;]&apos; xx $n).pick(*).join;</div><div class="line">say &quot;$s &#123; BalBrack.parse($s) ?? &quot;is&quot; !! &quot;is not&quot; &#125; well-balanced&quot;;</div></pre></td></tr></table></figure>
<p>——-</p>
<ul>
<li>凯撒加密</li>
</ul>
<p>实现一个凯撒加密， 编码和解码都要有</p>
<p> key 是一个 1 到 25 之间的整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">my @alpha = &apos;A&apos; .. &apos;Z&apos;;</div><div class="line">sub encrypt ( $key where 1..25, $plaintext ) &#123;</div><div class="line">    $plaintext.trans( @alpha Z=&gt; @alpha.rotate($key) );</div><div class="line">&#125;</div><div class="line">sub decrypt ( $key where 1..25, $cyphertext ) &#123;</div><div class="line">    $cyphertext.trans( @alpha.rotate($key) Z=&gt; @alpha );</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $original = &apos;THE FIVE BOXING WIZARDS JUMP QUICKLY&apos;;</div><div class="line">my $en = encrypt( 13, $original );</div><div class="line">my $de = decrypt( 13, $en );</div><div class="line"></div><div class="line">.say for $original, $en, $de;</div><div class="line"></div><div class="line">say &apos;OK&apos; if $original eq all( map &#123; .&amp;decrypt(.&amp;encrypt($original)) &#125;, 1..25 );</div></pre></td></tr></table></figure>
<pre><code>Output:
THE FIVE BOXING WIZARDS JUMP QUICKLY
GUR SVIR OBKVAT JVMNEQF WHZC DHVPXYL
THE FIVE BOXING WIZARDS JUMP QUICKLY
OK
</code></pre><p>——-</p>
<ul>
<li>日期格式化</li>
</ul>
<p>使用 “2007-11-10” 和 “ Sunday, November 10, 2007” 日期格式显式当前日期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">use DateTime::Utils;</div><div class="line"></div><div class="line">my $dt = DateTime.now;</div><div class="line"></div><div class="line">say strftime(&apos;%Y-%m-%d&apos;, $dt);</div><div class="line">say strftime(&apos;%A, %B %d, %Y&apos;, $dt);</div></pre></td></tr></table></figure>
<p>——-</p>
<ul>
<li><p>阶乘</p>
<p>n 的阶乘定义为 <code>n*(n-1)*(n-2)…*1</code>, 零的阶乘为1.</p>
<p>定义一个函数返回一个数字的阶乘。</p>
</li>
<li><p>使用自定义后缀操作符</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub postfix:&lt;!&gt;($n where $n &gt; 0) &#123;</div><div class="line">    [*] 2..$n</div><div class="line">&#125;</div><div class="line">say 5!</div></pre></td></tr></table></figure>
<ul>
<li>[*]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my @a = 1, [\*] 1..*;</div><div class="line">say @a[5];</div></pre></td></tr></table></figure>
<p>——-</p>
<ul>
<li>动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my $row-count = 6;</div><div class="line"></div><div class="line">constant $peg = &quot;*&quot;;</div><div class="line">constant @coin-icons = &quot;\c[UPPER HALF BLOCK]&quot;, &quot;\c[LOWER HALF BLOCK]&quot;;</div><div class="line"></div><div class="line">sub display-board(@positions, @stats is copy, $halfstep) &#123;</div><div class="line">    my $coin = @coin-icons[$halfstep.Int];</div><div class="line"></div><div class="line">    state @board-tmpl = &#123;</div><div class="line">        # precompute a board</div><div class="line">        my @tmpl;</div><div class="line">        sub out(*@stuff) &#123;</div><div class="line">            @tmpl.push: @stuff&gt;&gt;.ords.item;</div><div class="line">        &#125;</div><div class="line">        # three lines of space above</div><div class="line">        for (1..3) &#123;</div><div class="line">            out &quot;  &quot;, &quot; &quot; x (2 * $row-count);</div><div class="line">        &#125;</div><div class="line">        # $row-count lines of pegs</div><div class="line">        for ($row-count...1) Z (1...$row-count) -&gt; $spaces, $pegs &#123;</div><div class="line">            out &quot;  &quot;, &quot; &quot; x $spaces, ($peg xx $pegs).join(&quot; &quot;), &quot; &quot; x $spaces;</div><div class="line">        &#125;</div><div class="line">        # four lines of space below</div><div class="line">        for (1..4) &#123;</div><div class="line">            out &quot;  &quot;, &quot; &quot; x (2 * $row-count);</div><div class="line">        &#125;</div><div class="line">        @tmpl</div><div class="line">    &#125;();</div><div class="line"></div><div class="line">    my $midpos = $row-count + 2;</div><div class="line"></div><div class="line">    my @output;</div><div class="line">    &#123;</div><div class="line">        # collect all the output and output it all at once at the end</div><div class="line">        sub say(Str $foo) &#123;</div><div class="line">            @output.push: $foo, &quot;\n&quot;;</div><div class="line">        &#125;</div><div class="line">        sub print(Str $foo) &#123;</div><div class="line">            @output.push: $foo;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # make some space above the picture</div><div class="line">        say &quot;&quot; for ^10;</div><div class="line"></div><div class="line">        my @output-lines = map &#123; [map *.clone, @$_].item &#125;, @board-tmpl;</div><div class="line">        # place the coins</div><div class="line">        for @positions.kv -&gt; $line, $pos &#123;</div><div class="line">            next unless $pos.defined;</div><div class="line">            @output-lines[$line][$pos + $midpos] = $coin.ord;</div><div class="line">        &#125;</div><div class="line">        # output the board with its coins</div><div class="line">        for @output-lines -&gt; @line &#123;</div><div class="line">            say @line&gt;&gt;.chr.join(&quot;&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # show the statistics</div><div class="line">        my $padding = 0;</div><div class="line">        while any(@stats) &gt; 0 &#123;</div><div class="line">            $padding++;</div><div class="line">            print &quot;  &quot;;</div><div class="line">            @stats = do for @stats -&gt; $stat &#123;</div><div class="line">                given $stat &#123;</div><div class="line">                    when 1 &#123;</div><div class="line">                        print &quot;\c[UPPER HALF BLOCK]&quot;;</div><div class="line">                        $stat - 1;</div><div class="line">                    &#125;</div><div class="line">                    when * &lt;= 0 &#123;</div><div class="line">                        print &quot; &quot;;</div><div class="line">                        0</div><div class="line">                    &#125;</div><div class="line">                    default &#123;</div><div class="line">                        print &quot;\c[FULL BLOCK]&quot;;</div><div class="line">                        $stat - 2;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            say &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        say &quot;&quot; for $padding...^10;</div><div class="line">    &#125;</div><div class="line">    say @output.join(&quot;&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub simulate($coins is copy) &#123;</div><div class="line">    my $alive = True;</div><div class="line"></div><div class="line">    sub hits-peg($x, $y) &#123;</div><div class="line">        if 3 &lt;= $y &lt; 3 + $row-count and -($y - 2) &lt;= $x &lt;= $y - 2 &#123;</div><div class="line">            return not ($x - $y) %% 2;</div><div class="line">        &#125;</div><div class="line">        return False;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    my @coins = Int xx (3 + $row-count + 4);</div><div class="line">    my @stats = 0 xx ($row-count * 2);</div><div class="line">    # this line will dispense coins until turned off.</div><div class="line">    @coins[0] = 0;</div><div class="line">    while $alive &#123;</div><div class="line">        $alive = False;</div><div class="line">        # if a coin falls through the bottom, count it</div><div class="line">        given @coins[*-1] &#123;</div><div class="line">            when *.defined &#123;</div><div class="line">                @stats[$_ + $row-count]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # move every coin down one row</div><div class="line">        for ( 3 + $row-count + 3 )...1 -&gt; $line &#123;</div><div class="line">            my $coinpos = @coins[$line - 1];</div><div class="line"></div><div class="line">            @coins[$line] = do if not $coinpos.defined &#123;</div><div class="line">                Nil</div><div class="line">            &#125; elsif hits-peg($coinpos, $line) &#123;</div><div class="line">                # when a coin from above hits a peg, it will bounce to either side.</div><div class="line">                $alive = True;</div><div class="line">                ($coinpos - 1, $coinpos + 1).pick;</div><div class="line">            &#125; else &#123;</div><div class="line">                # if there was a coin above, it will fall to this position.</div><div class="line">                $alive = True;</div><div class="line">                $coinpos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        # let the coin dispenser blink and turn it off if we run out of coins</div><div class="line">        if @coins[0].defined &#123;</div><div class="line">            @coins[0] = Nil</div><div class="line">        &#125; elsif --$coins &gt; 0 &#123;</div><div class="line">            @coins[0] = 0</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # smooth out the two halfsteps of the animation</div><div class="line">        my $start-time;</div><div class="line">        ENTER &#123; $start-time = now &#125;</div><div class="line">        my $wait-time = now - $start-time;</div><div class="line"></div><div class="line">        sleep 0.1 - $wait-time if $wait-time &lt; 0.1;</div><div class="line">        for @coin-icons.keys &#123;</div><div class="line">            sleep $wait-time max 0.1;</div><div class="line">            display-board(@coins, @stats, $_);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sub MAIN($coins = 20, $peg-lines = 6) &#123;</div><div class="line">    $row-count = $peg-lines;</div><div class="line">    simulate($coins);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用方式： perl6 Galton_box_animation.p6 50 8</p>
<p>——-</p>
<ul>
<li>列表和迭代</li>
</ul>
<p>Perl 6 中的列表扩展为惰性列表、无限列表、元素可变列表、元素不可变列表、类型列表、展开行为等等。</p>
<p>对于程序员来说，列表潜在是懒惰并含有无限元素的序列。列表是可变的，你可以通过诸如 push、pop、shift、unshift、splice等操作符来操作序列。列表中的元素可以是可变的或者不可变的。</p>
<p>列表对象是基于位置的，意味着它们能被绑定到数组变量上，并且支持 <code>.[]</code> 后缀操作符。</p>
<p>列表也是懒惰的，因为列表中的元素可以来自于能按需产生元素的生成函数（叫做迭代）。</p>
<p>数组就是一个所有元素都存储在标量容器的列表。</p>
<p>逗号操作符 <code>infix:&lt;,&gt;</code> 创建 Parcel 对象。这些不应该改和列表混淆； Parcel 是一种未经加工的元素序列。Parcel 是不可变的，尽管 Parcel中的元素可以是不可变的，也可是不可变的。</p>
<p>Parcel 来自于短语  “parenthesis cell”. 因为很多 Parcel 对象出现在圆括号里面。然而，除了空的 parcel，是逗号操作符创建了 Parcel 对象。</p>
<pre><code>()       # empty Parcel
(1)      # 一个整数
(1,2)    # a Parcel with two Ints
(1,)     # a Parcel with one Int
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; (1).WHAT()</div><div class="line">(Int)</div><div class="line">&gt; (1,).WHAT()</div><div class="line">(Parcel)</div></pre></td></tr></table></figure>
<p>Parcel 也是位置的，并且对于诸如  <code>.[]</code> 和 <code>.elems</code> 列表操作会使用 展开上下文。查看下面的  “Flattening contexts”。访问没有展开的原始参数，你可以使用 <code>.arg($n)</code> 代替 <code>.[$n]</code>, 和 <code>.args</code> 代替 <code>.elems</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt; (1,2,3).elems</div><div class="line">3</div><div class="line">&gt; (1,2,3).[2]</div><div class="line">3</div><div class="line">&gt; (1,2,3).[1]</div><div class="line">2</div><div class="line"></div><div class="line">&gt; my $a =(1,2,3,(4,5,6),7).[3]</div><div class="line">4 5 6</div><div class="line">&gt; $a.WHAT.say</div><div class="line">(Parcel)</div><div class="line">&gt; $a.[2]</div><div class="line">6</div><div class="line">&gt; $a.[1]</div><div class="line">5</div><div class="line"></div><div class="line">&gt; [+] $a.list</div><div class="line">15</div></pre></td></tr></table></figure>
<p>列表和Parcel 对象都把其它容器对象作为元素。在一些上下文中，我们想把容器对象的值插入到列表或 parcel的周围，而在其它上下文中，我们想保留所有的子容器。这样的插值叫做 展开。</p>
<p>列表和Parcel都是可迭代的，可迭代表明它支持 <code>.iterator</code> 方法</p>
<p>标量容器中存储的对象不会在 flattening 上下文中插值，即使那个对象是可迭代的。</p>
<pre><code>my @a = 3,4,5;
for 1,2,@a  { .say }        # 5次迭代
</code></pre><p>1<br>2<br>3<br>4<br>5</p>
<pre><code>my $s = @a;
for 1,2,$s { ... }         # 3次迭代
</code></pre><p>1<br>2<br>3 4 5</p>
<p>这里，<code>$s</code> 和 <code>@a</code> 指向同一个数组对象，但是标量容器的出现阻止 <code>$s</code> 被展开到 for 循环中。</p>
<p>.list 和 .flat 方法能被用于还原展开行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for 1,2,$s.list &#123; .say &#125;    # 5次遍历</div><div class="line">for 1,2,@($s)   &#123; .say  &#125;   # 5次遍历，@()会强制为列表上下文</div></pre></td></tr></table></figure>
<p>1<br>2<br>3<br>4<br>5</p>
<p>相反，<code>.item</code> 方法和 <code>$()</code> 能用于防止插值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    my @b = 1,2,@a;           # @b 有5个元素</div><div class="line">    my @c = 1,2,@a.item;      # @c 有3个元素</div><div class="line">    my @c = 1,2,$(@a);        # 同上</div><div class="line"></div><div class="line">&gt; say +@c</div><div class="line">3</div></pre></td></tr></table></figure>
<p>迭代器</p>
<p><code>.reify($n)</code> 方法要求迭代器返回一个含有至少<code>$n</code>个具体元素的 Parcel，后面跟着序列中剩余元素的附加的迭代器，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $r = 10..50;</div><div class="line">say $r.iterator.reify(5).perl;  # (10, 11, 12, 13, 14, 15..50)</div></pre></td></tr></table></figure>
<blockquote>
<p>say $r.iterator.reify(*).perl<br>(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 37, 48, 49, 50)</p>
</blockquote>
<ul>
<li>Feed operators</li>
</ul>
<p>feed操作符是完全懒惰的，意味着在使用者要求任何元素之前不会执行任何操作。这就是</p>
<p>  my @a &lt;== grep { … } &lt;== map { … } &lt;== grep { … } &lt;== 1, 2, 3</p>
<p>是完全懒惰的。</p>
<p>——</p>
<ul>
<li><p>Grammars 文法</p>
<p>  Named Regexes<br>  Creating Grammars<br>  Methods<br>  method parse<br>  method subparse<br>  method parsefile<br>  Action Classes</p>
</li>
</ul>
<p>文法是一种强大的工具, 用于拆解文本,并通常返回数据结构<br>例如, Perl 6 是使用 Perl 6 风格的文法解析和执行的.<br>对普通 Perl 6 用户来说,一个更实用的例子就是 JSON::Simple 模块, 这个模块能反序列化任何有效的 JSON 文件, 反序列化代码还写了不到 100 行, 简单,可扩展.</p>
<p>词法允许你组织正则, 就像类允许你组织普通代码的方法一样.</p>
<h2 id="命名正则-Named-Regexes"><a href="#命名正则-Named-Regexes" class="headerlink" title="命名正则 Named Regexes"></a>命名正则 Named Regexes</h2><hr>
<p>命名正则有特殊的语法, 与<strong>子例程</strong>的定义类似:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my regex number &#123; \d+ [ \. \d+ ]? &#125;</div></pre></td></tr></table></figure>
<p>这个例子中, 我们必须使用 <strong> my </strong> 关键词指定这个正则是词法作用域的, 因为 <strong>命名正则</strong> 通常用在 词法中.<br>给正则命名后有利于在其他地方<code>复用</code>正则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say &quot;32.51&quot;    ~~ &amp;number;</div><div class="line">say &quot;15 + 4.5&quot; ~~ / &lt;number&gt; \s* &apos;+&apos; \s* &lt;number&gt; /</div></pre></td></tr></table></figure>
<p>首先说下, 使用 <code>regex/token/rule</code> 定义了一个正则表达式后怎么去调用它:<br>就像调用一个子例程那样, 使用 <code>&amp;</code> 符号:<br>&amp; 后面跟正则表达式的名字,  即 &amp;regex_name<br>regex 不是命名正则仅有的标识符 – 实际上, 它用的不多. 大多数时候, 用的最多的是 <code>token</code> 和 <code>rule</code> 标识符. 它们都是<code>不能回溯</code>的, 这意味着正则引擎在匹配失败时不会备份和重试. 这通常是你想要的, 但不是对所有场合都合适:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my regex works-but-slow &#123; .+ q &#125;</div><div class="line">my token fails-but-fast &#123; .+ q &#125;</div><div class="line">my $s = &apos;Tokens won\&apos;t backtrack, which makes them fail quicker!&apos;; # Tokens 不会沿原路返回, 这让它们更快地失败!</div><div class="line">say so $s ~~ &amp;works-but-slow; # True</div><div class="line">say so $s ~~ &amp;fails-but-fast; # False, the entire string get taken by the .+</div></pre></td></tr></table></figure>
<p><code>token</code> 和 <code>rule</code> 标识符的不同之处在于 <code>rule</code> 标识符让 <code>Regex</code> 的 <code>:sigspace</code> 起作用了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my token non-space-y &#123; once upon a time &#125;</div><div class="line">my rule space-y      &#123; once upon a time &#125;</div><div class="line">say &apos;onceuponatime&apos;    ~~ &amp;non-space-y;</div><div class="line">say &apos;once upon a time&apos; ~~ &amp;space-y;</div></pre></td></tr></table></figure>
<h2 id="创建文法-Creating-Grammars"><a href="#创建文法-Creating-Grammars" class="headerlink" title="创建文法 Creating Grammars"></a>创建文法 Creating Grammars</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Grammar is Cursor &#123; &#125;</div></pre></td></tr></table></figure>
<p>使用 grammar 关键字而非 <code>class</code> 关键字声明文法. Grammars 应该只用于<code>解析文本</code>; 如果你想<code>提取</code>复杂的数据, 建议将 <code>action</code> 类 和 <code>grammar</code> 结合使用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">grammar CSV &#123;</div><div class="line">    token TOP &#123; [ &lt;line&gt; \n? ]+ &#125;</div><div class="line">    token line &#123;</div><div class="line">        ^^            # Beginning of a line</div><div class="line">        &lt;value&gt;* % \, # Any number of &lt;value&gt;s with commas in `between` them</div><div class="line">        $$            # End of a line</div><div class="line">    &#125;</div><div class="line">    token value &#123;</div><div class="line">        [</div><div class="line">        | &lt;-[&quot;,\n]&gt;     # Anything not a double quote, comma or newline</div><div class="line">        | &lt;quoted-text&gt; # Or some quoted text</div><div class="line">        ]*              # Any number of times</div><div class="line">    &#125;</div><div class="line">    token quoted-text &#123;</div><div class="line">        \&quot;</div><div class="line">        [</div><div class="line">        | &lt;-[&quot;\\]&gt; # Anything not a &quot; or \</div><div class="line">        | &apos;\&quot;&apos;     # Or \&quot;, an escaped quotation mark</div><div class="line">        ]*         # Any number of times</div><div class="line">        \&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say &quot;Valid CSV file!&quot; if CSV.parse( q:to/EOCSV/ );</div><div class="line">    Year,Make,Model,Length</div><div class="line">    1997,Ford,E350,2.34</div><div class="line">    2000,Mercury,Cougar,2.38</div><div class="line">    EOCSV</div></pre></td></tr></table></figure>
<ul>
<li><p>方法    Methods</p>
</li>
<li><p>方法解析</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method parse($str, :$rule = &apos;TOP&apos;, :$actions) returns Match:D</div></pre></td></tr></table></figure>
<p>让 grammar 与 $str 匹配,使用 $rule 作为起始 rule, 选择性地将 $action 作为 action 对象应用.</p>
<p>如果 grammar 不能解析全部文本就会失败. 如果只想解析部分字符串, 使用 subparse<br>返回结果匹配对象, 并设置调用者的 <code>$/</code> 变量为结果匹配对象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">say CSV.parse( q:to/EOCSV/ );</div><div class="line">    Year,Make,Model,Length</div><div class="line">    1997,Ford,E350,2.34</div><div class="line">    2000,Mercury,Cougar,2.38</div><div class="line">    EOCSV</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">	This outputs:</div><div class="line"></div><div class="line">｢Year,Make,Model,Length</div><div class="line">1997,Ford,E350,2.34</div><div class="line">2000,Mercury,Cougar,2.38</div><div class="line">｣</div><div class="line"> line =&gt; ｢Year,Make,Model,Length｣</div><div class="line">  value =&gt; ｢Year｣</div><div class="line">  value =&gt; ｢Make｣</div><div class="line">  value =&gt; ｢Model｣</div><div class="line">  value =&gt; ｢Length｣</div><div class="line"> line =&gt; ｢1997,Ford,E350,2.34｣</div><div class="line">  value =&gt; ｢1997｣</div><div class="line">  value =&gt; ｢Ford｣</div><div class="line">  value =&gt; ｢E350｣</div><div class="line">  value =&gt; ｢2.34｣</div><div class="line"> line =&gt; ｢2000,Mercury,Cougar,2.38 ｣</div><div class="line">  value =&gt; ｢2000｣</div><div class="line">  value =&gt; ｢Mercury｣</div><div class="line">  value =&gt; ｢Cougar｣</div><div class="line">  value =&gt; ｢2.38 ｣</div></pre></td></tr></table></figure>
<h2 id="method-subparse"><a href="#method-subparse" class="headerlink" title="method subparse"></a>method subparse</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method subparse($str, :$rule = &apos;TOP&apos;, :$actions) returns Match:D</div></pre></td></tr></table></figure>
<p>将 <code>$str</code> 与 grammar 匹配, 使用 <code>$rule</code> 作为<code>起始 rule</code>, 选择性将 <code>$action</code> 作为 <code>action</code> 对象应用.<br>不像 <code>parse</code> , <code>subparse</code> 允许 <code>grammar</code> 只匹配所提供的字符串的一部分.</p>
<h2 id="method-parsefile"><a href="#method-parsefile" class="headerlink" title="method parsefile"></a>method parsefile</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method parsefile(Cool $filename as Str, *%opts) 返回 Match:D</div></pre></td></tr></table></figure>
<pre><code>使用 parse 方法解析 文件 $filename 的内容, 传递任何命名选项到 %opts
</code></pre><h2 id="Action-Classes"><a href="#Action-Classes" class="headerlink" title="Action Classes"></a>Action Classes</h2><hr>
<p>In fact, named regexes can even take extra arguments, using the same syntax as subroutine parameter lists<br>实际上, 命名正则甚至能接受额外的参数, 它使用的语法跟子例程参数列表的语法一样.</p>
<p>​写一个程序打印从 1  到 100 的整数，但是对 3 的倍数打印 “Fizz”, 对 5 的倍数打印 “Buzz”, 对于即是 3 的倍数，又是 5 的倍数的打印 “FizzBuzz”.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">for 1 .. 100 &#123;</div><div class="line">    when $_ %% (3 &amp; 5) &#123; say &apos;FizzBuzz&apos;; &#125;</div><div class="line">    when $_ %% 3       &#123; say &apos;Fizz&apos;;     &#125;</div><div class="line">    when $_ %% 5       &#123; say &apos;Buzz&apos;;     &#125;</div><div class="line">    default            &#123; .say;           &#125;</div><div class="line">&#125;</div><div class="line">Or abusing multi subs:</div><div class="line"></div><div class="line"></div><div class="line">```perl6</div><div class="line">multi sub fizzbuzz(Int $ where * %% 15) &#123; &apos;FizzBuzz&apos; &#125;</div><div class="line">multi sub fizzbuzz(Int $ where * %% 5)  &#123; &apos;Buzz&apos;     &#125;</div><div class="line">multi sub fizzbuzz(Int $ where * %% 3)  &#123; &apos;Fizz&apos;     &#125;</div><div class="line">multi sub fizzbuzz(Int $number )        &#123; $number    &#125;</div><div class="line">(1 .. 100)».&amp;fizzbuzz.join(&quot;\n&quot;).say;</div></pre></td></tr></table></figure>
<p>Most concisely:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &apos;Fizz&apos; x $_ %% 3 ~ &apos;Buzz&apos; x $_ %% 5 || $_ for 1 .. 100;</div></pre></td></tr></table></figure>
<p>And here’s an implementation that never checks for divisibility:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.say for</div><div class="line">    ((&apos;&apos; xx 2, &apos;Fizz&apos;) xx * Z~</div><div class="line">    (&apos;&apos; xx 4, &apos;Buzz&apos;) xx *) Z||1 .. 100;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
